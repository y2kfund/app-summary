var ym = Object.defineProperty;
var Sm = (e, t, i) => t in e ? ym(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i;
var K = (e, t, i) => Sm(e, typeof t != "symbol" ? t + "" : t, i);
import { defineComponent as Bo, mergeModels as Bd, useTemplateRef as Rm, ref as we, toRefs as xm, watch as mo, useModel as Fm, getCurrentInstance as Xo, createElementBlock as J, onMounted as Bn, markRaw as Pm, onUnmounted as vh, openBlock as X, mergeDefaults as Em, toRaw as Co, isRef as Dm, isReactive as Tm, isProxy as Sl, createVNode as Ea, render as Gd, inject as wh, shallowRef as bh, h as Da, nextTick as Mm, version as Am, reactive as Hr, computed as Ie, onBeforeUnmount as Im, resolveComponent as km, Fragment as Yi, createElementVNode as O, renderList as Ls, normalizeClass as Br, toDisplayString as ce, createCommentVNode as pi, unref as fi, createBlock as Lm, withCtx as Om, createTextVNode as Vd, withModifiers as Os, withDirectives as _m, vModelCheckbox as Hm, normalizeStyle as Bm } from "vue";
import { useQueryClient as Gm, useQuery as Ta } from "@tanstack/vue-query";
import { useSupabase as Vm } from "@y2kfund/core";
var Li = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
  }
  setFrameworkOverrides(e) {
    this.frameworkOverrides = e;
  }
  getListeners(e, t, i) {
    const s = t ? this.allAsyncListeners : this.allSyncListeners;
    let o = s.get(e);
    return !o && i && (o = /* @__PURE__ */ new Set(), s.set(e, o)), o;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(e, t, i = !1) {
    this.getListeners(e, i, !0).add(t);
  }
  removeEventListener(e, t, i = !1) {
    const s = this.getListeners(e, i, !1);
    s && (s.delete(t), s.size === 0 && (i ? this.allAsyncListeners : this.allSyncListeners).delete(e));
  }
  addGlobalListener(e, t = !1) {
    this.getGlobalListeners(t).add(e);
  }
  removeGlobalListener(e, t = !1) {
    this.getGlobalListeners(t).delete(e);
  }
  dispatchEvent(e) {
    this.dispatchToListeners(e, !0), this.dispatchToListeners(e, !1), this.firedEvents[e.type] = !0;
  }
  dispatchEventOnce(e) {
    this.firedEvents[e.type] || this.dispatchEvent(e);
  }
  dispatchToListeners(e, t) {
    const i = e.type;
    if (t && "event" in e) {
      const a = e.event;
      a instanceof Event && (e.eventPath = a.composedPath());
    }
    const { frameworkOverrides: s } = this, o = (a) => {
      const l = s ? () => s.wrapIncoming(a) : a;
      t ? this.dispatchAsync(l) : l();
    }, n = this.getListeners(i, t, !1);
    if (((n == null ? void 0 : n.size) ?? 0) > 0) {
      const a = new Set(n);
      for (const l of a)
        n != null && n.has(l) && o(() => l(e));
    }
    const r = this.getGlobalListeners(t);
    if (r.size > 0) {
      const a = new Set(r);
      for (const l of a)
        o(() => l(i, e));
    }
  }
  getGlobalListeners(e) {
    return e ? this.globalAsyncListeners : this.globalSyncListeners;
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(e) {
    if (this.asyncFunctionsQueue.push(e), !this.scheduled) {
      const t = () => {
        window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      };
      this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(t) : t(), this.scheduled = !0;
    }
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = !1;
    const e = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [], e.forEach((t) => t());
  }
};
function Vt(e) {
  return e == null || e === "" ? null : e;
}
function H(e) {
  return e != null && e !== "";
}
function de(e) {
  return !H(e);
}
function Ma(e) {
  return e != null && typeof e.toString == "function" ? e.toString() : null;
}
function vo(e, t) {
  const i = e ? JSON.stringify(e) : null, s = t ? JSON.stringify(t) : null;
  return i === s;
}
function Nm(e, t, i = !1) {
  const s = e == null, o = t == null;
  if (e && e.toNumber && (e = e.toNumber()), t && t.toNumber && (t = t.toNumber()), s && o)
    return 0;
  if (s)
    return -1;
  if (o)
    return 1;
  function n(r, a) {
    return r > a ? 1 : r < a ? -1 : 0;
  }
  if (typeof e != "string" || !i)
    return n(e, t);
  try {
    return e.localeCompare(t);
  } catch {
    return n(e, t);
  }
}
var Wm = /[&<>"']/g, zm = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Es(e) {
  return (e == null ? void 0 : e.toString().toString()) ?? null;
}
function to(e) {
  var t;
  return ((t = Es(e)) == null ? void 0 : t.replace(Wm, (i) => zm[i])) ?? null;
}
function wo(e) {
  return e.eRootDiv.getRootNode();
}
function he(e) {
  return wo(e).activeElement;
}
function Ee(e) {
  const { gos: t, eRootDiv: i } = e;
  let s = null;
  const o = t.get("getDocument");
  return o && H(o) ? s = o() : i && (s = i.ownerDocument), s && H(s) ? s : document;
}
function yh(e) {
  const t = he(e);
  return t === null || t === Ee(e).body;
}
function Sh(e) {
  return Ee(e).defaultView || window;
}
function Rl(e) {
  let t = null, i = null;
  try {
    t = Ee(e).fullscreenElement;
  } catch {
  } finally {
    t || (t = wo(e));
    const s = t.querySelector("body");
    s ? i = s : t instanceof ShadowRoot ? i = t : t instanceof Document ? i = t == null ? void 0 : t.documentElement : i = t;
  }
  return i;
}
function Um(e) {
  const t = Rl(e);
  return (t == null ? void 0 : t.clientWidth) ?? (window.innerWidth || -1);
}
function $m(e) {
  const t = Rl(e);
  return (t == null ? void 0 : t.clientHeight) ?? (window.innerHeight || -1);
}
function ht(e, t, i) {
  i == null || typeof i == "string" && i == "" ? Rh(e, t) : nt(e, t, i);
}
function nt(e, t, i) {
  e.setAttribute(xh(t), i.toString());
}
function Rh(e, t) {
  e.removeAttribute(xh(t));
}
function xh(e) {
  return `aria-${e}`;
}
function oi(e, t) {
  t ? e.setAttribute("role", t) : e.removeAttribute("role");
}
function Km(e) {
  let t;
  return e === "asc" ? t = "ascending" : e === "desc" ? t = "descending" : e === "mixed" ? t = "other" : t = "none", t;
}
function jm(e) {
  return e.getAttribute("aria-label");
}
function vs(e, t) {
  ht(e, "label", t);
}
function bo(e, t) {
  ht(e, "labelledby", t);
}
function Fh(e, t) {
  ht(e, "live", t);
}
function qm(e, t) {
  ht(e, "atomic", t);
}
function Ym(e, t) {
  ht(e, "relevant", t);
}
function Qm(e, t) {
  ht(e, "invalid", t);
}
function Xm(e, t) {
  ht(e, "disabled", t);
}
function Ph(e, t) {
  ht(e, "hidden", t);
}
function Aa(e, t) {
  nt(e, "expanded", t);
}
function Zm(e, t) {
  nt(e, "setsize", t);
}
function Jm(e, t) {
  nt(e, "posinset", t);
}
function eC(e, t) {
  nt(e, "multiselectable", t);
}
function tC(e, t) {
  nt(e, "rowcount", t);
}
function Gn(e, t) {
  nt(e, "rowindex", t);
}
function iC(e, t) {
  nt(e, "rowspan", t);
}
function sC(e, t) {
  nt(e, "colcount", t);
}
function Eh(e, t) {
  nt(e, "colindex", t);
}
function oC(e, t) {
  nt(e, "colspan", t);
}
function nC(e, t) {
  nt(e, "sort", t);
}
function rC(e) {
  Rh(e, "sort");
}
function Dh(e, t) {
  ht(e, "selected", t);
}
function aC(e, t) {
  ht(e, "controls", t);
}
function lC(e, t) {
  aC(e, t.id), bo(t, e.id);
}
function Nd(e, t) {
  ht(e, "owns", t);
}
function Cr(e, t) {
  return t === void 0 ? e("ariaIndeterminate", "indeterminate") : t === !0 ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked");
}
var dC = "[tabindex], input, select, button, textarea, [href]", Th = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function xl(e) {
  const t = Element.prototype.matches || Element.prototype.msMatchesSelector, s = t.call(e, "input, select, button, textarea"), o = t.call(e, Th), n = Mt(e);
  return s && !o && n;
}
function le(e, t, i = {}) {
  const { skipAriaHidden: s } = i;
  e.classList.toggle("ag-hidden", !t), s || Ph(e, !t);
}
function cC(e, t, i = {}) {
  const { skipAriaHidden: s } = i;
  e.classList.toggle("ag-invisible", !t), s || Ph(e, !t);
}
function yo(e, t) {
  const i = "disabled", s = t ? (n) => n.setAttribute(i, "") : (n) => n.removeAttribute(i);
  s(e);
  const o = e.querySelectorAll("input") ?? [];
  for (const n of o)
    s(n);
}
function Ei(e, t, i) {
  let s = 0;
  for (; e; ) {
    if (e.classList.contains(t))
      return !0;
    if (e = e.parentElement, typeof i == "number") {
      if (++s > i)
        break;
    } else if (e === i)
      break;
  }
  return !1;
}
function Ni(e) {
  const {
    height: t,
    width: i,
    borderTopWidth: s,
    borderRightWidth: o,
    borderBottomWidth: n,
    borderLeftWidth: r,
    paddingTop: a,
    paddingRight: l,
    paddingBottom: d,
    paddingLeft: c,
    marginTop: u,
    marginRight: h,
    marginBottom: g,
    marginLeft: p,
    boxSizing: f
  } = window.getComputedStyle(e);
  return {
    height: parseFloat(t || "0"),
    width: parseFloat(i || "0"),
    borderTopWidth: parseFloat(s || "0"),
    borderRightWidth: parseFloat(o || "0"),
    borderBottomWidth: parseFloat(n || "0"),
    borderLeftWidth: parseFloat(r || "0"),
    paddingTop: parseFloat(a || "0"),
    paddingRight: parseFloat(l || "0"),
    paddingBottom: parseFloat(d || "0"),
    paddingLeft: parseFloat(c || "0"),
    marginTop: parseFloat(u || "0"),
    marginRight: parseFloat(h || "0"),
    marginBottom: parseFloat(g || "0"),
    marginLeft: parseFloat(p || "0"),
    boxSizing: f
  };
}
function Fl(e) {
  const t = Ni(e);
  return t.boxSizing === "border-box" ? t.height - t.paddingTop - t.paddingBottom : t.height;
}
function So(e) {
  const t = Ni(e);
  return t.boxSizing === "border-box" ? t.width - t.paddingLeft - t.paddingRight : t.width;
}
function Mh(e) {
  const { height: t, marginBottom: i, marginTop: s } = Ni(e);
  return Math.floor(t + i + s);
}
function Vn(e) {
  const { width: t, marginLeft: i, marginRight: s } = Ni(e);
  return Math.floor(t + i + s);
}
function Ah(e) {
  const t = e.getBoundingClientRect(), { borderTopWidth: i, borderLeftWidth: s, borderRightWidth: o, borderBottomWidth: n } = Ni(e);
  return {
    top: t.top + (i || 0),
    left: t.left + (s || 0),
    right: t.right + (o || 0),
    bottom: t.bottom + (n || 0)
  };
}
function Nn(e, t) {
  let i = e.scrollLeft;
  return t && (i = Math.abs(i)), i;
}
function Wn(e, t, i) {
  i && (t *= -1), e.scrollLeft = t;
}
function Te(e) {
  for (; e && e.firstChild; )
    e.removeChild(e.firstChild);
}
function dt(e) {
  e && e.parentNode && e.parentNode.removeChild(e);
}
function Ih(e) {
  return !!e.offsetParent;
}
function Mt(e) {
  const t = e;
  return t.checkVisibility ? t.checkVisibility({ checkVisibilityCSS: !0 }) : !(!Ih(e) || window.getComputedStyle(e).visibility !== "visible");
}
function Pl(e) {
  const t = document.createElement("div");
  return t.innerHTML = (e || "").trim(), t.firstChild;
}
function kh(e, t, i) {
  i && i.nextSibling === t || (e.firstChild ? i ? i.nextSibling ? e.insertBefore(t, i.nextSibling) : e.appendChild(t) : e.firstChild && e.firstChild !== t && e.insertAdjacentElement("afterbegin", t) : e.appendChild(t));
}
function Lh(e, t) {
  for (let i = 0; i < t.length; i++) {
    const s = t[i], o = e.children[i];
    o !== s && e.insertBefore(s, o);
  }
}
function uC(e) {
  return e.replace(/[A-Z]/g, (t) => `-${t.toLocaleLowerCase()}`);
}
function Go(e, t) {
  if (t)
    for (const i of Object.keys(t)) {
      const s = t[i];
      if (!i || !i.length || s == null)
        continue;
      const o = uC(i), n = s.toString(), r = n.replace(/\s*!important/g, ""), a = r.length != n.length ? "important" : void 0;
      e.style.setProperty(o, r, a);
    }
}
function xn(e) {
  return () => {
    const t = e();
    return t ? El(t) || Oh(t) : !0;
  };
}
function El(e) {
  return e.clientWidth < e.scrollWidth;
}
function Oh(e) {
  return e.clientHeight < e.scrollHeight;
}
function zn(e, t) {
  t === "flex" ? (e.style.removeProperty("width"), e.style.removeProperty("minWidth"), e.style.removeProperty("maxWidth"), e.style.flex = "1 1 auto") : Ft(e, t);
}
function Ft(e, t) {
  t = Dl(t), e.style.width = t, e.style.maxWidth = t, e.style.minWidth = t;
}
function io(e, t) {
  t = Dl(t), e.style.height = t, e.style.maxHeight = t, e.style.minHeight = t;
}
function Dl(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function Tl(e) {
  return e instanceof Node || e instanceof HTMLElement;
}
function Ue(e, t, i) {
  i == null || i === "" ? e.removeAttribute(t) : e.setAttribute(t, i.toString());
}
function di(e, t, i) {
  const o = Sh(e).ResizeObserver, n = o ? new o(i) : null;
  return n == null || n.observe(t), () => n == null ? void 0 : n.disconnect();
}
function $t(e, t) {
  const i = Sh(e);
  i.requestAnimationFrame ? i.requestAnimationFrame(t) : i.webkitRequestAnimationFrame ? i.webkitRequestAnimationFrame(t) : i.setTimeout(t, 0);
}
var _h = "data-ref", Gr;
function Wd() {
  return Gr ?? (Gr = document.createTextNode(" ")), Gr.cloneNode();
}
function Vo(e) {
  const { attrs: t, children: i, cls: s, ref: o, role: n, tag: r } = e, a = document.createElement(r);
  if (s && (a.className = s), o && a.setAttribute(_h, o), n && a.setAttribute("role", n), t)
    for (const l of Object.keys(t))
      a.setAttribute(l, t[l]);
  if (i)
    if (typeof i == "string")
      a.textContent = i;
    else {
      let l = !0;
      for (const d of i)
        d && (typeof d == "string" ? (a.appendChild(document.createTextNode(d)), l = !1) : typeof d == "function" ? a.appendChild(d()) : (l && (a.appendChild(Wd()), l = !1), a.append(Vo(d)), a.appendChild(Wd())));
    }
  return a;
}
var hC = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"], gC = ["wheel"], Vr = {}, Hh = /* @__PURE__ */ (() => {
  const e = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  return (i) => {
    if (typeof Vr[i] == "boolean")
      return Vr[i];
    const s = document.createElement(e[i] || "div");
    return i = "on" + i, Vr[i] = i in s;
  };
})();
function pC(e, t) {
  return !t || !e ? !1 : mC(t).indexOf(e) >= 0;
}
function fC(e) {
  const t = [];
  let i = e.target;
  for (; i; )
    t.push(i), i = i.parentElement;
  return t;
}
function mC(e) {
  const t = e;
  return t.path ? t.path : t.composedPath ? t.composedPath() : fC(t);
}
function CC(e, t, i) {
  const s = vC(t);
  let o;
  s != null && (o = { passive: s }), e.addEventListener(t, i, o);
}
var vC = (e) => {
  const t = hC.includes(e), i = gC.includes(e);
  if (t)
    return !0;
  if (i)
    return !1;
};
function Bh(e, t, i) {
  if (i === 0)
    return !1;
  const s = Math.abs(e.clientX - t.clientX), o = Math.abs(e.clientY - t.clientY);
  return Math.max(s, o) <= i;
}
function Ro(e, t) {
  return e.gos.isElementInThisInstance(t.target);
}
function wC(e, t, i) {
  const o = e.getBoundingClientRect().height, n = Um(i) - 2, r = $m(i) - 2;
  if (!e.offsetParent)
    return;
  const l = Ah(e.offsetParent), { clientY: d, clientX: c } = t;
  let u = d - l.top - o / 2, h = c - l.left - 10;
  const g = Ee(i), p = g.defaultView || window, f = p.pageYOffset || g.documentElement.scrollTop, m = p.pageXOffset || g.documentElement.scrollLeft;
  n > 0 && h + e.clientWidth > n + m && (h = n + m - e.clientWidth), h < 0 && (h = 0), r > 0 && u + e.clientHeight > r + f && (u = r + f - e.clientHeight), u < 0 && (u = 0), e.style.left = `${h}px`, e.style.top = `${u}px`;
}
function bC(e, t) {
  return t;
}
function Gh(e) {
  return (e == null ? void 0 : e.getLocaleTextFunc()) ?? bC;
}
function yC(e, t, i, s) {
  const o = t[i];
  return e.getLocaleTextFunc()(
    i,
    typeof o == "function" ? o(s) : o,
    s
  );
}
function SC(e) {
  return (t, i, s) => e({
    key: t,
    defaultValue: i,
    variableValues: s
  });
}
function RC(e) {
  return (t, i, s) => {
    let o = e && e[t];
    if (o && s && s.length) {
      let n = 0;
      for (; !(n >= s.length || o.indexOf("${variable}") === -1); )
        o = o.replace("${variable}", s[n++]);
    }
    return o ?? i;
  };
}
var At = class {
  constructor() {
    this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.propertyListenerId = 0, this.lastChangeSetIdLookup = {}, this.isAlive = () => !this.destroyed;
  }
  preWireBeans(e) {
    this.beans = e, this.stubContext = e.context, this.eventSvc = e.eventSvc, this.gos = e.gos;
  }
  // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
  // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
  // points to a bean or component that was not properly disposed of.
  // constructor() {
  //     setTimeout(()=> {
  //         if (this.isAlive()) {
  //             let prototype: any = Object.getPrototypeOf(this);
  //             const constructor: any = prototype.constructor;
  //             const constructorString = constructor.toString();
  //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
  //             console.log('is alive ' + beanName);
  //         }
  //     }, 5000);
  // }
  destroy() {
    const { destroyFunctions: e } = this;
    for (let t = 0; t < e.length; t++)
      e[t]();
    e.length = 0, this.destroyed = !0, this.dispatchLocalEvent({ type: "destroyed" });
  }
  /** Add a local event listener against this BeanStub */
  addEventListener(e, t, i) {
    this.localEventService || (this.localEventService = new Li()), this.localEventService.addEventListener(e, t, i);
  }
  /** Remove a local event listener from this BeanStub */
  removeEventListener(e, t, i) {
    var s;
    (s = this.localEventService) == null || s.removeEventListener(e, t, i);
  }
  dispatchLocalEvent(e) {
    var t;
    (t = this.localEventService) == null || t.dispatchEvent(e);
  }
  addManagedElementListeners(e, t) {
    return this._setupListeners(e, t);
  }
  addManagedEventListeners(e) {
    return this._setupListeners(this.eventSvc, e);
  }
  addManagedListeners(e, t) {
    return this._setupListeners(e, t);
  }
  _setupListeners(e, t) {
    const i = [];
    for (const s of Object.keys(t)) {
      const o = t[s];
      o && i.push(this._setupListener(e, s, o));
    }
    return i;
  }
  _setupListener(e, t, i) {
    if (this.destroyed)
      return () => null;
    let s;
    if (xC(e))
      e.__addEventListener(t, i), s = () => (e.__removeEventListener(t, i), null);
    else {
      const o = FC(e);
      e instanceof HTMLElement ? CC(e, t, i) : o ? e.addListener(t, i) : e.addEventListener(t, i), s = o ? () => (e.removeListener(t, i), null) : () => (e.removeEventListener(t, i), null);
    }
    return this.destroyFunctions.push(s), () => (s(), this.destroyFunctions = this.destroyFunctions.filter((o) => o !== s), null);
  }
  /**
   * Setup a managed property listener for the given property.
   * However, stores the destroy function in the beanStub so that if this bean
   * is a component the destroy function will be called when the component is destroyed
   * as opposed to being cleaned up only when the properties service is destroyed.
   */
  setupPropertyListener(e, t) {
    const { gos: i } = this;
    i.addPropertyEventListener(e, t);
    const s = () => (i.removePropertyEventListener(e, t), null);
    return this.destroyFunctions.push(s), () => (s(), this.destroyFunctions = this.destroyFunctions.filter((o) => o !== s), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */
  addManagedPropertyListener(e, t) {
    return this.destroyed ? () => null : this.setupPropertyListener(e, t);
  }
  /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */
  addManagedPropertyListeners(e, t) {
    if (this.destroyed)
      return;
    const i = e.join("-") + this.propertyListenerId++, s = (o) => {
      if (o.changeSet) {
        if (o.changeSet && o.changeSet.id === this.lastChangeSetIdLookup[i])
          return;
        this.lastChangeSetIdLookup[i] = o.changeSet.id;
      }
      const n = {
        type: "propertyChanged",
        changeSet: o.changeSet,
        source: o.source
      };
      t(n);
    };
    e.forEach((o) => this.setupPropertyListener(o, s));
  }
  getLocaleTextFunc() {
    return Gh(this.beans.localeSvc);
  }
  addDestroyFunc(e) {
    this.isAlive() ? this.destroyFunctions.push(e) : e();
  }
  /** doesn't throw an error if `bean` is undefined */
  createOptionalManagedBean(e, t) {
    return e ? this.createManagedBean(e, t) : void 0;
  }
  createManagedBean(e, t) {
    const i = this.createBean(e, t);
    return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), i;
  }
  createBean(e, t, i) {
    return (t || this.stubContext).createBean(e, i);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e, t) {
    return (t || this.stubContext).destroyBean(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e, t) {
    return (t || this.stubContext).destroyBeans(e);
  }
};
function xC(e) {
  return e.__addEventListener !== void 0;
}
function FC(e) {
  return e.eventServiceType === "global";
}
var E = class extends At {
}, zd = {};
function Ml(e, t) {
  zd[t] || (e(), zd[t] = !0);
}
var PC = {
  pending: !1,
  funcs: []
}, EC = {
  pending: !1,
  funcs: []
};
function Ia(e, t = "setTimeout", i) {
  const s = t === "raf" ? EC : PC;
  if (s.funcs.push(e), s.pending)
    return;
  s.pending = !0;
  const o = () => {
    const n = s.funcs.slice();
    s.funcs.length = 0, s.pending = !1, n.forEach((r) => r());
  };
  t === "raf" ? $t(i, o) : window.setTimeout(o, 0);
}
function De(e, t, i) {
  let s;
  return function(...o) {
    const n = this;
    window.clearTimeout(s), s = window.setTimeout(function() {
      e.isAlive() && t.apply(n, o);
    }, i);
  };
}
function Ud(e, t) {
  let i = 0;
  return function(...s) {
    const o = this, n = Date.now();
    n - i < t || (i = n, e.apply(o, s));
  };
}
function DC(e, t, i, s = 100) {
  const o = Date.now();
  let n = null, r = !1;
  const a = () => {
    n != null && (window.clearInterval(n), n = null);
  };
  e.addDestroyFunc(a);
  const l = () => {
    const d = Date.now() - o > s;
    (t() || d) && (i(), r = !0, a());
  };
  l(), r || (n = window.setInterval(l, 10));
}
var Vh = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function TC(e, t) {
  if (e != null) {
    if (Array.isArray(e)) {
      for (let i = 0; i < e.length; i++)
        t(i.toString(), e[i]);
      return;
    }
    for (const i of Object.keys(e).filter((s) => !Vh.has(s)))
      t(i, e[i]);
  }
}
function Be(e, t, i = !0, s = !1) {
  H(t) && TC(t, (o, n) => {
    let r = e[o];
    r !== n && (s && r == null && n != null && typeof n == "object" && n.constructor === Object && (r = {}, e[o] = r), $d(n) && $d(r) && !Array.isArray(r) ? Be(r, n, i, s) : (i || n !== void 0) && (e[o] = n));
  });
}
function $d(e) {
  return typeof e == "object" && e !== null;
}
var Al = class wi {
  /**
   * @param providedOptions
   * @returns Shallow copy of the provided options with global options merged in.
   */
  static applyGlobalGridOptions(t) {
    if (!wi.gridOptions)
      return { ...t };
    let i = {};
    return Be(i, wi.gridOptions, !0, !0), wi.mergeStrategy === "deep" ? Be(i, t, !0, !0) : i = { ...i, ...t }, wi.gridOptions.context && (i.context = wi.gridOptions.context), t.context && (wi.mergeStrategy === "deep" && i.context && Be(t.context, i.context, !0, !0), i.context = t.context), i;
  }
};
Al.gridOptions = void 0;
Al.mergeStrategy = "shallow";
var MC = Al, AC = {
  suppressContextMenu: !1,
  preventDefaultOnContextMenu: !1,
  allowContextMenuWithControlKey: !1,
  suppressMenuHide: !0,
  enableBrowserTooltips: !1,
  tooltipTrigger: "hover",
  tooltipShowDelay: 2e3,
  tooltipHideDelay: 1e4,
  tooltipMouseTrack: !1,
  tooltipShowMode: "standard",
  tooltipInteraction: !1,
  copyHeadersToClipboard: !1,
  copyGroupHeadersToClipboard: !1,
  clipboardDelimiter: "	",
  suppressCopyRowsToClipboard: !1,
  suppressCopySingleCellRanges: !1,
  suppressLastEmptyLineOnPaste: !1,
  suppressClipboardPaste: !1,
  suppressClipboardApi: !1,
  suppressCutToClipboard: !1,
  maintainColumnOrder: !1,
  enableStrictPivotColumnOrder: !1,
  suppressFieldDotNotation: !1,
  allowDragFromColumnsToolPanel: !1,
  suppressMovableColumns: !1,
  suppressColumnMoveAnimation: !1,
  suppressMoveWhenColumnDragging: !1,
  suppressDragLeaveHidesColumns: !1,
  suppressRowGroupHidesColumns: !1,
  suppressAutoSize: !1,
  autoSizePadding: 20,
  skipHeaderOnAutoSize: !1,
  singleClickEdit: !1,
  suppressClickEdit: !1,
  readOnlyEdit: !1,
  stopEditingWhenCellsLoseFocus: !1,
  enterNavigatesVertically: !1,
  enterNavigatesVerticallyAfterEdit: !1,
  enableCellEditingOnBackspace: !1,
  undoRedoCellEditing: !1,
  undoRedoCellEditingLimit: 10,
  suppressCsvExport: !1,
  suppressExcelExport: !1,
  cacheQuickFilter: !1,
  includeHiddenColumnsInQuickFilter: !1,
  excludeChildrenWhenTreeDataFiltering: !1,
  enableAdvancedFilter: !1,
  includeHiddenColumnsInAdvancedFilter: !1,
  enableCharts: !1,
  masterDetail: !1,
  keepDetailRows: !1,
  keepDetailRowsCount: 10,
  detailRowAutoHeight: !1,
  tabIndex: 0,
  rowBuffer: 10,
  valueCache: !1,
  valueCacheNeverExpires: !1,
  enableCellExpressions: !1,
  suppressTouch: !1,
  suppressFocusAfterRefresh: !1,
  suppressBrowserResizeObserver: !1,
  suppressPropertyNamesCheck: !1,
  suppressChangeDetection: !1,
  debug: !1,
  suppressLoadingOverlay: !1,
  suppressNoRowsOverlay: !1,
  pagination: !1,
  paginationPageSize: 100,
  paginationPageSizeSelector: !0,
  paginationAutoPageSize: !1,
  paginateChildRows: !1,
  suppressPaginationPanel: !1,
  pivotMode: !1,
  pivotPanelShow: "never",
  pivotDefaultExpanded: 0,
  pivotSuppressAutoColumn: !1,
  suppressExpandablePivotGroups: !1,
  functionsReadOnly: !1,
  suppressAggFuncInHeader: !1,
  alwaysAggregateAtRootLevel: !1,
  aggregateOnlyChangedColumns: !1,
  suppressAggFilteredOnly: !1,
  removePivotHeaderRowWhenSingleValueColumn: !1,
  animateRows: !0,
  cellFlashDuration: 500,
  cellFadeDuration: 1e3,
  allowShowChangeAfterFilter: !1,
  domLayout: "normal",
  ensureDomOrder: !1,
  enableRtl: !1,
  suppressColumnVirtualisation: !1,
  suppressMaxRenderedRowRestriction: !1,
  suppressRowVirtualisation: !1,
  rowDragManaged: !1,
  rowDragInsertDelay: 500,
  suppressRowDrag: !1,
  suppressMoveWhenRowDragging: !1,
  rowDragEntireRow: !1,
  rowDragMultiRow: !1,
  embedFullWidthRows: !1,
  groupDisplayType: "singleColumn",
  groupDefaultExpanded: 0,
  groupMaintainOrder: !1,
  groupSelectsChildren: !1,
  groupSuppressBlankHeader: !1,
  groupSelectsFiltered: !1,
  showOpenedGroup: !1,
  groupRemoveSingleChildren: !1,
  groupRemoveLowestSingleChildren: !1,
  groupHideOpenParents: !1,
  groupAllowUnbalanced: !1,
  rowGroupPanelShow: "never",
  suppressMakeColumnVisibleAfterUnGroup: !1,
  treeData: !1,
  rowGroupPanelSuppressSort: !1,
  suppressGroupRowsSticky: !1,
  rowModelType: "clientSide",
  asyncTransactionWaitMillis: 50,
  suppressModelUpdateAfterUpdateTransaction: !1,
  cacheOverflowSize: 1,
  infiniteInitialRowCount: 1,
  serverSideInitialRowCount: 1,
  cacheBlockSize: 100,
  maxBlocksInCache: -1,
  maxConcurrentDatasourceRequests: 2,
  blockLoadDebounceMillis: 0,
  purgeClosedRowNodes: !1,
  serverSideSortAllLevels: !1,
  serverSideOnlyRefreshFilteredGroups: !1,
  serverSidePivotResultFieldSeparator: "_",
  viewportRowModelPageSize: 5,
  viewportRowModelBufferSize: 5,
  alwaysShowHorizontalScroll: !1,
  alwaysShowVerticalScroll: !1,
  debounceVerticalScrollbar: !1,
  suppressHorizontalScroll: !1,
  suppressScrollOnNewData: !1,
  suppressScrollWhenPopupsAreOpen: !1,
  suppressAnimationFrame: !1,
  suppressMiddleClickScrolls: !1,
  suppressPreventDefaultOnMouseWheel: !1,
  rowMultiSelectWithClick: !1,
  suppressRowDeselection: !1,
  suppressRowClickSelection: !1,
  suppressCellFocus: !1,
  suppressHeaderFocus: !1,
  suppressMultiRangeSelection: !1,
  enableCellTextSelection: !1,
  enableRangeSelection: !1,
  enableRangeHandle: !1,
  enableFillHandle: !1,
  fillHandleDirection: "xy",
  suppressClearOnFillReduction: !1,
  accentedSort: !1,
  unSortIcon: !1,
  suppressMultiSort: !1,
  alwaysMultiSort: !1,
  suppressMaintainUnsortedOrder: !1,
  suppressRowHoverHighlight: !1,
  suppressRowTransform: !1,
  columnHoverHighlight: !1,
  deltaSort: !1,
  enableGroupEdit: !1,
  groupLockGroupColumns: 0,
  serverSideEnableClientSideSort: !1,
  suppressServerSideFullWidthLoadingRow: !1,
  pivotMaxGeneratedColumns: -1,
  columnMenu: "new",
  reactiveCustomComponents: !0,
  suppressSetFilterByDefault: !1,
  rowNumbers: !1,
  enableFilterHandlers: !1
}, Nh = "https://www.ag-grid.com";
function ni(e, t, ...i) {
  e.get("debug") && console.log("AG Grid: " + t, ...i);
}
function so(e, ...t) {
  Ml(() => console.warn("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function ns(e, ...t) {
  Ml(() => console.error("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
var B = "34.2.0", Kd = 2e3, jd = 100, Wh = "_version_", Fn = null, rs = `${Nh}/javascript-data-grid`;
function IC(e) {
  Fn = e;
}
function kC(e) {
  rs = e;
}
function zh(e, t, i) {
  return (Fn == null ? void 0 : Fn(e, t)) ?? [HC(e, t, i)];
}
function Il(e, t, i, s, o) {
  e(`${s ? "warning" : "error"} #${t}`, ...zh(t, i, o));
}
function LC(e) {
  if (!e)
    return String(e);
  const t = {};
  for (const i of Object.keys(e))
    typeof e[i] != "object" && typeof e[i] != "function" && (t[i] = e[i]);
  return JSON.stringify(t);
}
function OC(e) {
  let t = e;
  return e instanceof Error ? t = e.toString() : typeof e == "object" && (t = LC(e)), t;
}
function Un(e) {
  return e === void 0 ? "undefined" : e === null ? "null" : e;
}
function ka(e, t) {
  return `${e}?${t.toString()}`;
}
function _C(e, t, i) {
  const s = Array.from(t.entries()).sort((n, r) => r[1].length - n[1].length);
  let o = ka(e, t);
  for (const [n, r] of s) {
    if (n === Wh)
      continue;
    const a = o.length - i;
    if (a <= 0)
      break;
    const l = "...", d = a + l.length, c = r.length - d > jd ? r.slice(0, r.length - d) + l : r.slice(0, jd) + l;
    t.set(n, c), o = ka(e, t);
  }
  return o;
}
function Uh(e, t) {
  const i = new URLSearchParams();
  if (i.append(Wh, B), t)
    for (const n of Object.keys(t))
      i.append(n, OC(t[n]));
  const s = `${rs}/errors/${e}`, o = ka(s, i);
  return o.length <= Kd ? o : _C(s, i, Kd);
}
var HC = (e, t, i) => {
  const s = Uh(e, t);
  return `${i ? i + ` 
` : ""}Visit ${s}${i ? "" : ` 
  Alternatively register the ValidationModule to see the full message in the console.`}`;
};
function I(...e) {
  Il(so, e[0], e[1], !0);
}
function Z(...e) {
  Il(ns, e[0], e[1], !1);
}
function qs(e, t, i) {
  Il(ns, e, t, !1, i);
}
function BC(e, t) {
  const i = t[0];
  return `error #${i} ` + zh(i, t[1], e).join(" ");
}
function Pt(...e) {
  return BC(void 0, e);
}
function $h(e, t) {
  return e.get("rowModelType") === t;
}
function xe(e, t) {
  return $h(e, "clientSide");
}
function Ds(e, t) {
  return $h(e, "serverSide");
}
function Me(e, t) {
  return e.get("domLayout") === t;
}
function Di(e) {
  return Kn(e) !== void 0;
}
function Kh(e) {
  return typeof e.get("getRowHeight") == "function";
}
function GC(e, t) {
  return t ? !e.get("enableStrictPivotColumnOrder") : e.get("maintainColumnOrder");
}
function ri(e, t, i = !1, s) {
  const { gos: o, environment: n } = e;
  if (s == null && (s = n.getDefaultRowHeight()), Kh(o)) {
    if (i)
      return { height: s, estimated: !0 };
    const l = {
      node: t,
      data: t.data
    }, d = o.getCallback("getRowHeight")(l);
    if (La(d))
      return d === 0 && I(23), { height: Math.max(1, d), estimated: !1 };
  }
  if (t.detail && o.get("masterDetail"))
    return VC(o);
  const r = o.get("rowHeight");
  return { height: r && La(r) ? r : s, estimated: !1 };
}
function VC(e) {
  if (e.get("detailRowAutoHeight"))
    return { height: 1, estimated: !1 };
  const t = e.get("detailRowHeight");
  return La(t) ? { height: t, estimated: !1 } : { height: 300, estimated: !1 };
}
function Ti(e) {
  const { environment: t, gos: i } = e, s = i.get("rowHeight");
  if (!s || de(s))
    return t.getDefaultRowHeight();
  const o = t.refreshRowHeightVariable();
  return o !== -1 ? o : (I(24), t.getDefaultRowHeight());
}
function La(e) {
  return !isNaN(e) && typeof e == "number" && isFinite(e);
}
function jh(e, t, i) {
  const s = t[e.getDomDataKey()];
  return s ? s[i] : void 0;
}
function Oi(e, t, i, s) {
  const o = e.getDomDataKey();
  let n = t[o];
  de(n) && (n = {}, t[o] = n), n[i] = s;
}
function as(e) {
  return e.get("ensureDomOrder") ? !1 : e.get("animateRows");
}
function qh(e) {
  return !(e.get("paginateChildRows") || e.get("groupHideOpenParents") || Me(e, "print"));
}
function St(e) {
  const t = e.get("autoGroupColumnDef");
  return !(t != null && t.comparator) && !e.get("treeData");
}
function Oa(e) {
  const t = e.get("groupAggFiltering");
  if (typeof t == "function")
    return e.getCallback("groupAggFiltering");
  if (t === !0)
    return () => !0;
}
function Yh(e) {
  return e.get("grandTotalRow");
}
function Qh(e, t) {
  return t ? !1 : e.get("groupDisplayType") === "groupRows";
}
function Xh(e, t, i) {
  return !!t.group && !t.footer && Qh(e, i);
}
function ws(e) {
  const t = e.getCallback("getRowId");
  return t === void 0 ? t : (i) => {
    let s = t(i);
    return typeof s != "string" && (Ml(() => I(25, { id: s }), "getRowIdString"), s = String(s)), s;
  };
}
function NC(e, t) {
  const i = e.get("groupHideParentOfSingleChild");
  return !!(i === !0 || i === "leafGroupsOnly" && t.leafGroup || e.get("groupRemoveSingleChildren") || e.get("groupRemoveLowestSingleChildren") && t.leafGroup);
}
function WC(e) {
  const t = e.get("maxConcurrentDatasourceRequests");
  return t > 0 ? t : void 0;
}
function ls(e) {
  return (e == null ? void 0 : e.checkboxes) ?? !0;
}
function Pn(e) {
  return (e == null ? void 0 : e.mode) === "multiRow" && (e.headerCheckbox ?? !0);
}
function $n(e) {
  if (typeof e == "object")
    return e.checkboxLocation ?? "selectionColumn";
}
function Nr(e) {
  return (e == null ? void 0 : e.hideDisabledCheckboxes) ?? !1;
}
function zC(e) {
  return typeof e.get("rowSelection") != "string";
}
function zt(e) {
  const t = e.get("cellSelection");
  return t !== void 0 ? !!t : e.get("enableRangeSelection");
}
function Zh(e) {
  const t = e.get("rowSelection") ?? "single";
  if (typeof t == "string") {
    const i = e.get("suppressRowClickSelection"), s = e.get("suppressRowDeselection");
    return i && s ? !1 : i ? "enableDeselection" : s ? "enableSelection" : !0;
  }
  return t.mode === "singleRow" || t.mode === "multiRow" ? t.enableClickSelection ?? !1 : !1;
}
function UC(e) {
  const t = Zh(e);
  return t === !0 || t === "enableSelection";
}
function $C(e) {
  const t = Zh(e);
  return t === !0 || t === "enableDeselection";
}
function _a(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("isRowSelectable") : t == null ? void 0 : t.isRowSelectable;
}
function Kn(e) {
  const t = "beanName" in e && e.beanName === "gos" ? e.get("rowSelection") : e.rowSelection;
  if (typeof t == "string")
    switch (t) {
      case "multiple":
        return "multiRow";
      case "single":
        return "singleRow";
      default:
        return;
    }
  switch (t == null ? void 0 : t.mode) {
    case "multiRow":
    case "singleRow":
      return t.mode;
    default:
      return;
  }
}
function xo(e) {
  return Kn(e) === "multiRow";
}
function KC(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("rowMultiSelectWithClick") : (t == null ? void 0 : t.enableSelectionWithoutKeys) ?? !1;
}
function jn(e) {
  const t = e.get("rowSelection");
  if (typeof t == "string") {
    const i = e.get("groupSelectsChildren"), s = e.get("groupSelectsFiltered");
    return i && s ? "filteredDescendants" : i ? "descendants" : "self";
  }
  return (t == null ? void 0 : t.mode) === "multiRow" ? t.groupSelects : void 0;
}
function Jh(e, t = !0) {
  const i = e.get("rowSelection");
  return typeof i != "object" ? t ? "all" : void 0 : i.mode === "multiRow" ? i.selectAll : "all";
}
function Fo(e) {
  const t = jn(e);
  return t === "descendants" || t === "filteredDescendants";
}
function qd(e) {
  const t = e.get("rowSelection");
  return typeof t == "object" && t.masterSelects || "self";
}
function jC(e) {
  return e.isModuleRegistered("SetFilter") && !e.get("suppressSetFilterByDefault");
}
function $e(e) {
  return e.get("columnMenu") === "legacy";
}
function qC(e) {
  return !$e(e);
}
function YC(e) {
  return !e || e.length < 2 ? e : "on" + e[0].toUpperCase() + e.substring(1);
}
function QC(e, t, i) {
  typeof e != "object" && (e = {});
  const s = { ...e };
  return i.forEach((o) => {
    const n = t[o];
    typeof n < "u" && (s[o] = n);
  }), s;
}
function XC(e, t) {
  if (!e)
    return;
  const i = {};
  let s = !1;
  if (Object.keys(e).forEach((r) => {
    i[r] = e[r], s = !0;
  }), !s)
    return;
  const o = {
    type: "gridOptionsChanged",
    options: i
  };
  t.dispatchEvent(o);
  const n = {
    type: "componentStateChanged",
    ...i
  };
  t.dispatchEvent(n);
}
function W(e, t) {
  return e.addCommon(t);
}
function eg(e) {
  return e.get("treeData") ? e.get("treeDataParentIdField") ? "treeSelfRef" : e.get("treeDataChildrenField") ? "treeNested" : "treePath" : "group";
}
function Yd({ gos: e }, t) {
  return t.button === 2 || t.ctrlKey && e.get("allowContextMenuWithControlKey");
}
var ZC = {
  resizable: !0,
  sortable: !0
}, JC = 0;
function tg() {
  return JC++;
}
function ai(e) {
  return e instanceof Wi;
}
var Wi = class extends E {
  constructor(e, t, i, s) {
    super(), this.colDef = e, this.userProvidedColDef = t, this.colId = i, this.primary = s, this.isColumn = !0, this.instanceId = tg(), this.autoHeaderHeight = null, this.moving = !1, this.resizing = !1, this.menuVisible = !1, this.lastLeftPinned = !1, this.firstRightPinned = !1, this.filterActive = !1, this.colEventSvc = new Li(), this.tooltipEnabled = !1, this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.flex = null, this.colIdSanitised = to(i);
  }
  destroy() {
    var e;
    super.destroy(), (e = this.beans.rowSpanSvc) == null || e.deregister(this);
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState() {
    const {
      colDef: e,
      beans: { sortSvc: t, pinnedCols: i, colFlex: s }
    } = this;
    t == null || t.initCol(this);
    const o = e.hide;
    o !== void 0 ? this.visible = !o : this.visible = !e.initialHide, i == null || i.initCol(this), s == null || s.initCol(this);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(e, t, i) {
    var o;
    const s = e.spanRows !== this.colDef.spanRows;
    this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation(), this.initTooltip(), s && ((o = this.beans.rowSpanSvc) == null || o.deregister(this), this.initRowSpan()), this.dispatchColEvent("colDefChanged", i);
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  getParent() {
    return this.parent;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  // this is done after constructor as it uses gridOptionsService
  postConstruct() {
    this.setState(), this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip(), this.initRowSpan(), this.addPivotListener();
  }
  initDotNotation() {
    const {
      gos: e,
      colDef: { field: t, tooltipField: i }
    } = this, s = e.get("suppressFieldDotNotation");
    this.fieldContainsDots = H(t) && t.indexOf(".") >= 0 && !s, this.tooltipFieldContainsDots = H(i) && i.indexOf(".") >= 0 && !s;
  }
  initMinAndMaxWidths() {
    const e = this.colDef;
    this.minWidth = e.minWidth ?? this.beans.environment.getDefaultColumnMinWidth(), this.maxWidth = e.maxWidth ?? Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    var e;
    (e = this.beans.tooltipSvc) == null || e.initCol(this);
  }
  initRowSpan() {
    var e;
    this.colDef.spanRows && ((e = this.beans.rowSpanSvc) == null || e.register(this));
  }
  addPivotListener() {
    const e = this.beans.pivotColDefSvc, t = this.colDef.pivotValueColumn;
    !e || !t || this.addManagedListeners(t, {
      colDefChanged: (i) => {
        const s = e.recreateColDef(this.colDef);
        this.setColDef(s, s, i.source);
      }
    });
  }
  resetActualWidth(e) {
    const t = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(t, e, !0);
  }
  calculateColInitialWidth(e) {
    let t;
    const i = e.width, s = e.initialWidth;
    return i != null ? t = i : s != null ? t = s : t = 200, Math.max(Math.min(t, this.maxWidth), this.minWidth);
  }
  isEmptyGroup() {
    return !1;
  }
  isRowGroupDisplayed(e) {
    var t;
    return ((t = this.beans.showRowGroupCols) == null ? void 0 : t.isRowGroupDisplayed(this, e)) ?? !1;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    return !!this.colDef.filter;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  getHighlighted() {
    return this.highlighted;
  }
  __addEventListener(e, t) {
    this.colEventSvc.addEventListener(e, t);
  }
  __removeEventListener(e, t) {
    this.colEventSvc.removeEventListener(e, t);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  addEventListener(e, t) {
    var s, o, n;
    this.frameworkEventListenerService = (o = (s = this.beans.frameworkOverrides).createLocalEventListenerWrapper) == null ? void 0 : o.call(
      s,
      this.frameworkEventListenerService,
      this.colEventSvc
    );
    const i = ((n = this.frameworkEventListenerService) == null ? void 0 : n.wrap(e, t)) ?? t;
    this.colEventSvc.addEventListener(e, i);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  removeEventListener(e, t) {
    var s;
    const i = ((s = this.frameworkEventListenerService) == null ? void 0 : s.unwrap(e, t)) ?? t;
    this.colEventSvc.removeEventListener(e, i);
  }
  createColumnFunctionCallbackParams(e) {
    return W(this.gos, {
      node: e,
      data: e.data,
      column: this,
      colDef: this.colDef
    });
  }
  isSuppressNavigable(e) {
    var t;
    return ((t = this.beans.cellNavigation) == null ? void 0 : t.isSuppressNavigable(this, e)) ?? !1;
  }
  isCellEditable(e) {
    var t;
    return ((t = this.beans.editSvc) == null ? void 0 : t.isCellEditable({ rowNode: e, column: this })) ?? !1;
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(e) {
    return this.isColumnFunc(e, this.colDef.rowDrag);
  }
  isDndSource(e) {
    return this.isColumnFunc(e, this.colDef.dndSource);
  }
  isCellCheckboxSelection(e) {
    var t;
    return ((t = this.beans.selectionSvc) == null ? void 0 : t.isCellCheckboxSelection(this, e)) ?? !1;
  }
  isSuppressPaste(e) {
    var t;
    return this.isColumnFunc(e, ((t = this.colDef) == null ? void 0 : t.suppressPaste) ?? null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  /** Get value from ColDef or default if it exists. */
  getColDefValue(e) {
    return this.colDef[e] ?? ZC[e];
  }
  isColumnFunc(e, t) {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function") {
      const i = this.createColumnFunctionCallbackParams(e);
      return t(i);
    }
    return !1;
  }
  createColumnEvent(e, t) {
    return W(this.gos, {
      type: e,
      column: this,
      columns: [this],
      source: t
    });
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  /** @deprecated v32 use col.getSort() === 'asc */
  isSortAscending() {
    return this.sort === "asc";
  }
  /** @deprecated v32 use col.getSort() === 'desc */
  isSortDescending() {
    return this.sort === "desc";
  }
  /** @deprecated v32 use col.getSort() === undefined */
  isSortNone() {
    return de(this.sort);
  }
  /** @deprecated v32 use col.getSort() !== undefined */
  isSorting() {
    return H(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(e, t) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchColEvent("leftChanged", t));
  }
  isFilterActive() {
    return this.filterActive;
  }
  /** @deprecated v33 Use `api.isColumnHovered(column)` instead. */
  isHovered() {
    var e;
    return I(261), !!((e = this.beans.colHover) != null && e.isHovered(this));
  }
  setFirstRightPinned(e, t) {
    this.firstRightPinned !== e && (this.firstRightPinned = e, this.dispatchColEvent("firstRightPinnedChanged", t));
  }
  setLastLeftPinned(e, t) {
    this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.dispatchColEvent("lastLeftPinnedChanged", t));
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(e, t) {
    const i = e === !0;
    this.visible !== i && (this.visible = i, this.dispatchColEvent("visibleChanged", t)), this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    return !this.getColDef().suppressSpanHeaderHeight;
  }
  /**
   * Returns the first parent that is not a padding group.
   */
  getFirstRealParent() {
    let e = this.getOriginalParent();
    for (; e && e.isPadding(); )
      e = e.getOriginalParent();
    return e;
  }
  getColumnGroupPaddingInfo() {
    let e = this.getParent();
    if (!e || !e.isPadding())
      return { numberOfParents: 0, isSpanningTotal: !1 };
    const t = e.getPaddingLevel() + 1;
    let i = !0;
    for (; e; ) {
      if (!e.isPadding()) {
        i = !1;
        break;
      }
      e = e.getParent();
    }
    return { numberOfParents: t, isSpanningTotal: i };
  }
  getColDef() {
    return this.colDef;
  }
  getDefinition() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  createBaseColDefParams(e) {
    return W(this.gos, {
      node: e,
      data: e.data,
      colDef: this.colDef,
      column: this
    });
  }
  getColSpan(e) {
    if (de(this.colDef.colSpan))
      return 1;
    const t = this.createBaseColDefParams(e), i = this.colDef.colSpan(t);
    return Math.max(i, 1);
  }
  getRowSpan(e) {
    if (de(this.colDef.rowSpan))
      return 1;
    const t = this.createBaseColDefParams(e), i = this.colDef.rowSpan(t);
    return Math.max(i, 1);
  }
  setActualWidth(e, t, i = !1) {
    e = Math.max(e, this.minWidth), e = Math.min(e, this.maxWidth), this.actualWidth !== e && (this.actualWidth = e, this.flex != null && t !== "flex" && t !== "gridInitializing" && (this.flex = null), i || this.fireColumnWidthChangedEvent(t)), this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(e) {
    this.dispatchColEvent("widthChanged", e);
  }
  isGreaterThanMax(e) {
    return e > this.maxWidth;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex;
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === !0;
  }
  isAllowValue() {
    return this.colDef.enableValue === !0;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === !0;
  }
  dispatchColEvent(e, t, i) {
    const s = this.createColumnEvent(e, t);
    i && Be(s, i), this.colEventSvc.dispatchEvent(s);
  }
  dispatchStateUpdatedEvent(e) {
    this.colEventSvc.dispatchEvent({
      type: "columnStateUpdated",
      key: e
    });
  }
};
function Oe(e) {
  return e instanceof En;
}
var En = class extends E {
  constructor(e, t, i, s) {
    super(), this.colGroupDef = e, this.groupId = t, this.padding = i, this.level = s, this.isColumn = !1, this.expandable = !1, this.instanceId = tg(), this.expandableListenerRemoveCallback = null, this.expanded = !!(e != null && e.openByDefault);
  }
  destroy() {
    this.expandableListenerRemoveCallback && this.reset(null, void 0), super.destroy();
  }
  reset(e, t) {
    this.colGroupDef = e, this.level = t, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    return this.children ? this.children.some((e) => e.isVisible()) : !1;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(e) {
    this.expanded = e === void 0 ? !1 : e, this.dispatchLocalEvent({ type: "expandedChanged" });
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(e) {
    this.children = e;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  forEachLeafColumn(e) {
    if (this.children)
      for (const t of this.children)
        ai(t) ? e(t) : Oe(t) && t.forEachLeafColumn(e);
  }
  addLeafColumns(e) {
    this.children && this.children.forEach((t) => {
      ai(t) ? e.push(t) : Oe(t) && t.addLeafColumns(e);
    });
  }
  getColumnGroupShow() {
    const e = this.colGroupDef;
    if (e)
      return e.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
    const e = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((t) => t.__addEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((t) => t.__removeEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding())
      return;
    let e = !1, t = !1, i = !1;
    const s = this.findChildrenRemovingPadding();
    for (let n = 0, r = s.length; n < r; n++) {
      const a = s[n];
      if (!a.isVisible())
        continue;
      const l = a.getColumnGroupShow();
      l === "open" ? (e = !0, i = !0) : l === "closed" ? (t = !0, i = !0) : (e = !0, t = !0);
    }
    const o = e && t && i;
    this.expandable !== o && (this.expandable = o, this.dispatchLocalEvent({ type: "expandableChanged" }));
  }
  findChildrenRemovingPadding() {
    const e = [], t = (i) => {
      i.forEach((s) => {
        Oe(s) && s.isPadding() ? t(s.children) : e.push(s);
      });
    };
    return t(this.children), e;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
}, ev = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
};
function Qd(e, t, i) {
  const s = {}, o = e.gos;
  return Object.assign(s, o.get("defaultColGroupDef")), Object.assign(s, t), o.validateColDef(s, i), s;
}
var tv = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(e) {
    for (let t = 0; t < e.length; t++)
      this.existingKeys[e[t]] = !0;
  }
  getUniqueKey(e, t) {
    e = Ma(e);
    let i = 0;
    for (; ; ) {
      let s = e ?? t;
      if (s ? i !== 0 && (s += "_" + i) : s = i, !this.existingKeys[s]) {
        const o = String(s);
        return e && i > 0 && I(273, { providedId: e, usedId: o }), this.existingKeys[o] = !0, o;
      }
      i++;
    }
  }
}, Xd = Object.freeze([]);
function se(e) {
  if (e != null && e.length)
    return e[e.length - 1];
}
function ci(e, t, i) {
  if (e === t)
    return !0;
  if (!e || !t)
    return e == null && t == null;
  const s = e.length;
  if (s !== t.length)
    return !1;
  for (let o = 0; o < s; o++)
    if (e[o] !== t[o] && !(i != null && i(e[o], t[o])))
      return !1;
  return !0;
}
function _s(e, t) {
  if (e)
    for (const i of e)
      t(i);
}
function tt(e, t) {
  const i = e.indexOf(t);
  i >= 0 && e.splice(i, 1);
}
function Zd(e, t, i) {
  for (let s = 0; s < t.length; s++)
    tt(e, t[s]);
  for (let s = t.length - 1; s >= 0; s--)
    e.splice(i, 0, t[s]);
}
var vr = "ag-Grid-AutoColumn", ig = "ag-Grid-SelectionColumn", sg = "ag-Grid-RowNumbersColumn";
function og(e) {
  const t = [], i = (s) => {
    for (let o = 0; o < s.length; o++) {
      const n = s[o];
      ai(n) ? t.push(n) : Oe(n) && i(n.getChildren());
    }
  };
  return i(e), t;
}
function _t(e) {
  return e.reduce((t, i) => t + i.getActualWidth(), 0);
}
function qn(e, t, i) {
  const s = {};
  if (!t)
    return;
  Nt(null, t, (n) => {
    s[n.getInstanceId()] = n;
  }), i && Nt(null, i, (n) => {
    s[n.getInstanceId()] = null;
  });
  const o = Object.values(s).filter((n) => n != null);
  e.context.destroyBeans(o);
}
function kl(e) {
  return e.getId().startsWith(vr);
}
function ui(e) {
  const t = typeof e == "string" ? e : "getColId" in e ? e.getColId() : e.colId;
  return (t == null ? void 0 : t.startsWith(ig)) ?? !1;
}
function ii(e) {
  const t = typeof e == "string" ? e : "getColId" in e ? e.getColId() : e.colId;
  return (t == null ? void 0 : t.startsWith(sg)) ?? !1;
}
function iv(e) {
  return ui(e) || ii(e);
}
function Yn(e) {
  let t = [];
  return e instanceof Array ? t = e : typeof e == "string" && (t = e.split(",")), t;
}
function sv(e, t) {
  return ci(e, t, (i, s) => i.getColId() === s.getColId());
}
function ov(e) {
  e.map = {}, e.list.forEach((t) => e.map[t.getId()] = t);
}
function ds(e) {
  return e === "optionsUpdated" ? "gridOptionsChanged" : e;
}
function ng(e, t) {
  const i = e === t, s = e.getColDef() === t, o = e.getColId() == t;
  return i || s || o;
}
var nv = (e, t) => (i, s) => {
  const o = {
    value1: void 0,
    value2: void 0
  };
  let n = !1;
  return e && (e[i] !== void 0 && (o.value1 = e[i], n = !0), H(s) && e[s] !== void 0 && (o.value2 = e[s], n = !0)), !n && t && (t[i] !== void 0 && (o.value1 = t[i]), H(s) && t[s] !== void 0 && (o.value2 = t[s])), o;
};
function rv(e, t = null, i, s, o) {
  const n = new tv(), { existingCols: r, existingGroups: a, existingColKeys: l } = av(s);
  n.addExistingKeys(l);
  const d = rg(
    e,
    t,
    0,
    i,
    r,
    n,
    a,
    o
  ), { colGroupSvc: c } = e, u = (c == null ? void 0 : c.findMaxDepth(d, 0)) ?? 0, h = c ? c.balanceColumnTree(d, 0, u, n) : d;
  return Nt(null, h, (p, f) => {
    Oe(p) && p.setupExpandable(), p.originalParent = f;
  }), {
    columnTree: h,
    treeDepth: u
  };
}
function av(e) {
  const t = [], i = [], s = [];
  return e && Nt(null, e, (o) => {
    if (Oe(o)) {
      const n = o;
      i.push(n);
    } else {
      const n = o;
      s.push(n.getId()), t.push(n);
    }
  }), { existingCols: t, existingGroups: i, existingColKeys: s };
}
function rg(e, t, i, s, o, n, r, a) {
  if (!t)
    return [];
  const { colGroupSvc: l } = e, d = new Array(t.length);
  for (let c = 0; c < d.length; c++) {
    const u = t[c];
    l && gv(u) ? d[c] = l.createProvidedColumnGroup(
      s,
      u,
      i,
      o,
      n,
      r,
      a
    ) : d[c] = lv(e, s, u, o, n, a);
  }
  return d;
}
function lv(e, t, i, s, o, n) {
  var l;
  const r = cv(i, s);
  r && (s == null || s.splice(r.idx, 1));
  let a = r == null ? void 0 : r.column;
  if (a) {
    const d = Ha(e, i, a.getColId());
    a.setColDef(d, i, n), dv(e, a, d, n);
  } else {
    const d = o.getUniqueKey(i.colId, i.field), c = Ha(e, i, d);
    a = new Wi(c, i, d, t), e.context.createBean(a);
  }
  return (l = e.dataTypeSvc) == null || l.addColumnListeners(a), a;
}
function ag(e, t, i, s, o, n, r, a) {
  const { sortSvc: l, pinnedCols: d, colFlex: c } = e;
  i !== void 0 && t.setVisible(!i, a), l && (l.updateColSort(t, s, a), o !== void 0 && l.setColSortIndex(t, o)), n !== void 0 && (d == null || d.setColPinned(t, n)), r !== void 0 && (c == null || c.setColFlex(t, r));
}
function dv(e, t, i, s) {
  ag(
    e,
    t,
    i.hide,
    i.sort,
    i.sortIndex,
    i.pinned,
    i.flex,
    s
  );
  const o = t.getFlex();
  if (!(o != null && o > 0))
    if (i.width != null)
      t.setActualWidth(i.width, s);
    else {
      const n = t.getActualWidth();
      t.setActualWidth(n, s);
    }
}
function cv(e, t) {
  if (t)
    for (let i = 0; i < t.length; i++) {
      const s = t[i].getUserProvidedColDef();
      if (!s)
        continue;
      if (e.colId != null) {
        if (t[i].getId() === e.colId)
          return { idx: i, column: t[i] };
        continue;
      }
      if (e.field != null) {
        if (s.field === e.field)
          return { idx: i, column: t[i] };
        continue;
      }
      if (s === e)
        return { idx: i, column: t[i] };
    }
}
function Ha(e, t, i, s) {
  const { gos: o, dataTypeSvc: n } = e, r = {}, a = o.get("defaultColDef");
  Be(r, a, !1, !0);
  const l = uv(e, r, t, i);
  l && hv(e, l, r);
  const d = r.cellDataType;
  Be(r, t, !1, !0), d !== void 0 && (r.cellDataType = d);
  const c = o.get("autoGroupColumnDef"), u = St(o);
  return t.rowGroup && c && u && Be(
    r,
    { sort: c.sort, initialSort: c.initialSort },
    !1,
    !0
  ), n && (n.postProcess(r), n.validateColDef(r)), o.validateColDef(r, i, s), r;
}
function uv(e, t, i, s) {
  var r;
  const o = (r = e.dataTypeSvc) == null ? void 0 : r.updateColDefAndGetColumnType(t, i, s), n = i.type ?? o ?? t.type;
  return t.type = n, n ? Yn(n) : void 0;
}
function hv(e, t, i) {
  if (!t.length)
    return;
  const s = Object.assign({}, ev), o = e.gos.get("columnTypes") || {};
  for (const n of Object.keys(o)) {
    const r = o[n];
    n in s ? I(34, { key: n }) : (r.type && I(35), s[n] = r);
  }
  t.forEach((n) => {
    const r = s[n.trim()];
    r ? Be(i, r, !1, !0) : I(36, { t: n });
  });
}
function gv(e) {
  return e.children !== void 0;
}
function Nt(e, t, i) {
  if (t)
    for (let s = 0; s < t.length; s++) {
      const o = t[s];
      Oe(o) && Nt(o, o.getChildren(), i), i(o, e);
    }
}
function lg(e, t) {
  const i = [], s = [], o = [];
  return e.forEach((r) => {
    const a = r.getColDef().lockPosition;
    a === "right" ? o.push(r) : a === "left" || a === !0 ? i.push(r) : s.push(r);
  }), t.get("enableRtl") ? [...o, ...s, ...i] : [...i, ...s, ...o];
}
function dg(e, t) {
  let i = !0;
  return Nt(null, t, (s) => {
    if (!Oe(s))
      return;
    const o = s, n = o.getColGroupDef();
    if (!(n && n.marryChildren))
      return;
    const a = [];
    o.getLeafColumns().forEach((h) => {
      const g = e.indexOf(h);
      a.push(g);
    });
    const l = Math.max.apply(Math, a), d = Math.min.apply(Math, a), c = l - d, u = o.getLeafColumns().length - 1;
    c > u && (i = !1);
  }), i;
}
function cg(e, t) {
  if (!e || e.length == 0)
    return;
  const i = t(e[0]);
  for (let s = 1; s < e.length; s++)
    if (i !== t(e[s]))
      return;
  return i;
}
function ug(e, t, i) {
  if (!t.length)
    return;
  const s = t.length === 1 ? t[0] : null, o = cg(t, (n) => n.getPinned());
  e.dispatchEvent({
    type: "columnPinned",
    // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
    pinned: o ?? null,
    columns: t,
    column: s,
    source: i
  });
}
function pv(e, t, i) {
  if (!t.length)
    return;
  const s = t.length === 1 ? t[0] : null, o = cg(t, (n) => n.isVisible());
  e.dispatchEvent({
    type: "columnVisible",
    visible: o,
    columns: t,
    column: s,
    source: i
  });
}
function fv(e, t, i, s) {
  e.dispatchEvent({
    type: t,
    columns: i,
    column: i && i.length == 1 ? i[0] : null,
    source: s
  });
}
function bs(e, t, i, s, o = null) {
  t != null && t.length && e.dispatchEvent({
    type: "columnResized",
    columns: t,
    column: t.length === 1 ? t[0] : null,
    flexColumns: o,
    finished: i,
    source: s
  });
}
function ut(e, t, i) {
  var w;
  const {
    colModel: s,
    rowGroupColsSvc: o,
    pivotColsSvc: n,
    autoColSvc: r,
    selectionColSvc: a,
    colAnimation: l,
    visibleCols: d,
    pivotResultCols: c,
    environment: u,
    valueColsSvc: h,
    eventSvc: g,
    gos: p
  } = e, f = s.getColDefCols() ?? [], m = a == null ? void 0 : a.getColumns();
  if (!f.length && !(m != null && m.length))
    return !1;
  if (t != null && t.state && !t.state.forEach)
    return I(32), !1;
  const C = (x, F, D, T, k) => {
    if (!x)
      return;
    const A = nv(F, t.defaultState), G = A("flex").value1;
    if (ag(
      e,
      x,
      A("hide").value1,
      A("sort").value1,
      A("sortIndex").value1,
      A("pinned").value1,
      G,
      i
    ), G == null) {
      const $ = A("width").value1;
      if ($ != null) {
        const q = x.getColDef().minWidth ?? u.getDefaultColumnMinWidth();
        q != null && $ >= q && x.setActualWidth($, i);
      }
    }
    k || !x.isPrimary() || (h == null || h.syncColumnWithState(x, i, A), o == null || o.syncColumnWithState(x, i, A, D), n == null || n.syncColumnWithState(x, i, A, T));
  }, v = (x, F, D) => {
    var pt, rt;
    const T = hg(e, i), k = F.slice(), A = {}, G = {}, $ = [], q = [], j = [];
    let oe = 0;
    const ne = (o == null ? void 0 : o.columns.slice()) ?? [], gt = (n == null ? void 0 : n.columns.slice()) ?? [];
    x.forEach((ge) => {
      const He = ge.colId;
      if (He.startsWith(vr)) {
        $.push(ge), j.push(ge);
        return;
      }
      if (ui(He)) {
        q.push(ge), j.push(ge);
        return;
      }
      const Ae = D(He);
      Ae ? (C(Ae, ge, A, G, !1), tt(k, Ae)) : (j.push(ge), oe += 1);
    });
    const It = (ge) => C(ge, null, A, G, !1);
    k.forEach(It), o == null || o.sortColumns(Jd.bind(o, A, ne)), n == null || n.sortColumns(Jd.bind(n, G, gt)), s.refreshCols(!1);
    const je = (ge, He, at = []) => {
      He.forEach((Ae) => {
        const me = ge(Ae.colId);
        tt(at, me), C(me, Ae, null, null, !0);
      }), at.forEach(It);
    };
    return je(
      (ge) => (r == null ? void 0 : r.getColumn(ge)) ?? null,
      $,
      (pt = r == null ? void 0 : r.getColumns()) == null ? void 0 : pt.slice()
    ), je(
      (ge) => (a == null ? void 0 : a.getColumn(ge)) ?? null,
      q,
      (rt = a == null ? void 0 : a.getColumns()) == null ? void 0 : rt.slice()
    ), Cv(t, s, p), d.refresh(i), g.dispatchEvent({
      type: "columnEverythingChanged",
      source: i
    }), T(), { unmatchedAndAutoStates: j, unmatchedCount: oe };
  };
  l == null || l.start();
  let { unmatchedAndAutoStates: R, unmatchedCount: b } = v(
    t.state || [],
    f,
    (x) => s.getColDefCol(x)
  );
  if (R.length > 0 || H(t.defaultState)) {
    const x = ((w = c == null ? void 0 : c.getPivotResultCols()) == null ? void 0 : w.list) ?? [];
    b = v(
      R,
      x,
      (F) => (c == null ? void 0 : c.getPivotResultCol(F)) ?? null
    ).unmatchedCount;
  }
  return l == null || l.finish(), b === 0;
}
function mv(e, t) {
  var v, R;
  const { colModel: i, autoColSvc: s, selectionColSvc: o, eventSvc: n, gos: r } = e, a = i.getColDefCols();
  if (!(a != null && a.length))
    return;
  const l = i.getColDefColTree(), d = og(l), c = [];
  let u = 1e3, h = 1e3;
  const g = (b) => {
    const w = gg(b);
    de(w.rowGroupIndex) && w.rowGroup && (w.rowGroupIndex = u++), de(w.pivotIndex) && w.pivot && (w.pivotIndex = h++), c.push(w);
  };
  (v = s == null ? void 0 : s.getColumns()) == null || v.forEach(g), (R = o == null ? void 0 : o.getColumns()) == null || R.forEach(g), d == null || d.forEach(g), ut(e, { state: c }, t);
  const p = (s == null ? void 0 : s.getColumns()) ?? [], C = [...(o == null ? void 0 : o.getColumns()) ?? [], ...p, ...a].map((b) => ({ colId: b.colId }));
  ut(e, { state: C, applyOrder: !0 }, t), n.dispatchEvent(W(r, { type: "columnsReset", source: t }));
}
function hg(e, t) {
  const { rowGroupColsSvc: i, pivotColsSvc: s, valueColsSvc: o, colModel: n, sortSvc: r, eventSvc: a } = e, l = {
    rowGroupColumns: (i == null ? void 0 : i.columns.slice()) ?? [],
    pivotColumns: (s == null ? void 0 : s.columns.slice()) ?? [],
    valueColumns: (o == null ? void 0 : o.columns.slice()) ?? []
  }, d = Qn(e), c = {};
  return d.forEach((u) => {
    c[u.colId] = u;
  }), () => {
    const u = (x, F, D, T) => {
      const k = F.map(T), A = D.map(T);
      if (ci(k, A))
        return;
      const $ = new Set(F);
      D.forEach((j) => {
        $.delete(j) || $.add(j);
      });
      const q = [...$];
      a.dispatchEvent({
        type: x,
        columns: q,
        column: q.length === 1 ? q[0] : null,
        source: t
      });
    }, h = (x) => {
      const F = [];
      return n.forAllCols((D) => {
        const T = c[D.getColId()];
        T && x(T, D) && F.push(D);
      }), F;
    }, g = (x) => x.getColId();
    u(
      "columnRowGroupChanged",
      l.rowGroupColumns,
      (i == null ? void 0 : i.columns) ?? [],
      g
    ), u(
      "columnPivotChanged",
      l.pivotColumns,
      (s == null ? void 0 : s.columns) ?? [],
      g
    );
    const f = h((x, F) => {
      const D = x.aggFunc != null, T = D != F.isValueActive(), k = D && x.aggFunc != F.getAggFunc();
      return T || k;
    });
    f.length > 0 && fv(a, "columnValueChanged", f, t), bs(a, h((x, F) => x.width != F.getActualWidth()), !0, t), ug(a, h((x, F) => x.pinned != F.getPinned()), t), pv(a, h((x, F) => x.hide == F.isVisible()), t);
    const b = h((x, F) => x.sort != F.getSort() || x.sortIndex != F.getSortIndex());
    b.length > 0 && (r == null || r.dispatchSortChangedEvents(t, b));
    const w = Qn(e);
    wv(d, w, t, n, a);
  };
}
function Qn(e) {
  const { colModel: t, rowGroupColsSvc: i, pivotColsSvc: s } = e, o = t.getColDefCols();
  if (de(o) || !t.isAlive())
    return [];
  const n = i == null ? void 0 : i.columns, r = s == null ? void 0 : s.columns, a = [], l = (c) => {
    const u = c.isRowGroupActive() && n ? n.indexOf(c) : null, h = c.isPivotActive() && r ? r.indexOf(c) : null, g = c.isValueActive() ? c.getAggFunc() : null, p = c.getSort() != null ? c.getSort() : null, f = c.getSortIndex() != null ? c.getSortIndex() : null;
    a.push({
      colId: c.getColId(),
      width: c.getActualWidth(),
      hide: !c.isVisible(),
      pinned: c.getPinned(),
      sort: p,
      sortIndex: f,
      aggFunc: g,
      rowGroup: c.isRowGroupActive(),
      rowGroupIndex: u,
      pivot: c.isPivotActive(),
      pivotIndex: h,
      flex: c.getFlex() ?? null
    });
  };
  t.forAllCols((c) => l(c));
  const d = new Map(
    t.getCols().map((c, u) => [c.getColId(), u])
  );
  return a.sort((c, u) => {
    const h = d.has(c.colId) ? d.get(c.colId) : -1, g = d.has(u.colId) ? d.get(u.colId) : -1;
    return h - g;
  }), a;
}
function gg(e) {
  const t = (p, f) => p ?? f ?? null, i = e.getColDef(), s = t(i.sort, i.initialSort), o = t(i.sortIndex, i.initialSortIndex), n = t(i.hide, i.initialHide), r = t(i.pinned, i.initialPinned), a = t(i.width, i.initialWidth), l = t(i.flex, i.initialFlex);
  let d = t(i.rowGroupIndex, i.initialRowGroupIndex), c = t(i.rowGroup, i.initialRowGroup);
  d == null && (c == null || c == !1) && (d = null, c = null);
  let u = t(i.pivotIndex, i.initialPivotIndex), h = t(i.pivot, i.initialPivot);
  u == null && (h == null || h == !1) && (u = null, h = null);
  const g = t(i.aggFunc, i.initialAggFunc);
  return {
    colId: e.getColId(),
    sort: s,
    sortIndex: o,
    hide: n,
    pinned: r,
    width: a,
    flex: l,
    rowGroup: c,
    rowGroupIndex: d,
    pivot: h,
    pivotIndex: u,
    aggFunc: g
  };
}
function Cv(e, t, i) {
  if (!e.applyOrder || !e.state)
    return;
  const s = [];
  e.state.forEach((o) => {
    o.colId != null && s.push(o.colId);
  }), vv(t.cols, s, t, i);
}
function vv(e, t, i, s) {
  if (e == null)
    return;
  let o = [];
  const n = {};
  t.forEach((a) => {
    if (n[a])
      return;
    const l = e.map[a];
    l && (o.push(l), n[a] = !0);
  });
  let r = 0;
  if (e.list.forEach((a) => {
    const l = a.getColId();
    if (n[l] != null)
      return;
    l.startsWith(vr) ? o.splice(r++, 0, a) : o.push(a);
  }), o = lg(o, s), !dg(o, i.getColTree())) {
    I(39);
    return;
  }
  e.list = o;
}
function wv(e, t, i, s, o) {
  const n = {};
  t.forEach((c) => n[c.colId] = c);
  const r = {};
  e.forEach((c) => {
    n[c.colId] && (r[c.colId] = !0);
  });
  const a = e.filter((c) => r[c.colId]), l = t.filter((c) => r[c.colId]), d = [];
  l.forEach((c, u) => {
    const h = a && a[u];
    if (h && h.colId !== c.colId) {
      const g = s.getCol(h.colId);
      g && d.push(g);
    }
  }), d.length && o.dispatchEvent({
    type: "columnMoved",
    columns: d,
    column: d.length === 1 ? d[0] : null,
    finished: !0,
    source: i
  });
}
var Jd = (e, t, i, s) => {
  const o = e[i.getId()], n = e[s.getId()], r = o != null, a = n != null;
  if (r && a)
    return o - n;
  if (r)
    return -1;
  if (a)
    return 1;
  const l = t.indexOf(i), d = t.indexOf(s), c = l >= 0, u = d >= 0;
  return c && u ? l - d : c ? -1 : 1;
}, bv = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colModel", this.pivotMode = !1, this.ready = !1, this.changeEventsDispatching = !1;
  }
  postConstruct() {
    this.pivotMode = this.gos.get("pivotMode"), this.addManagedPropertyListeners(
      [
        "groupDisplayType",
        "treeData",
        "treeDataDisplayType",
        "groupHideOpenParents",
        "rowNumbers",
        "hidePaddedHeaderRows"
      ],
      (e) => this.refreshAll(ds(e.source))
    ), this.addManagedPropertyListeners(
      ["defaultColDef", "defaultColGroupDef", "columnTypes", "suppressFieldDotNotation"],
      this.recreateColumnDefs.bind(this)
    ), this.addManagedPropertyListener(
      "pivotMode",
      (e) => this.setPivotMode(this.gos.get("pivotMode"), ds(e.source))
    );
  }
  // called from SyncService, when grid has finished initialising
  createColsFromColDefs(e) {
    var v, R, b;
    const { beans: t } = this, {
      valueCache: i,
      colAutosize: s,
      rowGroupColsSvc: o,
      pivotColsSvc: n,
      valueColsSvc: r,
      visibleCols: a,
      eventSvc: l,
      groupHierarchyColSvc: d
    } = t, c = this.colDefs ? hg(t, e) : void 0;
    i == null || i.expire();
    const u = (v = this.colDefCols) == null ? void 0 : v.list, h = (R = this.colDefCols) == null ? void 0 : R.tree, g = rv(t, this.colDefs, !0, h, e);
    qn(t, (b = this.colDefCols) == null ? void 0 : b.tree, g.columnTree);
    const p = g.columnTree, f = g.treeDepth, m = og(p), C = {};
    m.forEach((w) => C[w.getId()] = w), this.colDefCols = { tree: p, treeDepth: f, list: m, map: C }, this.createColumnsForService([d], this.colDefCols), o == null || o.extractCols(e, u), n == null || n.extractCols(e, u), r == null || r.extractCols(e, u), this.ready = !0, this.refreshCols(!0), a.refresh(e), l.dispatchEvent({
      type: "columnEverythingChanged",
      source: e
    }), c && (this.changeEventsDispatching = !0, c(), this.changeEventsDispatching = !1), l.dispatchEvent({
      type: "newColumnsLoaded",
      source: e
    }), e === "gridInitializing" && (s == null || s.applyAutosizeStrategy());
  }
  // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
  // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
  // setPivotMode, applyColumnState,
  // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
  // pivotResultCols.setPivotResultCols
  refreshCols(e) {
    var f;
    if (!this.colDefCols)
      return;
    const t = (f = this.cols) == null ? void 0 : f.tree;
    this.saveColOrder();
    const {
      autoColSvc: i,
      selectionColSvc: s,
      rowNumbersSvc: o,
      quickFilter: n,
      pivotResultCols: r,
      showRowGroupCols: a,
      rowAutoHeight: l,
      visibleCols: d,
      colViewport: c,
      eventSvc: u
    } = this.beans, h = this.selectCols(r, this.colDefCols);
    this.createColumnsForService([i, s, o], h);
    const g = GC(this.gos, this.showingPivotResult);
    (!e || g) && this.restoreColOrder(h), this.positionLockedCols(h), a == null || a.refresh(), n == null || n.refreshCols(), this.setColSpanActive(), l == null || l.setAutoHeightActive(h), d.clear(), c.clear(), !ci(t, this.cols.tree) && u.dispatchEvent({
      type: "gridColumnsChanged"
    });
  }
  createColumnsForService(e, t) {
    for (const i of e)
      i && (i.createColumns(t, (s) => {
        this.lastOrder = s(this.lastOrder), this.lastPivotOrder = s(this.lastPivotOrder);
      }), i.addColumns(t));
  }
  selectCols(e, t) {
    const i = (e == null ? void 0 : e.getPivotResultCols()) ?? null;
    this.showingPivotResult = i != null;
    const { map: s, list: o, tree: n, treeDepth: r } = i ?? t;
    return this.cols = {
      list: o.slice(),
      map: { ...s },
      tree: n.slice(),
      treeDepth: r
    }, i && (i.list.some((l) => {
      var d;
      return ((d = this.cols) == null ? void 0 : d.map[l.getColId()]) !== void 0;
    }) || (this.lastPivotOrder = null)), this.cols;
  }
  getColsToShow() {
    if (!this.cols)
      return [];
    const { valueColsSvc: e, selectionColSvc: t, gos: i } = this.beans, s = this.isPivotMode() && !this.showingPivotResult, o = t == null ? void 0 : t.isSelectionColumnEnabled(), n = i.get("rowNumbers"), r = e == null ? void 0 : e.columns;
    return this.cols.list.filter((l) => {
      const d = kl(l);
      if (s) {
        const c = r == null ? void 0 : r.includes(l);
        return d || c || o && ui(l) || n && ii(l);
      } else
        return d || l.isVisible();
    });
  }
  // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
  refreshAll(e) {
    this.ready && (this.refreshCols(!1), this.beans.visibleCols.refresh(e));
  }
  setColsVisible(e, t = !1, i) {
    ut(
      this.beans,
      {
        state: e.map((s) => ({
          colId: typeof s == "string" ? s : s.getColId(),
          hide: !t
        }))
      },
      i
    );
  }
  /**
   * Restores provided columns order to the previous order in this.lastPivotOrder / this.lastOrder
   * If columns are not in the last order:
   *  - Check column groups, and apply column after the last column in the lowest shared group
   *  - If no sibling is found, apply the column at the end of the cols
   */
  restoreColOrder(e) {
    const t = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
    if (!t)
      return;
    const i = t.filter((u) => e.map[u.getId()] != null);
    if (i.length === 0)
      return;
    if (i.length === e.list.length) {
      e.list = i;
      return;
    }
    const s = (u) => {
      const h = u.getOriginalParent();
      return h ? h.getChildren().length > 1 ? !0 : s(h) : !1;
    };
    if (!i.some((u) => s(u))) {
      const u = new Set(i);
      for (const h of e.list)
        u.has(h) || i.push(h);
      e.list = i;
      return;
    }
    const o = /* @__PURE__ */ new Map();
    for (let u = 0; u < i.length; u++) {
      const h = i[u];
      o.set(h, u);
    }
    const n = e.list.filter((u) => !o.has(u));
    if (n.length === 0) {
      e.list = i;
      return;
    }
    const r = (u, h) => {
      const g = h ? h.getOriginalParent() : u.getOriginalParent();
      if (!g)
        return null;
      let p = null, f = null;
      for (const m of g.getChildren())
        if (!(m === h || m === u)) {
          if (m instanceof Wi) {
            const C = o.get(m);
            if (C == null)
              continue;
            (p == null || p < C) && (p = C, f = m);
            continue;
          }
          m.forEachLeafColumn((C) => {
            const v = o.get(C);
            v != null && (p == null || p < v) && (p = v, f = C);
          });
        }
      return f ?? r(u, g);
    }, a = [], l = /* @__PURE__ */ new Map();
    for (const u of n) {
      const h = r(u, null);
      if (h == null) {
        a.push(u);
        continue;
      }
      const g = l.get(h);
      g === void 0 ? l.set(h, u) : Array.isArray(g) ? g.push(u) : l.set(h, [g, u]);
    }
    const d = new Array(e.list.length);
    let c = d.length - 1;
    for (let u = a.length - 1; u >= 0; u--)
      d[c--] = a[u];
    for (let u = i.length - 1; u >= 0; u--) {
      const h = i[u], g = l.get(h);
      if (g)
        if (Array.isArray(g))
          for (let p = g.length - 1; p >= 0; p--) {
            const f = g[p];
            d[c--] = f;
          }
        else
          d[c--] = g;
      d[c--] = h;
    }
    e.list = d;
  }
  positionLockedCols(e) {
    e.list = lg(e.list, this.gos);
  }
  saveColOrder() {
    var e, t;
    this.showingPivotResult ? this.lastPivotOrder = ((e = this.cols) == null ? void 0 : e.list) ?? null : this.lastOrder = ((t = this.cols) == null ? void 0 : t.list) ?? null;
  }
  getColumnDefs() {
    var e, t;
    return this.colDefCols ? (t = this.beans.colDefFactory) == null ? void 0 : t.getColumnDefs(
      this.colDefCols.list,
      this.showingPivotResult,
      this.lastOrder,
      ((e = this.cols) == null ? void 0 : e.list) ?? []
    ) : void 0;
  }
  setColSpanActive() {
    var e;
    this.colSpanActive = !!((e = this.cols) != null && e.list.some((t) => t.getColDef().colSpan != null));
  }
  isPivotMode() {
    return this.pivotMode;
  }
  setPivotMode(e, t) {
    if (e === this.pivotMode || (this.pivotMode = e, !this.ready))
      return;
    this.refreshCols(!1);
    const { visibleCols: i, eventSvc: s } = this.beans;
    i.refresh(t), s.dispatchEvent({
      type: "columnPivotModeChanged"
    });
  }
  // + clientSideRowModel
  isPivotActive() {
    var t;
    const e = (t = this.beans.pivotColsSvc) == null ? void 0 : t.columns;
    return this.pivotMode && !!(e != null && e.length);
  }
  // called when dataTypes change
  recreateColumnDefs(e) {
    var i;
    if (!this.cols)
      return;
    (i = this.beans.autoColSvc) == null || i.updateColumns(e);
    const t = ds(e.source);
    this.createColsFromColDefs(t);
  }
  setColumnDefs(e, t) {
    this.colDefs = e, this.createColsFromColDefs(t);
  }
  destroy() {
    var e;
    qn(this.beans, (e = this.colDefCols) == null ? void 0 : e.tree), super.destroy();
  }
  getColTree() {
    var e;
    return ((e = this.cols) == null ? void 0 : e.tree) ?? [];
  }
  // + columnSelectPanel
  getColDefColTree() {
    var e;
    return ((e = this.colDefCols) == null ? void 0 : e.tree) ?? [];
  }
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getColDefCols() {
    var e;
    return ((e = this.colDefCols) == null ? void 0 : e.list) ?? null;
  }
  // + moveColumnController
  getCols() {
    var e;
    return ((e = this.cols) == null ? void 0 : e.list) ?? [];
  }
  forAllCols(e) {
    var n, r, a, l, d;
    const { pivotResultCols: t, autoColSvc: i, selectionColSvc: s, groupHierarchyColSvc: o } = this.beans;
    _s((n = this.colDefCols) == null ? void 0 : n.list, e), _s((r = i == null ? void 0 : i.columns) == null ? void 0 : r.list, e), _s((a = s == null ? void 0 : s.columns) == null ? void 0 : a.list, e), _s((l = o == null ? void 0 : o.columns) == null ? void 0 : l.list, e), _s((d = t == null ? void 0 : t.getPivotResultCols()) == null ? void 0 : d.list, e);
  }
  getColsForKeys(e) {
    return e ? e.map((t) => this.getCol(t)).filter((t) => t != null) : [];
  }
  getColDefCol(e) {
    var t;
    return (t = this.colDefCols) != null && t.list ? this.getColFromCollection(e, this.colDefCols) : null;
  }
  getCol(e) {
    return e == null ? null : this.getColFromCollection(e, this.cols);
  }
  /**
   * Get column exclusively by ID.
   *
   * Note getCol/getColFromCollection have poor performance when col has been removed.
   */
  getColById(e) {
    var t;
    return ((t = this.cols) == null ? void 0 : t.map[e]) ?? null;
  }
  getColFromCollection(e, t) {
    if (t == null)
      return null;
    const { map: i, list: s } = t;
    if (typeof e == "string" && i[e])
      return i[e];
    for (let a = 0; a < s.length; a++)
      if (ng(s[a], e))
        return s[a];
    const { autoColSvc: o, selectionColSvc: n, groupHierarchyColSvc: r } = this.beans;
    return (o == null ? void 0 : o.getColumn(e)) ?? (n == null ? void 0 : n.getColumn(e)) ?? (r == null ? void 0 : r.getColumn(e)) ?? null;
  }
}, pg = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(e) {
    const t = this.existingIds[e];
    let i;
    return typeof t != "number" ? i = 0 : i = t + 1, this.existingIds[e] = i, i;
  }
};
function No(e, t, i) {
  return i && e.addDestroyFunc(() => t.destroyBean(i)), i ?? e;
}
var _ = null;
function ec(e) {
  return typeof (e == null ? void 0 : e.getGui) == "function";
}
var fg = class {
  constructor(e) {
    this.cssClassStates = {}, this.getGui = e;
  }
  toggleCss(e, t) {
    var s;
    if (!e)
      return;
    if (e.indexOf(" ") >= 0) {
      const o = (e || "").split(" ");
      if (o.length > 1) {
        o.forEach((n) => this.toggleCss(n, t));
        return;
      }
    }
    this.cssClassStates[e] !== t && e.length && ((s = this.getGui()) == null || s.classList.toggle(e, t), this.cssClassStates[e] = t);
  }
}, yv = 0, Wo = class extends At {
  constructor(e, t) {
    super(), this.suppressDataRefValidation = !1, this.displayed = !0, this.visible = !0, this.compId = yv++, this.cssManager = new fg(() => this.eGui), this.componentSelectors = new Map((t ?? []).map((i) => [i.selector, i])), e && this.setTemplate(e);
  }
  preConstruct() {
    var t, i, s;
    this.wireTemplate(this.getGui());
    const e = "component-" + ((i = (t = Object.getPrototypeOf(this)) == null ? void 0 : t.constructor) == null ? void 0 : i.name);
    (s = this.css) == null || s.forEach((o) => this.beans.environment.addGlobalCSS(o, e));
  }
  wireTemplate(e, t) {
    e && this.gos && (this.applyElementsToComponent(e), this.createChildComponentsFromTags(e, t));
  }
  getCompId() {
    return this.compId;
  }
  getDataRefAttribute(e) {
    return e.getAttribute ? e.getAttribute(_h) : null;
  }
  applyElementsToComponent(e, t, i, s = null) {
    if (t === void 0 && (t = this.getDataRefAttribute(e)), t) {
      const o = this[t];
      if (o === _)
        this[t] = s ?? e;
      else {
        const n = i && i[t];
        if (!this.suppressDataRefValidation && !n)
          throw new Error(`data-ref: ${t} on ${this.constructor.name} with ${o}`);
      }
    }
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(e, t) {
    const i = [];
    for (const s of e.childNodes ?? [])
      i.push(s);
    i.forEach((s) => {
      if (!(s instanceof HTMLElement))
        return;
      const o = this.createComponentFromElement(
        s,
        (n) => {
          const r = n.getGui();
          if (r)
            for (const a of s.attributes ?? [])
              r.setAttribute(a.name, a.value);
        },
        t
      );
      if (o) {
        if (o.addItems && s.children.length) {
          this.createChildComponentsFromTags(s, t);
          const n = Array.prototype.slice.call(s.children);
          o.addItems(n);
        }
        this.swapComponentForNode(o, e, s);
      } else s.childNodes && this.createChildComponentsFromTags(s, t);
    });
  }
  createComponentFromElement(e, t, i) {
    const s = e.nodeName, o = this.getDataRefAttribute(e), n = s.indexOf("AG-") === 0, r = n ? this.componentSelectors.get(s) : null;
    let a = null;
    if (r) {
      const l = i && o ? i[o] : void 0;
      a = new r.component(l), a.setParentComponent(
        this
      ), this.createBean(a, null, t);
    } else if (n)
      throw new Error(`selector: ${s}`);
    return this.applyElementsToComponent(e, o, i, a), a;
  }
  swapComponentForNode(e, t, i) {
    const s = e.getGui();
    t.replaceChild(s, i), t.insertBefore(document.createComment(i.nodeName), s), this.addDestroyFunc(this.destroyBean.bind(this, e));
  }
  activateTabIndex(e) {
    const t = this.gos.get("tabIndex");
    e || (e = []), e.length || e.push(this.getGui()), e.forEach((i) => i.setAttribute("tabindex", t.toString()));
  }
  setTemplate(e, t, i) {
    let s;
    typeof e == "string" || e == null ? s = Pl(e) : s = Vo(e), this.setTemplateFromElement(s, t, i);
  }
  setTemplateFromElement(e, t, i, s = !1) {
    if (this.eGui = e, this.suppressDataRefValidation = s, t)
      for (let o = 0; o < t.length; o++) {
        const n = t[o];
        this.componentSelectors.set(n.selector, n);
      }
    this.wireTemplate(e, i);
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(e) {
    this.parentComponent = e;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(e) {
    this.eGui = e;
  }
  queryForHtmlElement(e) {
    return this.eGui.querySelector(e);
  }
  getContainerAndElement(e, t) {
    let i = t;
    return e == null ? null : (i || (i = this.eGui), Tl(e) ? {
      element: e,
      parent: i
    } : {
      element: e.getGui(),
      parent: i
    });
  }
  prependChild(e, t) {
    const { element: i, parent: s } = this.getContainerAndElement(e, t) || {};
    !i || !s || s.insertAdjacentElement("afterbegin", i);
  }
  appendChild(e, t) {
    const { element: i, parent: s } = this.getContainerAndElement(e, t) || {};
    !i || !s || s.appendChild(i);
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(e, t = {}) {
    if (e !== this.visible) {
      this.visible = e;
      const { skipAriaHidden: i } = t;
      cC(this.eGui, e, { skipAriaHidden: i });
    }
  }
  setDisplayed(e, t = {}) {
    if (e !== this.displayed) {
      this.displayed = e;
      const { skipAriaHidden: i } = t;
      le(this.eGui, e, { skipAriaHidden: i });
      const s = {
        type: "displayChanged",
        visible: this.displayed
      };
      this.dispatchLocalEvent(s);
    }
  }
  destroy() {
    this.parentComponent && (this.parentComponent = void 0), super.destroy();
  }
  addGuiEventListener(e, t, i) {
    this.eGui.addEventListener(e, t, i), this.addDestroyFunc(() => this.eGui.removeEventListener(e, t));
  }
  addCss(e) {
    this.cssManager.toggleCss(e, !0);
  }
  removeCss(e) {
    this.cssManager.toggleCss(e, !1);
  }
  toggleCss(e, t) {
    this.cssManager.toggleCss(e, t);
  }
  registerCSS(e) {
    this.css || (this.css = []), this.css.push(e);
  }
}, te = class extends Wo {
};
function mg(e) {
  return typeof e == "object" && !!e.component;
}
function Sv(e, t) {
  return new fe((i) => {
    i(window.setInterval(e, t));
  });
}
var fe = class Ys {
  constructor(t) {
    this.status = 0, this.resolution = null, this.waiters = [], t(
      (i) => this.onDone(i),
      (i) => this.onReject(i)
    );
  }
  static all(t) {
    return t.length ? new Ys((i) => {
      let s = t.length;
      const o = new Array(s);
      t.forEach((n, r) => {
        n.then((a) => {
          o[r] = a, s--, s === 0 && i(o);
        });
      });
    }) : Ys.resolve();
  }
  static resolve(t = null) {
    return new Ys((i) => i(t));
  }
  then(t) {
    return new Ys((i) => {
      this.status === 1 ? i(t(this.resolution)) : this.waiters.push((s) => i(t(s)));
    });
  }
  onDone(t) {
    this.status = 1, this.resolution = t, this.waiters.forEach((i) => i(t));
  }
  onReject(t) {
  }
};
function Rv(e) {
  return e ? e.prototype && "getGui" in e.prototype : !1;
}
function Cg(e, t, i, s) {
  const { name: o } = i;
  let n, r, a, l, d, c;
  if (t) {
    const u = t, h = u[o + "Selector"], g = h ? h(s) : null, p = (f) => {
      typeof f == "string" ? n = f : f != null && f !== !0 && (e.isFrameworkComponent(f) ? a = f : r = f);
    };
    g ? (p(g.component), l = g.params, d = g.popup, c = g.popupPosition) : p(u[o]);
  }
  return { compName: n, jsComp: r, fwComp: a, paramsFromSelector: l, popupFromSelector: d, popupPositionFromSelector: c };
}
var xv = class extends E {
  constructor() {
    super(...arguments), this.beanName = "userCompFactory";
  }
  wireBeans(e) {
    this.agCompUtils = e.agCompUtils, this.registry = e.registry, this.frameworkCompWrapper = e.frameworkCompWrapper, this.gridOptions = e.gridOptions;
  }
  getCompDetailsFromGridOptions(e, t, i, s = !1) {
    return this.getCompDetails(this.gridOptions, e, t, i, s);
  }
  getCompDetails(e, t, i, s, o = !1) {
    var R;
    const { name: n, cellRenderer: r } = t;
    let { compName: a, jsComp: l, fwComp: d, paramsFromSelector: c, popupFromSelector: u, popupPositionFromSelector: h } = Cg(this.beans.frameworkOverrides, e, t, s), g, p;
    const f = (b) => {
      const w = this.registry.getUserComponent(n, b);
      w && (l = w.componentFromFramework ? void 0 : w.component, d = w.componentFromFramework ? w.component : void 0, g = w.params, p = w.processParams);
    };
    if (a != null && f(a), l == null && d == null && i != null && f(i), l && r && !Rv(l) && (l = (R = this.agCompUtils) == null ? void 0 : R.adaptFunction(t, l)), !l && !d) {
      const { validation: b } = this.beans;
      o && (a !== i || !i) ? a ? b != null && b.isProvidedUserComp(a) || Z(50, { compName: a }) : i ? b || Z(260, {
        ...this.gos.getModuleErrorParams(),
        propName: n,
        compName: i
      }) : Z(216, { name: n }) : i && !b && Z(146, { comp: i });
      return;
    }
    const m = this.mergeParams(
      e,
      t,
      s,
      c,
      g,
      p
    ), C = l == null, v = l ?? d;
    return {
      componentFromFramework: C,
      componentClass: v,
      params: m,
      type: t,
      popupFromSelector: u,
      popupPositionFromSelector: h,
      newAgStackInstance: () => this.newAgStackInstance(v, C, m, t)
    };
  }
  newAgStackInstance(e, t, i, s) {
    var a;
    const o = !t;
    let n;
    o ? n = new e() : n = this.frameworkCompWrapper.wrap(
      e,
      s.mandatoryMethods,
      s.optionalMethods,
      s
    ), this.createBean(n);
    const r = (a = n.init) == null ? void 0 : a.call(n, i);
    return r == null ? fe.resolve(n) : r.then(() => n);
  }
  /**
   * merges params with application provided params
   * used by Floating Filter
   */
  mergeParams(e, t, i, s = null, o, n) {
    const r = { ...i, ...o }, a = e, l = a && a[t.name + "Params"];
    if (typeof l == "function") {
      const d = l(i);
      Be(r, d);
    } else typeof l == "object" && Be(r, l);
    return Be(r, s), n ? n(r) : r;
  }
}, Fv = {
  name: "dateComponent",
  mandatoryMethods: ["getDate", "setDate"],
  optionalMethods: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled", "refresh"]
}, Pv = {
  name: "dragAndDropImageComponent",
  mandatoryMethods: ["setIcon", "setLabel"]
}, Ev = { name: "headerComponent", optionalMethods: ["refresh"] }, Dv = { name: "innerHeaderComponent" }, Tv = { name: "innerHeaderGroupComponent" }, Mv = { name: "headerGroupComponent" }, Av = {
  name: "cellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: !0
}, Iv = { name: "loadingCellRenderer", cellRenderer: !0 }, kv = {
  name: "cellEditor",
  mandatoryMethods: ["getValue"],
  optionalMethods: [
    "isPopup",
    "isCancelBeforeStart",
    "isCancelAfterEnd",
    "getPopupPosition",
    "focusIn",
    "focusOut",
    "afterGuiAttached",
    "refresh"
  ]
}, Lv = { name: "loadingOverlayComponent", optionalMethods: ["refresh"] }, Ov = { name: "noRowsOverlayComponent", optionalMethods: ["refresh"] }, _v = { name: "tooltipComponent" }, Ll = {
  name: "filter",
  mandatoryMethods: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
  optionalMethods: [
    "afterGuiAttached",
    "afterGuiDetached",
    "onNewRowsLoaded",
    "getModelAsString",
    "onFloatingFilterChanged",
    "onAnyFilterChanged",
    "refresh"
  ]
}, Hv = {
  name: "floatingFilterComponent",
  mandatoryMethods: ["onParentModelChanged"],
  optionalMethods: ["afterGuiAttached", "refresh"]
}, Bv = {
  name: "fullWidthCellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: !0
}, Gv = { name: "loadingCellRenderer", cellRenderer: !0 }, Vv = {
  name: "groupRowRenderer",
  optionalMethods: ["afterGuiAttached"],
  cellRenderer: !0
}, Nv = { name: "detailCellRenderer", optionalMethods: ["refresh"], cellRenderer: !0 };
function Wv(e, t) {
  return e.getCompDetailsFromGridOptions(Pv, "agDragAndDropImage", t, !0);
}
function zv(e, t, i) {
  return e.getCompDetails(t, Ev, "agColumnHeader", i);
}
function Uv(e, t, i) {
  return e.getCompDetails(t, Dv, void 0, i);
}
function $v(e, t) {
  const i = t.columnGroup.getColGroupDef();
  return e.getCompDetails(i, Mv, "agColumnGroupHeader", t);
}
function Kv(e, t, i) {
  return e.getCompDetails(t, Tv, void 0, i);
}
function jv(e, t) {
  return e.getCompDetailsFromGridOptions(Bv, void 0, t, !0);
}
function qv(e, t) {
  return e.getCompDetailsFromGridOptions(Gv, "agLoadingCellRenderer", t, !0);
}
function Yv(e, t) {
  return e.getCompDetailsFromGridOptions(Vv, "agGroupRowRenderer", t, !0);
}
function Qv(e, t) {
  return e.getCompDetailsFromGridOptions(Nv, "agDetailCellRenderer", t, !0);
}
function tc(e, t, i) {
  return e.getCompDetails(t, Av, void 0, i);
}
function ic(e, t, i) {
  return e.getCompDetails(t, Iv, "agSkeletonCellRenderer", i, !0);
}
function vg(e, t, i) {
  return e.getCompDetails(t, kv, "agCellEditor", i, !0);
}
function Xv(e, t, i, s) {
  const o = t.filter;
  return mg(o) && (t = {
    filter: o.component,
    filterParams: t.filterParams
  }), e.getCompDetails(t, Ll, s, i, !0);
}
function Zv(e, t, i) {
  return e.getCompDetails(t, Fv, "agDateInput", i, !0);
}
function Jv(e, t) {
  return e.getCompDetailsFromGridOptions(Lv, "agLoadingOverlay", t, !0);
}
function ew(e, t) {
  return e.getCompDetailsFromGridOptions(Ov, "agNoRowsOverlay", t, !0);
}
function tw(e, t) {
  return e.getCompDetails(t.colDef, _v, "agTooltipComponent", t, !0);
}
function iw(e, t, i, s) {
  return e.getCompDetails(t, Hv, s, i);
}
function wg(e, t) {
  return Cg(e, t, Ll);
}
function Wr(e, t, i) {
  return e.mergeParams(t, Ll, i);
}
function Po(e) {
  const t = e;
  return t != null && t.getFrameworkComponentInstance != null ? t.getFrameworkComponentInstance() : e;
}
function sw(e) {
  return typeof e == "object" && !!e.getComp;
}
var P = {
  BACKSPACE: "Backspace",
  TAB: "Tab",
  ENTER: "Enter",
  ESCAPE: "Escape",
  SPACE: " ",
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown",
  DELETE: "Delete",
  F2: "F2",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  PAGE_HOME: "Home",
  PAGE_END: "End",
  // these should be used with `event.code` instead of `event.key`
  // as `event.key` changes when non-latin keyboards are used
  A: "KeyA",
  C: "KeyC",
  D: "KeyD",
  V: "KeyV",
  X: "KeyX",
  Y: "KeyY",
  Z: "KeyZ"
}, Ol = class extends Wo {
  isPopup() {
    return !0;
  }
  setParentComponent(e) {
    e.addCss("ag-has-popup"), super.setParentComponent(e);
  }
  destroy() {
    const e = this.parentComponent;
    e && e.isAlive() && e.getGui().classList.remove("ag-has-popup"), super.destroy();
  }
}, zr, Ur, $r, Kr, Ba, Ga, jr;
function hi() {
  return zr === void 0 && (zr = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), zr;
}
function bg() {
  return Ur === void 0 && (Ur = /(firefox)/i.test(navigator.userAgent)), Ur;
}
function yg() {
  return $r === void 0 && ($r = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), $r;
}
function Mi() {
  return Kr === void 0 && (Kr = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), Kr;
}
function Va(e) {
  if (!e)
    return null;
  const t = e.tabIndex, i = e.getAttribute("tabIndex");
  return t === -1 && (i === null || i === "" && !bg()) ? null : t.toString();
}
function ow() {
  if (jr !== void 0)
    return jr;
  if (!document.body)
    return -1;
  let e = 1e6;
  const t = bg() ? 6e6 : 1e9, i = document.createElement("div");
  for (document.body.appendChild(i); ; ) {
    const s = e * 2;
    if (i.style.height = s + "px", s > t || i.clientHeight !== s)
      break;
    e = s;
  }
  return document.body.removeChild(i), jr = e, e;
}
function nw() {
  return Ga == null && Sg(), Ga;
}
function Sg() {
  const e = document.body, t = document.createElement("div");
  t.style.width = t.style.height = "100px", t.style.opacity = "0", t.style.overflow = "scroll", t.style.msOverflowStyle = "scrollbar", t.style.position = "absolute", e.appendChild(t);
  let i = t.offsetWidth - t.clientWidth;
  i === 0 && t.clientWidth === 0 && (i = null), t.parentNode && t.parentNode.removeChild(t), i != null && (Ga = i, Ba = i === 0);
}
function Rg() {
  return Ba == null && Sg(), Ba;
}
var _l = "T", rw = new RegExp(`[${_l} ]`), aw = new RegExp(`^\\d{4}-\\d{2}-\\d{2}(${_l}\\d{2}:\\d{2}:\\d{2}\\D?)?`);
function Rt(e, t) {
  return e.toString().padStart(t, "0");
}
function Ke(e, t = !0, i = _l) {
  if (!e)
    return null;
  let s = [e.getFullYear(), e.getMonth() + 1, e.getDate()].map((o) => Rt(o, 2)).join("-");
  return t && (s += i + [e.getHours(), e.getMinutes(), e.getSeconds()].map((o) => Rt(o, 2)).join(":")), s;
}
function Zo(e, t = !0) {
  return e ? t ? [
    String(e.getFullYear()),
    String(e.getMonth() + 1),
    Rt(e.getDate(), 2),
    Rt(e.getHours(), 2),
    `:${Rt(e.getMinutes(), 2)}`,
    `:${Rt(e.getSeconds(), 2)}`
  ] : [e.getFullYear(), e.getMonth() + 1, Rt(e.getDate(), 2)].map(String) : null;
}
var qr = (e) => {
  if (e > 3 && e < 21)
    return "th";
  switch (e % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
}, sc = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], Yr = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
function Na(e, t) {
  if (t == null)
    return Ke(e, !1);
  const i = Rt(e.getFullYear(), 4), s = {
    YYYY: () => i.slice(i.length - 4, i.length),
    YY: () => i.slice(i.length - 2, i.length),
    Y: () => `${e.getFullYear()}`,
    MMMM: () => sc[e.getMonth()],
    MMM: () => sc[e.getMonth()].slice(0, 3),
    MM: () => Rt(e.getMonth() + 1, 2),
    Mo: () => `${e.getMonth() + 1}${qr(e.getMonth() + 1)}`,
    M: () => `${e.getMonth() + 1}`,
    Do: () => `${e.getDate()}${qr(e.getDate())}`,
    DD: () => Rt(e.getDate(), 2),
    D: () => `${e.getDate()}`,
    dddd: () => Yr[e.getDay()],
    ddd: () => Yr[e.getDay()].slice(0, 3),
    dd: () => Yr[e.getDay()].slice(0, 2),
    do: () => `${e.getDay()}${qr(e.getDay())}`,
    d: () => `${e.getDay()}`
  }, o = new RegExp(Object.keys(s).join("|"), "g");
  return t.replace(o, (n) => n in s ? s[n]() : n);
}
function Dn(e, t = !1) {
  return !!ze(e, t);
}
function lw(e) {
  return Dn(e, !0);
}
function ze(e, t = !1, i) {
  if (!e || !i && !aw.test(e))
    return null;
  const [s, o] = e.split(rw);
  if (!s)
    return null;
  const n = s.split("-").map((g) => parseInt(g, 10));
  if (n.filter((g) => !isNaN(g)).length !== 3)
    return null;
  const [r, a, l] = n, d = new Date(r, a - 1, l);
  if (d.getFullYear() !== r || d.getMonth() !== a - 1 || d.getDate() !== l || !o && t)
    return null;
  if (!o || o === "00:00:00")
    return d;
  const [c, u, h] = o.split(":").map((g) => parseInt(g, 10));
  if (c >= 0 && c < 24)
    d.setHours(c);
  else if (t)
    return null;
  if (u >= 0 && u < 60)
    d.setMinutes(u);
  else if (t)
    return null;
  if (h >= 0 && h < 60)
    d.setSeconds(h);
  else if (t)
    return null;
  return d;
}
function Wa(e) {
  const { inputValue: t, allSuggestions: i, hideIrrelevant: s, filterByPercentageOfBestMatch: o } = e;
  let n = (i ?? []).map(
    (l, d) => ({
      value: l,
      relevance: dw(t, l),
      idx: d
    })
  );
  if (n.sort((l, d) => l.relevance - d.relevance), s && (n = n.filter(
    (l) => l.relevance < Math.max(l.value.length, t.length)
  )), n.length > 0 && o && o > 0) {
    const d = n[0].relevance * o;
    n = n.filter((c) => d - c.relevance < 0);
  }
  const r = [], a = [];
  for (const l of n)
    r.push(l.value), a.push(l.idx);
  return { values: r, indices: a };
}
function dw(e, t) {
  e.length < t.length && ([e, t] = [t, e]);
  let i = [], s = [];
  const o = e.length, n = t.length;
  for (let a = 0; a <= n; a++)
    i[a] = a;
  let r = 0;
  for (let a = 1; a <= o; a++) {
    s[0] = a;
    for (let l = 1; l <= n; l++) {
      const d = e[a - 1], c = t[l - 1];
      if (d.toLocaleLowerCase() === c.toLocaleLowerCase())
        ++r, d === c && ++r, a > 1 && l > 1 && e[a - 2].toLocaleLowerCase() === t[l - 2].toLocaleLowerCase() && (++r, e[a - 2] === t[l - 2] && ++r), a < o / 2 - 10 && ++r, s[l] = i[l - 1];
      else {
        const u = s[l - 1], h = i[l], g = i[l - 1];
        s[l] = 1 + Math.min(u, h, g);
      }
    }
    [i, s] = [s, i];
  }
  return i[n] / (r + 1);
}
function xg(e) {
  var i;
  return e.altKey || e.ctrlKey || e.metaKey ? !1 : ((i = e.key) == null ? void 0 : i.length) === 1;
}
var za = !1, Xn = 0;
function cw(e) {
  Xn > 0 || (e.addEventListener("keydown", Zn), e.addEventListener("mousedown", Zn));
}
function uw(e) {
  Xn > 0 || (e.removeEventListener("keydown", Zn), e.removeEventListener("mousedown", Zn));
}
function Zn(e) {
  const t = za, i = e.type === "keydown";
  i && (e.ctrlKey || e.metaKey || e.altKey) || t !== i && (za = i);
}
function hw(e) {
  const t = Ee(e);
  return cw(t), Xn++, () => {
    Xn--, uw(t);
  };
}
function gw() {
  return za;
}
function cs(e, t, i = !1) {
  const s = dC;
  let o = Th;
  t && (o += ", " + t), i && (o += ', [tabindex="-1"]');
  const n = Array.prototype.slice.apply(e.querySelectorAll(s)).filter((l) => Mt(l)), r = Array.prototype.slice.apply(e.querySelectorAll(o));
  return r.length ? ((l, d) => l.filter((c) => d.indexOf(c) === -1))(n, r) : n;
}
function _i(e, t = !1, i = !1, s = !1) {
  const o = cs(
    e,
    s ? ".ag-tab-guard" : null,
    i
  ), n = t ? se(o) : o[0];
  return n ? (n.focus({ preventScroll: !0 }), !0) : !1;
}
function zi(e, t, i, s) {
  const o = cs(t, i ? ':not([tabindex="-1"])' : null), n = he(e);
  let r;
  i ? r = o.findIndex((l) => l.contains(n)) : r = o.indexOf(n);
  const a = r + (s ? -1 : 1);
  return a < 0 || a >= o.length ? null : o[a];
}
function Fg(e, t = 5) {
  let i = 0;
  for (; e && Va(e) === null && ++i <= t; )
    e = e.parentElement;
  return Va(e) === null ? null : e;
}
var pw = (
  /*css*/
  ".ag-label{white-space:nowrap}:where(.ag-ltr) .ag-label{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-label-align-right) .ag-label{order:1}:where(.ag-ltr) :where(.ag-label-align-right) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-rtl) :where(.ag-label-align-right) .ag-label{margin-right:var(--ag-spacing)}.ag-label-align-right>*{flex:none}.ag-label-align-top{align-items:flex-start;flex-direction:column;>*{align-self:stretch}}.ag-label-ellipsis{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-label-align-top) .ag-label{margin-bottom:calc(var(--ag-spacing)*.5)}"
), fw = class extends Wo {
  constructor(e, t, i) {
    super(t, i), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = !1, this.label = "", this.config = e || {}, this.registerCSS(pw);
  }
  postConstruct() {
    this.addCss("ag-labeled"), this.eLabel.classList.add("ag-label");
    const { labelSeparator: e, label: t, labelWidth: i, labelAlignment: s, disabled: o } = this.config;
    o != null && this.setDisabled(o), e != null && this.setLabelSeparator(e), t != null && this.setLabel(t), i != null && this.setLabelWidth(i), this.setLabelAlignment(s || this.labelAlignment), this.refreshLabel();
  }
  refreshLabel() {
    const { label: e, eLabel: t } = this;
    Te(t), typeof e == "string" ? t.innerText = e + this.labelSeparator : e && t.appendChild(e), e === "" ? (le(t, !1), oi(t, "presentation")) : (le(t, !0), oi(t, null));
  }
  setLabelSeparator(e) {
    return this.labelSeparator === e ? this : (this.labelSeparator = e, this.label != null && this.refreshLabel(), this);
  }
  getLabelId() {
    const e = this.eLabel;
    return e.id = e.id || `ag-${this.getCompId()}-label`, e.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(e) {
    return this.label === e ? this : (this.label = e, this.refreshLabel(), this);
  }
  setLabelAlignment(e) {
    const i = this.getGui().classList;
    return i.toggle("ag-label-align-left", e === "left"), i.toggle("ag-label-align-right", e === "right"), i.toggle("ag-label-align-top", e === "top"), this;
  }
  setLabelEllipsis(e) {
    return this.eLabel.classList.toggle("ag-label-ellipsis", e), this;
  }
  setLabelWidth(e) {
    return this.label == null ? this : (zn(this.eLabel, e), this);
  }
  setDisabled(e) {
    e = !!e;
    const t = this.getGui();
    return yo(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this;
  }
  isDisabled() {
    return !!this.disabled;
  }
}, Pg = class extends fw {
  constructor(e, t, i, s) {
    super(e, t, i), this.className = s;
  }
  postConstruct() {
    super.postConstruct();
    const { width: e, value: t, onValueChange: i } = this.config;
    e != null && this.setWidth(e), t != null && this.setValue(t), i != null && this.onValueChange(i), this.className && this.addCss(this.className), this.refreshAriaLabelledBy();
  }
  setLabel(e) {
    return super.setLabel(e), this.refreshAriaLabelledBy(), this;
  }
  refreshAriaLabelledBy() {
    const e = this.getAriaElement(), t = this.getLabelId(), i = this.getLabel();
    i == null || i == "" || jm(e) !== null ? bo(e, "") : bo(e, t ?? "");
  }
  setAriaLabel(e) {
    return vs(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this;
  }
  onValueChange(e) {
    return this.addManagedListeners(this, { fieldValueChanged: () => e(this.getValue()) }), this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(e) {
    return Ft(this.getGui(), e), this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(e, t) {
    return this.value === e ? this : (this.previousValue = this.value, this.value = e, t || this.dispatchLocalEvent({ type: "fieldValueChanged" }), this);
  }
};
function mw(e) {
  return {
    tag: "div",
    role: "presentation",
    children: [
      { tag: "div", ref: "eLabel", cls: "ag-input-field-label" },
      {
        tag: "div",
        ref: "eWrapper",
        cls: "ag-wrapper ag-input-wrapper",
        role: "presentation",
        children: [{ tag: e, ref: "eInput", cls: "ag-input-field-input" }]
      }
    ]
  };
}
var Ri = class extends Pg {
  constructor(e, t, i = "text", s = "input") {
    super(e, (e == null ? void 0 : e.template) ?? mw(s), [], t), this.inputType = i, this.displayFieldTag = s, this.eLabel = _, this.eWrapper = _, this.eInput = _;
  }
  postConstruct() {
    super.postConstruct(), this.setInputType(this.inputType);
    const { eLabel: e, eWrapper: t, eInput: i, className: s } = this;
    e.classList.add(`${s}-label`), t.classList.add(`${s}-input-wrapper`), i.classList.add(`${s}-input`), this.addCss("ag-input-field"), i.id = i.id || `ag-${this.getCompId()}-input`;
    const { inputName: o, inputWidth: n } = this.config;
    o != null && this.setInputName(o), n != null && this.setInputWidth(n), this.addInputListeners(), this.activateTabIndex([i]);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, {
      input: (e) => this.setValue(e.target.value)
    });
  }
  setInputType(e) {
    this.displayFieldTag === "input" && (this.inputType = e, Ue(this.eInput, "type", e));
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(e) {
    return zn(this.eWrapper, e), this;
  }
  setInputName(e) {
    return this.getInputElement().setAttribute("name", e), this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(e) {
    const t = this.eInput;
    return t.maxLength = e, this;
  }
  setInputPlaceholder(e) {
    return Ue(this.eInput, "placeholder", e), this;
  }
  setInputAriaLabel(e) {
    return vs(this.eInput, e), this.refreshAriaLabelledBy(), this;
  }
  setDisabled(e) {
    return yo(this.eInput, e), super.setDisabled(e);
  }
  setAutoComplete(e) {
    if (e === !0)
      Ue(this.eInput, "autocomplete", null);
    else {
      const t = typeof e == "string" ? e : "off";
      Ue(this.eInput, "autocomplete", t);
    }
    return this;
  }
}, Hl = class extends Ri {
  constructor(e, t = "ag-checkbox", i = "checkbox") {
    super(e, t, i), this.labelAlignment = "right", this.selected = !1, this.readOnly = !1, this.passive = !1;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly: e, passive: t } = this.config;
    typeof e == "boolean" && this.setReadOnly(e), typeof t == "boolean" && this.setPassive(t);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) }), this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
  }
  getNextValue() {
    return this.selected === void 0 ? !0 : !this.selected;
  }
  setPassive(e) {
    this.passive = e;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(e) {
    this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e;
  }
  setDisabled(e) {
    return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e);
  }
  toggle() {
    if (this.eInput.disabled)
      return;
    const e = this.isSelected(), t = this.getNextValue();
    this.passive ? this.dispatchChange(t, e) : this.setValue(t);
  }
  getValue() {
    return this.isSelected();
  }
  setValue(e, t) {
    return this.refreshSelectedClass(e), this.setSelected(e, t), this;
  }
  setName(e) {
    const t = this.getInputElement();
    return t.name = e, this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(e, t) {
    if (this.isSelected() === e)
      return;
    this.previousValue = this.isSelected(), e = this.selected = typeof e == "boolean" ? e : void 0;
    const i = this.eInput;
    i.checked = e, i.indeterminate = e === void 0, t || this.dispatchChange(this.selected, this.previousValue);
  }
  dispatchChange(e, t, i) {
    this.dispatchLocalEvent({ type: "fieldValueChanged", selected: e, previousValue: t, event: i });
    const s = this.getInputElement();
    this.eventSvc.dispatchEvent({
      type: "checkboxChanged",
      id: s.id,
      name: s.name,
      selected: e,
      previousValue: t
    });
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled)
      return;
    const t = this.isSelected(), i = this.selected = e.target.checked;
    this.refreshSelectedClass(i), this.dispatchChange(i, t, e);
  }
  refreshSelectedClass(e) {
    const t = this.eWrapper.classList;
    t.toggle("ag-checked", e === !0), t.toggle("ag-indeterminate", e == null);
  }
}, Bl = {
  selector: "AG-CHECKBOX",
  component: Hl
}, Cw = class extends Hl {
  constructor(e) {
    super(e, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    this.eInput.disabled || this.isSelected() || this.setValue(!0);
  }
  addInputListeners() {
    super.addInputListeners(), this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
  }
  /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */
  onChange(e) {
    const t = this.eInput;
    e.selected && e.name && t.name && t.name === e.name && e.id && t.id !== e.id && this.setValue(!1, !0);
  }
}, Ui = class extends Ri {
  constructor(e, t = "ag-text-field", i = "text") {
    super(e, t, i);
  }
  postConstruct() {
    super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters();
  }
  setValue(e, t) {
    const i = this.eInput;
    return i.value !== e && (i.value = H(e) ? e : ""), super.setValue(e, t);
  }
  /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
  setStartValue(e) {
    this.setValue(e, !0);
  }
  preventDisallowedCharacters() {
    const e = new RegExp(`[${this.config.allowedCharPattern}]`), t = (i) => {
      xg(i) && i.key && !e.test(i.key) && i.preventDefault();
    };
    this.addManagedListeners(this.eInput, {
      keydown: t,
      paste: (i) => {
        var o;
        const s = (o = i.clipboardData) == null ? void 0 : o.getData("text");
        s && s.split("").some((n) => !e.test(n)) && i.preventDefault();
      }
    });
  }
}, wr = {
  selector: "AG-INPUT-TEXT-FIELD",
  component: Ui
}, vw = class extends Ri {
  constructor(e) {
    super(e, "ag-text-area", null, "textarea");
  }
  setValue(e, t) {
    const i = super.setValue(e, t);
    return this.eInput.value = e, i;
  }
  setCols(e) {
    return this.eInput.cols = e, this;
  }
  setRows(e) {
    return this.eInput.rows = e, this;
  }
}, ww = {
  selector: "AG-INPUT-TEXT-AREA",
  component: vw
}, Gl = class extends Ui {
  constructor(e) {
    super(e, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct();
    const e = this.eInput;
    this.addManagedListeners(e, {
      blur: () => {
        const n = parseFloat(e.value), r = isNaN(n) ? "" : this.normalizeValue(n.toString());
        this.value !== r && this.setValue(r);
      },
      wheel: this.onWheel.bind(this)
    }), e.step = "any";
    const { precision: t, min: i, max: s, step: o } = this.config;
    typeof t == "number" && this.setPrecision(t), typeof i == "number" && this.setMin(i), typeof s == "number" && this.setMax(s), typeof o == "number" && this.setStep(o);
  }
  onWheel(e) {
    he(this.beans) === this.eInput && e.preventDefault();
  }
  normalizeValue(e) {
    return e === "" ? "" : (this.precision != null && (e = this.adjustPrecision(e)), e);
  }
  adjustPrecision(e, t) {
    const i = this.precision;
    if (i == null)
      return e;
    if (t) {
      const o = parseFloat(e).toFixed(i);
      return parseFloat(o).toString();
    }
    const s = String(e).split(".");
    if (s.length > 1) {
      if (s[1].length <= i)
        return e;
      if (i > 0)
        return `${s[0]}.${s[1].slice(0, i)}`;
    }
    return s[0];
  }
  setMin(e) {
    return this.min === e ? this : (this.min = e, Ue(this.eInput, "min", e), this);
  }
  setMax(e) {
    return this.max === e ? this : (this.max = e, Ue(this.eInput, "max", e), this);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Ue(this.eInput, "step", e), this);
  }
  setValue(e, t) {
    return this.setValueOrInputValue(
      (i) => super.setValue(i, t),
      () => this,
      e
    );
  }
  setStartValue(e) {
    return this.setValueOrInputValue(
      (t) => super.setValue(t, !0),
      (t) => {
        this.eInput.value = t;
      },
      e
    );
  }
  setValueOrInputValue(e, t, i) {
    if (H(i)) {
      let s = this.isScientificNotation(i);
      if (s && this.eInput.validity.valid)
        return e(i);
      if (!s) {
        i = this.adjustPrecision(i);
        const o = this.normalizeValue(i);
        s = i != o;
      }
      if (s)
        return t(i);
    }
    return e(i);
  }
  getValue() {
    const e = this.eInput;
    if (!e.validity.valid)
      return;
    const t = e.value;
    return this.isScientificNotation(t) ? this.adjustPrecision(t, !0) : super.getValue();
  }
  isScientificNotation(e) {
    return typeof e == "string" && e.includes("e");
  }
}, bw = {
  selector: "AG-INPUT-NUMBER-FIELD",
  component: Gl
}, yw = class extends Ui {
  constructor(e) {
    super(e, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct();
    const e = hi();
    this.addManagedListeners(this.eInput, {
      wheel: this.onWheel.bind(this),
      mousedown: () => {
        this.isDisabled() || e || this.eInput.focus();
      }
    }), this.eInput.step = "any";
  }
  onWheel(e) {
    he(this.beans) === this.eInput && e.preventDefault();
  }
  setMin(e) {
    const t = e instanceof Date ? Ke(e ?? null, !!this.includeTime) ?? void 0 : e;
    return this.min === t ? this : (this.min = t, Ue(this.eInput, "min", t), this);
  }
  setMax(e) {
    const t = e instanceof Date ? Ke(e ?? null, !!this.includeTime) ?? void 0 : e;
    return this.max === t ? this : (this.max = t, Ue(this.eInput, "max", t), this);
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Ue(this.eInput, "step", e), this);
  }
  setIncludeTime(e) {
    return this.includeTime === e ? this : (this.includeTime = e, super.setInputType(e ? "datetime-local" : "date"), e && this.setStep(1), this);
  }
  getDate() {
    if (this.eInput.validity.valid)
      return ze(this.getValue()) ?? void 0;
  }
  setDate(e, t) {
    this.setValue(Ke(e ?? null, this.includeTime), t);
  }
}, Eg = {
  selector: "AG-INPUT-DATE-FIELD",
  component: yw
}, Sw = (
  /*css*/
  ".ag-list-item{align-items:center;display:flex;height:var(--ag-list-item-height);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;&.ag-active-item{background-color:var(--ag-row-hover-color)}}"
), Rw = "ag-active-item", xw = (e, t) => ({
  tag: "div",
  cls: `ag-list-item ag-${e}-list-item`,
  attrs: { role: "option" },
  children: [
    {
      tag: "span",
      ref: "eText",
      children: t
    }
  ]
}), Fw = class extends Wo {
  constructor(e, t, i) {
    super(xw(e, t)), this.label = t, this.value = i, this.eText = _;
  }
  postConstruct() {
    this.createTooltip(), this.addEventListeners();
  }
  setHighlighted(e) {
    const t = this.getGui();
    t.classList.toggle(Rw, e), Dh(t, e), this.dispatchLocalEvent({
      type: "itemHighlighted",
      highlighted: e
    });
  }
  getHeight() {
    return this.getGui().clientHeight;
  }
  setIndex(e, t) {
    const i = this.getGui();
    Jm(i, e), Zm(i, t);
  }
  createTooltip() {
    const e = {
      getTooltipValue: () => this.label,
      getGui: () => this.getGui(),
      getLocation: () => "UNKNOWN",
      // only show tooltips for items where the text cannot be fully displayed
      shouldDisplayTooltip: () => El(this.eText)
    }, t = this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean(
        "highlightTooltipFeature",
        !1,
        e,
        this
      )
    );
    t && (this.tooltipFeature = t);
  }
  addEventListeners() {
    const e = this.getParentComponent();
    e && (this.addGuiEventListener("mouseover", () => {
      e.highlightItem(this);
    }), this.addGuiEventListener("mousedown", (t) => {
      t.preventDefault(), t.stopPropagation(), e.setValue(this.value);
    }));
  }
}, Pw = class extends Wo {
  constructor(e = "default") {
    super({ tag: "div", cls: `ag-list ag-${e}-list` }), this.cssIdentifier = e, this.options = [], this.listItems = [], this.highlightedItem = null, this.registerCSS(Sw);
  }
  postConstruct() {
    const e = this.getGui();
    this.addManagedElementListeners(e, { mouseleave: () => this.clearHighlighted() });
  }
  handleKeyDown(e) {
    const t = e.key;
    switch (t) {
      case P.ENTER:
        if (!this.highlightedItem)
          this.setValue(this.getValue());
        else {
          const i = this.listItems.indexOf(this.highlightedItem);
          this.setValueByIndex(i);
        }
        break;
      case P.DOWN:
      case P.UP:
        e.preventDefault(), this.navigate(t);
        break;
      case P.PAGE_DOWN:
      case P.PAGE_UP:
      case P.PAGE_HOME:
      case P.PAGE_END:
        e.preventDefault(), this.navigateToPage(t);
        break;
    }
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    const { value: t, text: i } = e, s = i ?? t;
    return this.options.push({ value: t, text: s }), this.renderOption(t, s), this.updateIndices(), this;
  }
  clearOptions() {
    this.options = [], this.reset(!0), this.listItems.forEach((e) => {
      e.destroy();
    }), Te(this.getGui()), this.listItems = [], this.refreshAriaRole();
  }
  setValue(e, t) {
    if (this.value === e)
      return this.fireItemSelected(), this;
    if (e == null)
      return this.reset(t), this;
    const i = this.options.findIndex((s) => s.value === e);
    if (i !== -1) {
      const s = this.options[i];
      this.value = s.value, this.displayValue = s.text, this.highlightItem(this.listItems[i]), t || this.fireChangeEvent();
    }
    return this;
  }
  setValueByIndex(e) {
    return this.setValue(this.options[e].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const e = this.options.findIndex((t) => t.value === this.value);
    e !== -1 && this.highlightItem(this.listItems[e]);
  }
  highlightItem(e) {
    const t = e.getGui();
    if (!Mt(t))
      return;
    this.clearHighlighted(), e.setHighlighted(!0), this.highlightedItem = e;
    const i = this.getGui(), { scrollTop: s, clientHeight: o } = i, { offsetTop: n, offsetHeight: r } = t;
    (n + r > s + o || n < s) && t.scrollIntoView({ block: "nearest" });
  }
  hideItemTooltip() {
    var e, t;
    (t = (e = this.highlightedItem) == null ? void 0 : e.tooltipFeature) == null || t.attemptToHideTooltip();
  }
  destroy() {
    this.hideItemTooltip(), super.destroy();
  }
  reset(e) {
    this.value = null, this.displayValue = null, this.clearHighlighted(), e || this.fireChangeEvent();
  }
  clearHighlighted() {
    var e;
    (e = this.highlightedItem) == null || e.setHighlighted(!1), this.highlightedItem = null;
  }
  renderOption(e, t) {
    const i = new Fw(this.cssIdentifier, t, e);
    i.setParentComponent(this);
    const s = this.createManagedBean(i);
    this.listItems.push(s), this.getGui().appendChild(s.getGui());
  }
  navigate(e) {
    const t = e === P.DOWN;
    let i;
    const { listItems: s, highlightedItem: o } = this;
    if (!o)
      i = t ? s[0] : se(s);
    else {
      let r = s.indexOf(o) + (t ? 1 : -1);
      r = Math.min(Math.max(r, 0), s.length - 1), i = s[r];
    }
    this.highlightItem(i);
  }
  navigateToPage(e) {
    const { listItems: t, highlightedItem: i } = this;
    if (!i || t.length === 0)
      return;
    const s = t.indexOf(i), o = this.options.length - 1, n = t[0].getHeight(), r = Math.floor(this.getGui().clientHeight / n);
    let a = -1;
    e === P.PAGE_HOME ? a = 0 : e === P.PAGE_END ? a = o : e === P.PAGE_DOWN ? a = Math.min(s + r, o) : e === P.PAGE_UP && (a = Math.max(s - r, 0)), a !== -1 && this.highlightItem(t[a]);
  }
  refreshAriaRole() {
    oi(this.getGui(), this.options.length === 0 ? "presentation" : "listbox");
  }
  updateIndices() {
    this.refreshAriaRole();
    const e = this.listItems, t = e.length;
    e.forEach((i, s) => {
      i.setIndex(s + 1, t);
    });
  }
  fireChangeEvent() {
    this.dispatchLocalEvent({ type: "fieldValueChanged" }), this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchLocalEvent({ type: "selectedItem" });
  }
}, Ew = (
  /*css*/
  ".ag-picker-field-display{flex:1 1 auto}.ag-picker-field{align-items:center;display:flex}.ag-picker-field-icon{border:0;cursor:pointer;display:flex;margin:0;padding:0}.ag-picker-field-wrapper{background-color:var(--ag-picker-button-background-color);border:var(--ag-picker-button-border);border-radius:5px;min-height:max(var(--ag-list-item-height),calc(var(--ag-spacing)*4));overflow:hidden;&:where(.ag-picker-has-focus),&:where(:focus-within){background-color:var(--ag-picker-button-focus-background-color);border:var(--ag-picker-button-focus-border);box-shadow:var(--ag-focus-shadow);&:where(.invalid){box-shadow:var(--ag-focus-error-shadow)}}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:disabled{opacity:.5}}"
), Dw = {
  tag: "div",
  cls: "ag-picker-field",
  role: "presentation",
  children: [
    { tag: "div", ref: "eLabel" },
    {
      tag: "div",
      ref: "eWrapper",
      cls: "ag-wrapper ag-picker-field-wrapper ag-picker-collapsed",
      children: [
        { tag: "div", ref: "eDisplayField", cls: "ag-picker-field-display" },
        { tag: "div", ref: "eIcon", cls: "ag-picker-field-icon", attrs: { "aria-hidden": "true" } }
      ]
    }
  ]
}, Tw = class extends Pg {
  constructor(e) {
    if (super(e, (e == null ? void 0 : e.template) || Dw, (e == null ? void 0 : e.agComponents) || [], e == null ? void 0 : e.className), this.isPickerDisplayed = !1, this.skipClick = !1, this.pickerGap = 4, this.hideCurrentPicker = null, this.eLabel = _, this.eWrapper = _, this.eDisplayField = _, this.eIcon = _, this.registerCSS(Ew), this.ariaRole = e == null ? void 0 : e.ariaRole, this.onPickerFocusIn = this.onPickerFocusIn.bind(this), this.onPickerFocusOut = this.onPickerFocusOut.bind(this), !e)
      return;
    const { pickerGap: t, maxPickerHeight: i, variableWidth: s, minPickerWidth: o, maxPickerWidth: n } = e;
    t != null && (this.pickerGap = t), this.variableWidth = !!s, i != null && this.setPickerMaxHeight(i), o != null && this.setPickerMinWidth(o), n != null && this.setPickerMaxWidth(n);
  }
  postConstruct() {
    super.postConstruct(), this.setupAria();
    const e = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", e);
    const t = this.getAriaElement();
    this.addManagedElementListeners(t, { keydown: this.onKeyDown.bind(this) }), this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) }), this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
    const { pickerIcon: i, inputWidth: s } = this.config;
    if (i) {
      const o = this.beans.iconSvc.createIconNoSpan(i);
      o && this.eIcon.appendChild(o);
    }
    s != null && this.setInputWidth(s);
  }
  setupAria() {
    const e = this.getAriaElement();
    e.setAttribute("tabindex", this.gos.get("tabIndex").toString()), Aa(e, !1), this.ariaRole && oi(e, this.ariaRole);
  }
  onLabelOrWrapperMouseDown(e) {
    if (e) {
      const t = this.getFocusableElement();
      if (t !== this.eWrapper && (e == null ? void 0 : e.target) === t)
        return;
      e.preventDefault(), this.getFocusableElement().focus();
    }
    if (this.skipClick) {
      this.skipClick = !1;
      return;
    }
    this.isDisabled() || (this.isPickerDisplayed ? this.hidePicker() : this.showPicker());
  }
  onKeyDown(e) {
    switch (e.key) {
      case P.UP:
      case P.DOWN:
      case P.ENTER:
      case P.SPACE:
        e.preventDefault(), this.onLabelOrWrapperMouseDown();
        break;
      case P.ESCAPE:
        this.isPickerDisplayed && (e.preventDefault(), e.stopPropagation(), this.hideCurrentPicker && this.hideCurrentPicker());
        break;
    }
  }
  showPicker() {
    this.isPickerDisplayed = !0, this.pickerComponent || (this.pickerComponent = this.createPickerComponent());
    const e = this.pickerComponent.getGui();
    e.addEventListener("focusin", this.onPickerFocusIn), e.addEventListener("focusout", this.onPickerFocusOut), this.hideCurrentPicker = this.renderAndPositionPicker(), this.toggleExpandedStyles(!0);
  }
  renderAndPositionPicker() {
    const e = this.pickerComponent.getGui();
    this.gos.get("suppressScrollWhenPopupsAreOpen") || ([this.destroyMouseWheelFunc] = this.addManagedEventListeners({
      bodyScroll: () => {
        this.hidePicker();
      }
    }));
    const t = this.getLocaleTextFunc(), {
      config: { pickerAriaLabelKey: i, pickerAriaLabelValue: s, modalPicker: o = !0 },
      maxPickerHeight: n,
      minPickerWidth: r,
      maxPickerWidth: a,
      variableWidth: l,
      beans: d,
      eWrapper: c
    } = this, u = {
      modal: o,
      eChild: e,
      closeOnEsc: !0,
      closedCallback: () => {
        const f = yh(d);
        this.beforeHidePicker(), f && this.isAlive() && this.getFocusableElement().focus();
      },
      ariaLabel: t(i, s),
      anchorToElement: c
    };
    e.style.position = "absolute";
    const h = d.popupSvc, g = h.addPopup(u);
    l ? (r && (e.style.minWidth = r), e.style.width = Dl(Vn(c)), a && (e.style.maxWidth = a)) : zn(e, a ?? Vn(c));
    const p = n ?? `${Fl(h.getPopupParent())}px`;
    return e.style.setProperty("max-height", p), this.alignPickerToComponent(), g.hideFunc;
  }
  alignPickerToComponent() {
    if (!this.pickerComponent)
      return;
    const {
      pickerGap: e,
      config: { pickerType: t },
      beans: { popupSvc: i, gos: s },
      eWrapper: o,
      pickerComponent: n
    } = this, r = s.get("enableRtl") ? "right" : "left";
    i.positionPopupByComponent({
      type: t,
      eventSource: o,
      ePopup: n.getGui(),
      position: "under",
      alignSide: r,
      keepWithinBounds: !0,
      nudgeY: e
    });
  }
  beforeHidePicker() {
    this.destroyMouseWheelFunc && (this.destroyMouseWheelFunc(), this.destroyMouseWheelFunc = void 0), this.toggleExpandedStyles(!1);
    const e = this.pickerComponent.getGui();
    e.removeEventListener("focusin", this.onPickerFocusIn), e.removeEventListener("focusout", this.onPickerFocusOut), this.isPickerDisplayed = !1, this.pickerComponent = void 0, this.hideCurrentPicker = null;
  }
  toggleExpandedStyles(e) {
    if (!this.isAlive())
      return;
    const t = this.getAriaElement();
    Aa(t, e);
    const i = this.eWrapper.classList;
    i.toggle("ag-picker-expanded", e), i.toggle("ag-picker-collapsed", !e);
  }
  onPickerFocusIn() {
    this.togglePickerHasFocus(!0);
  }
  onPickerFocusOut(e) {
    var t;
    (t = this.pickerComponent) != null && t.getGui().contains(e.relatedTarget) || this.togglePickerHasFocus(!1);
  }
  togglePickerHasFocus(e) {
    this.pickerComponent && this.eWrapper.classList.toggle("ag-picker-has-focus", e);
  }
  hidePicker() {
    this.hideCurrentPicker && (this.hideCurrentPicker(), this.dispatchLocalEvent({
      type: "pickerHidden"
    }));
  }
  setInputWidth(e) {
    return zn(this.eWrapper, e), this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  setPickerGap(e) {
    return this.pickerGap = e, this;
  }
  setPickerMinWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.minPickerWidth = e ?? void 0, this;
  }
  setPickerMaxWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerWidth = e ?? void 0, this;
  }
  setPickerMaxHeight(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerHeight = e ?? void 0, this;
  }
  destroy() {
    this.hidePicker(), super.destroy();
  }
}, Mw = (
  /*css*/
  ".ag-select{align-items:center;display:flex;&.ag-disabled{opacity:.5}}:where(.ag-select){.ag-picker-field-wrapper{cursor:default}&.ag-disabled .ag-picker-field-wrapper:focus{box-shadow:none}&:not(.ag-cell-editor,.ag-label-align-top){min-height:var(--ag-list-item-height)}.ag-picker-field-display{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-picker-field-icon{align-items:center;display:flex}}:where(.ag-ltr) :where(.ag-select){.ag-picker-field-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding)/2);padding-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-select){.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:calc(var(--ag-cell-horizontal-padding)/2)}}.ag-select-list{background-color:var(--ag-picker-list-background-color);border:var(--ag-picker-list-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);overflow:hidden auto}.ag-select-list-item{cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none;:where(span){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}}:where(.ag-ltr) .ag-select-list-item{padding-left:calc(var(--ag-cell-horizontal-padding)/2)}:where(.ag-rtl) .ag-select-list-item{padding-right:calc(var(--ag-cell-horizontal-padding)/2)}"
), Vl = class extends Tw {
  constructor(e) {
    super({
      pickerAriaLabelKey: "ariaLabelSelectField",
      pickerAriaLabelValue: "Select Field",
      pickerType: "ag-list",
      className: "ag-select",
      pickerIcon: "selectOpen",
      ariaRole: "combobox",
      ...e
    }), this.registerCSS(Mw);
  }
  postConstruct() {
    this.tooltipFeature = this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean(
        "tooltipFeature",
        !1,
        {
          shouldDisplayTooltip: xn(() => this.eDisplayField),
          getGui: () => this.getGui()
        }
      )
    ), super.postConstruct(), this.createListComponent(), this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { options: e, value: t, placeholder: i } = this.config;
    e != null && this.addOptions(e), t != null && this.setValue(t, !0), i && t == null && (this.eDisplayField.textContent = i), this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
  }
  onWrapperFocusOut(e) {
    this.eWrapper.contains(e.relatedTarget) || this.hidePicker();
  }
  createListComponent() {
    const e = this.createBean(
      new Pw("select")
    );
    this.listComponent = e, e.setParentComponent(this);
    const t = e.getAriaElement(), i = `ag-select-list-${e.getCompId()}`;
    t.setAttribute("id", i), lC(this.getAriaElement(), t), e.addManagedElementListeners(e.getGui(), {
      mousedown: (s) => {
        s == null || s.preventDefault();
      }
    }), e.addManagedListeners(e, {
      selectedItem: () => {
        this.hidePicker(), this.dispatchLocalEvent({ type: "selectedItem" });
      },
      fieldValueChanged: () => {
        this.listComponent && (this.setValue(this.listComponent.getValue(), !1, !0), this.hidePicker());
      }
    });
  }
  createPickerComponent() {
    return this.listComponent;
  }
  beforeHidePicker() {
    var e;
    (e = this.listComponent) == null || e.hideItemTooltip(), super.beforeHidePicker();
  }
  onKeyDown(e) {
    var i;
    const { key: t } = e;
    switch (t === P.TAB && this.hidePicker(), t) {
      case P.ENTER:
      case P.UP:
      case P.DOWN:
      case P.PAGE_UP:
      case P.PAGE_DOWN:
      case P.PAGE_HOME:
      case P.PAGE_END:
        e.preventDefault(), this.isPickerDisplayed ? (i = this.listComponent) == null || i.handleKeyDown(e) : super.onKeyDown(e);
        break;
      case P.ESCAPE:
        super.onKeyDown(e);
        break;
      case P.SPACE:
        this.isPickerDisplayed ? e.preventDefault() : super.onKeyDown(e);
        break;
    }
  }
  showPicker() {
    const e = this.listComponent;
    e && (super.showPicker(), e.refreshHighlighted());
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    return this.listComponent.addOption(e), this;
  }
  clearOptions() {
    var e;
    return (e = this.listComponent) == null || e.clearOptions(), this.setValue(void 0, !0), this;
  }
  setValue(e, t, i) {
    const {
      listComponent: s,
      config: { placeholder: o },
      eDisplayField: n,
      tooltipFeature: r
    } = this;
    if (this.value === e || !s)
      return this;
    if (i || s.setValue(e, !0), s.getValue() === this.getValue())
      return this;
    let l = s.getDisplayValue();
    return l == null && o && (l = o), n.textContent = l, r == null || r.setTooltipAndRefresh(l ?? null), super.setValue(e, t);
  }
  destroy() {
    this.listComponent = this.destroyBean(this.listComponent), super.destroy();
  }
}, Aw = {
  selector: "AG-SELECT",
  component: Vl
}, Iw = (
  /*css*/
  ':where(.ag-root-wrapper,.ag-external,.ag-popup,.ag-dnd-ghost,.ag-chart),:where(.ag-root-wrapper,.ag-external,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]){box-sizing:border-box;&:after,&:before{box-sizing:border-box}&:where(div,span,label):focus-visible{box-shadow:inset var(--ag-focus-shadow);outline:none;&:where(.invalid){box-shadow:inset var(--ag-focus-error-shadow)}}&:where(button){color:inherit}}:where(.ag-root-wrapper,ag-external,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]) ::-ms-clear{display:none}.ag-hidden{display:none!important}.ag-invisible{visibility:hidden!important}.ag-popup-child{top:0;z-index:5;&:where(:not(.ag-tooltip-custom)){box-shadow:var(--ag-popup-shadow)}}.ag-input-wrapper,.ag-picker-field-wrapper{align-items:center;display:flex;flex:1 1 auto;line-height:normal;position:relative}.ag-input-field{align-items:center;display:flex;flex-direction:row}.ag-input-field-input:where(:not([type=checkbox],[type=radio])){flex:1 1 auto;min-width:0;width:100%}.ag-chart,.ag-dnd-ghost,.ag-external,.ag-popup,.ag-root-wrapper{cursor:default;line-height:normal;white-space:normal;-webkit-font-smoothing:antialiased;background-color:var(--ag-background-color);color:var(--ag-text-color);color-scheme:var(--ag-browser-color-scheme);font-family:var(--ag-font-family);font-size:var(--ag-font-size);--ag-indentation-level:0}:where(.ag-icon):before{align-items:center;background-color:currentcolor;color:inherit;content:"";display:flex;font-family:inherit;font-size:var(--ag-icon-size);font-style:normal;font-variant:normal;height:var(--ag-icon-size);justify-content:center;line-height:var(--ag-icon-size);-webkit-mask-size:contain;mask-size:contain;text-transform:none;width:var(--ag-icon-size)}.ag-icon{background-position:50%;background-repeat:no-repeat;background-size:contain;color:var(--ag-icon-color);display:block;height:var(--ag-icon-size);position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-icon-size)}.ag-disabled,[disabled]{.ag-icon{opacity:.5}&.ag-icon-grip{opacity:.35}}.ag-resizer{pointer-events:none;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:1}:where(.ag-resizer){&.ag-resizer-topLeft{cursor:nwse-resize;height:5px;left:0;top:0;width:5px}&.ag-resizer-top{cursor:ns-resize;height:5px;left:5px;right:5px;top:0}&.ag-resizer-topRight{cursor:nesw-resize;height:5px;right:0;top:0;width:5px}&.ag-resizer-right{bottom:5px;cursor:ew-resize;right:0;top:5px;width:5px}&.ag-resizer-bottomRight{bottom:0;cursor:nwse-resize;height:5px;right:0;width:5px}&.ag-resizer-bottom{bottom:0;cursor:ns-resize;height:5px;left:5px;right:5px}&.ag-resizer-bottomLeft{bottom:0;cursor:nesw-resize;height:5px;left:0;width:5px}&.ag-resizer-left{bottom:5px;cursor:ew-resize;left:0;top:5px;width:5px}}'
), mh, Ch, Nl = typeof window != "object" || !((Ch = (mh = window == null ? void 0 : window.document) == null ? void 0 : mh.fonts) != null && Ch.forEach), ys = (e, t, i, s, o, n) => {
  if (Nl)
    return;
  s && (e = `@layer ${CSS.escape(s)} { ${e} }`);
  let r = us.map.get(t);
  if (r || (r = [], us.map.set(t, r)), r.find((c) => c.css === e))
    return;
  const a = document.createElement("style");
  n && a.setAttribute("nonce", n), a.dataset.agGlobalCss = i, a.textContent = e;
  const l = { css: e, el: a, priority: o };
  let d;
  for (const c of r) {
    if (c.priority > o)
      break;
    d = c;
  }
  if (d) {
    d.el.insertAdjacentElement("afterend", a);
    const c = r.indexOf(d);
    r.splice(c + 1, 0, l);
  } else
    t.insertBefore(a, t.querySelector(":not(title, meta)")), r.push(l);
}, Dg = (e, t, i, s) => {
  ys(Iw, e, "shared", t, 0, i), s == null || s.forEach(
    (o, n) => o.forEach((r) => ys(r, e, n, t, 0, i))
  );
}, kw = (e) => {
  us.grids.add(e);
}, Lw = (e) => {
  if (us.grids.delete(e), us.grids.size === 0) {
    us.map = /* @__PURE__ */ new WeakMap();
    for (const t of document.head.querySelectorAll("style[data-ag-global-css]"))
      t.remove();
  }
}, oc, us = (oc = typeof window == "object" ? window : {}).agStyleInjectionState ?? (oc.agStyleInjectionState = {
  map: /* @__PURE__ */ new WeakMap(),
  grids: /* @__PURE__ */ new Set()
}), Dt = (e) => new Tg(e), Jt = "$default", Ow = 0, Tg = class {
  constructor({ feature: e, params: t, modeParams: i = {}, css: s, cssImports: o }) {
    this.feature = e, this.css = s, this.cssImports = o, this.modeParams = {
      // NOTE: it's important that default is defined first, putting it
      // first in iteration order, because when merging params the default
      // params override any prior modal params, so modal params in this
      // part need to come after default params to prevent them from being
      // immediately overridden.
      [Jt]: {
        ...i[Jt] ?? {},
        ...t ?? {}
      },
      ...i
    };
  }
  use(e, t, i) {
    let s = this._inject;
    if (s == null) {
      let { css: o } = this;
      if (o) {
        const n = `ag-theme-${this.feature ?? "part"}-${++Ow}`;
        typeof o == "function" && (o = o()), o = `:where(.${n}) {
${o}
}
`;
        for (const r of this.cssImports ?? [])
          o = `@import url(${JSON.stringify(r)});
${o}`;
        s = { css: o, class: n };
      } else
        s = !1;
      this._inject = s;
    }
    return s && e && ys(s.css, e, s.class, t, 1, i), s ? s.class : !1;
  }
}, _w = (e) => e.replace(/[A-Z]/g, (t) => `-${t}`).toLowerCase(), Mg = (e) => `--ag-${_w(e)}`, Tt = (e) => `var(${Mg(e)})`, Hw = (e, t, i) => Math.max(t, Math.min(i, e)), Bw = (e) => {
  const t = /* @__PURE__ */ new Map();
  return (i) => {
    const s = i;
    return t.has(s) || t.set(s, e(i)), t.get(s);
  };
}, yt = (e) => ({ ref: "accentColor", mix: e }), Ye = (e) => ({ ref: "foregroundColor", mix: e }), Xe = (e) => ({
  ref: "foregroundColor",
  mix: e,
  onto: "backgroundColor"
}), Gw = (e) => ({
  ref: "foregroundColor",
  mix: e,
  onto: "headerBackgroundColor"
}), We = { ref: "backgroundColor" }, is = { ref: "foregroundColor" }, Bt = { ref: "accentColor" }, Jn = {
  backgroundColor: "#fff",
  foregroundColor: "#181d1f",
  borderColor: Ye(0.15),
  chromeBackgroundColor: Xe(0.02),
  browserColorScheme: "light"
}, Vw = {
  ...Jn,
  textColor: is,
  accentColor: "#2196f3",
  invalidColor: "#e02525",
  fontFamily: [
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu",
    "Cantarell",
    "Helvetica Neue",
    "sans-serif"
  ],
  subtleTextColor: {
    ref: "textColor",
    mix: 0.5
  },
  borderWidth: 1,
  borderRadius: 4,
  spacing: 8,
  fontSize: 14,
  focusShadow: {
    spread: 3,
    color: yt(0.5)
  },
  focusErrorShadow: {
    spread: 3,
    color: {
      ref: "invalidColor",
      onto: "backgroundColor",
      mix: 0.5
    }
  },
  popupShadow: "0 0 16px #00000026",
  cardShadow: "0 1px 4px 1px #00000018",
  dropdownShadow: { ref: "cardShadow" },
  listItemHeight: {
    calc: "max(iconSize, dataFontSize) + widgetVerticalSpacing"
  },
  dragAndDropImageBackgroundColor: We,
  dragAndDropImageBorder: !0,
  dragAndDropImageNotAllowedBorder: {
    color: {
      ref: "invalidColor",
      onto: "dragAndDropImageBackgroundColor",
      mix: 0.5
    }
  },
  dragAndDropImageShadow: {
    ref: "popupShadow"
  },
  iconSize: 16,
  iconColor: "inherit",
  toggleButtonWidth: 28,
  toggleButtonHeight: 18,
  toggleButtonOnBackgroundColor: Bt,
  toggleButtonOffBackgroundColor: Xe(0.3),
  toggleButtonSwitchBackgroundColor: We,
  toggleButtonSwitchInset: 2,
  tooltipBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  tooltipErrorBackgroundColor: {
    ref: "invalidColor",
    onto: "backgroundColor",
    mix: 0.1
  },
  tooltipTextColor: {
    ref: "textColor"
  },
  tooltipErrorTextColor: {
    ref: "invalidColor"
  },
  tooltipBorder: !0,
  tooltipErrorBorder: {
    color: {
      ref: "invalidColor",
      onto: "backgroundColor",
      mix: 0.25
    }
  }
}, Nw = [
  "colorScheme",
  "color",
  "length",
  "scale",
  "borderStyle",
  "border",
  "shadow",
  "image",
  "fontFamily",
  "fontWeight",
  "duration"
], Ww = Bw((e) => (e = e.toLowerCase(), Nw.find((t) => e.endsWith(t.toLowerCase())) ?? "length")), br = (e) => typeof e == "object" && (e != null && e.ref) ? Tt(e.ref) : typeof e == "string" ? e : typeof e == "number" ? String(e) : !1, Wl = (e) => {
  if (typeof e == "string")
    return e;
  if (e && "ref" in e) {
    const t = Tt(e.ref);
    return e.mix == null ? t : `color-mix(in srgb, ${e.onto ? Tt(e.onto) : "transparent"}, ${t} ${Hw(e.mix * 100, 0, 100)}%)`;
  }
  return !1;
}, zw = br, ss = (e) => typeof e == "string" ? e : typeof e == "number" ? `${e}px` : e && "calc" in e ? `calc(${e.calc.replace(/ ?[*/+] ?/g, " $& ").replace(/-?\b[a-z][a-z0-9]*\b(?![-(])/gi, (i) => i[0] === "-" ? i : ` ${Tt(i)} `)})` : e && "ref" in e ? Tt(e.ref) : !1, Uw = br, Ua = (e, t) => typeof e == "string" ? e : e === !0 ? Ua({}, t) : e === !1 ? t === "columnBorder" ? Ua({ color: "transparent" }, t) : "none" : e && "ref" in e ? Tt(e.ref) : Ag(e.style ?? "solid") + " " + ss(e.width ?? { ref: "borderWidth" }) + " " + Wl(e.color ?? { ref: "borderColor" }), $w = (e) => typeof e == "string" ? e : e === !1 ? "none" : e && "ref" in e ? Tt(e.ref) : [
  ss(e.offsetX ?? 0),
  ss(e.offsetY ?? 0),
  ss(e.radius ?? 0),
  ss(e.spread ?? 0),
  Wl(e.color ?? { ref: "foregroundColor" })
].join(" "), Ag = br, Ig = (e) => typeof e == "string" ? e.includes(",") ? e : nc(e) : e && "googleFont" in e ? Ig(e.googleFont) : e && "ref" in e ? Tt(e.ref) : Array.isArray(e) ? e.map((t) => (typeof t == "object" && "googleFont" in t && (t = t.googleFont), nc(t))).join(", ") : !1, nc = (e) => (
  // don't quote var() expressions or quote safe identifier names, so that
  // people can specify fonts like sans-serif which are keywords not strings,
  // or var(--my-var)
  /^[\w-]+$|\w\(/.test(e) ? e : JSON.stringify(e)
), Kw = br, kg = (e) => typeof e == "string" ? e : e && "url" in e ? `url(${JSON.stringify(e.url)})` : e && "svg" in e ? kg({ url: `data:image/svg+xml,${encodeURIComponent(e.svg)}` }) : e && "ref" in e ? Tt(e.ref) : !1, jw = (e, t, i) => typeof e == "string" ? e : typeof e == "number" ? (e >= 10 && i.warn(104, { value: e, param: t }), `${e}s`) : e && "ref" in e ? Tt(e.ref) : !1, qw = {
  color: Wl,
  colorScheme: zw,
  length: ss,
  scale: Uw,
  border: Ua,
  borderStyle: Ag,
  shadow: $w,
  image: kg,
  fontFamily: Ig,
  fontWeight: Kw,
  duration: jw
}, Yw = (e, t, i) => {
  const s = Ww(e);
  return qw[s](t, e, i);
}, Qw = (e) => new Lg(e), Lg = class Og {
  constructor(t, i = []) {
    this.themeLogger = t, this.parts = i;
  }
  withPart(t) {
    return typeof t == "function" && (t = t()), t instanceof Tg ? new Og(this.themeLogger, [...this.parts, t]) : (this.themeLogger.preInitErr(259, "Invalid part", { part: t }), this);
  }
  withoutPart(t) {
    return this.withPart(Dt({ feature: t }));
  }
  withParams(t, i = Jt) {
    return this.withPart(
      Dt({
        modeParams: { [i]: t }
      })
    );
  }
  /**
   * Called by a grid instance when it starts using the theme. This installs
   * the theme's parts into document head, or the shadow DOM if the provided
   * container is within a shadow root.
   */
  _startUse({ styleContainer: t, cssLayer: i, nonce: s, loadThemeGoogleFonts: o, moduleCss: n }) {
    if (Nl)
      return;
    Zw(), Dg(t, i, s, n);
    const r = Xw(this);
    if (r.length > 0)
      for (const a of r)
        o && eb(a, s);
    for (const a of this.parts)
      a.use(t, i, s);
  }
  /**
   * Return CSS that that applies the params of this theme to elements with
   * the provided class name
   */
  _getCssClass() {
    return this._cssClassCache ?? (this._cssClassCache = rc(this.parts).map((t) => t.use(void 0, void 0, void 0)).filter(Boolean).join(" "));
  }
  _getModeParams() {
    let t = this._paramsCache;
    if (!t) {
      const i = {
        // NOTE: defining the default mode here is important, it ensures
        // that the default mode is first in iteration order, which puts
        // it first in outputted CSS, allowing other modes to override it
        [Jt]: { ...Vw }
      };
      for (const s of rc(this.parts))
        for (const o of Object.keys(s.modeParams)) {
          const n = s.modeParams[o];
          if (n) {
            const r = i[o] ?? (i[o] = {}), a = /* @__PURE__ */ new Set();
            for (const l of Object.keys(n)) {
              const d = n[l];
              d !== void 0 && (r[l] = d, a.add(l));
            }
            if (o === Jt)
              for (const l of Object.keys(i)) {
                const d = i[l];
                if (l !== Jt)
                  for (const c of a)
                    delete d[c];
              }
          }
        }
      this._paramsCache = t = i;
    }
    return t;
  }
  /**
   * Return the CSS chunk that is inserted into the grid DOM, and will
   * therefore be removed automatically when the grid is destroyed or it
   * starts to use a new theme.
   *
   * @param className a unique class name on the grid wrapper used to scope the returned CSS to the grid instance
   */
  _getPerInstanceCss(t) {
    const i = "##SELECTOR##";
    let s = this._paramsCssCache;
    if (!s) {
      let o = "", n = "";
      const r = this._getModeParams();
      for (const l of Object.keys(r)) {
        const d = r[l];
        if (l !== Jt) {
          const u = `:where([data-ag-theme-mode="${typeof CSS == "object" ? CSS.escape(l) : l}"]) & {
`;
          o += u, n += u;
        }
        for (const c of Object.keys(d).sort()) {
          const u = d[c], h = Yw(c, u, this.themeLogger);
          if (h === !1)
            this.themeLogger.error(107, { key: c, value: u });
          else {
            const g = Mg(c), p = g.replace("--ag-", "--ag-inherited-");
            o += `	${g}: var(${p}, ${h});
`, n += `	${p}: var(${g});
`;
          }
        }
        l !== Jt && (o += `}
`, n += `}
`);
      }
      let a = `${i} {
${o}}
`;
      a += `:has(> ${i}):not(${i}) {
${n}}
`, this._paramsCssCache = s = a;
    }
    return s.replaceAll(i, `:where(.${t})`);
  }
}, rc = (e) => {
  const t = /* @__PURE__ */ new Map();
  for (const s of e)
    t.set(s.feature, s);
  const i = [];
  for (const s of e)
    (!s.feature || t.get(s.feature) === s) && i.push(s);
  return i;
}, Xw = (e) => {
  const t = /* @__PURE__ */ new Set(), i = (n) => {
    if (Array.isArray(n))
      n.forEach(i);
    else {
      const r = n == null ? void 0 : n.googleFont;
      typeof r == "string" && t.add(r);
    }
  };
  return Object.values(e._getModeParams()).flatMap((n) => Object.values(n)).forEach(i), Array.from(t).sort();
}, ac = !1, Zw = () => {
  if (!ac) {
    ac = !0;
    for (const e of Array.from(document.head.querySelectorAll('style[data-ag-scope="legacy"]')))
      e.remove();
  }
}, Jw = /* @__PURE__ */ new Set(), eb = async (e, t) => {
  Jw.add(e);
  const i = `@import url('https://${tb}/css2?family=${encodeURIComponent(e)}:wght@100;200;300;400;500;600;700;800;900&display=swap');
`;
  ys(i, document.head, `googleFont:${e}`, void 0, 0, t);
}, tb = "fonts.googleapis.com", ib = 1, sb = class {
  constructor(e) {
    this.beans = {}, this.createdBeans = [], this.destroyed = !1, this.instanceId = ib++, !(!e || !e.beanClasses) && (this.beanDestroyComparator = e.beanDestroyComparator, this.init(e));
  }
  init(e) {
    var t;
    this.id = e.id, this.beans.context = this, this.destroyCallback = e.destroyCallback;
    for (const i of Object.keys(e.providedBeanInstances))
      this.beans[i] = e.providedBeanInstances[i];
    e.beanClasses.forEach((i) => {
      const s = new i();
      s.beanName ? this.beans[s.beanName] = s : console.error(`Bean ${i.name} is missing beanName`), this.createdBeans.push(s);
    }), (t = e.derivedBeans) == null || t.forEach((i) => {
      const { beanName: s, bean: o } = i(this);
      this.beans[s] = o, this.createdBeans.push(o);
    }), e.beanInitComparator && this.createdBeans.sort(e.beanInitComparator), this.initBeans(this.createdBeans);
  }
  getBeanInstances() {
    return Object.values(this.beans);
  }
  createBean(e, t) {
    return this.initBeans([e], t), e;
  }
  initBeans(e, t) {
    const i = this.beans;
    e.forEach((s) => {
      var o, n;
      (o = s.preWireBeans) == null || o.call(s, i), (n = s.wireBeans) == null || n.call(s, i);
    }), e.forEach((s) => {
      var o;
      return (o = s.preConstruct) == null ? void 0 : o.call(s);
    }), t && e.forEach(t), e.forEach((s) => {
      var o;
      return (o = s.postConstruct) == null ? void 0 : o.call(s);
    });
  }
  getBeans() {
    return this.beans;
  }
  getBean(e) {
    return this.beans[e];
  }
  getId() {
    return this.id;
  }
  destroy() {
    var t;
    if (this.destroyed)
      return;
    this.destroyed = !0;
    const e = this.getBeanInstances();
    this.beanDestroyComparator && e.sort(this.beanDestroyComparator), this.destroyBeans(e), this.beans = {}, this.createdBeans = [], (t = this.destroyCallback) == null || t.call(this);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e) {
    var t;
    (t = e == null ? void 0 : e.destroy) == null || t.call(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e) {
    if (e)
      for (let t = 0; t < e.length; t++)
        this.destroyBean(e[t]);
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
}, ob = 0, nb = class extends At {
  constructor() {
    super(...arguments), this.beanName = "environment", this.paramsClass = `ag-theme-params-${++ob}`, this.globalCSS = [];
  }
  wireBeans(e) {
    this.eRootDiv = e.eRootDiv;
  }
  postConstruct() {
    const { gos: e, eRootDiv: t } = this;
    e.setInstanceDomData(t), this.eStyleContainer = e.get("themeStyleContainer") ?? (t.getRootNode() === document ? document.head : t), this.cssLayer = e.get("themeCssLayer"), this.styleNonce = e.get("styleNonce"), this.addManagedPropertyListener("theme", () => this.handleThemeChange()), this.handleThemeChange(), this.initVariables(), this.addDestroyFunc(() => Lw(this)), this.mutationObserver = new MutationObserver(() => {
      this.fireStylesChangedEvent("themeChanged");
    }), this.addDestroyFunc(() => this.mutationObserver.disconnect());
  }
  applyThemeClasses(e, t = []) {
    const { theme: i } = this;
    let s;
    i ? s = `${this.paramsClass} ${i._getCssClass()}` : s = this.applyLegacyThemeClasses();
    for (const o of Array.from(e.classList))
      o.startsWith("ag-theme-") && e.classList.remove(o);
    if (s) {
      const o = e.className;
      e.className = `${o}${o ? " " : ""}${s}${t != null && t.length ? ` ${t.join(" ")}` : ""}`;
    }
  }
  applyLegacyThemeClasses() {
    let e = "";
    this.mutationObserver.disconnect();
    let t = this.eRootDiv;
    for (; t; ) {
      let i = !1;
      for (const s of Array.from(t.classList))
        s.startsWith("ag-theme-") && (i = !0, e = e ? `${e} ${s}` : s);
      i && this.mutationObserver.observe(t, {
        attributes: !0,
        attributeFilter: ["class"]
      }), t = t.parentElement;
    }
    return e;
  }
  addGlobalCSS(e, t) {
    this.theme ? ys(e, this.eStyleContainer, t, this.cssLayer, 0, this.styleNonce) : this.globalCSS.push([e, t]);
  }
  handleThemeChange() {
    const { gos: e, theme: t } = this, i = e.get("theme");
    let s;
    if (i === "legacy")
      s = void 0;
    else {
      const o = i ?? this.getDefaultTheme();
      o instanceof Lg ? s = o : this.themeError(o);
    }
    s !== t && this.handleNewTheme(s), this.postProcessThemeChange(s, i);
  }
  handleNewTheme(e) {
    const { gos: t, eRootDiv: i, globalCSS: s } = this, o = this.getAdditionalCss();
    if (e) {
      kw(this), Dg(this.eStyleContainer, this.cssLayer, this.styleNonce, o);
      for (const [r, a] of s)
        ys(r, this.eStyleContainer, a, this.cssLayer, 0, this.styleNonce);
      s.length = 0;
    }
    this.theme = e, e == null || e._startUse({
      loadThemeGoogleFonts: t.get("loadThemeGoogleFonts"),
      styleContainer: this.eStyleContainer,
      cssLayer: this.cssLayer,
      nonce: this.styleNonce,
      moduleCss: o
    });
    let n = this.eParamsStyle;
    if (!n) {
      n = this.eParamsStyle = Vo({ tag: "style" });
      const r = t.get("styleNonce");
      r && n.setAttribute("nonce", r), i.appendChild(n);
    }
    Nl || (n.textContent = (e == null ? void 0 : e._getPerInstanceCss(this.paramsClass)) || ""), this.applyThemeClasses(i), this.fireStylesChangedEvent("themeChanged");
  }
}, rb = class extends At {
  constructor() {
    super(...arguments), this.beanName = "registry";
  }
  registerDynamicBeans(e) {
    if (e) {
      this.dynamicBeans ?? (this.dynamicBeans = {});
      for (const t of Object.keys(e))
        this.dynamicBeans[t] = e[t];
    }
  }
  createDynamicBean(e, t, ...i) {
    if (!this.dynamicBeans)
      throw new Error(this.getDynamicError(e, !0));
    const s = this.dynamicBeans[e];
    if (s == null) {
      if (t)
        throw new Error(this.getDynamicError(e, !1));
      return;
    }
    return new s(...i);
  }
}, ab = class extends At {
  constructor() {
    super(...arguments), this.beanName = "eventSvc", this.eventServiceType = "global", this.globalSvc = new Li();
  }
  addListener(e, t, i) {
    this.globalSvc.addEventListener(e, t, i);
  }
  removeListener(e, t, i) {
    this.globalSvc.removeEventListener(e, t, i);
  }
  addGlobalListener(e, t = !1) {
    this.globalSvc.addGlobalListener(e, t);
  }
  removeGlobalListener(e, t = !1) {
    this.globalSvc.removeGlobalListener(e, t);
  }
  dispatchEvent(e) {
    this.globalSvc.dispatchEvent(this.gos.addCommon(e));
  }
  dispatchEventOnce(e) {
    this.globalSvc.dispatchEventOnce(this.gos.addCommon(e));
  }
}, _g = class extends At {
  constructor(e, t) {
    super(), this.ctrl = e, t && (this.beans = t);
  }
  postConstruct() {
    this.refreshTooltip();
  }
  /**
   *
   * @param tooltip The tooltip value
   * @param allowEmptyString Set it to true to allow the title to be set to `''`. This is necessary
   * when the browser adds a default tooltip the element and the tooltip service will be displayed
   * next to a browser tooltip causing confusion.
   */
  setBrowserTooltip(e, t) {
    const i = "title", s = this.ctrl.getGui();
    s && (e != null && (e != "" || t) ? s.setAttribute(i, e) : s.removeAttribute(i));
  }
  updateTooltipText() {
    const { getTooltipValue: e } = this.ctrl;
    e && (this.tooltip = e());
  }
  createTooltipFeatureIfNeeded() {
    if (this.tooltipManager == null) {
      const e = this.beans.registry.createDynamicBean("tooltipStateManager", !0, this.ctrl, () => this.tooltip);
      e && (this.tooltipManager = this.createBean(e, this.beans.context));
    }
  }
  attemptToShowTooltip() {
    var e;
    (e = this.tooltipManager) == null || e.prepareToShowTooltip();
  }
  attemptToHideTooltip() {
    var e;
    (e = this.tooltipManager) == null || e.hideTooltip();
  }
  setTooltipAndRefresh(e) {
    this.tooltip = e, this.refreshTooltip();
  }
  refreshTooltip(e) {
    this.browserTooltips = this.beans.gos.get("enableBrowserTooltips"), this.updateTooltipText(), this.browserTooltips ? (this.setBrowserTooltip(this.tooltip), this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context)) : (this.setBrowserTooltip(e ? "" : null, e), this.createTooltipFeatureIfNeeded());
  }
  destroy() {
    this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context), super.destroy();
  }
}, lb = 1e3, db = 1e3, lc = 100, dc, Jo = !1, cb = class extends At {
  constructor(e, t) {
    super(), this.tooltipCtrl = e, this.getTooltipValue = t, this.interactionEnabled = !1, this.isInteractingWithTooltip = !1, this.state = 0, this.tooltipInstanceCount = 0, this.tooltipMouseTrack = !1;
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc;
  }
  postConstruct() {
    this.gos.get("tooltipInteraction") && (this.interactionEnabled = !0), this.tooltipTrigger = this.getTooltipTrigger(), this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
    const e = this.tooltipCtrl.getGui();
    this.tooltipTrigger === 0 && this.addManagedListeners(e, {
      mouseenter: this.onMouseEnter.bind(this),
      mouseleave: this.onMouseLeave.bind(this)
    }), this.tooltipTrigger === 1 && this.addManagedListeners(e, {
      focusin: this.onFocusIn.bind(this),
      focusout: this.onFocusOut.bind(this)
    }), this.addManagedListeners(e, { mousemove: this.onMouseMove.bind(this) }), this.interactionEnabled || this.addManagedListeners(e, {
      mousedown: this.onMouseDown.bind(this),
      keydown: this.onKeyDown.bind(this)
    });
  }
  getGridOptionsTooltipDelay(e) {
    const t = this.gos.get(e);
    return Math.max(200, t);
  }
  getTooltipDelay(e) {
    var t, i, s, o;
    return e === "show" ? ((i = (t = this.tooltipCtrl).getTooltipShowDelayOverride) == null ? void 0 : i.call(t)) ?? this.getGridOptionsTooltipDelay("tooltipShowDelay") : ((o = (s = this.tooltipCtrl).getTooltipHideDelayOverride) == null ? void 0 : o.call(s)) ?? this.getGridOptionsTooltipDelay("tooltipHideDelay");
  }
  destroy() {
    this.setToDoNothing(), super.destroy();
  }
  getTooltipTrigger() {
    const e = this.gos.get("tooltipTrigger");
    return !e || e === "hover" ? 0 : 1;
  }
  onMouseEnter(e) {
    this.interactionEnabled && this.interactiveTooltipTimeoutId && (this.unlockService(), this.startHideTimeout()), !Mi() && (Jo ? this.showTooltipTimeoutId = window.setTimeout(() => {
      this.prepareToShowTooltip(e);
    }, lc) : this.prepareToShowTooltip(e));
  }
  onMouseMove(e) {
    this.lastMouseEvent && (this.lastMouseEvent = e), this.tooltipMouseTrack && this.state === 2 && this.tooltipComp && this.positionTooltip();
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  onMouseLeave() {
    this.interactionEnabled ? this.lockService() : this.setToDoNothing();
  }
  onFocusIn() {
    this.prepareToShowTooltip();
  }
  onFocusOut(e) {
    var o;
    const t = e.relatedTarget, i = this.tooltipCtrl.getGui(), s = (o = this.tooltipComp) == null ? void 0 : o.getGui();
    this.isInteractingWithTooltip || i.contains(t) || this.interactionEnabled && (s != null && s.contains(t)) || this.setToDoNothing();
  }
  onKeyDown() {
    this.isInteractingWithTooltip && (this.isInteractingWithTooltip = !1), this.setToDoNothing();
  }
  prepareToShowTooltip(e) {
    if (this.state != 0 || Jo)
      return;
    let t = 0;
    e && (t = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show")), this.lastMouseEvent = e || null, this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), t), this.state = 1;
  }
  isLastTooltipHiddenRecently() {
    return Date.now() - dc < lb;
  }
  setToDoNothing(e) {
    !e && this.state === 2 && this.hideTooltip(), this.onBodyScrollEventCallback && (this.onBodyScrollEventCallback(), this.onBodyScrollEventCallback = void 0), this.clearEventHandlers(), this.onDocumentKeyDownCallback && (this.onDocumentKeyDownCallback(), this.onDocumentKeyDownCallback = void 0), this.clearTimeouts(), this.state = 0, this.lastMouseEvent = null;
  }
  showTooltip() {
    var o, n;
    const e = this.getTooltipValue(), t = this.tooltipCtrl;
    if (!H(e) || t.shouldDisplayTooltip && !t.shouldDisplayTooltip()) {
      this.setToDoNothing();
      return;
    }
    const i = this.gos.addCommon({
      location: ((o = t.getLocation) == null ? void 0 : o.call(t)) ?? "UNKNOWN",
      value: e,
      hideTooltipCallback: () => this.hideTooltip(!0),
      ...(n = t.getAdditionalParams) == null ? void 0 : n.call(t)
    });
    this.state = 2, this.tooltipInstanceCount++;
    const s = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
    this.createTooltipComp(i, s);
  }
  hideTooltip(e) {
    !e && this.isInteractingWithTooltip || (this.tooltipComp && (this.destroyTooltipComp(), dc = Date.now()), this.eventSvc.dispatchEvent({
      type: "tooltipHide",
      parentGui: this.tooltipCtrl.getGui()
    }), e && (this.isInteractingWithTooltip = !1), this.setToDoNothing(!0));
  }
  newTooltipComponentCallback(e, t) {
    var r;
    if (this.state !== 2 || this.tooltipInstanceCount !== e) {
      this.destroyBean(t);
      return;
    }
    const s = t.getGui();
    this.tooltipComp = t, s.classList.contains("ag-tooltip") || s.classList.add("ag-tooltip-custom"), this.tooltipTrigger === 0 && s.classList.add("ag-tooltip-animate"), this.interactionEnabled && s.classList.add("ag-tooltip-interactive");
    const o = this.getLocaleTextFunc(), n = (r = this.popupSvc) == null ? void 0 : r.addPopup({
      eChild: s,
      ariaLabel: o("ariaLabelTooltip", "Tooltip")
    });
    if (n && (this.tooltipPopupDestroyFunc = n.hideFunc), this.positionTooltip(), this.tooltipTrigger === 1) {
      const a = () => this.setToDoNothing();
      [this.onBodyScrollEventCallback] = this.addManagedEventListeners({
        bodyScroll: a
      }), this.setEventHandlers(a);
    }
    this.interactionEnabled && ([this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(s, {
      mouseenter: this.onTooltipMouseEnter.bind(this),
      mouseleave: this.onTooltipMouseLeave.bind(this)
    }), [this.onDocumentKeyDownCallback] = this.addManagedElementListeners(Ee(this.beans), {
      keydown: (a) => {
        s.contains(a == null ? void 0 : a.target) || this.onKeyDown();
      }
    }), this.tooltipTrigger === 1 && ([this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(s, {
      focusin: this.onTooltipFocusIn.bind(this),
      focusout: this.onTooltipFocusOut.bind(this)
    }))), this.eventSvc.dispatchEvent({
      type: "tooltipShow",
      tooltipGui: s,
      parentGui: this.tooltipCtrl.getGui()
    }), this.startHideTimeout();
  }
  onTooltipMouseEnter() {
    this.isInteractingWithTooltip = !0, this.unlockService();
  }
  onTooltipMouseLeave() {
    this.isTooltipFocused() || (this.isInteractingWithTooltip = !1, this.lockService());
  }
  onTooltipFocusIn() {
    this.isInteractingWithTooltip = !0;
  }
  isTooltipFocused() {
    var i;
    const e = (i = this.tooltipComp) == null ? void 0 : i.getGui(), t = he(this.beans);
    return !!e && e.contains(t);
  }
  onTooltipFocusOut(e) {
    const t = this.tooltipCtrl.getGui();
    this.isTooltipFocused() || (this.isInteractingWithTooltip = !1, t.contains(e.relatedTarget) ? this.startHideTimeout() : this.hideTooltip());
  }
  positionTooltip() {
    var t, i;
    const e = {
      type: "tooltip",
      ePopup: this.tooltipComp.getGui(),
      nudgeY: 18,
      skipObserver: this.tooltipMouseTrack
    };
    this.lastMouseEvent ? (t = this.popupSvc) == null || t.positionPopupUnderMouseEvent({
      ...e,
      mouseEvent: this.lastMouseEvent
    }) : (i = this.popupSvc) == null || i.positionPopupByComponent({
      ...e,
      eventSource: this.tooltipCtrl.getGui(),
      position: "under",
      keepWithinBounds: !0,
      nudgeY: 5
    });
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const e = this.tooltipPopupDestroyFunc, t = this.tooltipComp, i = this.tooltipTrigger === 0 ? db : 0;
    window.setTimeout(() => {
      e(), this.destroyBean(t);
    }, i), this.clearTooltipListeners(), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
  }
  clearTooltipListeners() {
    [
      this.tooltipMouseEnterListener,
      this.tooltipMouseLeaveListener,
      this.tooltipFocusInListener,
      this.tooltipFocusOutListener
    ].forEach((e) => {
      e && e();
    }), this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
  }
  lockService() {
    Jo = !0, this.interactiveTooltipTimeoutId = window.setTimeout(() => {
      this.unlockService(), this.setToDoNothing();
    }, lc);
  }
  unlockService() {
    Jo = !1, this.clearInteractiveTimeout();
  }
  startHideTimeout() {
    this.clearHideTimeout(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
  }
  clearShowTimeout() {
    this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0);
  }
  clearHideTimeout() {
    this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
  }
  clearInteractiveTimeout() {
    this.interactiveTooltipTimeoutId && (window.clearTimeout(this.interactiveTooltipTimeoutId), this.interactiveTooltipTimeoutId = void 0);
  }
  clearTimeouts() {
    this.clearShowTimeout(), this.clearHideTimeout(), this.clearInteractiveTimeout();
  }
}, ub = class extends _g {
  constructor(e, t, i) {
    super(e, i), this.highlightTracker = t, this.onHighlight = this.onHighlight.bind(this);
  }
  postConstruct() {
    super.postConstruct(), this.wireHighlightListeners();
  }
  wireHighlightListeners() {
    this.addManagedPropertyListener("tooltipTrigger", ({ currentValue: e }) => {
      this.setTooltipMode(e);
    }), this.setTooltipMode(this.gos.get("tooltipTrigger")), this.highlightTracker.addEventListener("itemHighlighted", this.onHighlight);
  }
  onHighlight(e) {
    this.tooltipMode === 1 && (e.highlighted ? this.attemptToShowTooltip() : this.attemptToHideTooltip());
  }
  setTooltipMode(e = "focus") {
    this.tooltipMode = e === "focus" ? 1 : 0;
  }
  destroy() {
    this.highlightTracker.removeEventListener("itemHighlighted", this.onHighlight), super.destroy();
  }
}, en = 0, hb = 200, gb = class extends At {
  constructor() {
    super(...arguments), this.beanName = "popupSvc", this.popupList = [];
  }
  getPopupParent() {
    const e = this.gos.get("popupParent");
    return e || this.getDefaultPopupParent();
  }
  positionPopupUnderMouseEvent(e) {
    const { ePopup: t, nudgeX: i, nudgeY: s, skipObserver: o } = e;
    this.positionPopup({
      ePopup: t,
      nudgeX: i,
      nudgeY: s,
      keepWithinBounds: !0,
      skipObserver: o,
      updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(e, e.type, e.ePopup, null, e.mouseEvent)
    });
  }
  calculatePointerAlign(e) {
    const t = this.getParentRect();
    return {
      x: e.clientX - t.left,
      y: e.clientY - t.top
    };
  }
  positionPopupByComponent(e) {
    const {
      ePopup: t,
      nudgeX: i,
      nudgeY: s,
      keepWithinBounds: o,
      eventSource: n,
      alignSide: r = "left",
      position: a = "over",
      type: l
    } = e, d = n.getBoundingClientRect(), c = this.getParentRect();
    this.setAlignedTo(n, t);
    const u = () => {
      let h = d.left - c.left;
      r === "right" && (h -= t.offsetWidth - d.width);
      let g;
      return a === "over" ? (g = d.top - c.top, this.setAlignedStyles(t, "over")) : (this.setAlignedStyles(t, "under"), this.shouldRenderUnderOrAbove(t, d, c, e.nudgeY || 0) === "under" ? g = d.top - c.top + d.height : g = d.top - t.offsetHeight - (s || 0) * 2 - c.top), { x: h, y: g };
    };
    this.positionPopup({
      ePopup: t,
      nudgeX: i,
      nudgeY: s,
      keepWithinBounds: o,
      updatePosition: u,
      postProcessCallback: () => this.callPostProcessPopup(e, l, t, n, null)
    });
  }
  shouldRenderUnderOrAbove(e, t, i, s) {
    const o = i.bottom - t.bottom, n = t.top - i.top, r = e.offsetHeight + s;
    return o > r ? "under" : n > r || n > o ? "above" : "under";
  }
  setAlignedStyles(e, t) {
    const i = this.getPopupIndex(e);
    if (i === -1)
      return;
    const s = this.popupList[i], { alignedToElement: o } = s;
    !o || (["right", "left", "over", "above", "under"].forEach((r) => {
      o.classList.remove(`ag-has-popup-positioned-${r}`), e.classList.remove(`ag-popup-positioned-${r}`);
    }), !t) || (o.classList.add(`ag-has-popup-positioned-${t}`), e.classList.add(`ag-popup-positioned-${t}`));
  }
  setAlignedTo(e, t) {
    const i = this.getPopupIndex(t);
    if (i !== -1) {
      const s = this.popupList[i];
      s.alignedToElement = e;
    }
  }
  positionPopup(e) {
    const { ePopup: t, keepWithinBounds: i, nudgeX: s, nudgeY: o, skipObserver: n, updatePosition: r } = e, a = { width: 0, height: 0 }, l = (d = !1) => {
      let { x: c, y: u } = r();
      d && t.clientWidth === a.width && t.clientHeight === a.height || (a.width = t.clientWidth, a.height = t.clientHeight, s && (c += s), o && (u += o), i && (c = this.keepXYWithinBounds(
        t,
        c,
        1
        /* Horizontal */
      ), u = this.keepXYWithinBounds(
        t,
        u,
        0
        /* Vertical */
      )), t.style.left = `${c}px`, t.style.top = `${u}px`, e.postProcessCallback && e.postProcessCallback());
    };
    if (l(), !n) {
      const d = di(this.beans, t, () => l(!0));
      setTimeout(() => d(), hb);
    }
  }
  getParentRect() {
    const e = Ee(this.beans);
    let t = this.getPopupParent();
    return t === e.body ? t = e.documentElement : getComputedStyle(t).position === "static" && (t = t.offsetParent), Ah(t);
  }
  keepXYWithinBounds(e, t, i) {
    const s = i === 0, o = s ? "clientHeight" : "clientWidth", n = s ? "top" : "left", r = s ? "height" : "width", a = s ? "scrollTop" : "scrollLeft", l = Ee(this.beans), d = l.documentElement, c = this.getPopupParent(), u = e.getBoundingClientRect(), h = c.getBoundingClientRect(), g = l.documentElement.getBoundingClientRect(), p = c === l.body, f = Math.ceil(u[r]);
    let C = p ? (s ? Mh : Vn)(d) + d[a] : c[o];
    p && (C -= Math.abs(g[n] - h[n]));
    const v = C - f;
    return Math.min(Math.max(t, 0), Math.abs(v));
  }
  addPopup(e) {
    const { eChild: t, ariaLabel: i, ariaOwns: s, alwaysOnTop: o, positionCallback: n, anchorToElement: r } = e, a = this.getPopupIndex(t);
    if (a !== -1)
      return { hideFunc: this.popupList[a].hideFunc };
    this.initialisePopupPosition(t);
    const l = this.createPopupWrapper(t, !!o, i, s), d = this.addEventListenersToPopup({ ...e, wrapperEl: l });
    return n && n(), this.addPopupToPopupList(t, l, d, r), {
      hideFunc: d
    };
  }
  initialisePopupPosition(e) {
    const i = this.getPopupParent().getBoundingClientRect();
    H(e.style.top) || (e.style.top = `${i.top * -1}px`), H(e.style.left) || (e.style.left = `${i.left * -1}px`);
  }
  createPopupWrapper(e, t, i, s) {
    const o = this.getPopupParent(), { environment: n, gos: r } = this.beans, a = Vo({ tag: "div" });
    return n.applyThemeClasses(a), a.classList.add("ag-popup"), e.classList.add(r.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child"), e.hasAttribute("role") || oi(e, "dialog"), i ? vs(e, i) : s && (e.id || (e.id = `popup-component-${en}`), Nd(s, e.id)), a.appendChild(e), o.appendChild(a), t ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e), a;
  }
  addEventListenersToPopup(e) {
    const t = this.beans, i = Ee(t), s = this.getPopupParent(), { wrapperEl: o, eChild: n, closedCallback: r, afterGuiAttached: a, closeOnEsc: l, modal: d, ariaOwns: c } = e;
    let u = !1;
    const h = (m) => {
      if (!o.contains(he(t)))
        return;
      m.key === P.ESCAPE && !this.isStopPropagation(m) && f({ keyboardEvent: m });
    }, g = (m) => f({ mouseEvent: m }), p = (m) => f({ touchEvent: m }), f = (m = {}) => {
      const { mouseEvent: C, touchEvent: v, keyboardEvent: R, forceHide: b } = m;
      !b && // we don't hide popup if the event was on the child, or any
      // children of this child
      (this.isEventFromCurrentPopup({ mouseEvent: C, touchEvent: v }, n) || // this method should only be called once. the client can have different
      // paths, each one wanting to close, so this method may be called multiple times.
      u) || (u = !0, s.removeChild(o), i.removeEventListener("keydown", h), i.removeEventListener("mousedown", g), i.removeEventListener("touchstart", p), i.removeEventListener("contextmenu", g), this.eventSvc.removeListener("dragStarted", g), r && r(C || v || R), this.removePopupFromPopupList(n, c));
    };
    return a && a({ hidePopup: f }), window.setTimeout(() => {
      l && i.addEventListener("keydown", h), d && (i.addEventListener("mousedown", g), this.eventSvc.addListener("dragStarted", g), i.addEventListener("touchstart", p), i.addEventListener("contextmenu", g));
    }, 0), f;
  }
  addPopupToPopupList(e, t, i, s) {
    this.popupList.push({
      element: e,
      wrapper: t,
      hideFunc: i,
      instanceId: en,
      isAnchored: !!s
    }), s && this.setPopupPositionRelatedToElement(e, s), en = en + 1;
  }
  getPopupIndex(e) {
    return this.popupList.findIndex((t) => t.element === e);
  }
  setPopupPositionRelatedToElement(e, t) {
    const i = this.getPopupIndex(e);
    if (i === -1)
      return;
    const s = this.popupList[i];
    if (s.stopAnchoringPromise && s.stopAnchoringPromise.then((n) => n && n()), s.stopAnchoringPromise = void 0, s.isAnchored = !1, !t)
      return;
    const o = this.keepPopupPositionedRelativeTo({
      element: t,
      ePopup: e,
      hidePopup: s.hideFunc
    });
    return s.stopAnchoringPromise = o, s.isAnchored = !0, o;
  }
  removePopupFromPopupList(e, t) {
    this.setAlignedStyles(e, null), this.setPopupPositionRelatedToElement(e, null), t && Nd(t, null), this.popupList = this.popupList.filter((i) => i.element !== e);
  }
  keepPopupPositionedRelativeTo(e) {
    const t = this.getPopupParent(), i = t.getBoundingClientRect(), { element: s, ePopup: o } = e, n = s.getBoundingClientRect(), r = (u) => parseInt(u.substring(0, u.length - 1), 10), a = (u, h) => {
      const g = i[u] - n[u], p = r(o.style[u]);
      return {
        initialDiff: g,
        lastDiff: g,
        initial: p,
        last: p,
        direction: h
      };
    }, l = a(
      "top",
      0
      /* Vertical */
    ), d = a(
      "left",
      1
      /* Horizontal */
    ), c = this.beans.frameworkOverrides;
    return new fe((u) => {
      c.wrapIncoming(() => {
        Sv(() => {
          const h = t.getBoundingClientRect(), g = s.getBoundingClientRect();
          if (g.top == 0 && g.left == 0 && g.height == 0 && g.width == 0) {
            e.hidePopup();
            return;
          }
          const f = (m, C) => {
            const v = r(o.style[C]);
            m.last !== v && (m.initial = v, m.last = v);
            const R = h[C] - g[C];
            if (R != m.lastDiff) {
              const b = this.keepXYWithinBounds(
                o,
                m.initial + m.initialDiff - R,
                m.direction
              );
              o.style[C] = `${b}px`, m.last = b;
            }
            m.lastDiff = R;
          };
          f(l, "top"), f(d, "left");
        }, 200).then((h) => {
          u(() => {
            h != null && window.clearInterval(h);
          });
        });
      }, "popupPositioning");
    });
  }
  isEventFromCurrentPopup(e, t) {
    const { mouseEvent: i, touchEvent: s } = e, o = i || s;
    if (!o)
      return !1;
    const n = this.getPopupIndex(t);
    if (n === -1)
      return !1;
    for (let r = n; r < this.popupList.length; r++) {
      const a = this.popupList[r];
      if (pC(a.element, o))
        return !0;
    }
    return this.isElementWithinCustomPopup(o.target);
  }
  isElementWithinCustomPopup(e) {
    const t = Ee(this.beans);
    for (; e && e !== t.body; ) {
      if (e.classList.contains("ag-custom-component-popup") || e.parentElement === null)
        return !0;
      e = e.parentElement;
    }
    return !1;
  }
  getWrapper(e) {
    for (; !e.classList.contains("ag-popup") && e.parentElement; )
      e = e.parentElement;
    return e.classList.contains("ag-popup") ? e : null;
  }
  setAlwaysOnTop(e, t) {
    const i = this.getWrapper(e);
    i && (i.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(i));
  }
  /** @returns true if moved */
  bringPopupToFront(e) {
    const t = this.getPopupParent(), i = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")), s = i.length, o = this.getWrapper(e);
    if (!o || s <= 1 || !t.contains(e))
      return;
    const n = [], r = [];
    for (const h of i)
      h !== o && (h.classList.contains("ag-always-on-top") ? r.push(h) : n.push(h));
    const a = [], l = r.length, u = o.classList.contains("ag-always-on-top") || !l ? [...n, ...r, o] : [...n, o, ...r];
    for (let h = 0; h <= s; h++) {
      const g = u[h];
      if (i[h] === u[h] || g === o)
        continue;
      g.querySelectorAll("div").forEach((f) => {
        f.scrollTop !== 0 && a.push([f, f.scrollTop]);
      }), h === 0 ? t.insertAdjacentElement("afterbegin", g) : u[h - 1].insertAdjacentElement("afterend", g);
    }
    for (; a.length; ) {
      const h = a.pop();
      h[0].scrollTop = h[1];
    }
  }
}, pb = class extends Ol {
  constructor() {
    super({ tag: "div", cls: "ag-tooltip" });
  }
  // will need to type params
  init(e) {
    const { value: t } = e, i = this.getGui();
    i.textContent = Es(t);
    const s = e.location.replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
    i.classList.add(`ag-${s}-tooltip`);
  }
}, fb = class extends At {
  constructor() {
    super(...arguments), this.beanName = "dragSvc", this.dragEndFunctions = [], this.dragSources = [];
  }
  destroy() {
    const { dragSources: e } = this;
    e.forEach(this.removeListener.bind(this)), e.length = 0, super.destroy();
  }
  removeListener(e) {
    const t = e.dragSource.eElement, i = e.mouseDownListener;
    if (t.removeEventListener("mousedown", i), e.touchEnabled) {
      const s = e.touchStartListener;
      t.removeEventListener("touchstart", s, { passive: !0 });
    }
  }
  removeDragSource(e) {
    const { dragSources: t } = this, i = t.find((s) => s.dragSource === e);
    i && (this.removeListener(i), tt(t, i));
  }
  addDragSource(e) {
    const t = this.onMouseDown.bind(this, e), { eElement: i, includeTouch: s, stopPropagationForTouch: o } = e;
    i.addEventListener("mousedown", t);
    let n = null;
    const r = this.gos.get("suppressTouch");
    s && !r && (n = (a) => {
      xl(a.target) || (o && a.stopPropagation(), this.onTouchStart(e, a));
    }, i.addEventListener("touchstart", n, { passive: !1 })), this.dragSources.push({
      dragSource: e,
      mouseDownListener: t,
      touchStartListener: n,
      touchEnabled: !!s
    });
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(e, t) {
    this.currentDragParams = e, this.dragging = !1;
    const i = t.touches[0];
    this.touchLastTime = i, this.touchStart = i;
    const s = (l) => this.onTouchMove(l, e.eElement), o = (l) => this.onTouchUp(l, e.eElement), n = (l) => {
      l.cancelable && l.preventDefault();
    }, r = t.target, a = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      {
        target: wo(this.beans),
        type: "touchmove",
        listener: n,
        options: { passive: !1 }
      },
      { target: r, type: "touchmove", listener: s, options: { passive: !0 } },
      { target: r, type: "touchend", listener: o, options: { passive: !0 } },
      { target: r, type: "touchcancel", listener: o, options: { passive: !0 } }
    ];
    this.addTemporaryEvents(a), e.dragStartPixels === 0 && this.onCommonMove(i, this.touchStart, e.eElement);
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(e, t) {
    const i = t;
    if (e.skipMouseEvent && e.skipMouseEvent(t) || i._alreadyProcessedByDragService || (i._alreadyProcessedByDragService = !0, t.button !== 0))
      return;
    this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = !1, this.mouseStartEvent = t, this.startTarget = t.target;
    const s = (d) => this.onMouseMove(d, e.eElement), o = (d) => this.onMouseUp(d, e.eElement), n = (d) => d.preventDefault(), r = (d) => {
      d.key === P.ESCAPE && this.cancelDrag(e.eElement);
    }, a = wo(this.beans), l = [
      { target: a, type: "mousemove", listener: s },
      { target: a, type: "mouseup", listener: o },
      { target: a, type: "contextmenu", listener: n },
      { target: a, type: "keydown", listener: r }
    ];
    this.addTemporaryEvents(l), e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement);
  }
  addTemporaryEvents(e) {
    e.forEach((t) => {
      const { target: i, type: s, listener: o, options: n } = t;
      i.addEventListener(s, o, n);
    }), this.dragEndFunctions.push(() => {
      e.forEach((t) => {
        const { target: i, type: s, listener: o, options: n } = t;
        i.removeEventListener(s, o, n);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(e, t) {
    const { dragStartPixels: i } = this.currentDragParams, s = H(i) ? i : 4;
    return Bh(e, t, s);
  }
  getFirstActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  onCommonMove(e, t, i) {
    var s;
    if (!this.dragging) {
      if (this.isEventNearStartEvent(e, t))
        return;
      if (this.dragging = !0, this.eventSvc.dispatchEvent({
        type: "dragStarted",
        target: i
      }), this.currentDragParams.onDragStart(t), !this.currentDragParams) {
        this.dragging = !1;
        return;
      }
      this.currentDragParams.onDragging(t);
    }
    (s = this.currentDragParams) == null || s.onDragging(e);
  }
  onTouchMove(e, t) {
    const i = this.getFirstActiveTouch(e.touches);
    i && this.onCommonMove(i, this.touchStart, t);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(e, t) {
    var i;
    hi() && ((i = Ee(this.beans).getSelection()) == null || i.removeAllRanges()), this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t);
  }
  shouldPreventMouseEvent(e) {
    const t = e.type === "mousemove", i = (s) => {
      const o = s.target, n = o == null ? void 0 : o.tagName.toLocaleLowerCase();
      return !!(n != null && n.match("^a$|textarea|input|select|button"));
    };
    return t && e.cancelable && Ro(this.beans, e) && !i(e);
  }
  onTouchUp(e, t) {
    let i = this.getFirstActiveTouch(e.changedTouches);
    i || (i = this.touchLastTime), this.onUpCommon(i, t);
  }
  onMouseUp(e, t) {
    this.onUpCommon(e, t);
  }
  onUpCommon(e, t) {
    this.dragging && (this.dragging = !1, this.currentDragParams.onDragStop(e), this.eventSvc.dispatchEvent({
      type: "dragStopped",
      target: t
    })), this.resetDragProperties();
  }
  cancelDrag(e) {
    var t, i;
    this.eventSvc.dispatchEvent({
      type: "dragCancelled",
      target: e
    }), (i = (t = this.currentDragParams) == null ? void 0 : t.onDragCancel) == null || i.call(t), this.resetDragProperties();
  }
  resetDragProperties() {
    this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null;
    const { dragEndFunctions: e } = this;
    e.forEach((t) => t()), e.length = 0;
  }
}, mb = class extends At {
  constructor() {
    super(...arguments), this.beanName = "dragAndDrop", this.dragSourceAndParamsList = [], this.dragItem = null, this.lastMouseEvent = null, this.lastDraggingEvent = null, this.dragSource = null, this.dragImageParent = null, this.dragImageCompPromise = null, this.dragImageComp = null, this.dragImageLastIcon = void 0, this.dragImageLastLabel = void 0, this.dropTargets = [], this.lastDropTarget = null;
  }
  addDragSource(e, t = !1) {
    const i = {
      dragSource: e,
      eElement: e.eElement,
      dragStartPixels: e.dragStartPixels,
      onDragStart: (s) => this.onDragStart(e, s),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragCancel: this.onDragCancel.bind(this),
      includeTouch: t
    };
    this.dragSourceAndParamsList.push(i), this.beans.dragSvc.addDragSource(i);
  }
  setDragImageCompIcon(e, t = !1) {
    const i = this.dragImageComp;
    i && (t || this.dragImageLastIcon !== e) && (this.dragImageLastIcon = e, i.setIcon(e, t));
  }
  removeDragSource(e) {
    var o;
    const { dragSourceAndParamsList: t, beans: i } = this, s = t.find((n) => n.dragSource === e);
    s && ((o = i.dragSvc) == null || o.removeDragSource(s), tt(t, s));
  }
  destroy() {
    const { dragSourceAndParamsList: e, dropTargets: t, beans: i } = this, s = i.dragSvc;
    for (const o of e)
      s == null || s.removeDragSource(o);
    e.length = 0, t.length = 0, this.clearDragAndDropProperties(), super.destroy();
  }
  nudge() {
    const e = this.lastMouseEvent;
    e && this.onDragging(e, !0);
  }
  onDragStart(e, t) {
    var i;
    this.lastMouseEvent = t, this.dragSource = e, this.dragItem = e.getDragItem(), (i = e.onDragStarted) == null || i.call(e), this.createAndUpdateDragImageComp(e);
  }
  onDragStop(e) {
    var s, o;
    const { dragSource: t, lastDropTarget: i } = this;
    if ((s = t == null ? void 0 : t.onDragStopped) == null || s.call(t), i) {
      const n = this.dropTargetEvent(i, e, !1);
      (o = i.onDragStop) == null || o.call(i, n);
    }
    this.clearDragAndDropProperties();
  }
  onDragCancel() {
    var s, o;
    const { dragSource: e, lastDropTarget: t, lastMouseEvent: i } = this;
    if ((s = e == null ? void 0 : e.onDragCancelled) == null || s.call(e), t && i) {
      const n = this.dropTargetEvent(t, i, !1);
      (o = t.onDragCancel) == null || o.call(t, n);
    }
    this.clearDragAndDropProperties();
  }
  onDragging(e, t = !1) {
    var a, l, d;
    this.positionDragImageComp(e);
    const i = this.findCurrentDropTarget(e), { lastDropTarget: s, dragSource: o, dragItem: n } = this;
    let r = !1;
    if (i !== s) {
      if (r = !0, s) {
        const c = this.dropTargetEvent(s, e, t);
        (a = s.onDragLeave) == null || a.call(s, c);
      }
      if (s !== null && !i ? this.handleExit(o, n) : s === null && i && this.handleEnter(o, n), i) {
        const c = this.dropTargetEvent(i, e, t);
        (l = i.onDragEnter) == null || l.call(i, c);
      }
      this.lastDropTarget = i;
    } else if (i) {
      const c = this.dropTargetEvent(i, e, t);
      (d = i.onDragging) == null || d.call(i, c), c != null && c.changed && (r = !0);
    }
    this.lastMouseEvent = e, r && this.updateDragImageComp();
  }
  clearDragAndDropProperties() {
    this.removeDragImageComp(this.dragImageComp), this.dragImageCompPromise = null, this.dragImageParent = null, this.dragImageLastIcon = void 0, this.dragImageLastLabel = void 0, this.lastMouseEvent = null, this.lastDraggingEvent = null, this.lastDropTarget = null, this.dragItem = null, this.dragSource = null;
  }
  getAllContainersFromDropTarget(e) {
    const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null, i = [[e.getContainer()]];
    return t ? i.concat(t) : i;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(e, t) {
    const i = this.getAllContainersFromDropTarget(t);
    let s = !1;
    const o = (a, l) => {
      for (const d of l) {
        const { width: c, height: u, left: h, right: g, top: p, bottom: f } = d.getBoundingClientRect();
        if (c === 0 || u === 0)
          return !1;
        const m = a.clientX >= h && a.clientX < g, C = a.clientY >= p && a.clientY < f;
        if (!m || !C)
          return !1;
      }
      return !0;
    };
    for (const a of i)
      if (o(e, a)) {
        s = !0;
        break;
      }
    const { eElement: n, type: r } = this.dragSource;
    return t.targetContainsSource && !t.getContainer().contains(n) ? !1 : s && t.isInterestedIn(r, n);
  }
  findCurrentDropTarget(e) {
    const t = this.dropTargets.filter((n) => this.isMouseOnDropTarget(e, n)), i = t.length;
    if (i === 0)
      return null;
    if (i === 1)
      return t[0];
    const o = wo(this.beans).elementsFromPoint(e.clientX, e.clientY);
    for (const n of o)
      for (const r of t)
        if (this.getAllContainersFromDropTarget(r).flatMap((l) => l).indexOf(n) !== -1)
          return r;
    return null;
  }
  addDropTarget(e) {
    this.dropTargets.push(e);
  }
  removeDropTarget(e) {
    this.dropTargets = this.dropTargets.filter((t) => t.getContainer() !== e.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((e) => e.external);
  }
  findExternalZone(e) {
    return this.dropTargets.find((t) => t.external && t.getContainer() === e) || null;
  }
  dropTargetEvent(e, t, i) {
    const { dragSource: s, dragItem: o, lastDraggingEvent: n, lastMouseEvent: r } = this, a = e.getContainer(), l = a.getBoundingClientRect(), { clientX: d, clientY: c } = t, u = d - ((r == null ? void 0 : r.clientX) || 0), h = c - ((r == null ? void 0 : r.clientY) || 0), g = this.createEvent({
      event: t,
      x: d - l.left,
      // relative x
      y: c - l.top,
      // relative y
      vDirection: h > 0 ? "down" : h < 0 ? "up" : null,
      hDirection: u < 0 ? "left" : u > 0 ? "right" : null,
      dragSource: s,
      fromNudge: i,
      dragItem: o,
      dropZoneTarget: a,
      dropTarget: (n == null ? void 0 : n.dropTarget) ?? null,
      // updated by rowDragFeature
      changed: !!(n != null && n.changed)
    });
    return this.lastDraggingEvent = g, g;
  }
  positionDragImageComp(e) {
    var i;
    const t = (i = this.dragImageComp) == null ? void 0 : i.getGui();
    t && wC(t, e, this.beans);
  }
  removeDragImageComp(e) {
    var t;
    if (this.dragImageComp === e && (this.dragImageComp = null), e) {
      const i = e.getGui();
      (t = this.dragImageParent) == null || t.removeChild(i), this.destroyBean(e);
    }
  }
  createAndUpdateDragImageComp(e) {
    const t = this.createDragImageComp(e) ?? null;
    this.dragImageCompPromise = t, t == null || t.then((i) => {
      if (t !== this.dragImageCompPromise || !this.lastMouseEvent || !this.isAlive()) {
        this.destroyBean(i);
        return;
      }
      this.dragImageCompPromise = null, this.dragImageLastIcon = void 0, this.dragImageLastLabel = void 0;
      const s = this.dragImageComp;
      s !== i && (this.dragImageComp = i, this.removeDragImageComp(s)), i && (this.appendDragImageComp(i), this.updateDragImageComp());
    });
  }
  appendDragImageComp(e) {
    const t = e.getGui(), i = t.style;
    i.setProperty("position", "absolute"), i.setProperty("z-index", "9999"), this.gos.setInstanceDomData(t), this.beans.environment.applyThemeClasses(t), i.top = "20px", i.left = "20px";
    const s = Rl(this.beans);
    this.dragImageParent = s, s ? s.appendChild(t) : this.warnNoBody();
  }
  updateDragImageComp() {
    var r;
    const { dragImageComp: e, dragSource: t, lastDropTarget: i, lastDraggingEvent: s, dragImageLastLabel: o } = this;
    if (!e)
      return;
    this.setDragImageCompIcon(((r = i == null ? void 0 : i.getIconName) == null ? void 0 : r.call(i, s)) ?? null);
    let n = t == null ? void 0 : t.dragItemName;
    typeof n == "function" && (n = n(s)), n || (n = ""), o !== n && (this.dragImageLastLabel = n, e.setLabel(n));
  }
}, Cb = class extends mb {
  createEvent(e) {
    return W(this.gos, e);
  }
  createDragImageComp(e) {
    const { gos: t, beans: i } = this, s = Wv(
      i.userCompFactory,
      W(t, {
        dragSource: e
      })
    );
    return s == null ? void 0 : s.newAgStackInstance();
  }
  handleEnter(e, t) {
    var i;
    (i = e == null ? void 0 : e.onGridEnter) == null || i.call(e, t);
  }
  handleExit(e, t) {
    var i;
    (i = e == null ? void 0 : e.onGridExit) == null || i.call(e, t);
  }
  warnNoBody() {
    I(54);
  }
  isDropZoneWithinThisGrid(e) {
    return this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody.contains(e.dropZoneTarget);
  }
  registerGridDropTarget(e, t) {
    const i = {
      getContainer: e,
      isInterestedIn: (s) => s === 1 || s === 0,
      getIconName: () => "notAllowed"
    };
    this.addDropTarget(i), t.addDestroyFunc(() => this.removeDropTarget(i));
  }
};
function Hg(e, t) {
  return e + "_" + t;
}
function be(e) {
  return e instanceof Eo;
}
var Eo = class extends E {
  constructor(e, t, i, s) {
    super(), this.providedColumnGroup = e, this.groupId = t, this.partId = i, this.pinned = s, this.isColumn = !1, this.displayedChildren = [], this.autoHeaderHeight = null, this.parent = null, this.colIdSanitised = to(this.getUniqueId());
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null, this.children = null, this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  getUniqueId() {
    return Hg(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const e = this.getProvidedColumnGroup().getLeafColumns();
    return !e || e.length === 0 ? !1 : e.every((t) => t.isMoving());
  }
  checkLeft() {
    if (this.displayedChildren.forEach((e) => {
      be(e) && e.checkLeft();
    }), this.displayedChildren.length > 0)
      if (this.gos.get("enableRtl")) {
        const t = se(this.displayedChildren).getLeft();
        this.setLeft(t);
      } else {
        const e = this.displayedChildren[0].getLeft();
        this.setLeft(e);
      }
    else
      this.setLeft(null);
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(e) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchLocalEvent({ type: "leftChanged" }));
  }
  getPinned() {
    return this.pinned;
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  getActualWidth() {
    var t;
    let e = 0;
    return (t = this.displayedChildren) == null || t.forEach((i) => {
      e += i.getActualWidth();
    }), e;
  }
  isResizable() {
    if (!this.displayedChildren)
      return !1;
    let e = !1;
    return this.displayedChildren.forEach((t) => {
      t.isResizable() && (e = !0);
    }), e;
  }
  getMinWidth() {
    let e = 0;
    return this.displayedChildren.forEach((t) => {
      e += t.getMinWidth();
    }), e;
  }
  addChild(e) {
    this.children || (this.children = []), this.children.push(e);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  getDisplayedLeafColumns() {
    const e = [];
    return this.addDisplayedLeafColumns(e), e;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(e) {
    this.providedColumnGroup.setExpanded(e);
  }
  isAutoHeaderHeight() {
    var e;
    return !!((e = this.getColGroupDef()) != null && e.autoHeaderHeight);
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  addDisplayedLeafColumns(e) {
    this.displayedChildren.forEach((t) => {
      ai(t) ? e.push(t) : be(t) && t.addDisplayedLeafColumns(e);
    });
  }
  addLeafColumns(e) {
    this.children.forEach((t) => {
      ai(t) ? e.push(t) : be(t) && t.addLeafColumns(e);
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const e = this.getParent();
    return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let e = this;
    for (; e != null && e.isPadding(); )
      e = e.getParent();
    if (!(e ? e.getProvidedColumnGroup().isExpandable() : !1)) {
      this.displayedChildren = this.children, this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
      return;
    }
    this.children.forEach((i) => {
      var n;
      if (be(i) && !((n = i.displayedChildren) != null && n.length))
        return;
      switch (i.getColumnGroupShow()) {
        case "open":
          e.getProvidedColumnGroup().isExpanded() && this.displayedChildren.push(i);
          break;
        case "closed":
          e.getProvidedColumnGroup().isExpanded() || this.displayedChildren.push(i);
          break;
        default:
          this.displayedChildren.push(i);
          break;
      }
    }), this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
  }
}, $a = "row-group-", zl = "t-", Ul = "b-", vb = 0, Hi = class {
  constructor(e) {
    this.master = !1, this.detail = void 0, this.rowIndex = null, this.key = null, this.sourceRowIndex = -1, this.childrenMapped = null, this.treeParent = null, this.treeNodeFlags = 0, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = vb++, this.alreadyRendered = !1, this.hovered = !1, this.__selected = !1, this.beans = e;
  }
  /**
   * Replaces the data on the `rowNode`. When this method is called, the grid refreshes the entire rendered row if it is displayed.
   */
  setData(e) {
    this.setDataCommon(e, !1);
  }
  // similar to setRowData, however it is expected that the data is the same data item. this
  // is intended to be used with Redux type stores, where the whole data can be changed. we are
  // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
  // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
  // dataChanged event, refreshes the cells rather than rip them all out (so user can show transitions).
  /**
   * Updates the data on the `rowNode`. When this method is called, the grid refreshes the entire rendered row if it is displayed.
   */
  updateData(e) {
    this.setDataCommon(e, !0);
  }
  setDataCommon(e, t) {
    var a, l, d;
    const { valueCache: i, eventSvc: s } = this.beans, o = this.data;
    this.data = e, i == null || i.onDataChanged(), this.updateDataOnDetailNode(), this.resetQuickFilterAggregateText();
    const n = this.createDataChangedEvent(e, o, t);
    if ((a = this.__localEventService) == null || a.dispatchEvent(n), this.sibling) {
      this.sibling.data = e;
      const c = this.sibling.createDataChangedEvent(e, o, t);
      (l = this.sibling.__localEventService) == null || l.dispatchEvent(c);
    }
    s.dispatchEvent({ type: "rowNodeDataChanged", node: this });
    const r = this.pinnedSibling;
    r && (r.data = e, (d = r.__localEventService) == null || d.dispatchEvent(
      r.createDataChangedEvent(e, o, t)
    ), s.dispatchEvent({ type: "rowNodeDataChanged", node: r }));
  }
  // when we are doing master / detail, the detail node is lazy created, but then kept around.
  // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
  // in sync, otherwise expand/collapse of the detail would still show the old values.
  updateDataOnDetailNode() {
    this.detailNode && (this.detailNode.data = this.data);
  }
  createDataChangedEvent(e, t, i) {
    return {
      type: "dataChanged",
      node: this,
      oldData: t,
      newData: e,
      update: i
    };
  }
  getRowIndexString() {
    return this.rowIndex == null ? (Z(13), null) : this.rowPinned === "top" ? zl + this.rowIndex : this.rowPinned === "bottom" ? Ul + this.rowIndex : this.rowIndex.toString();
  }
  setDataAndId(e, t) {
    var r, a;
    const { selectionSvc: i } = this.beans, s = (r = i == null ? void 0 : i.createDaemonNode) == null ? void 0 : r.call(i, this), o = this.data;
    this.data = e, this.updateDataOnDetailNode(), this.setId(t), i && (i.updateRowSelectable(this), i.syncInRowNode(this, s));
    const n = this.createDataChangedEvent(e, o, !1);
    (a = this.__localEventService) == null || a.dispatchEvent(n);
  }
  setId(e) {
    var i;
    const t = ws(this.beans.gos);
    if (t)
      if (this.data) {
        const s = ((i = this.parent) == null ? void 0 : i.getRoute()) ?? [];
        this.id = t({
          data: this.data,
          parentKeys: s.length > 0 ? s : void 0,
          level: this.level,
          rowPinned: this.rowPinned
        }), this.id.startsWith($a) && Z(14, {
          groupPrefix: $a
        });
      } else
        this.id = void 0;
    else
      this.id = e;
  }
  setRowTop(e) {
    this.oldRowTop = this.rowTop, this.rowTop !== e && (this.rowTop = e, this.dispatchRowEvent("topChanged"), this.setDisplayed(e !== null));
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
  }
  setHovered(e) {
    this.hovered = e;
  }
  isHovered() {
    return this.hovered;
  }
  /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
  setRowHeight(e, t = !1) {
    this.rowHeight = e, this.rowHeightEstimated = t, this.dispatchRowEvent("heightChanged");
  }
  setExpanded(e, t, i) {
    var s;
    (s = this.beans.expansionSvc) == null || s.setExpanded(this, e, t, i);
  }
  /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid refreshes the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   * **Note**: This method defers to EditModule if available and batches the edit when `fullRow` or `batchEdit` is enabled.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */
  setDataValue(e, t, i) {
    const { colModel: s, valueSvc: o, gos: n, editSvc: r } = this.beans, a = typeof e != "string" ? e : s.getCol(e) ?? s.getColDefCol(e);
    if (!a)
      return !1;
    const l = o.getValueForDisplay(a, this, void 0, void 0, "api").value;
    if (n.get("readOnlyEdit")) {
      const {
        beans: { eventSvc: u },
        data: h,
        rowIndex: g,
        rowPinned: p
      } = this;
      return u.dispatchEvent({
        type: "cellEditRequest",
        event: null,
        rowIndex: g,
        rowPinned: p,
        column: a,
        colDef: a.colDef,
        data: h,
        node: this,
        oldValue: l,
        newValue: t,
        value: t,
        source: i
      }), !1;
    }
    if (r && !r.committing) {
      const u = r.setDataValue({ rowNode: this, column: a }, t, i);
      if (u != null)
        return u;
    }
    const d = o.setValue(this, a, t, i);
    this.dispatchCellChangedEvent(a, t, l);
    const c = this.pinnedSibling;
    return c && d && c.dispatchCellChangedEvent(a, t, l), d;
  }
  updateHasChildren() {
    let e = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    const { rowChildrenSvc: t } = this.beans;
    t && (e = t.getHasChildrenValue(this)), e !== this.__hasChildren && (this.__hasChildren = !!e, this.dispatchRowEvent("hasChildrenChanged"));
  }
  hasChildren() {
    return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
  }
  dispatchCellChangedEvent(e, t, i) {
    var o;
    const s = {
      type: "cellChanged",
      node: this,
      column: e,
      newValue: t,
      oldValue: i
    };
    (o = this.__localEventService) == null || o.dispatchEvent(s);
  }
  /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However, if you edit without using grid editing, you need to clear this string down for the row to be updated with the new values.
   * Otherwise, new values would not work with the `quickFilter`. */
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  /** Returns:
   * - `true` if the node can be expanded, i.e it is a group or master row.
   * - `false` if the node cannot be expanded
   */
  isExpandable() {
    var e;
    return ((e = this.beans.expansionSvc) == null ? void 0 : e.isExpandable(this)) ?? !1;
  }
  /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */
  isSelected() {
    return this.footer ? this.sibling.isSelected() : this.rowPinned && this.pinnedSibling ? this.pinnedSibling.isSelected() : this.__selected;
  }
  /** Perform a depth-first search of this node and its children. */
  depthFirstSearch(e) {
    var t;
    (t = this.childrenAfterGroup) == null || t.forEach((i) => i.depthFirstSearch(e)), e(this);
  }
  dispatchRowEvent(e) {
    var t;
    (t = this.__localEventService) == null || t.dispatchEvent({
      type: e,
      node: this
    });
  }
  /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` selects the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that appears in the `selectionChanged` event.
   */
  setSelected(e, t = !1, i = "api") {
    var s;
    (s = this.beans.selectionSvc) == null || s.setNodesSelected({
      nodes: [this],
      newValue: e,
      clearSelection: t,
      source: i
    });
  }
  /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */
  isRowPinned() {
    return !!this.rowPinned;
  }
  __addEventListener(e, t) {
    this.__localEventService || (this.__localEventService = new Li()), this.__localEventService.addEventListener(e, t);
  }
  __removeEventListener(e, t) {
    this.removeLocalListener(e, t);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  addEventListener(e, t) {
    var s, o, n, r;
    (s = this.beans.validation) == null || s.checkRowEvents(e), this.__localEventService || (this.__localEventService = new Li()), this.frameworkEventListenerService = (n = (o = this.beans.frameworkOverrides).createLocalEventListenerWrapper) == null ? void 0 : n.call(
      o,
      this.frameworkEventListenerService,
      this.__localEventService
    );
    const i = ((r = this.frameworkEventListenerService) == null ? void 0 : r.wrap(e, t)) ?? t;
    this.__localEventService.addEventListener(e, i);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  removeEventListener(e, t) {
    var s;
    const i = ((s = this.frameworkEventListenerService) == null ? void 0 : s.unwrap(e, t)) ?? t;
    this.removeLocalListener(e, i);
  }
  removeLocalListener(e, t) {
    var i, s;
    (i = this.__localEventService) == null || i.removeEventListener(e, t), (s = this.__localEventService) != null && s.noRegisteredListenersExist() && (this.__localEventService = null);
  }
  /**
   * @deprecated v32.2.0 Check `node.detail` then user provided callback `isFullWidthRow` instead.
   *
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */
  isFullWidthCell() {
    if (I(61), this.detail)
      return !0;
    const e = this.beans.gos.getCallback("isFullWidthRow");
    return e ? e({ rowNode: this }) : !1;
  }
  /**
   * Returns the route of keys to the row node. Returns undefined if the node has no key.
   */
  getRoute() {
    if (this.level === -1)
      return [];
    if (this.key == null)
      return;
    const e = [];
    let t = this;
    for (; t && t.key != null; )
      e.push(t.key), t = t.parent;
    return e.reverse();
  }
  setDisplayed(e) {
    this.displayed !== e && (this.displayed = e, this.dispatchRowEvent("displayedChanged"));
  }
  setRowIndex(e) {
    this.rowIndex !== e && (this.rowIndex = e, this.dispatchRowEvent("rowIndexChanged"));
  }
  setAllChildrenCount(e) {
    this.allChildrenCount !== e && (this.allChildrenCount = e, this.dispatchRowEvent("allChildrenCountChanged"));
  }
  setUiLevel(e) {
    this.uiLevel !== e && (this.uiLevel = e, this.dispatchRowEvent("uiLevelChanged"));
  }
  getFirstChild() {
    var e;
    return this.childStore ? this.childStore.getFirstNode() : ((e = this.childrenAfterSort) == null ? void 0 : e[0]) ?? null;
  }
};
function wb(e, t, i) {
  return W(t, {
    type: i,
    node: e,
    data: e.data,
    rowIndex: e.rowIndex,
    rowPinned: e.rowPinned
  });
}
var bb = /* @__PURE__ */ new Set(["__localEventService", "__objectId", "sticky", "__autoHeights", "__checkAutoHeightsDebounced", "childStore"]);
function yb(e, t) {
  const i = new Hi(t);
  return Object.keys(e).forEach((s) => {
    bb.has(s) || (i[s] = e[s]);
  }), i.oldRowTop = null, i;
}
var Bg = {
  agSetColumnFilter: "agSetColumnFilterHandler",
  agMultiColumnFilter: "agMultiColumnFilterHandler",
  agGroupColumnFilter: "agGroupColumnFilterHandler",
  agNumberColumnFilter: "agNumberColumnFilterHandler",
  agDateColumnFilter: "agDateColumnFilterHandler",
  agTextColumnFilter: "agTextColumnFilterHandler"
}, Sb = new Set(Object.values(Bg));
function qt(e, t) {
  const i = e.filterUi;
  if (!i)
    return null;
  if (i.created)
    return i.promise;
  if (t)
    return null;
  const s = i.create(i.refreshed), o = i;
  return o.created = !0, o.promise = s, s;
}
function Rb(e, t, i, s, o, n) {
  var r;
  return (r = t.refresh) == null || r.call(t, { ...i, model: s, source: n }), e().then((a) => {
    if (a) {
      const { filter: l, filterParams: d } = a;
      Gg(l, d, s, o, n);
    }
  });
}
function Gg(e, t, i, s, o) {
  var n;
  (n = e == null ? void 0 : e.refresh) == null || n.call(e, {
    ...t,
    model: i,
    state: s,
    source: o
  });
}
function Vg(e, t, i) {
  const s = e();
  s != null && s.created && s.promise.then((o) => {
    const n = t();
    Gg(o, s.filterParams, n, i() ?? { model: n }, "ui");
  });
}
function cc(e, t, i, s, o, n, r) {
  let a, l = !1, d;
  switch (e) {
    case "apply": {
      const c = s();
      d = (c == null ? void 0 : c.model) ?? null, r && (d = r(d)), a = {
        // keep the other UI state
        state: c == null ? void 0 : c.state,
        model: d
      }, l = !0;
      break;
    }
    case "clear": {
      a = {
        // wipe other UI state
        model: null
      };
      break;
    }
    case "reset": {
      a = {
        // wipe other UI state
        model: null
      }, l = !0, d = null;
      break;
    }
    case "cancel": {
      a = {
        // wipe other UI state
        model: i()
      };
      break;
    }
  }
  o(a), l ? n(d) : Vg(t, i, s);
}
function Re(e, t) {
  return e[t] ?? null;
}
function ye(e) {
  return Vo(e);
}
function xb(e) {
  return {
    tag: "div",
    cls: e
  };
}
var Fb = class extends te {
  constructor(e) {
    const { className: t = "ag-filter-apply-panel" } = e ?? {};
    super(xb(t)), this.listeners = [], this.validationMessage = null, this.className = t;
  }
  updateButtons(e, t) {
    const i = this.buttons;
    if (this.buttons = e, i === e)
      return;
    const s = this.getGui();
    Te(s);
    let o;
    this.destroyListeners();
    const n = document.createDocumentFragment(), r = this.className, a = ({ type: d, label: c }) => {
      const u = (C) => {
        this.dispatchLocalEvent({
          type: d,
          event: C
        });
      };
      ["apply", "clear", "reset", "cancel"].includes(d) || I(75);
      const h = d === "apply", p = ye({
        tag: "button",
        attrs: { type: h && t ? "submit" : "button" },
        ref: `${d}FilterButton`,
        cls: `ag-button ag-standard-button ${r}-button${h ? " " + r + "-apply-button" : ""}`,
        children: c
      });
      this.activateTabIndex([p]), h && (o = p);
      const f = (C) => {
        C.key === P.ENTER && (C.preventDefault(), u(C));
      }, m = this.listeners;
      p.addEventListener("click", u), m.push(() => p.removeEventListener("click", u)), p.addEventListener("keydown", f), m.push(() => p.removeEventListener("keydown", f)), n.append(p);
    };
    e.forEach((d) => a(d)), this.eApply = o;
    const l = this.validationTooltipFeature;
    o && !l ? this.validationTooltipFeature = this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.eApply,
        getLocation: () => "advancedFilter",
        getTooltipShowDelayOverride: () => 1e3
      })
    ) : !o && l && (this.validationTooltipFeature = this.destroyBean(l)), s.append(n);
  }
  getApplyButton() {
    return this.eApply;
  }
  updateValidity(e, t = null) {
    var s;
    const i = this.eApply;
    i && (yo(i, e === !1), this.validationMessage = t ?? null, (s = this.validationTooltipFeature) == null || s.setTooltipAndRefresh(this.validationMessage));
  }
  destroyListeners() {
    this.listeners.forEach((e) => e()), this.listeners = [];
  }
  destroy() {
    this.destroyListeners(), super.destroy();
  }
}, Pb = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose one",
  equals: "Equals",
  notEqual: "Does not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "Between",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equal to",
  greaterThanOrEqual: "Greater than or equal to",
  contains: "Contains",
  notContains: "Does not contain",
  startsWith: "Begins with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  before: "Before",
  after: "After",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd",
  filterSummaryInactive: "is (All)",
  filterSummaryContains: "contains",
  filterSummaryNotContains: "does not contain",
  filterSummaryTextEquals: "equals",
  filterSummaryTextNotEqual: "does not equal",
  filterSummaryStartsWith: "begins with",
  filterSummaryEndsWith: "ends with",
  filterSummaryBlank: "is blank",
  filterSummaryNotBlank: "is not blank",
  filterSummaryEquals: "=",
  filterSummaryNotEqual: "!=",
  filterSummaryGreaterThan: ">",
  filterSummaryGreaterThanOrEqual: ">=",
  filterSummaryLessThan: "<",
  filterSummaryLessThanOrEqual: "<=",
  filterSummaryInRange: "between",
  filterSummaryInRangeValues: (e) => `(${e[0]}, ${e[1]})`,
  filterSummaryTextQuote: (e) => `"${e[0]}"`
};
function ei(e, t, i) {
  return yC(e, Pb, t, i);
}
function $l(e, t) {
  const { debounceMs: i } = e;
  return yr(e) ? (i != null && I(71), 0) : i ?? t;
}
function yr(e) {
  var t;
  return (((t = e.buttons) == null ? void 0 : t.indexOf("apply")) ?? -1) >= 0;
}
var Eb = class extends te {
  constructor(e, t, i, s, o, n) {
    super(), this.column = e, this.wrapper = t, this.eventParent = i, this.updateModel = s, this.isGlobalButtons = o, this.enableGlobalButtonCheck = n, this.hidePopup = null, this.applyActive = !1;
  }
  postConstruct() {
    const { comp: e, params: t } = this.wrapper, i = t, s = i.useForm, o = s ? "form" : "div";
    this.setTemplate({
      tag: o,
      cls: "ag-filter-wrapper"
    }), s && this.addManagedElementListeners(this.getGui(), {
      submit: (n) => {
        n == null || n.preventDefault();
      },
      keydown: this.handleKeyDown.bind(this)
    }), this.appendChild(e.getGui()), this.params = i, this.resetButtonsPanel(i), this.addManagedListeners(this.eventParent, {
      filterParamsChanged: ({ column: n, params: r }) => {
        n === this.column && this.resetButtonsPanel(r, this.params);
      },
      filterStateChanged: ({ column: n, state: r }) => {
        var a;
        n === this.column && ((a = this.eButtons) == null || a.updateValidity(r.valid !== !1));
      },
      filterAction: ({ column: n, action: r, event: a }) => {
        n === this.column && this.afterAction(r, a);
      },
      ...this.enableGlobalButtonCheck ? {
        filterGlobalButtons: ({ isGlobal: n }) => {
          if (n !== this.isGlobalButtons) {
            this.isGlobalButtons = n;
            const r = this.params;
            this.resetButtonsPanel(r, r, !0);
          }
        }
      } : void 0
    });
  }
  afterGuiAttached(e) {
    e && (this.hidePopup = e.hidePopup);
  }
  resetButtonsPanel(e, t, i) {
    const { buttons: s, readOnly: o } = t ?? {}, { buttons: n, readOnly: r, useForm: a } = e;
    if (!i && o === r && vo(s, n))
      return;
    const l = n && n.length > 0 && !e.readOnly && !this.isGlobalButtons;
    let d = this.eButtons;
    if (l) {
      const c = n.map((u) => {
        const h = `${u}Filter`;
        return { type: u, label: ei(this, h) };
      });
      if (this.applyActive = yr(this.params), !d) {
        d = this.createBean(new Fb()), this.appendChild(d.getGui());
        const u = this.column, h = (g) => ({ event: p }) => {
          this.updateModel(u, g), this.afterAction(g, p);
        };
        d == null || d.addManagedListeners(d, {
          apply: h("apply"),
          clear: h("clear"),
          reset: h("reset"),
          cancel: h("cancel")
        }), this.eButtons = d;
      }
      d.updateButtons(c, a);
    } else
      this.applyActive = !1, d && (dt(d.getGui()), this.eButtons = this.destroyBean(d));
  }
  close(e) {
    const t = this.hidePopup;
    if (!t)
      return;
    const i = e, s = i && i.key;
    let o;
    (s === P.ENTER || s === P.SPACE) && (o = { keyboardEvent: i }), t(o), this.hidePopup = null;
  }
  afterAction(e, t) {
    const { params: i, applyActive: s } = this, o = i == null ? void 0 : i.closeOnApply;
    switch (e) {
      case "apply": {
        t == null || t.preventDefault(), o && s && this.close(t);
        break;
      }
      case "reset": {
        o && s && this.close();
        break;
      }
      case "cancel": {
        o && this.close(t);
        break;
      }
    }
  }
  handleKeyDown(e) {
    !e.defaultPrevented && e.key === P.ENTER && this.applyActive && (this.updateModel(this.column, "apply"), this.afterAction("apply", e));
  }
  destroy() {
    this.hidePopup = null, this.eButtons = this.destroyBean(this.eButtons);
  }
}, Db = { tag: "div", cls: "ag-filter" }, Tb = class extends te {
  constructor(e, t, i) {
    super(Db), this.column = e, this.source = t, this.enableGlobalButtonCheck = i, this.wrapper = null;
  }
  postConstruct() {
    var e;
    (e = this.beans.colFilter) == null || e.activeFilterComps.add(this), this.createFilter(!0), this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
  }
  hasFilter() {
    return this.wrapper != null;
  }
  getFilter() {
    var e;
    return ((e = this.wrapper) == null ? void 0 : e.then((t) => t.comp)) ?? null;
  }
  afterInit() {
    var e;
    return ((e = this.wrapper) == null ? void 0 : e.then(() => {
    })) ?? fe.resolve();
  }
  afterGuiAttached(e) {
    var t;
    this.afterGuiAttachedParams = e, (t = this.wrapper) == null || t.then((i) => {
      var s, o, n;
      (s = this.comp) == null || s.afterGuiAttached(e), (n = (o = i == null ? void 0 : i.comp) == null ? void 0 : o.afterGuiAttached) == null || n.call(o, e);
    });
  }
  afterGuiDetached() {
    var e;
    (e = this.wrapper) == null || e.then((t) => {
      var i, s;
      (s = (i = t == null ? void 0 : t.comp) == null ? void 0 : i.afterGuiDetached) == null || s.call(i);
    });
  }
  createFilter(e) {
    const {
      column: t,
      source: i,
      beans: { colFilter: s }
    } = this, o = s.getFilterUiForDisplay(t) ?? null;
    this.wrapper = o, o == null || o.then((n) => {
      var d;
      if (!n)
        return;
      const { isHandler: r, comp: a } = n;
      let l;
      if (r) {
        const c = !!this.enableGlobalButtonCheck, u = this.createBean(
          new Eb(
            t,
            n,
            s,
            s.updateModel.bind(s),
            c && s.isGlobalButtons,
            c
          )
        );
        this.comp = u, l = u.getGui();
      } else
        l = a.getGui(), H(l) || I(69, { guiFromFilter: l });
      this.appendChild(l), e ? this.eventSvc.dispatchEvent({
        type: "filterOpened",
        column: t,
        source: i,
        eGui: this.getGui()
      }) : (d = a.afterGuiAttached) == null || d.call(a, this.afterGuiAttachedParams);
    });
  }
  onFilterDestroyed(e) {
    const { source: t, column: i } = e;
    (t === "api" || t === "paramsUpdated") && i.getId() === this.column.getId() && this.beans.colModel.getColDefCol(this.column) && (Te(this.getGui()), this.comp = this.destroyBean(this.comp), this.createFilter());
  }
  destroy() {
    var e;
    (e = this.beans.colFilter) == null || e.activeFilterComps.delete(this), this.eventSvc.dispatchEvent({
      type: "filterClosed",
      column: this.column
    }), this.wrapper = null, this.comp = this.destroyBean(this.comp), this.afterGuiAttachedParams = void 0, super.destroy();
  }
}, uc = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, hc = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
];
function Mb(e, t) {
  return e == null ? -1 : t == null ? 1 : parseFloat(e) - parseFloat(t);
}
function gc(e) {
  return e instanceof Date && !isNaN(e.getTime());
}
var Ka = {
  number: () => {
  },
  boolean: () => ({
    maxNumConditions: 1,
    debounceMs: 0,
    filterOptions: [
      "empty",
      {
        displayKey: "true",
        displayName: "True",
        predicate: (e, t) => t,
        numberOfInputs: 0
      },
      {
        displayKey: "false",
        displayName: "False",
        predicate: (e, t) => t === !1,
        numberOfInputs: 0
      }
    ]
  }),
  date: () => ({ isValidDate: gc }),
  dateString: ({ dataTypeDefinition: e }) => ({
    comparator: (t, i) => {
      const s = e.dateParser(i);
      return i == null || s < t ? -1 : s > t ? 1 : 0;
    },
    isValidDate: (t) => typeof t == "string" && gc(e.dateParser(t))
  }),
  dateTime: (e) => Ka.date(e),
  dateTimeString: (e) => Ka.dateString(e),
  object: () => {
  },
  text: () => {
  }
}, ja = {
  number: () => ({ comparator: Mb }),
  boolean: ({ t: e }) => ({
    valueFormatter: (t) => H(t.value) ? e(String(t.value), t.value ? "True" : "False") : e("blanks", "(Blanks)")
  }),
  date: ({ formatValue: e, t }) => ({
    valueFormatter: (i) => {
      const s = e(i);
      return H(s) ? s : t("blanks", "(Blanks)");
    },
    treeList: !0,
    treeListFormatter: (i, s) => {
      if (i === "NaN")
        return t("invalidDate", "Invalid Date");
      if (s === 1 && i != null) {
        const o = hc[Number(i) - 1];
        return t(o, uc[o]);
      }
      return i ?? t("blanks", "(Blanks)");
    },
    treeListPathGetter: (i) => Zo(i, !1)
  }),
  dateString: ({ formatValue: e, dataTypeDefinition: t, t: i }) => ({
    valueFormatter: (s) => {
      const o = e(s);
      return H(o) ? o : i("blanks", "(Blanks)");
    },
    treeList: !0,
    treeListPathGetter: (s) => Zo(t.dateParser(s ?? void 0), !1),
    treeListFormatter: (s, o) => {
      if (o === 1 && s != null) {
        const n = hc[Number(s) - 1];
        return i(n, uc[n]);
      }
      return s ?? i("blanks", "(Blanks)");
    }
  }),
  dateTime: (e) => {
    const t = ja.date(e);
    return t.treeListPathGetter = Zo, t;
  },
  dateTimeString(e) {
    const t = e.dataTypeDefinition.dateParser, i = ja.dateString(e);
    return i.treeListPathGetter = (s) => Zo(t(s ?? void 0)), i;
  },
  object: ({ formatValue: e, t }) => ({
    valueFormatter: (i) => {
      const s = e(i);
      return H(s) ? s : t("blanks", "(Blanks)");
    }
  }),
  text: () => {
  }
};
function Ab(e, t, i, s, o, n, r) {
  let a = t, l = i;
  const d = e === "agSetColumnFilter";
  !l && s.baseDataType === "object" && !d && (l = ({ column: g, node: p }) => o({ column: g, node: p, value: n.valueSvc.getValue(g, p) }));
  const u = (d ? ja : Ka)[s.baseDataType], h = u({ dataTypeDefinition: s, formatValue: o, t: r });
  return a = typeof t == "object" ? {
    ...h,
    ...t
  } : h, { filterParams: a, filterValueGetter: l };
}
var Ib = {
  boolean: "agTextColumnFilter",
  date: "agDateColumnFilter",
  dateString: "agDateColumnFilter",
  dateTime: "agDateColumnFilter",
  dateTimeString: "agDateColumnFilter",
  number: "agNumberColumnFilter",
  object: "agTextColumnFilter",
  text: "agTextColumnFilter"
}, kb = {
  boolean: "agTextColumnFloatingFilter",
  date: "agDateColumnFloatingFilter",
  dateString: "agDateColumnFloatingFilter",
  dateTime: "agDateColumnFloatingFilter",
  dateTimeString: "agDateColumnFloatingFilter",
  number: "agNumberColumnFloatingFilter",
  object: "agTextColumnFloatingFilter",
  text: "agTextColumnFloatingFilter"
};
function Lb(e, t = !1) {
  return (t ? kb : Ib)[e ?? "text"];
}
var Ng = "ag-resizer-wrapper", Yt = (e, t) => ({
  tag: "div",
  ref: `${e}Resizer`,
  cls: `ag-resizer ag-resizer-${t}`
}), Ob = {
  tag: "div",
  cls: Ng,
  children: [
    Yt("eTopLeft", "topLeft"),
    Yt("eTop", "top"),
    Yt("eTopRight", "topRight"),
    Yt("eRight", "right"),
    Yt("eBottomRight", "bottomRight"),
    Yt("eBottom", "bottom"),
    Yt("eBottomLeft", "bottomLeft"),
    Yt("eLeft", "left")
  ]
}, _b = class extends E {
  constructor(e, t) {
    super(), this.element = e, this.dragStartPosition = {
      x: 0,
      y: 0
    }, this.position = {
      x: 0,
      y: 0
    }, this.lastSize = {
      width: -1,
      height: -1
    }, this.positioned = !1, this.resizersAdded = !1, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = !1, this.isMoving = !1, this.resizable = {}, this.movable = !1, this.currentResizer = null, this.config = Object.assign({}, { popup: !1 }, t);
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc, this.dragSvc = e.dragSvc;
  }
  center(e) {
    const { clientHeight: t, clientWidth: i } = this.offsetParent, s = i / 2 - this.getWidth() / 2, o = t / 2 - this.getHeight() / 2;
    this.offsetElement(s, o, e);
  }
  initialisePosition(e) {
    if (this.positioned)
      return;
    const { centered: t, forcePopupParentAsOffsetParent: i, minWidth: s, width: o, minHeight: n, height: r, x: a, y: l } = this.config;
    this.offsetParent || this.setOffsetParent();
    let d = 0, c = 0;
    const u = Mt(this.element);
    if (u) {
      const h = this.findBoundaryElement(), g = window.getComputedStyle(h);
      if (g.minWidth != null) {
        const p = h.offsetWidth - this.element.offsetWidth;
        c = parseInt(g.minWidth, 10) - p;
      }
      if (g.minHeight != null) {
        const p = h.offsetHeight - this.element.offsetHeight;
        d = parseInt(g.minHeight, 10) - p;
      }
    }
    if (this.minHeight = n || d, this.minWidth = s || c, o && this.setWidth(o), r && this.setHeight(r), (!o || !r) && this.refreshSize(), t)
      this.center(e);
    else if (a || l)
      this.offsetElement(a, l, e);
    else if (u && i) {
      let h = this.boundaryEl, g = !0;
      if (h || (h = this.findBoundaryElement(), g = !1), h) {
        const p = parseFloat(h.style.top), f = parseFloat(h.style.left);
        g ? this.offsetElement(isNaN(f) ? 0 : f, isNaN(p) ? 0 : p, e) : this.setPosition(f, p);
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(e, t) {
    var s, o;
    if (!this.config.popup || e === this.movable)
      return;
    this.movable = e;
    const i = this.moveElementDragListener || {
      eElement: t,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    e ? ((s = this.dragSvc) == null || s.addDragSource(i), this.moveElementDragListener = i) : ((o = this.dragSvc) == null || o.removeDragSource(i), this.moveElementDragListener = void 0);
  }
  setResizable(e) {
    if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), typeof e == "boolean") {
      if (e === !1)
        return;
      e = {
        topLeft: e,
        top: e,
        topRight: e,
        right: e,
        bottomRight: e,
        bottom: e,
        bottomLeft: e,
        left: e
      };
    }
    Object.keys(e).forEach((t) => {
      var r;
      const s = !!e[t], o = this.getResizerElement(t), n = {
        dragStartPixels: 0,
        eElement: o,
        onDragStart: (a) => this.onResizeStart(a, t),
        onDragging: this.onResize.bind(this),
        onDragStop: (a) => this.onResizeEnd(a, t)
      };
      (s || !this.isAlive() && !s) && (s ? ((r = this.dragSvc) == null || r.addDragSource(n), this.resizeListeners.push(n), o.style.pointerEvents = "all") : o.style.pointerEvents = "none", this.resizable[t] = s);
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height: e, width: t } = this.lastSize;
    t !== -1 && (this.element.style.width = `${t}px`), e !== -1 && (this.element.style.height = `${e}px`);
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(e) {
    const { popup: t } = this.config, i = this.element;
    let s = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      io(i, e), e = Mh(i), s = !0;
    else if (e = Math.max(this.minHeight, e), this.positioned) {
      const o = this.getAvailableHeight();
      o && e > o && (e = o);
    }
    this.getHeight() !== e && (s ? (i.style.maxHeight = "unset", i.style.minHeight = "unset") : t ? io(i, e) : (i.style.height = `${e}px`, i.style.flex = "0 0 auto", this.lastSize.height = typeof e == "number" ? e : parseFloat(e)));
  }
  getAvailableHeight() {
    const { popup: e, forcePopupParentAsOffsetParent: t } = this.config;
    this.positioned || this.initialisePosition();
    const { clientHeight: i } = this.offsetParent;
    if (!i)
      return null;
    const s = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), n = e ? this.position.y : s.top, r = e ? 0 : o.top;
    let a = 0;
    if (t) {
      const d = this.element.parentElement;
      if (d) {
        const { bottom: c } = d.getBoundingClientRect();
        a = c - s.bottom;
      }
    }
    return i + r - n - a;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(e) {
    const t = this.element, { popup: i } = this.config;
    let s = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      Ft(t, e), e = Vn(t), s = !0;
    else if (this.positioned) {
      e = Math.max(this.minWidth, e);
      const { clientWidth: o } = this.offsetParent, n = i ? this.position.x : this.element.getBoundingClientRect().left;
      o && e + n > o && (e = o - n);
    }
    this.getWidth() !== e && (s ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? Ft(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = typeof e == "number" ? e : parseFloat(e)));
  }
  offsetElement(e = 0, t = 0, i) {
    var n;
    const { forcePopupParentAsOffsetParent: s } = this.config, o = s ? this.boundaryEl : this.element;
    o && ((n = this.popupSvc) == null || n.positionPopup({
      ePopup: o,
      keepWithinBounds: !0,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x: e, y: t }),
      postProcessCallback: i
    }), this.setPosition(parseFloat(o.style.left), parseFloat(o.style.top)));
  }
  constrainSizeToAvailableHeight(e) {
    var i, s;
    if (!this.config.forcePopupParentAsOffsetParent)
      return;
    const t = () => {
      const o = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${o}px`);
    };
    e && this.popupSvc ? ((i = this.resizeObserverSubscriber) == null || i.call(this), this.resizeObserverSubscriber = di(
      this.beans,
      (s = this.popupSvc) == null ? void 0 : s.getPopupParent(),
      t
    )) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0));
  }
  setPosition(e, t) {
    this.position.x = e, this.position.y = t;
  }
  updateDragStartPosition(e, t) {
    this.dragStartPosition = { x: e, y: t };
  }
  calculateMouseMovement(e) {
    const { e: t, isLeft: i, isTop: s, anywhereWithin: o, topBuffer: n } = e, r = t.clientX - this.dragStartPosition.x, a = t.clientY - this.dragStartPosition.y, l = this.shouldSkipX(t, !!i, !!o, r) ? 0 : r, d = this.shouldSkipY(t, !!s, n, a) ? 0 : a;
    return { movementX: l, movementY: d };
  }
  shouldSkipX(e, t, i, s) {
    const o = this.element.getBoundingClientRect(), n = this.offsetParent.getBoundingClientRect(), r = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.x : o.left;
    let l = a <= 0 && n.left >= e.clientX || n.right <= e.clientX && n.right <= r.right;
    return l ? !0 : (t ? l = // skip if we are moving to the left and the cursor
    // is positioned to the right of the left side anchor
    s < 0 && e.clientX > a + n.left || // skip if we are moving to the right and the cursor
    // is positioned to the left of the dialog
    s > 0 && e.clientX < a + n.left : i ? l = s < 0 && e.clientX > r.right || s > 0 && e.clientX < a + n.left : l = // if the movement is bound to the right side of the dialog
    // we skip if we are moving to the left and the cursor
    // is to the right of the dialog
    s < 0 && e.clientX > r.right || // or skip if we are moving to the right and the cursor
    // is to the left of the right side anchor
    s > 0 && e.clientX < r.right, l);
  }
  shouldSkipY(e, t, i = 0, s) {
    const o = this.element.getBoundingClientRect(), n = this.offsetParent.getBoundingClientRect(), r = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.y : o.top;
    let l = a <= 0 && n.top >= e.clientY || n.bottom <= e.clientY && n.bottom <= r.bottom;
    return l ? !0 : (t ? l = // skip if we are moving to towards top and the cursor is
    // below the top anchor + topBuffer
    // note: topBuffer is used when moving the dialog using the title bar
    s < 0 && e.clientY > a + n.top + i || // skip if we are moving to the bottom and the cursor is
    // above the top anchor
    s > 0 && e.clientY < a + n.top : l = // skip if we are moving towards the top and the cursor
    // is below the bottom anchor
    s < 0 && e.clientY > r.bottom || // skip if we are moving towards the bottom and the cursor
    // is above the bottom anchor
    s > 0 && e.clientY < r.bottom, l);
  }
  createResizeMap() {
    const e = (t) => ({
      element: this.element.querySelector(`[data-ref=${t}Resizer]`)
    });
    this.resizerMap = {
      topLeft: e("eTopLeft"),
      top: e("eTop"),
      topRight: e("eTopRight"),
      right: e("eRight"),
      bottomRight: e("eBottomRight"),
      bottom: e("eBottom"),
      bottomLeft: e("eBottomLeft"),
      left: e("eLeft")
    };
  }
  addResizers() {
    if (this.resizersAdded)
      return;
    const e = this.element;
    e && (e.appendChild(ye(Ob)), this.createResizeMap(), this.resizersAdded = !0);
  }
  removeResizers() {
    this.resizerMap = void 0;
    const e = this.element.querySelector(`.${Ng}`);
    e && this.element.removeChild(e), this.resizersAdded = !1;
  }
  getResizerElement(e) {
    return this.resizerMap[e].element;
  }
  onResizeStart(e, t) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
      isTop: !!t.match(/top/i),
      isRight: !!t.match(/right/i),
      isBottom: !!t.match(/bottom/i),
      isLeft: !!t.match(/left/i)
    }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
    const { popup: i, forcePopupParentAsOffsetParent: s } = this.config;
    !i && !s && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const t = this.element.parentElement;
    return t ? Array.prototype.slice.call(t.children).filter((i) => !i.classList.contains("ag-hidden")) : null;
  }
  getMinSizeOfSiblings() {
    const e = this.getSiblings() || [];
    let t = 0, i = 0;
    for (let s = 0; s < e.length; s++) {
      const o = e[s], n = !!o.style.flex && o.style.flex !== "0 0 auto";
      if (o === this.element)
        continue;
      let r = this.minHeight || 0, a = this.minWidth || 0;
      if (n) {
        const l = window.getComputedStyle(o);
        l.minHeight && (r = parseInt(l.minHeight, 10)), l.minWidth && (a = parseInt(l.minWidth, 10));
      } else
        r = o.offsetHeight, a = o.offsetWidth;
      t += r, i += a;
    }
    return { height: t, width: i };
  }
  applySizeToSiblings(e) {
    let t = null;
    const i = this.getSiblings();
    if (i) {
      for (let s = 0; s < i.length; s++) {
        const o = i[s];
        o !== t && (e ? o.style.height = `${o.offsetHeight}px` : o.style.width = `${o.offsetWidth}px`, o.style.flex = "0 0 auto", o === this.element && (t = i[s + 1]));
      }
      t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto");
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((e) => e);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer)
      return;
    const { popup: t, forcePopupParentAsOffsetParent: i } = this.config, { isTop: s, isRight: o, isBottom: n, isLeft: r } = this.currentResizer, a = o || r, l = n || s, { movementX: d, movementY: c } = this.calculateMouseMovement({ e, isLeft: r, isTop: s }), u = this.position.x, h = this.position.y;
    let g = 0, p = 0;
    if (a && d) {
      const f = r ? -1 : 1, m = this.getWidth(), C = m + d * f;
      let v = !1;
      r && (g = m - C, (u + g <= 0 || C <= this.minWidth) && (v = !0, g = 0)), v || this.setWidth(C);
    }
    if (l && c) {
      const f = s ? -1 : 1, m = this.getHeight(), C = m + c * f;
      let v = !1;
      s ? (p = m - C, (h + p <= 0 || C <= this.minHeight) && (v = !0, p = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && m < C && this.getMinSizeOfSiblings().height + C > this.element.parentElement.offsetHeight && (v = !0), v || this.setHeight(C);
    }
    this.updateDragStartPosition(e.clientX, e.clientY), ((t || i) && g || p) && this.offsetElement(u + g, h + p);
  }
  onResizeEnd(e, t) {
    this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null, this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchLocalEvent({ type: "resize" });
  }
  refreshSize() {
    const e = this.element;
    this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight));
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving)
      return;
    const { x: t, y: i } = this.position;
    let s;
    this.config.calculateTopBuffer && (s = this.config.calculateTopBuffer());
    const { movementX: o, movementY: n } = this.calculateMouseMovement({
      e,
      isTop: !0,
      anywhereWithin: !0,
      topBuffer: s
    });
    this.offsetElement(t + o, i + n), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    this.config.forcePopupParentAsOffsetParent && this.popupSvc ? this.offsetParent = this.popupSvc.getPopupParent() : this.offsetParent = this.element.offsetParent;
  }
  findBoundaryElement() {
    let e = this.element;
    for (; e; ) {
      if (window.getComputedStyle(e).position !== "static")
        return e;
      e = e.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    var e;
    for (; this.resizeListeners.length; ) {
      const t = this.resizeListeners.pop();
      (e = this.dragSvc) == null || e.removeDragSource(t);
    }
  }
  destroy() {
    var e;
    super.destroy(), this.moveElementDragListener && ((e = this.dragSvc) == null || e.removeDragSource(this.moveElementDragListener)), this.constrainSizeToAvailableHeight(!1), this.clearResizeListeners(), this.removeResizers();
  }
}, Wg = "__ag_Grid_Stop_Propagation";
function Bi(e) {
  e[Wg] = !0;
}
function Wt(e) {
  return e[Wg] === !0;
}
var Hb = "ag-focus-managed", Ts = class extends E {
  constructor(e, t = {}) {
    super(), this.eFocusable = e, this.callbacks = t, this.callbacks = {
      shouldStopEventPropagation: () => !1,
      onTabKeyDown: (i) => {
        if (i.defaultPrevented)
          return;
        const s = zi(this.beans, this.eFocusable, !1, i.shiftKey);
        s && (s.focus(), i.preventDefault());
      },
      ...t
    };
  }
  postConstruct() {
    const {
      eFocusable: e,
      callbacks: { onFocusIn: t, onFocusOut: i }
    } = this;
    e.classList.add(Hb), this.addKeyDownListeners(e), t && this.addManagedElementListeners(e, { focusin: t }), i && this.addManagedElementListeners(e, { focusout: i });
  }
  addKeyDownListeners(e) {
    this.addManagedElementListeners(e, {
      keydown: (t) => {
        if (t.defaultPrevented || Wt(t))
          return;
        const { callbacks: i } = this;
        if (i.shouldStopEventPropagation(t)) {
          Bi(t);
          return;
        }
        t.key === P.TAB ? i.onTabKeyDown(t) : i.handleKeyDown && i.handleKeyDown(t);
      }
    });
  }
}, Bb = class extends te {
  constructor(e, t) {
    super(), this.filterNameKey = e, this.cssIdentifier = t, this.applyActive = !1, this.debouncePending = !1, this.defaultDebounceMs = 0;
  }
  postConstruct() {
    const e = {
      tag: "div",
      cls: `ag-filter-body-wrapper ag-${this.cssIdentifier}-body-wrapper`,
      children: [this.createBodyTemplate()]
    };
    this.setTemplate(e, this.getAgComponents()), this.createManagedBean(
      new Ts(this.getFocusableElement(), {
        handleKeyDown: this.handleKeyDown.bind(this)
      })
    ), this.positionableFeature = this.createBean(
      new _b(this.getPositionableElement(), {
        forcePopupParentAsOffsetParent: !0
      })
    );
  }
  handleKeyDown(e) {
  }
  init(e) {
    const t = e;
    this.setParams(t), this.setModelIntoUi(t.state.model, !0).then(() => this.updateUiVisibility());
  }
  refresh(e) {
    const t = e, i = this.params;
    this.params = t, t.source === "colDef" && this.updateParams(t, i);
    const o = t.state, n = this.state;
    return this.state = o, (o.model !== n.model || o.state !== n.state) && this.setModelIntoUi(o.model), !0;
  }
  /** Called on init only. Override in subclasses */
  setParams(e) {
    this.params = e, this.state = e.state, this.commonUpdateParams(e);
  }
  /** Called on refresh only. Override in subclasses */
  updateParams(e, t) {
    this.commonUpdateParams(e, t);
  }
  commonUpdateParams(e, t) {
    this.applyActive = yr(e), this.setupApplyDebounced();
  }
  /**
   * @deprecated v34 Use the same method on the filter handler (`api.getColumnFilterHandler()`) instead.
   */
  doesFilterPass(e) {
    I(283);
    const { getHandler: t, model: i, column: s } = this.params;
    return t().doesFilterPass({
      ...e,
      model: i,
      handlerParams: this.beans.colFilter.getHandlerParams(s)
    });
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  /**
   * @deprecated v34 Filters are active when they have a model. Use `api.getColumnFilterModel()` instead.
   */
  isFilterActive() {
    return I(284), this.params.model != null;
  }
  setupApplyDebounced() {
    const e = $l(this.params, this.defaultDebounceMs), t = De(this, this.checkApplyDebounce.bind(this), e);
    this.applyDebounced = () => {
      this.debouncePending = !0, t();
    };
  }
  checkApplyDebounce() {
    this.debouncePending && (this.debouncePending = !1, this.doApplyModel());
  }
  /**
   * @deprecated v34 Use (`api.getColumnFilterModel()`) instead.
   */
  getModel() {
    return I(285), this.params.model;
  }
  /**
   * @deprecated v34 Use (`api.setColumnFilterModel()`) instead.
   */
  setModel(e) {
    I(286);
    const { beans: t, params: i } = this;
    return t.colFilter.setModelForColumnLegacy(i.column, e);
  }
  /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */
  applyModel(e = "api") {
    return this.doApplyModel();
  }
  canApply(e) {
    return !0;
  }
  doApplyModel(e) {
    const { params: t, state: i } = this, s = !this.areModelsEqual(t.model, i.model);
    return s && t.onAction("apply", e), s;
  }
  /**
   * @deprecated v34 Internal method - should only be called by the grid.
   */
  onNewRowsLoaded() {
  }
  /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */
  onUiChanged(e, t = !1) {
    this.updateUiVisibility();
    const i = this.getModelFromUi(), s = {
      model: i,
      state: this.getState(),
      valid: this.canApply(i)
    };
    this.state = s;
    const o = this.params;
    o.onStateChange(s), o.onUiChange(this.getUiChangeEventParams()), this.gos.get("enableFilterHandlers") || this.eventSvc.dispatchEvent({
      type: "filterModified",
      column: o.column,
      filterInstance: this
    }), e ?? (e = this.applyActive ? void 0 : "debounce"), e === "immediately" ? this.doApplyModel({ afterFloatingFilter: t, afterDataChange: !1 }) : e === "debounce" && this.applyDebounced();
  }
  getState() {
  }
  getUiChangeEventParams() {
  }
  afterGuiAttached(e) {
    this.lastContainerType = e == null ? void 0 : e.container, this.refreshFilterResizer(e == null ? void 0 : e.container);
  }
  refreshFilterResizer(e) {
    const { positionableFeature: t, gos: i } = this;
    if (!t)
      return;
    const s = e === "floatingFilter" || e === "columnFilter";
    s ? (t.restoreLastSize(), t.setResizable(
      i.get("enableRtl") ? { bottom: !0, bottomLeft: !0, left: !0 } : { bottom: !0, bottomRight: !0, right: !0 }
    )) : (t.removeSizeFromEl(), t.setResizable(!1)), t.constrainSizeToAvailableHeight(s);
  }
  afterGuiDetached() {
    var e;
    this.checkApplyDebounce(), (e = this.positionableFeature) == null || e.constrainSizeToAvailableHeight(!1);
  }
  destroy() {
    this.positionableFeature = this.destroyBean(this.positionableFeature), super.destroy();
  }
  translate(e) {
    return ei(this, e);
  }
  // override to control positionable feature
  getPositionableElement() {
    return this.getGui();
  }
  areModelsEqual(e, t) {
    return e === t || e == null && t == null ? !0 : e == null || t == null ? !1 : this.areNonNullModelsEqual(e, t);
  }
};
function zg(e) {
  return !!e.operator;
}
function Gb(e, t, i) {
  if (t == null)
    return null;
  let s = null;
  const { compName: o, jsComp: n, fwComp: r } = wg(e, t);
  return o ? s = {
    agSetColumnFilter: "agSetColumnFloatingFilter",
    agMultiColumnFilter: "agMultiColumnFloatingFilter",
    agGroupColumnFilter: "agGroupColumnFloatingFilter",
    agNumberColumnFilter: "agNumberColumnFloatingFilter",
    agDateColumnFilter: "agDateColumnFloatingFilter",
    agTextColumnFilter: "agTextColumnFloatingFilter"
  }[o] : n == null && r == null && t.filter === !0 && (s = i()), s;
}
var lt = {
  AUTO_HEIGHT: "ag-layout-auto-height",
  NORMAL: "ag-layout-normal",
  PRINT: "ag-layout-print"
}, Kl = class extends E {
  constructor(e) {
    super(), this.view = e;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const e = this.gos.get("domLayout"), t = {
      autoHeight: e === "autoHeight",
      normal: e === "normal",
      print: e === "print"
    }, i = t.autoHeight ? lt.AUTO_HEIGHT : t.print ? lt.PRINT : lt.NORMAL;
    this.view.updateLayoutClasses(i, t);
  }
}, Qt = "Viewport", pc = "fakeVScrollComp", Qr = [
  "fakeHScrollComp",
  "centerHeader",
  "topCenter",
  "bottomCenter",
  "stickyTopCenter",
  "stickyBottomCenter"
], fc = 100, Xr = 150, Vb = class extends E {
  constructor(e) {
    super(), this.clearRetryListenerFncs = [], this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.lastOffsetHeight = -1, this.lastScrollTop = -1, this.lastIsHorizontalScrollShowing = !1, this.scrollTimer = 0, this.isScrollActive = !1, this.isVerticalPositionInvalidated = !0, this.isHorizontalPositionInvalidated = !0, this.eBodyViewport = e, this.resetLastHScrollDebounced = De(
      this,
      () => this.lastScrollSource[
        1
        /* Horizontal */
      ] = null,
      Xr
    ), this.resetLastVScrollDebounced = De(
      this,
      () => this.lastScrollSource[
        0
        /* Vertical */
      ] = null,
      Xr
    );
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.animationFrameSvc = e.animationFrameSvc, this.visibleCols = e.visibleCols;
  }
  destroy() {
    super.destroy(), this.clearRetryListenerFncs = [], window.clearTimeout(this.scrollTimer);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl");
    const e = this.invalidateVerticalScroll.bind(this), t = this.invalidateHorizontalScroll.bind(this);
    this.addManagedEventListeners({
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
      gridSizeChanged: e,
      // We only invalidate horizontal scrolling when the viewport switches
      // between scrollable and non-scrollable, avoiding unnecessary
      // invalidation on every gridSizeChanged event. If more properties
      // require invalidation, read/write DOM cycles may be needed.
      scrollGapChanged: t
    }), this.addManagedElementListeners(this.eBodyViewport, {
      scroll: e
    }), this.ctrlsSvc.whenReady(this, (i) => {
      this.centerRowsCtrl = i.center, this.onDisplayedColumnsWidthChanged(), this.addScrollListener();
    });
  }
  invalidateHorizontalScroll() {
    this.isHorizontalPositionInvalidated = !0;
  }
  invalidateVerticalScroll() {
    this.isVerticalPositionInvalidated = !0;
  }
  addScrollListener() {
    this.addHorizontalScrollListeners(), this.addVerticalScrollListeners();
  }
  addHorizontalScrollListeners() {
    this.addManagedElementListeners(this.centerRowsCtrl.eViewport, {
      scroll: this.onHScroll.bind(this, Qt)
    });
    for (const e of Qr) {
      const t = this.ctrlsSvc.get(e);
      this.registerScrollPartner(t, this.onHScroll.bind(this, e));
    }
  }
  addVerticalScrollListeners() {
    const e = this.ctrlsSvc.get("fakeVScrollComp"), t = this.gos.get("debounceVerticalScrollbar"), i = t ? De(this, this.onVScroll.bind(this, Qt), fc) : this.onVScroll.bind(this, Qt), s = t ? De(this, this.onVScroll.bind(this, pc), fc) : this.onVScroll.bind(this, pc);
    this.addManagedElementListeners(this.eBodyViewport, { scroll: i }), this.registerScrollPartner(e, s);
  }
  registerScrollPartner(e, t) {
    e.onScrollCallback(t);
  }
  onDisplayedColumnsWidthChanged() {
    this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(e) {
    this.centerRowsCtrl != null && (e === void 0 && (e = this.centerRowsCtrl.getCenterViewportScrollLeft()), this.setScrollLeftForAllContainersExceptCurrent(Math.abs(e)));
  }
  setScrollLeftForAllContainersExceptCurrent(e) {
    for (const t of [...Qr, Qt]) {
      if (this.lastScrollSource[
        1
        /* Horizontal */
      ] === t)
        continue;
      const i = this.getViewportForSource(t);
      Wn(i, e, this.enableRtl);
    }
  }
  getViewportForSource(e) {
    return e === Qt ? this.centerRowsCtrl.eViewport : this.ctrlsSvc.get(e).eViewport;
  }
  isControllingScroll(e, t) {
    return this.lastScrollSource[t] == null ? (t === 0 ? this.lastScrollSource[0] = e : this.lastScrollSource[1] = e, !0) : this.lastScrollSource[t] === e;
  }
  onHScroll(e) {
    if (!this.isControllingScroll(
      e,
      1
      /* Horizontal */
    ))
      return;
    const t = this.centerRowsCtrl.eViewport, { scrollLeft: i } = t;
    if (this.shouldBlockScrollUpdate(1, i, !0))
      return;
    const s = Nn(this.getViewportForSource(e), this.enableRtl);
    this.doHorizontalScroll(s), this.resetLastHScrollDebounced();
  }
  onVScroll(e) {
    if (!this.isControllingScroll(
      e,
      0
      /* Vertical */
    ))
      return;
    let t;
    if (e === Qt ? t = this.eBodyViewport.scrollTop : t = this.ctrlsSvc.get("fakeVScrollComp").getScrollPosition(), this.shouldBlockScrollUpdate(0, t, !0))
      return;
    const { animationFrameSvc: i } = this;
    i == null || i.setScrollTop(t), this.nextScrollTop = t, e === Qt ? this.ctrlsSvc.get("fakeVScrollComp").setScrollPosition(t) : this.eBodyViewport.scrollTop = t, i != null && i.active ? i.schedule() : this.scrollGridIfNeeded(!0), this.resetLastVScrollDebounced();
  }
  doHorizontalScroll(e) {
    const t = this.ctrlsSvc.get("fakeHScrollComp").getScrollPosition();
    this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(
      1
      /* Horizontal */
    ), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.centerRowsCtrl.onHorizontalViewportChanged(!0));
  }
  isScrolling() {
    return this.isScrollActive;
  }
  fireScrollEvent(e) {
    const t = {
      type: "bodyScroll",
      direction: e === 1 ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.isScrollActive = !0, this.eventSvc.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = window.setTimeout(() => {
      this.scrollTimer = 0, this.isScrollActive = !1, this.eventSvc.dispatchEvent({
        ...t,
        type: "bodyScrollEnd"
      });
    }, Xr);
  }
  shouldBlockScrollUpdate(e, t, i = !1) {
    return i && !Mi() ? !1 : e === 0 ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t);
  }
  shouldBlockVerticalScroll(e) {
    const t = Fl(this.eBodyViewport), { scrollHeight: i } = this.eBodyViewport;
    return e < 0 || e + t > i;
  }
  shouldBlockHorizontalScroll(e) {
    const t = this.centerRowsCtrl.getCenterWidth(), { scrollWidth: i } = this.centerRowsCtrl.eViewport;
    if (this.enableRtl) {
      if (e > 0)
        return !0;
    } else if (e < 0)
      return !0;
    return Math.abs(e) + t > i;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(
      0
      /* Vertical */
    );
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    const e = this.scrollLeft;
    let t = !1;
    for (const i of Qr)
      if (this.getViewportForSource(i).scrollLeft !== e) {
        t = !0;
        break;
      }
    t && this.onHScroll(Qt);
  }
  scrollGridIfNeeded(e = !1) {
    const t = this.scrollTop != this.nextScrollTop;
    return t && (this.scrollTop = this.nextScrollTop, e && this.invalidateVerticalScroll(), this.redrawRowsAfterScroll()), t;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(e, t = !1) {
    const s = this.centerRowsCtrl.eViewport.scrollWidth - this.centerRowsCtrl.getCenterWidth();
    !t && this.shouldBlockScrollUpdate(1, e) && (this.enableRtl ? e = e > 0 ? 0 : s : e = Math.min(Math.max(e, 0), s)), Wn(this.centerRowsCtrl.eViewport, Math.abs(e), this.enableRtl), this.doHorizontalScroll(e);
  }
  setVerticalScrollPosition(e) {
    this.invalidateVerticalScroll(), this.eBodyViewport.scrollTop = e;
  }
  getVScrollPosition() {
    if (!this.isVerticalPositionInvalidated) {
      const { lastOffsetHeight: i, lastScrollTop: s } = this;
      return {
        top: s,
        bottom: s + i
      };
    }
    this.isVerticalPositionInvalidated = !1;
    const { scrollTop: e, offsetHeight: t } = this.eBodyViewport;
    return this.lastScrollTop = e, this.lastOffsetHeight = t, {
      top: e,
      bottom: e + t
    };
  }
  /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */
  getApproximateVScollPosition() {
    return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0 ? {
      top: this.scrollTop,
      bottom: this.scrollTop + this.lastOffsetHeight
    } : this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.isHorizontalPositionInvalidated && (this.lastIsHorizontalScrollShowing = this.centerRowsCtrl.isHorizontalScrollShowing(), this.isHorizontalPositionInvalidated = !1), this.lastIsHorizontalScrollShowing;
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(e) {
    const t = this.centerRowsCtrl.eViewport.scrollLeft;
    return this.setHorizontalScrollPosition(t + e), this.centerRowsCtrl.eViewport.scrollLeft - t;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(e, t = null) {
    const { rowModel: i } = this.beans, s = i.getRowCount();
    let o = -1;
    for (let n = 0; n < s; n++) {
      const r = i.getRow(n);
      if (typeof e == "function") {
        if (r && e(r)) {
          o = n;
          break;
        }
      } else if (e === r || e === r.data) {
        o = n;
        break;
      }
    }
    o >= 0 && this.ensureIndexVisible(o, t);
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(e, t, i = 0) {
    if (Me(this.gos, "print"))
      return;
    const { rowModel: s } = this.beans, o = s.getRowCount();
    if (typeof e != "number" || e < 0 || e >= o) {
      I(88, { index: e });
      return;
    }
    this.clearRetryListeners();
    const { frameworkOverrides: n, pageBounds: r, rowContainerHeight: a, rowRenderer: l } = this.beans;
    n.wrapIncoming(() => {
      var p, f;
      const d = this.ctrlsSvc.getGridBodyCtrl(), c = s.getRow(e);
      let u, h, g = 0;
      this.invalidateVerticalScroll();
      do {
        const { stickyTopHeight: m, stickyBottomHeight: C } = d, v = c.rowTop, R = c.rowHeight, b = r.getPixelOffset(), w = c.rowTop - b, x = w + c.rowHeight, F = this.getVScrollPosition(), D = a.divStretchOffset, T = F.top + D, k = F.bottom + D, A = k - T, G = a.getScrollPositionForPixel(w), $ = a.getScrollPositionForPixel(x - A), q = Math.min((G + $) / 2, w), j = T + m > w, oe = k - C < x;
        let ne = null;
        t === "top" ? ne = G - m : t === "bottom" ? ne = $ + C : t === "middle" ? ne = q : j ? ne = G - m : oe && ($ - G > A ? ne = G - m : ne = $ + C), ne !== null && (this.setVerticalScrollPosition(ne), l.redraw({ afterScroll: !0 })), u = v !== c.rowTop || R !== c.rowHeight, h = m !== d.stickyTopHeight || C !== d.stickyBottomHeight, g++;
      } while ((u || h) && g < 10);
      if ((p = this.animationFrameSvc) == null || p.flushAllFrames(), i < 10 && (c != null && c.stub || !((f = this.beans.rowAutoHeight) != null && f.areRowsMeasured()))) {
        const m = this.getVScrollPosition().top;
        this.clearRetryListenerFncs = this.addManagedEventListeners({
          bodyScroll: () => {
            const C = this.getVScrollPosition().top;
            m !== C && this.clearRetryListeners();
          },
          modelUpdated: () => {
            this.clearRetryListeners(), !(e >= s.getRowCount()) && this.ensureIndexVisible(e, t, i + 1);
          }
        });
      }
    });
  }
  clearRetryListeners() {
    this.clearRetryListenerFncs.forEach((e) => e()), this.clearRetryListenerFncs = [];
  }
  ensureColumnVisible(e, t = "auto") {
    const { colModel: i, frameworkOverrides: s } = this.beans, o = i.getCol(e);
    if (!o || o.isPinned() || !this.visibleCols.isColDisplayed(o))
      return;
    const n = this.getPositionedHorizontalScroll(o, t);
    s.wrapIncoming(() => {
      var r;
      n !== null && this.centerRowsCtrl.setCenterViewportScrollLeft(n), this.centerRowsCtrl.onHorizontalViewportChanged(), (r = this.animationFrameSvc) == null || r.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(e, t) {
    const { columnBeforeStart: i, columnAfterEnd: s } = this.isColumnOutsideViewport(e), o = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(), n = this.centerRowsCtrl.getCenterWidth(), r = this.enableRtl;
    let a = (r ? i : s) || o, l = r ? s : i;
    t !== "auto" && (a = t === "start", l = t === "end");
    const d = t === "middle";
    if (a || l || d) {
      const { colLeft: c, colMiddle: u, colRight: h } = this.getColumnBounds(e);
      return d ? u - n / 2 : a ? r ? h : c : r ? c - n : h - n;
    }
    return null;
  }
  isColumnOutsideViewport(e) {
    const { start: t, end: i } = this.getViewportBounds(), { colLeft: s, colRight: o } = this.getColumnBounds(e), n = this.enableRtl, r = n ? t > o : i < o, a = n ? i < s : t > s;
    return { columnBeforeStart: r, columnAfterEnd: a };
  }
  getColumnBounds(e) {
    const t = this.enableRtl, i = this.visibleCols.bodyWidth, s = e.getActualWidth(), o = e.getLeft(), n = t ? -1 : 1, r = t ? i - o : o, a = r + s * n, l = r + s / 2 * n;
    return { colLeft: r, colMiddle: l, colRight: a };
  }
  getViewportBounds() {
    const e = this.centerRowsCtrl.getCenterWidth(), t = this.centerRowsCtrl.getCenterViewportScrollLeft(), i = t, s = e + t;
    return { start: i, end: s, width: e };
  }
}, jl = class extends E {
  constructor(e, t = !1) {
    super(), this.callback = e, this.addSpacer = t;
  }
  postConstruct() {
    const e = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", e), this.addManagedEventListeners({
      columnContainerWidthChanged: e,
      displayedColumnsChanged: e,
      leftPinnedWidthChanged: e
    }), this.addSpacer && this.addManagedEventListeners({
      rightPinnedWidthChanged: e,
      scrollVisibilityChanged: e,
      scrollbarWidthChanged: e
    }), this.setWidth();
  }
  setWidth() {
    const e = Me(this.gos, "print"), { visibleCols: t, scrollVisibleSvc: i } = this.beans, s = t.bodyWidth, o = t.getColsLeftWidth(), n = t.getDisplayedColumnsRightWidth();
    let r;
    e ? r = s + o + n : (r = s, this.addSpacer && (this.gos.get("enableRtl") ? o : n) === 0 && i.verticalScrollShowing && (r += i.getScrollbarWidth())), this.callback(r);
  }
}, Nb = class extends E {
  constructor(e) {
    super(), this.centerContainerCtrl = e;
  }
  wireBeans(e) {
    this.scrollVisibleSvc = e.scrollVisibleSvc;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.listenForResize();
    }), this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) }), this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const { beans: e, centerContainerCtrl: t, gridBodyCtrl: i } = this, s = () => {
      $t(e, () => {
        this.onCenterViewportResized();
      });
    };
    t.registerViewportResizeListener(s), i.registerBodyViewportResizeListener(s);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.scrollVisibleSvc.updateScrollGap(), this.centerContainerCtrl.isViewportInTheDOMTree()) {
      const { pinnedCols: e, colFlex: t } = this.beans;
      e == null || e.keepPinnedColumnsNarrowerThanViewport(), this.checkViewportAndScrolls();
      const i = this.centerContainerCtrl.getCenterWidth();
      i !== this.centerWidth && (this.centerWidth = i, t == null || t.refreshFlexedColumns({
        viewportWidth: this.centerWidth,
        updateBodyWidths: !0,
        fireResizedEvent: !0
      }));
    } else
      this.bodyHeight = 0;
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.scrollFeature.checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const e = this.gridBodyCtrl.eBodyViewport, t = Fl(e);
    this.bodyHeight !== t && (this.bodyHeight = t, this.eventSvc.dispatchEvent({
      type: "bodyHeightChanged"
    }));
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    if (!this.isAlive())
      return;
    const e = {
      horizontalScrollShowing: this.centerContainerCtrl.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleSvc.setScrollsVisible(e);
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const e = this.centerContainerCtrl.getCenterWidth(), t = this.centerContainerCtrl.getViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(e, t);
  }
};
function Tn(e, t, i, s) {
  var n;
  const o = (n = t.getColDef().cellRendererParams) == null ? void 0 : n.suppressMouseEventHandling;
  return Ug(e, t, i, s, o);
}
function Wb(e, t, i, s) {
  const o = t == null ? void 0 : t.suppressMouseEventHandling;
  return Ug(e, void 0, i, s, o);
}
function Ug(e, t, i, s, o) {
  return o ? o(
    W(e, {
      column: t,
      node: i,
      event: s
    })
  ) : !1;
}
function $g(e, t, i) {
  let s = t;
  for (; s; ) {
    const o = jh(e, s, i);
    if (o)
      return o;
    s = s.parentElement;
  }
  return null;
}
var er = "cellCtrl";
function ql(e, t) {
  return $g(e, t, er);
}
var tr = "renderedRow";
function zb(e, t) {
  return $g(e, t, tr);
}
function qa(e, t, i, s, o) {
  const n = s ? s.getColDef().suppressKeyboardEvent : void 0;
  if (!n)
    return !1;
  const r = W(e, {
    event: t,
    editing: o,
    column: s,
    node: i,
    data: i.data,
    colDef: s.getColDef()
  });
  return !!(n && n(r));
}
function Ub(e) {
  const { pinnedRowModel: t, rowModel: i } = e, [s, o] = [
    (t == null ? void 0 : t.isEmpty("top")) ?? !0,
    (t == null ? void 0 : t.isEmpty("bottom")) ?? !0
  ], n = s ? null : "top";
  let r, a;
  o ? (r = null, a = i.getRowCount() - 1) : (r = "bottom", a = (t == null ? void 0 : t.getPinnedBottomRowCount()) ?? -1);
  const { visibleCols: l, rangeSvc: d } = e, c = l.allCols;
  !d || !(c != null && c.length) || d.setCellRange({
    rowStartIndex: 0,
    rowStartPinned: n,
    rowEndIndex: a,
    rowEndPinned: r
  });
}
var $b = 65, Kb = 67, jb = 86, qb = 68, Yb = 90, Qb = 89;
function Xb(e) {
  const { keyCode: t } = e;
  let i;
  switch (t) {
    case $b:
      i = P.A;
      break;
    case Kb:
      i = P.C;
      break;
    case jb:
      i = P.V;
      break;
    case qb:
      i = P.D;
      break;
    case Yb:
      i = P.Z;
      break;
    case Qb:
      i = P.Y;
      break;
    default:
      i = e.code;
  }
  return i;
}
var Zb = class extends E {
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    var e;
    this.addKeyboardListeners(), this.addMouseListeners(), (e = this.beans.touchSvc) == null || e.mockRowContextMenu(this), this.editSvc = this.beans.editSvc;
  }
  addKeyboardListeners() {
    const e = "keydown", t = this.processKeyboardEvent.bind(this, e);
    this.addManagedElementListeners(this.element, { [e]: t });
  }
  addMouseListeners() {
    ["dblclick", "contextmenu", "mouseover", "mouseout", "click", Hh("touchstart") ? "touchstart" : "mousedown"].forEach((i) => {
      const s = this.processMouseEvent.bind(this, i);
      this.addManagedElementListeners(this.element, { [i]: s });
    });
  }
  processMouseEvent(e, t) {
    var o;
    if (!Ro(this.beans, t) || Wt(t))
      return;
    const { cellCtrl: i, rowCtrl: s } = this.getControlsForEventTarget(t.target);
    e === "contextmenu" ? (i != null && i.column && i.dispatchCellContextMenuEvent(t), (o = this.beans.contextMenuSvc) == null || o.handleContextMenuMouseEvent(t, void 0, s, i)) : (i && i.onMouseEvent(e, t), s && s.onMouseEvent(e, t));
  }
  getControlsForEventTarget(e) {
    const { gos: t } = this;
    return {
      cellCtrl: ql(t, e),
      rowCtrl: zb(t, e)
    };
  }
  processKeyboardEvent(e, t) {
    const { cellCtrl: i, rowCtrl: s } = this.getControlsForEventTarget(t.target);
    t.defaultPrevented || (i ? this.processCellKeyboardEvent(i, e, t) : s != null && s.isFullWidth() && this.processFullWidthRowKeyboardEvent(s, e, t));
  }
  processCellKeyboardEvent(e, t, i) {
    var n, r;
    const s = ((n = this.editSvc) == null ? void 0 : n.isEditing(e, { withOpenEditor: !0 })) ?? !1;
    !qa(
      this.gos,
      i,
      e.rowNode,
      e.column,
      s
    ) && t === "keydown" && (!s && ((r = this.beans.navigation) != null && r.handlePageScrollingKey(i)) || e.onKeyDown(i), this.doGridOperations(i, s), xg(i) && e.processCharacter(i)), t === "keydown" && this.eventSvc.dispatchEvent(e.createEvent(i, "cellKeyDown"));
  }
  processFullWidthRowKeyboardEvent(e, t, i) {
    const { rowNode: s } = e, { focusSvc: o, navigation: n } = this.beans, r = o.getFocusedCell(), a = r == null ? void 0 : r.column;
    if (!qa(this.gos, i, s, a, !1)) {
      const d = i.key;
      if (t === "keydown")
        switch (d) {
          case P.PAGE_HOME:
          case P.PAGE_END:
          case P.PAGE_UP:
          case P.PAGE_DOWN:
            n == null || n.handlePageScrollingKey(i, !0);
            break;
          case P.LEFT:
          case P.RIGHT:
            if (!this.gos.get("embedFullWidthRows"))
              break;
          case P.UP:
          case P.DOWN:
            e.onKeyboardNavigate(i);
            break;
          case P.TAB:
            e.onTabKeyDown(i);
            break;
        }
    }
    t === "keydown" && this.eventSvc.dispatchEvent(e.createRowEvent("cellKeyDown", i));
  }
  doGridOperations(e, t) {
    if (!e.ctrlKey && !e.metaKey || t || !Ro(this.beans, e))
      return;
    const i = Xb(e), { clipboardSvc: s, undoRedo: o } = this.beans;
    if (i === P.A)
      return this.onCtrlAndA(e);
    if (i === P.C)
      return this.onCtrlAndC(s, e);
    if (i === P.D)
      return this.onCtrlAndD(s, e);
    if (i === P.V)
      return this.onCtrlAndV(s, e);
    if (i === P.X)
      return this.onCtrlAndX(s, e);
    if (i === P.Y)
      return this.onCtrlAndY(o);
    if (i === P.Z)
      return this.onCtrlAndZ(o, e);
  }
  onCtrlAndA(e) {
    const {
      beans: { rowModel: t, rangeSvc: i, selectionSvc: s },
      gos: o
    } = this;
    i && zt(o) && t.isRowsToRender() ? Ub(this.beans) : s && (s == null || s.selectAllRowNodes({ source: "keyboardSelectAll", selectAll: Jh(o) })), e.preventDefault();
  }
  onCtrlAndC(e, t) {
    var s;
    if (!e || this.gos.get("enableCellTextSelection"))
      return;
    const { cellCtrl: i } = this.getControlsForEventTarget(t.target);
    (s = this.editSvc) != null && s.isEditing(i, { withOpenEditor: !0 }) || (t.preventDefault(), e.copyToClipboard());
  }
  onCtrlAndX(e, t) {
    var s;
    if (!e || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard"))
      return;
    const { cellCtrl: i } = this.getControlsForEventTarget(t.target);
    (s = this.editSvc) != null && s.isEditing(i, { withOpenEditor: !0 }) || (t.preventDefault(), e.cutToClipboard(void 0, "ui"));
  }
  onCtrlAndV(e, t) {
    var s;
    const { cellCtrl: i } = this.getControlsForEventTarget(t.target);
    (s = this.editSvc) != null && s.isEditing(i, { withOpenEditor: !0 }) || e && !this.gos.get("suppressClipboardPaste") && e.pasteFromClipboard();
  }
  onCtrlAndD(e, t) {
    e && !this.gos.get("suppressClipboardPaste") && e.copyRangeDown(), t.preventDefault();
  }
  onCtrlAndZ(e, t) {
    !this.gos.get("undoRedoCellEditing") || !e || (t.preventDefault(), t.shiftKey ? e.redo("ui") : e.undo("ui"));
  }
  onCtrlAndY(e) {
    e == null || e.redo("ui");
  }
}, Kg = class extends E {
  constructor(e, t) {
    super(), this.eContainer = e, this.eViewport = t;
  }
  postConstruct() {
    this.addManagedEventListeners({
      rowContainerHeightChanged: this.onHeightChanged.bind(this, this.beans.rowContainerHeight)
    });
  }
  onHeightChanged(e) {
    const t = e.uiContainerHeight, i = t != null ? `${t}px` : "";
    this.eContainer.style.height = i, this.eViewport && (this.eViewport.style.height = i);
  }
}, tn = (e) => e.topRowCtrls, sn = (e) => e.getStickyTopRowCtrls(), on = (e) => e.getStickyBottomRowCtrls(), nn = (e) => e.bottomRowCtrls, rn = (e) => e.allRowCtrls, Zr = (e) => e.getCtrls("top"), Jr = (e) => e.getCtrls("center"), ea = (e) => e.getCtrls("bottom"), Jb = {
  center: {
    type: "center",
    name: "center-cols",
    getRowCtrls: rn,
    getSpannedRowCtrls: Jr
  },
  left: {
    type: "left",
    name: "pinned-left-cols",
    pinnedType: "left",
    getRowCtrls: rn,
    getSpannedRowCtrls: Jr
  },
  right: {
    type: "right",
    name: "pinned-right-cols",
    pinnedType: "right",
    getRowCtrls: rn,
    getSpannedRowCtrls: Jr
  },
  fullWidth: {
    type: "fullWidth",
    name: "full-width",
    fullWidth: !0,
    getRowCtrls: rn
  },
  topCenter: {
    type: "center",
    name: "floating-top",
    getRowCtrls: tn,
    getSpannedRowCtrls: Zr
  },
  topLeft: {
    type: "left",
    name: "pinned-left-floating",
    container: "ag-pinned-left-floating-top",
    pinnedType: "left",
    getRowCtrls: tn,
    getSpannedRowCtrls: Zr
  },
  topRight: {
    type: "right",
    name: "pinned-right-floating",
    container: "ag-pinned-right-floating-top",
    pinnedType: "right",
    getRowCtrls: tn,
    getSpannedRowCtrls: Zr
  },
  topFullWidth: {
    type: "fullWidth",
    name: "floating-top-full-width",
    fullWidth: !0,
    getRowCtrls: tn
  },
  stickyTopCenter: {
    type: "center",
    name: "sticky-top",
    getRowCtrls: sn
  },
  stickyTopLeft: {
    type: "left",
    name: "pinned-left-sticky-top",
    container: "ag-pinned-left-sticky-top",
    pinnedType: "left",
    getRowCtrls: sn
  },
  stickyTopRight: {
    type: "right",
    name: "pinned-right-sticky-top",
    container: "ag-pinned-right-sticky-top",
    pinnedType: "right",
    getRowCtrls: sn
  },
  stickyTopFullWidth: {
    type: "fullWidth",
    name: "sticky-top-full-width",
    fullWidth: !0,
    getRowCtrls: sn
  },
  stickyBottomCenter: {
    type: "center",
    name: "sticky-bottom",
    getRowCtrls: on
  },
  stickyBottomLeft: {
    type: "left",
    name: "pinned-left-sticky-bottom",
    container: "ag-pinned-left-sticky-bottom",
    pinnedType: "left",
    getRowCtrls: on
  },
  stickyBottomRight: {
    type: "right",
    name: "pinned-right-sticky-bottom",
    container: "ag-pinned-right-sticky-bottom",
    pinnedType: "right",
    getRowCtrls: on
  },
  stickyBottomFullWidth: {
    type: "fullWidth",
    name: "sticky-bottom-full-width",
    fullWidth: !0,
    getRowCtrls: on
  },
  bottomCenter: {
    type: "center",
    name: "floating-bottom",
    getRowCtrls: nn,
    getSpannedRowCtrls: ea
  },
  bottomLeft: {
    type: "left",
    name: "pinned-left-floating-bottom",
    container: "ag-pinned-left-floating-bottom",
    pinnedType: "left",
    getRowCtrls: nn,
    getSpannedRowCtrls: ea
  },
  bottomRight: {
    type: "right",
    name: "pinned-right-floating-bottom",
    container: "ag-pinned-right-floating-bottom",
    pinnedType: "right",
    getRowCtrls: nn,
    getSpannedRowCtrls: ea
  },
  bottomFullWidth: {
    type: "fullWidth",
    name: "floating-bottom-full-width",
    fullWidth: !0,
    getRowCtrls: nn
  }
};
function jg(e) {
  return `ag-${zo(e).name}-viewport`;
}
function Mn(e) {
  const t = zo(e);
  return t.container ?? `ag-${t.name}-container`;
}
function ey(e) {
  return `ag-${zo(e).name}-spanned-cells-container`;
}
function zo(e) {
  return Jb[e];
}
var ty = ["topCenter", "topLeft", "topRight"], iy = ["bottomCenter", "bottomLeft", "bottomRight"], sy = ["center", "left", "right"], oy = ["center", "left", "right", "fullWidth"], ny = ["stickyTopCenter", "stickyBottomCenter", "center", "topCenter", "bottomCenter"], ry = ["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"], ay = ["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"], qg = ["stickyTopCenter", "stickyTopLeft", "stickyTopRight"], Yg = ["stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"], ly = [
  ...qg,
  "stickyTopFullWidth",
  ...Yg,
  "stickyBottomFullWidth"
], dy = [
  ...ty,
  ...iy,
  ...sy,
  ...qg,
  ...Yg
], cy = class extends E {
  constructor(e) {
    super(), this.name = e, this.visible = !0, this.EMPTY_CTRLS = [], this.options = zo(e);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.forContainers(["center"], () => {
      this.viewportSizeFeature = this.createManagedBean(new Nb(this)), this.addManagedEventListeners({
        stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this)
      });
    });
  }
  onStickyTopOffsetChanged(e) {
    this.comp.setOffsetTop(`${e.offset}px`);
  }
  registerWithCtrlsService() {
    this.options.fullWidth || this.beans.ctrlsSvc.register(this.name, this);
  }
  forContainers(e, t) {
    e.indexOf(this.name) >= 0 && t();
  }
  setComp(e, t, i, s) {
    this.comp = e, this.eContainer = t, this.eSpannedContainer = i, this.eViewport = s, this.createManagedBean(new Zb(this.eViewport ?? this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder();
    const { pinnedCols: o, rangeSvc: n } = this.beans, r = () => this.onPinnedWidthChanged();
    this.forContainers(ry, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        o == null ? void 0 : o.createPinnedWidthFeature(!0, this.eContainer, this.eSpannedContainer)
      ), this.addManagedEventListeners({ leftPinnedWidthChanged: r });
    }), this.forContainers(ay, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        o == null ? void 0 : o.createPinnedWidthFeature(!1, this.eContainer, this.eSpannedContainer)
      ), this.addManagedEventListeners({ rightPinnedWidthChanged: r });
    }), this.forContainers(
      oy,
      () => this.createManagedBean(
        new Kg(this.eContainer, this.name === "center" ? s : void 0)
      )
    ), n && this.forContainers(
      dy,
      () => this.createManagedBean(n.createDragListenerFeature(this.eContainer))
    ), this.forContainers(
      ny,
      () => this.createManagedBean(new jl((a) => this.comp.setContainerWidth(`${a}px`)))
    ), this.visible = this.isContainerVisible(), this.addListeners(), this.registerWithCtrlsService();
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.eViewport, { scroll: e });
  }
  addListeners() {
    const { spannedRowRenderer: e, gos: t } = this.beans, i = this.onDisplayedColumnsChanged.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: i,
      displayedColumnsWidthChanged: i,
      displayedRowsChanged: (s) => this.onDisplayedRowsChanged(s.afterScroll)
    }), i(), this.onDisplayedRowsChanged(), e && this.options.getSpannedRowCtrls && t.get("enableCellSpan") && this.addManagedListeners(e, {
      spannedRowsUpdated: () => {
        const s = this.options.getSpannedRowCtrls(e);
        s && this.comp.setSpannedRowCtrls(s, !1);
      }
    });
  }
  listenOnDomOrder() {
    if (ly.indexOf(this.name) >= 0) {
      this.comp.setDomOrder(!0);
      return;
    }
    const t = () => {
      const i = this.gos.get("ensureDomOrder"), s = Me(this.gos, "print");
      this.comp.setDomOrder(i || s);
    };
    this.addManagedPropertyListener("domLayout", t), t();
  }
  onDisplayedColumnsChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const { dragSvc: e } = this.beans;
    if (!e)
      return;
    const t = (i) => {
      e.dragging && i.cancelable && i.preventDefault();
    };
    this.eContainer.addEventListener("touchmove", t, { passive: !1 }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", t));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged(e = !1) {
    const t = this.getCenterWidth(), i = this.getCenterViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(t, i, e);
  }
  hasHorizontalScrollGap() {
    return this.eContainer.clientWidth - this.eViewport.clientWidth < 0;
  }
  hasVerticalScrollGap() {
    return this.eContainer.clientHeight - this.eViewport.clientHeight < 0;
  }
  getCenterWidth() {
    return So(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return Nn(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(e) {
    const t = di(this.beans, this.eViewport, e);
    this.addDestroyFunc(() => t());
  }
  isViewportInTheDOMTree() {
    return Ih(this.eViewport);
  }
  getViewportScrollLeft() {
    return Nn(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    return this.gos.get("alwaysShowHorizontalScroll") || El(this.eViewport);
  }
  setHorizontalScroll(e) {
    this.comp.setHorizontalScroll(e);
  }
  getHScrollPosition() {
    return {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
  }
  setCenterViewportScrollLeft(e) {
    Wn(this.eViewport, e, this.enableRtl);
  }
  isContainerVisible() {
    return !(this.options.pinnedType != null) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const e = this.isContainerVisible();
    this.visible != e && (this.visible = e, this.onDisplayedRowsChanged());
  }
  onDisplayedRowsChanged(e = !1) {
    const t = this.options.getRowCtrls(this.beans.rowRenderer);
    if (!this.visible || t.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const i = Me(this.gos, "print"), o = this.gos.get("embedFullWidthRows") || i, n = t.filter((r) => {
      const a = r.isFullWidth();
      return this.options.fullWidth ? !o && a : o || !a;
    });
    this.comp.setRowCtrls({ rowCtrls: n, useFlushSync: e });
  }
}, Qg = "ag-force-vertical-scroll", uy = "ag-selectable", hy = "ag-column-moving", gy = class extends E {
  constructor() {
    super(...arguments), this.stickyTopHeight = 0, this.stickyBottomHeight = 0;
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.colModel = e.colModel, this.scrollVisibleSvc = e.scrollVisibleSvc, this.pinnedRowModel = e.pinnedRowModel, this.filterManager = e.filterManager, this.rowGroupColsSvc = e.rowGroupColsSvc;
  }
  setComp(e, t, i, s, o, n, r) {
    var a, l;
    this.comp = e, this.eGridBody = t, this.eBodyViewport = i, this.eTop = s, this.eBottom = o, this.eStickyTop = n, this.eStickyBottom = r, this.eCenterColsViewport = i.querySelector(`.${jg("center")}`), this.eFullWidthContainer = i.querySelector(`.${Mn("fullWidth")}`), this.eStickyTopFullWidthContainer = n.querySelector(
      `.${Mn("stickyTopFullWidth")}`
    ), this.eStickyBottomFullWidthContainer = r.querySelector(
      `.${Mn("stickyBottomFullWidth")}`
    ), this.setCellTextSelection(this.gos.get("enableCellTextSelection")), this.addManagedPropertyListener(
      "enableCellTextSelection",
      (d) => this.setCellTextSelection(d.currentValue)
    ), this.createManagedBean(new Kl(this.comp)), this.scrollFeature = this.createManagedBean(new Vb(i)), (a = this.beans.rowDragSvc) == null || a.setupRowDrag(i, this), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([s, i, o, n, r]), this.setGridRootRole(), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.updateScrollingClasses(), (l = this.filterManager) == null || l.setupAdvFilterHeaderComp(s), this.ctrlsSvc.register("gridBodyCtrl", this);
  }
  addEventListeners() {
    const e = this.setFloatingHeights.bind(this), t = this.setGridRootRole.bind(this), i = this.toggleRowResizeStyles.bind(this);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
      scrollGapChanged: this.updateScrollingClasses.bind(this),
      pinnedRowDataChanged: e,
      pinnedHeightChanged: e,
      pinnedRowsChanged: e,
      headerHeightChanged: this.setStickyTopOffsetTop.bind(this),
      columnRowGroupChanged: t,
      columnPivotChanged: t,
      rowResizeStarted: i,
      rowResizeEnded: i
    }), this.addManagedPropertyListener("treeData", t);
  }
  toggleRowResizeStyles(e) {
    const t = e.type === "rowResizeStarted";
    this.eBodyViewport.classList.toggle("ag-prevent-animation", t);
  }
  onGridColumnsChanged() {
    const e = this.beans.colModel.getCols();
    this.comp.setColumnCount(e.length);
  }
  onScrollVisibilityChanged() {
    const { scrollVisibleSvc: e } = this, t = e.verticalScrollShowing;
    this.setVerticalScrollPaddingVisible(t), this.setStickyWidth(t), this.setStickyBottomOffsetBottom();
    const i = t && e.getScrollbarWidth() || 0, s = Rg() ? 16 : 0, o = `calc(100% + ${i + s}px)`;
    $t(this.beans, () => this.comp.setBodyViewportWidth(o)), this.updateScrollingClasses();
  }
  setGridRootRole() {
    const { rowGroupColsSvc: e, colModel: t } = this;
    let i = this.gos.get("treeData");
    if (!i) {
      const s = t.isPivotMode();
      i = (e ? e.columns.length : 0) >= (s ? 2 : 1);
    }
    this.comp.setGridRootRole(i ? "treegrid" : "grid");
  }
  addFocusListeners(e) {
    e.forEach((t) => {
      this.addManagedElementListeners(t, {
        focusin: (i) => {
          const { target: s } = i, o = Ei(s, "ag-root", t);
          t.classList.toggle("ag-has-focus", !o);
        },
        focusout: (i) => {
          const { target: s, relatedTarget: o } = i, n = t.contains(o), r = Ei(
            o,
            "ag-root",
            t
          );
          Ei(s, "ag-root", t) || (!n || r) && t.classList.remove("ag-has-focus");
        }
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(e) {
    this.comp.setColumnMovingCss(hy, e);
  }
  setCellTextSelection(e = !1) {
    this.comp.setCellSelectableCss(uy, e);
  }
  updateScrollingClasses() {
    const {
      eGridBody: { classList: e },
      scrollVisibleSvc: t
    } = this;
    e.toggle("ag-body-vertical-content-no-gap", !t.verticalScrollGap), e.toggle("ag-body-horizontal-content-no-gap", !t.horizontalScrollGap);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedElementListeners(this.eGridBody, {
      dragstart: (e) => {
        if (e.target instanceof HTMLImageElement)
          return e.preventDefault(), !1;
      }
    });
  }
  addStopEditingWhenGridLosesFocus() {
    var e;
    (e = this.beans.editSvc) == null || e.addStopEditingWhenGridLosesFocus([
      this.eBodyViewport,
      this.eBottom,
      this.eTop,
      this.eStickyTop,
      this.eStickyBottom
    ]);
  }
  updateRowCount() {
    var o, n;
    const e = (((o = this.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : o.getRowCount()) ?? 0) + (((n = this.filterManager) == null ? void 0 : n.getHeaderRowCount()) ?? 0), { rowModel: t } = this.beans, i = t.isLastRowIndexKnown() ? t.getRowCount() : -1, s = i === -1 ? -1 : e + i;
    this.comp.setRowCount(s);
  }
  registerBodyViewportResizeListener(e) {
    this.comp.registerBodyViewportResizeListener(e);
  }
  setVerticalScrollPaddingVisible(e) {
    const t = e ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(t);
  }
  isVerticalScrollShowing() {
    const e = this.gos.get("alwaysShowVerticalScroll"), t = e ? Qg : null, i = Me(this.gos, "normal");
    return this.comp.setAlwaysVerticalScrollClass(t, e), e || i && Oh(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    const { rowContainerHeight: e, environment: t } = this.beans;
    let i = t.sizesMeasured;
    const s = () => {
      const o = i && as(this.gos) && !e.stretching, n = o ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(n, o);
    };
    s(), this.addManagedEventListeners({ heightScaleChanged: s }), this.addManagedPropertyListener("animateRows", s), this.addManagedEventListeners({
      gridStylesChanged: () => {
        !i && t.sizesMeasured && (i = !0, s());
      }
    });
  }
  addBodyViewportListener() {
    const {
      eBodyViewport: e,
      eStickyTop: t,
      eStickyBottom: i,
      eTop: s,
      eBottom: o,
      beans: { popupSvc: n, touchSvc: r }
    } = this, a = this.onBodyViewportContextMenu.bind(this);
    this.addManagedElementListeners(e, { contextmenu: a }), r == null || r.mockBodyContextMenu(this, a), this.addManagedElementListeners(e, {
      wheel: this.onBodyViewportWheel.bind(this, n)
    });
    const l = this.onStickyWheel.bind(this);
    for (const c of [t, i, s, o])
      this.addManagedElementListeners(c, { wheel: l });
    const d = this.onHorizontalWheel.bind(this);
    for (const c of ["left", "right", "topLeft", "topRight", "bottomLeft", "bottomRight"])
      this.addManagedElementListeners(this.ctrlsSvc.get(c).eContainer, {
        wheel: d
      });
    this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    this.addManagedElementListeners(this.eFullWidthContainer, {
      wheel: (e) => this.onFullWidthContainerWheel(e)
    });
  }
  onFullWidthContainerWheel(e) {
    const { deltaX: t, deltaY: i, shiftKey: s } = e;
    (s || Math.abs(t) > Math.abs(i)) && Ro(this.beans, e) && this.scrollGridBodyToMatchEvent(e);
  }
  onStickyWheel(e) {
    const { deltaY: t } = e;
    this.scrollVertically(t) > 0 && e.preventDefault();
  }
  onHorizontalWheel(e) {
    const { deltaX: t, deltaY: i, shiftKey: s } = e;
    (s || Math.abs(t) > Math.abs(i)) && this.scrollGridBodyToMatchEvent(e);
  }
  scrollGridBodyToMatchEvent(e) {
    const { deltaX: t, deltaY: i } = e;
    e.preventDefault(), this.eCenterColsViewport.scrollBy({ left: t || i });
  }
  onBodyViewportContextMenu(e, t, i) {
    var o;
    if (!e && !i)
      return;
    this.gos.get("preventDefaultOnContextMenu") && (e || i).preventDefault();
    const { target: s } = e || t;
    (s === this.eBodyViewport || s === this.ctrlsSvc.get("center").eViewport) && ((o = this.beans.contextMenuSvc) == null || o.showContextMenu({
      mouseEvent: e,
      touchEvent: i,
      value: null,
      anchorToElement: this.eGridBody,
      source: "ui"
    }));
  }
  onBodyViewportWheel(e, t) {
    this.gos.get("suppressScrollWhenPopupsAreOpen") && e != null && e.hasAnchoredPopup() && t.preventDefault();
  }
  // called by rowDragFeature
  scrollVertically(e) {
    const t = this.eBodyViewport.scrollTop;
    return this.scrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t;
  }
  setFloatingHeights() {
    const {
      pinnedRowModel: e,
      beans: { environment: t }
    } = this, i = e == null ? void 0 : e.getPinnedTopTotalHeight(), s = e == null ? void 0 : e.getPinnedBottomTotalHeight(), o = t.getPinnedRowBorderWidth(), n = t.getRowBorderWidth(), r = o - n, a = i ? r + i : 0, l = s ? r + s : 0;
    this.comp.setTopHeight(a), this.comp.setBottomHeight(l), this.comp.setTopInvisible(a <= 0), this.comp.setBottomInvisible(l <= 0), this.setStickyTopOffsetTop(), this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(e = 0) {
    this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e;
  }
  setStickyBottomHeight(e = 0) {
    this.comp.setStickyBottomHeight(`${e}px`), this.stickyBottomHeight = e;
  }
  setStickyWidth(e) {
    if (!e)
      this.comp.setStickyTopWidth("100%"), this.comp.setStickyBottomWidth("100%");
    else {
      const t = this.scrollVisibleSvc.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${t}px)`), this.comp.setStickyBottomWidth(`calc(100% - ${t}px)`);
    }
  }
  setStickyTopOffsetTop() {
    var o, n;
    const t = this.ctrlsSvc.get("gridHeaderCtrl").headerHeight + (((o = this.filterManager) == null ? void 0 : o.getHeaderHeight()) ?? 0), i = ((n = this.pinnedRowModel) == null ? void 0 : n.getPinnedTopTotalHeight()) ?? 0;
    let s = 0;
    t > 0 && (s += t), i > 0 && (s += i), s > 0 && (s += 1), this.comp.setStickyTopTop(`${s}px`);
  }
  setStickyBottomOffsetBottom() {
    const { pinnedRowModel: e, scrollVisibleSvc: t, comp: i } = this, s = (e == null ? void 0 : e.getPinnedBottomTotalHeight()) ?? 0, n = t.horizontalScrollShowing && t.getScrollbarWidth() || 0, r = s + n;
    i.setStickyBottomBottom(`${r}px`);
  }
};
function py(e, t) {
  var i;
  return ((i = ql(e, t.target)) == null ? void 0 : i.getFocusedCellPosition()) ?? null;
}
function mc(e, t) {
  const i = Me(e.gos, "normal"), s = t;
  let o, n;
  s.clientX != null || s.clientY != null ? (o = s.clientX, n = s.clientY) : (o = s.x, n = s.y);
  const { pageFirstPixel: r } = e.pageBounds.getCurrentPagePixelRange();
  if (n += r, i) {
    const a = e.ctrlsSvc.getScrollFeature(), l = a.getVScrollPosition(), d = a.getHScrollPosition();
    o += d.left, n += l.top;
  }
  return { x: o, y: n };
}
var Xg = class extends te {
  constructor(e, t) {
    super(), this.direction = t, this.eViewport = _, this.eContainer = _, this.hideTimeout = 0, this.setTemplate(e);
  }
  postConstruct() {
    this.addManagedEventListeners({
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this)
    }), this.onScrollVisibilityChanged(), this.toggleCss("ag-apple-scrollbar", yg() || Mi());
  }
  destroy() {
    super.destroy(), window.clearTimeout(this.hideTimeout);
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.invisibleScrollbar = Rg(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()));
  }
  addActiveListenerToggles() {
    const e = this.getGui(), t = () => this.toggleCss("ag-scrollbar-active", !0), i = () => this.toggleCss("ag-scrollbar-active", !1);
    this.addManagedListeners(e, {
      mouseenter: t,
      mousedown: t,
      touchstart: t,
      mouseleave: i,
      touchend: i
    });
  }
  onScrollVisibilityChanged() {
    this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(), $t(this.beans, () => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedEventListeners({
      bodyScroll: (e) => {
        e.direction === this.direction && (this.hideTimeout && (window.clearTimeout(this.hideTimeout), this.hideTimeout = 0), this.toggleCss("ag-scrollbar-scrolling", !0));
      },
      bodyScrollEnd: () => {
        this.hideTimeout = window.setTimeout(() => {
          this.toggleCss("ag-scrollbar-scrolling", !1), this.hideTimeout = 0;
        }, 400);
      }
    });
  }
  attemptSettingScrollPosition(e) {
    const t = this.eViewport;
    DC(
      this,
      () => Mt(t),
      () => this.setScrollPosition(e),
      100
    );
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.eViewport, { scroll: e });
  }
}, fy = {
  tag: "div",
  cls: "ag-body-horizontal-scroll",
  attrs: { "aria-hidden": "true" },
  children: [
    { tag: "div", ref: "eLeftSpacer", cls: "ag-horizontal-left-spacer" },
    {
      tag: "div",
      ref: "eViewport",
      cls: "ag-body-horizontal-scroll-viewport",
      children: [{ tag: "div", ref: "eContainer", cls: "ag-body-horizontal-scroll-container" }]
    },
    { tag: "div", ref: "eRightSpacer", cls: "ag-horizontal-right-spacer" }
  ]
}, my = class extends Xg {
  constructor() {
    super(fy, "horizontal"), this.eLeftSpacer = _, this.eRightSpacer = _, this.setScrollVisibleDebounce = 0;
  }
  wireBeans(e) {
    this.visibleCols = e.visibleCols, this.scrollVisibleSvc = e.scrollVisibleSvc;
  }
  postConstruct() {
    super.postConstruct();
    const e = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e,
      pinnedRowDataChanged: this.refreshCompBottom.bind(this)
    }), this.addManagedPropertyListener("domLayout", e), this.beans.ctrlsSvc.register("fakeHScrollComp", this), this.createManagedBean(new jl((t) => this.eContainer.style.width = `${t}px`)), this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  destroy() {
    window.clearTimeout(this.setScrollVisibleDebounce), super.destroy();
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.enableRtl = this.gos.get("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom());
  }
  refreshCompBottom() {
    var t;
    if (!this.invisibleScrollbar)
      return;
    const e = ((t = this.beans.pinnedRowModel) == null ? void 0 : t.getPinnedBottomTotalHeight()) ?? 0;
    this.getGui().style.bottom = `${e}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const e = this.scrollVisibleSvc.verticalScrollShowing;
    let t = this.visibleCols.getDisplayedColumnsRightWidth();
    const i = !this.enableRtl && e, s = this.scrollVisibleSvc.getScrollbarWidth();
    i && (t += s), Ft(this.eRightSpacer, t), this.eRightSpacer.classList.toggle("ag-scroller-corner", t <= s);
    let o = this.visibleCols.getColsLeftWidth();
    this.enableRtl && e && (o += s), Ft(this.eLeftSpacer, o), this.eLeftSpacer.classList.toggle("ag-scroller-corner", o <= s);
  }
  setScrollVisible() {
    const e = this.scrollVisibleSvc.horizontalScrollShowing, t = this.invisibleScrollbar, i = this.gos.get("suppressHorizontalScroll"), s = e && this.scrollVisibleSvc.getScrollbarWidth() || 0, n = i ? 0 : s === 0 && t ? 16 : s, r = () => {
      this.setScrollVisibleDebounce = 0, this.toggleCss("ag-scrollbar-invisible", t), io(this.getGui(), n), io(this.eViewport, n), io(this.eContainer, n), n || this.eContainer.style.setProperty("min-height", "1px"), this.setVisible(e, { skipAriaHidden: !0 });
    };
    window.clearTimeout(this.setScrollVisibleDebounce), e ? this.setScrollVisibleDebounce = window.setTimeout(r, 100) : r();
  }
  getScrollPosition() {
    return Nn(this.eViewport, this.enableRtl);
  }
  setScrollPosition(e) {
    Mt(this.eViewport) || this.attemptSettingScrollPosition(e), Wn(this.eViewport, e, this.enableRtl);
  }
}, Cy = {
  selector: "AG-FAKE-HORIZONTAL-SCROLL",
  component: my
}, vy = {
  tag: "div",
  cls: "ag-body-vertical-scroll",
  attrs: { "aria-hidden": "true" },
  children: [
    {
      tag: "div",
      ref: "eViewport",
      cls: "ag-body-vertical-scroll-viewport",
      children: [{ tag: "div", ref: "eContainer", cls: "ag-body-vertical-scroll-container" }]
    }
  ]
}, wy = class extends Xg {
  constructor() {
    super(vy, "vertical");
  }
  postConstruct() {
    super.postConstruct(), this.createManagedBean(new Kg(this.eContainer));
    const { ctrlsSvc: e } = this.beans;
    e.register("fakeVScrollComp", this), this.addManagedEventListeners({
      rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this, e)
    });
  }
  setScrollVisible() {
    const { scrollVisibleSvc: e } = this.beans, t = e.verticalScrollShowing, i = this.invisibleScrollbar, s = t && e.getScrollbarWidth() || 0, o = s === 0 && i ? 16 : s;
    this.toggleCss("ag-scrollbar-invisible", i), Ft(this.getGui(), o), Ft(this.eViewport, o), Ft(this.eContainer, o), this.setDisplayed(t, { skipAriaHidden: !0 });
  }
  onRowContainerHeightChanged(e) {
    const i = e.getGridBodyCtrl().eBodyViewport, s = this.getScrollPosition(), o = i.scrollTop;
    s != o && this.setScrollPosition(o, !0);
  }
  getScrollPosition() {
    return this.eViewport.scrollTop;
  }
  setScrollPosition(e, t) {
    !t && !Mt(this.eViewport) && this.attemptSettingScrollPosition(e), this.eViewport.scrollTop = e;
  }
}, by = {
  selector: "AG-FAKE-VERTICAL-SCROLL",
  component: wy
}, yy = "ag-column-first", Sy = "ag-column-last";
function Zg(e, t, i, s) {
  return de(e) ? [] : xy(e.headerClass, e, t, i, s);
}
function Jg(e, t, i) {
  e.toggleCss(yy, i.isColAtEdge(t, "first")), e.toggleCss(Sy, i.isColAtEdge(t, "last"));
}
function Ry(e, t, i, s) {
  return W(t, {
    // bad naming, as colDef here can be a group or a column,
    // however most people won't appreciate the difference,
    // so keeping it as colDef to avoid confusion.
    colDef: e,
    column: i,
    columnGroup: s
  });
}
function xy(e, t, i, s, o) {
  if (de(e))
    return [];
  let n;
  if (typeof e == "function") {
    const r = Ry(t, i, s, o);
    n = e(r);
  } else
    n = e;
  return typeof n == "string" ? [n] : Array.isArray(n) ? [...n] : [];
}
function Fy(e, t, i) {
  t.addManagedElementListeners(i, {
    keydown: (s) => {
      if (!s.defaultPrevented && s.key === P.TAB) {
        const o = s.shiftKey;
        zi(e, i, !1, o) || Ss(e, o) && s.preventDefault();
      }
    }
  });
}
function Py(e, t) {
  return e.ctrlsSvc.get("gridCtrl").focusInnerElement(t);
}
function Ai(e) {
  var t;
  return e.gos.get("suppressHeaderFocus") || !!((t = e.overlays) != null && t.isExclusive());
}
function Sr(e) {
  var t;
  return e.gos.get("suppressCellFocus") || !!((t = e.overlays) != null && t.isExclusive());
}
function Ss(e, t, i = !1) {
  const s = e.ctrlsSvc.get("gridCtrl");
  return !i && s.focusNextInnerContainer(t) ? !0 : ((i || !t && !s.isDetailGrid()) && s.forceFocusOutOfContainer(t), !1);
}
function xt(e) {
  var t;
  return ((t = e.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : t.getRowCount()) ?? 0;
}
function Yl(e) {
  const t = [], i = e.ctrlsSvc.getHeaderRowContainerCtrls();
  for (const s of i) {
    if (!s)
      continue;
    const o = s.getGroupRowCount() || 0;
    for (let n = 0; n < o; n++) {
      const r = s.getGroupRowCtrlAtIndex(n), a = t[n];
      if (r) {
        const l = Ey(e, r);
        (a == null || l > a) && (t[n] = l);
      }
    }
  }
  return t;
}
function Ey(e, t) {
  let s = e.colModel.isPivotMode() ? Ty(e) : tp(e);
  const o = t.getHeaderCellCtrls();
  for (const n of o) {
    const { column: r } = n, a = r.getAutoHeaderHeight();
    a != null && a > s && r.isAutoHeaderHeight() && (s = a);
  }
  return s;
}
function Ql(e) {
  let i = e.colModel.isPivotMode() ? Dy(e) : Uo(e);
  return e.colModel.forAllCols((s) => {
    const o = s.getAutoHeaderHeight();
    o != null && o > i && s.isAutoHeaderHeight() && (i = o);
  }), i;
}
function Uo(e) {
  return e.gos.get("headerHeight") ?? e.environment.getDefaultHeaderHeight();
}
function ep(e) {
  return e.gos.get("floatingFiltersHeight") ?? Uo(e);
}
function tp(e) {
  return e.gos.get("groupHeaderHeight") ?? Uo(e);
}
function Dy(e) {
  return e.gos.get("pivotHeaderHeight") ?? Uo(e);
}
function Ty(e) {
  return e.gos.get("pivotGroupHeaderHeight") ?? tp(e);
}
var My = class extends E {
  setComp(e, t, i) {
    this.comp = e, this.eGui = t;
    const { beans: s } = this, { headerNavigation: o, touchSvc: n, ctrlsSvc: r } = s;
    o && this.createManagedBean(
      new Ts(i, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addManagedEventListeners({
      columnPivotModeChanged: this.onPivotModeChanged.bind(this, s),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this, s)
    }), this.onPivotModeChanged(s), this.setupHeaderHeight();
    const a = this.onHeaderContextMenu.bind(this);
    this.addManagedElementListeners(this.eGui, { contextmenu: a }), n == null || n.mockHeaderContextMenu(this, a), r.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const e = this.setHeaderHeight.bind(this);
    e(), this.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      e
    ), this.addManagedEventListeners({
      headerRowsChanged: e,
      columnHeaderHeightChanged: e,
      // add this to the animation frame to avoid a feedback loop
      columnGroupHeaderHeightChanged: () => $t(this.beans, () => e()),
      gridStylesChanged: e,
      advancedFilterEnabledChanged: e
    });
  }
  setHeaderHeight() {
    var n;
    const { beans: e } = this;
    let t = 0;
    const i = Yl(e).reduce((r, a) => r + a, 0), s = Ql(e);
    if ((n = e.filterManager) != null && n.hasFloatingFilters() && (t += ep(e)), t += i, t += s, this.headerHeight === t)
      return;
    this.headerHeight = t;
    const o = `${t + 1}px`;
    this.comp.setHeightAndMinHeight(o), this.eventSvc.dispatchEvent({
      type: "headerHeightChanged"
    });
  }
  onPivotModeChanged(e) {
    const t = e.colModel.isPivotMode();
    this.comp.toggleCss("ag-pivot-on", t), this.comp.toggleCss("ag-pivot-off", !t);
  }
  onDisplayedColumnsChanged(e) {
    const i = e.visibleCols.allCols.some((s) => s.isSpanHeaderHeight());
    this.comp.toggleCss("ag-header-allow-overflow", i);
  }
  onTabKeyDown(e) {
    const t = this.gos.get("enableRtl"), i = e.shiftKey, s = i !== t ? "LEFT" : "RIGHT", { beans: o } = this, { headerNavigation: n, focusSvc: r } = o;
    (n.navigateHorizontally(s, !0, e) || !i && r.focusOverlay(!1) || Ss(o, i, !0)) && e.preventDefault();
  }
  handleKeyDown(e) {
    let t = null;
    const { headerNavigation: i } = this.beans;
    switch (e.key) {
      case P.LEFT:
        t = "LEFT";
      case P.RIGHT: {
        H(t) || (t = "RIGHT"), i.navigateHorizontally(t, !1, e) && e.preventDefault();
        break;
      }
      case P.UP:
        t = "UP";
      case P.DOWN: {
        H(t) || (t = "DOWN"), i.navigateVertically(t, e) && e.preventDefault();
        break;
      }
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget: t } = e, { eGui: i, beans: s } = this;
    !t && i.contains(he(s)) || i.contains(t) || (s.focusSvc.focusedHeader = null);
  }
  onHeaderContextMenu(e, t, i) {
    var r;
    const { menuSvc: s, ctrlsSvc: o } = this.beans;
    if (!e && !i || !(s != null && s.isHeaderContextMenuEnabled()))
      return;
    const { target: n } = e ?? t;
    (n === this.eGui || n === ((r = o.getHeaderRowContainerCtrl()) == null ? void 0 : r.eViewport)) && s.showHeaderContextMenu(void 0, e, i);
  }
}, Xl = class extends te {
  constructor(e, t) {
    super(e), this.ctrl = t;
  }
  getCtrl() {
    return this.ctrl;
  }
}, Ay = {
  tag: "div",
  cls: "ag-header-cell",
  role: "columnheader",
  children: [
    { tag: "div", ref: "eResize", cls: "ag-header-cell-resize", role: "presentation" },
    { tag: "div", ref: "eHeaderCompWrapper", cls: "ag-header-cell-comp-wrapper", role: "presentation" }
  ]
}, Iy = class extends Xl {
  constructor(e) {
    super(Ay, e), this.eResize = _, this.eHeaderCompWrapper = _, this.headerCompVersion = 0;
  }
  postConstruct() {
    const e = this.getGui(), t = () => {
      const s = this.ctrl.getSelectAllGui();
      s && (this.eResize.insertAdjacentElement("afterend", s), this.addDestroyFunc(() => s.remove()));
    }, i = {
      setWidth: (s) => e.style.width = s,
      toggleCss: (s, o) => this.toggleCss(s, o),
      setUserStyles: (s) => Go(e, s),
      setAriaSort: (s) => s ? nC(e, s) : rC(e),
      setUserCompDetails: (s) => this.setUserCompDetails(s),
      getUserCompInstance: () => this.headerComp,
      refreshSelectAllGui: t,
      removeSelectAllGui: () => {
        var s;
        return (s = this.ctrl.getSelectAllGui()) == null ? void 0 : s.remove();
      }
    };
    this.ctrl.setComp(i, this.getGui(), this.eResize, this.eHeaderCompWrapper, void 0), t();
  }
  destroy() {
    this.destroyHeaderComp(), super.destroy();
  }
  destroyHeaderComp() {
    this.headerComp && (this.eHeaderCompWrapper.removeChild(this.headerCompGui), this.headerComp = this.destroyBean(this.headerComp), this.headerCompGui = void 0);
  }
  setUserCompDetails(e) {
    this.headerCompVersion++;
    const t = this.headerCompVersion;
    e.newAgStackInstance().then((i) => this.afterCompCreated(t, i));
  }
  afterCompCreated(e, t) {
    if (e != this.headerCompVersion || !this.isAlive()) {
      this.destroyBean(t);
      return;
    }
    this.destroyHeaderComp(), this.headerComp = t, this.headerCompGui = t.getGui(), this.eHeaderCompWrapper.appendChild(this.headerCompGui), this.ctrl.setDragSource(this.getGui());
  }
}, ky = {
  tag: "div",
  cls: "ag-header-group-cell",
  role: "columnheader",
  children: [
    { tag: "div", ref: "eHeaderCompWrapper", cls: "ag-header-cell-comp-wrapper", role: "presentation" },
    { tag: "div", ref: "eResize", cls: "ag-header-cell-resize", role: "presentation" }
  ]
}, Ly = class extends Xl {
  constructor(e) {
    super(ky, e), this.eResize = _, this.eHeaderCompWrapper = _;
  }
  postConstruct() {
    const e = this.getGui(), t = (s, o) => o != null ? e.setAttribute(s, o) : e.removeAttribute(s), i = {
      toggleCss: (s, o) => this.toggleCss(s, o),
      setUserStyles: (s) => Go(e, s),
      setHeaderWrapperHidden: (s) => {
        s ? this.eHeaderCompWrapper.style.setProperty("display", "none") : this.eHeaderCompWrapper.style.removeProperty("display");
      },
      setHeaderWrapperMaxHeight: (s) => {
        s != null ? this.eHeaderCompWrapper.style.setProperty("max-height", `${s}px`) : this.eHeaderCompWrapper.style.removeProperty("max-height"), this.eHeaderCompWrapper.classList.toggle("ag-header-cell-comp-wrapper-limited-height", s != null);
      },
      setResizableDisplayed: (s) => le(this.eResize, s),
      setWidth: (s) => e.style.width = s,
      setAriaExpanded: (s) => t("aria-expanded", s),
      setUserCompDetails: (s) => this.setUserCompDetails(s),
      getUserCompInstance: () => this.headerGroupComp
    };
    this.ctrl.setComp(i, e, this.eResize, this.eHeaderCompWrapper, void 0);
  }
  setUserCompDetails(e) {
    e.newAgStackInstance().then((t) => this.afterHeaderCompCreated(t));
  }
  afterHeaderCompCreated(e) {
    const t = () => this.destroyBean(e);
    if (!this.isAlive()) {
      t();
      return;
    }
    const i = this.getGui(), s = e.getGui();
    this.eHeaderCompWrapper.appendChild(s), this.addDestroyFunc(t), this.headerGroupComp = e, this.ctrl.setDragSource(i);
  }
}, Oy = {
  tag: "div",
  cls: "ag-header-cell ag-floating-filter",
  role: "gridcell",
  children: [
    { tag: "div", ref: "eFloatingFilterBody", role: "presentation" },
    {
      tag: "div",
      ref: "eButtonWrapper",
      cls: "ag-floating-filter-button ag-hidden",
      role: "presentation",
      children: [
        {
          tag: "button",
          ref: "eButtonShowMainFilter",
          cls: "ag-button ag-floating-filter-button-button",
          attrs: { type: "button", tabindex: "-1" }
        }
      ]
    }
  ]
}, _y = class extends Xl {
  constructor(e) {
    super(Oy, e), this.eFloatingFilterBody = _, this.eButtonWrapper = _, this.eButtonShowMainFilter = _;
  }
  postConstruct() {
    const e = this.getGui(), t = {
      toggleCss: (i, s) => this.toggleCss(i, s),
      setUserStyles: (i) => Go(e, i),
      addOrRemoveBodyCssClass: (i, s) => this.eFloatingFilterBody.classList.toggle(i, s),
      setButtonWrapperDisplayed: (i) => le(this.eButtonWrapper, i),
      setCompDetails: (i) => this.setCompDetails(i),
      getFloatingFilterComp: () => this.compPromise,
      setWidth: (i) => e.style.width = i,
      setMenuIcon: (i) => this.eButtonShowMainFilter.appendChild(i)
    };
    this.ctrl.setComp(t, e, this.eButtonShowMainFilter, this.eFloatingFilterBody, void 0);
  }
  setCompDetails(e) {
    if (!e) {
      this.destroyFloatingFilterComp(), this.compPromise = null;
      return;
    }
    this.compPromise = e.newAgStackInstance(), this.compPromise.then((t) => this.afterCompCreated(t));
  }
  destroy() {
    this.destroyFloatingFilterComp(), super.destroy();
  }
  destroyFloatingFilterComp() {
    this.floatingFilterComp && (this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui()), this.floatingFilterComp = this.destroyBean(this.floatingFilterComp));
  }
  afterCompCreated(e) {
    if (e) {
      if (!this.isAlive()) {
        this.destroyBean(e);
        return;
      }
      this.destroyFloatingFilterComp(), this.floatingFilterComp = e, this.eFloatingFilterBody.appendChild(e.getGui()), e.afterGuiAttached && e.afterGuiAttached();
    }
  }
}, Hy = class extends te {
  constructor(e) {
    super({ tag: "div", cls: e.headerRowClass, role: "row" }), this.ctrl = e, this.headerComps = {};
  }
  postConstruct() {
    this.getGui().setAttribute("tabindex", String(this.gos.get("tabIndex"))), Gn(this.getGui(), this.ctrl.getAriaRowIndex());
    const t = {
      setHeight: (i) => this.getGui().style.height = i,
      setTop: (i) => this.getGui().style.top = i,
      setHeaderCtrls: (i, s) => this.setHeaderCtrls(i, s),
      setWidth: (i) => this.getGui().style.width = i,
      setRowIndex: (i) => Gn(this.getGui(), i)
    };
    this.ctrl.setComp(t, void 0);
  }
  destroy() {
    this.setHeaderCtrls([], !1), super.destroy();
  }
  setHeaderCtrls(e, t) {
    if (!this.isAlive())
      return;
    const i = this.headerComps;
    if (this.headerComps = {}, e.forEach((s) => {
      const o = s.instanceId;
      let n = i[o];
      delete i[o], n == null && (n = this.createHeaderComp(s), this.getGui().appendChild(n.getGui())), this.headerComps[o] = n;
    }), Object.values(i).forEach((s) => {
      this.getGui().removeChild(s.getGui()), this.destroyBean(s);
    }), t) {
      const s = Object.values(this.headerComps);
      s.sort(
        (n, r) => {
          const a = n.getCtrl().column.getLeft(), l = r.getCtrl().column.getLeft();
          return a - l;
        }
      );
      const o = s.map((n) => n.getGui());
      Lh(this.getGui(), o);
    }
  }
  createHeaderComp(e) {
    let t;
    switch (this.ctrl.type) {
      case "group":
        t = new Ly(e);
        break;
      case "filter":
        t = new _y(e);
        break;
      default:
        t = new Iy(e);
        break;
    }
    return this.createBean(t), t.setParentComponent(this), t;
  }
}, Zl = class extends E {
  constructor(e, t, i, s) {
    super(), this.columnOrGroup = e, this.eCell = t, this.colsSpanning = s, this.columnOrGroup = e, this.ariaEl = t.querySelector("[role=columnheader]") || t, this.beans = i;
  }
  setColsSpanning(e) {
    this.colsSpanning = e, this.onLeftChanged();
  }
  getColumnOrGroup() {
    const { beans: e, colsSpanning: t } = this;
    return e.gos.get("enableRtl") && t ? se(t) : this.columnOrGroup;
  }
  postConstruct() {
    const e = this.onLeftChanged.bind(this);
    this.addManagedListeners(this.columnOrGroup, { leftChanged: e }), this.setLeftFirstTime(), this.addManagedEventListeners({ displayedColumnsWidthChanged: e }), this.addManagedPropertyListener("domLayout", e);
  }
  setLeftFirstTime() {
    const { gos: e, colAnimation: t } = this.beans, i = e.get("suppressColumnMoveAnimation"), s = H(this.columnOrGroup.getOldLeft());
    (t == null ? void 0 : t.isActive()) && s && !i ? this.animateInLeft() : this.onLeftChanged();
  }
  animateInLeft() {
    const e = this.getColumnOrGroup(), t = this.modifyLeftForPrintLayout(e, e.getOldLeft()), i = this.modifyLeftForPrintLayout(e, e.getLeft());
    this.setLeft(t), this.actualLeft = i, this.beans.colAnimation.executeNextVMTurn(() => {
      this.actualLeft === i && this.setLeft(i);
    });
  }
  onLeftChanged() {
    const e = this.getColumnOrGroup(), t = e.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(e, t) {
    const { gos: i, visibleCols: s } = this.beans;
    if (!Me(i, "print") || e.getPinned() === "left")
      return t;
    const n = s.getColsLeftWidth();
    if (e.getPinned() === "right") {
      const r = s.bodyWidth;
      return n + r + t;
    }
    return n + t;
  }
  setLeft(e) {
    if (H(e) && (this.eCell.style.left = `${e}px`), be(this.columnOrGroup)) {
      const t = this.columnOrGroup.getLeafColumns();
      if (!t.length)
        return;
      t.length > 1 && oC(this.ariaEl, t.length);
    }
  }
}, By = 0, ip = "headerCtrl", Jl = class extends E {
  constructor(e, t) {
    super(), this.column = e, this.rowCtrl = t, this.resizeToggleTimeout = 0, this.resizeMultiplier = 1, this.resizeFeature = null, this.lastFocusEvent = null, this.dragSource = null, this.reAttemptToFocus = !1, this.instanceId = e.getUniqueId() + "-" + By++;
  }
  postConstruct() {
    const e = this.refreshTabIndex.bind(this);
    this.addManagedPropertyListeners(["suppressHeaderFocus"], e), this.addManagedEventListeners({
      overlayExclusiveChanged: e
    });
  }
  setComp(e, t, i, s, o) {
    t.setAttribute("col-id", this.column.colIdSanitised), this.wireComp(e, t, i, s, o), this.reAttemptToFocus && (this.reAttemptToFocus = !1, this.focus(this.lastFocusEvent ?? void 0));
  }
  shouldStopEventPropagation(e) {
    const { headerRowIndex: t, column: i } = this.beans.focusSvc.focusedHeader, s = i.getDefinition(), o = s && s.suppressHeaderKeyboardEvent;
    if (!H(o))
      return !1;
    const n = W(this.gos, {
      colDef: s,
      column: i,
      headerRowIndex: t,
      event: e
    });
    return !!o(n);
  }
  getWrapperHasFocus() {
    return he(this.beans) === this.eGui;
  }
  setGui(e, t) {
    this.eGui = e, this.addDomData(t), t.addManagedListeners(this.beans.eventSvc, {
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    }), t.addManagedElementListeners(this.eGui, {
      focus: this.onGuiFocus.bind(this)
    }), this.onDisplayedColumnsChanged(), this.refreshTabIndex();
  }
  refreshHeaderStyles() {
    const e = this.column.getDefinition();
    if (!e)
      return;
    const { headerStyle: t } = e;
    let i;
    if (typeof t == "function") {
      const s = this.getHeaderClassParams();
      i = t(s);
    } else
      i = t;
    i && this.comp.setUserStyles(i);
  }
  onGuiFocus() {
    this.eventSvc.dispatchEvent({
      type: "headerFocused",
      column: this.column
    });
  }
  setupAutoHeight(e) {
    const { wrapperElement: t, checkMeasuringCallback: i, compBean: s } = e, { beans: o } = this, n = (u) => {
      if (!this.isAlive() || !s.isAlive())
        return;
      const { paddingTop: h, paddingBottom: g, borderBottomWidth: p, borderTopWidth: f } = Ni(this.eGui), m = h + g + p + f, v = t.offsetHeight + m;
      if (u < 5) {
        const R = Ee(o), b = !R || !R.contains(t), w = v == 0;
        if (b || w) {
          Ia(() => n(u + 1), "raf", o);
          return;
        }
      }
      this.setColHeaderHeight(this.column, v);
    };
    let r = !1, a;
    const l = () => {
      const u = this.column.isAutoHeaderHeight();
      u && !r && d(), !u && r && c();
    }, d = () => {
      r = !0, this.comp.toggleCss("ag-header-cell-auto-height", !0), n(0), a = di(this.beans, t, () => n(0));
    }, c = () => {
      r = !1, a && a(), this.comp.toggleCss("ag-header-cell-auto-height", !1), a = void 0;
    };
    l(), s.addDestroyFunc(() => c()), s.addManagedListeners(this.column, { widthChanged: () => r && n(0) }), s.addManagedEventListeners({
      sortChanged: () => {
        r && window.setTimeout(() => n(0));
      }
    }), i && i(l);
  }
  onDisplayedColumnsChanged() {
    const { comp: e, column: t, beans: i, eGui: s } = this;
    !e || !t || !s || (Jg(e, t, i.visibleCols), Eh(s, i.visibleCols.getAriaColIndex(t)));
  }
  addResizeAndMoveKeyboardListeners(e) {
    e.addManagedListeners(this.eGui, {
      keydown: this.onGuiKeyDown.bind(this),
      keyup: this.onGuiKeyUp.bind(this)
    });
  }
  refreshTabIndex() {
    const e = Ai(this.beans);
    this.eGui && Ue(this.eGui, "tabindex", e ? null : "-1");
  }
  onGuiKeyDown(e) {
    var n;
    const t = he(this.beans), i = e.key === P.LEFT || e.key === P.RIGHT;
    if (this.isResizing && (e.preventDefault(), e.stopImmediatePropagation()), // if elements within the header are focused, we don't process the event
    t !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
    !e.shiftKey && !e.altKey || ((this.isResizing || i) && (e.preventDefault(), e.stopImmediatePropagation()), !i))
      return;
    const o = e.key === P.LEFT !== this.gos.get("enableRtl") ? "left" : "right";
    if (e.altKey) {
      this.isResizing = !0, this.resizeMultiplier += 1;
      const r = this.getViewportAdjustedResizeDiff(e);
      this.resizeHeader(r, e.shiftKey), (n = this.resizeFeature) == null || n.toggleColumnResizing(!0);
    } else
      this.moveHeader(o);
  }
  moveHeader(e) {
    var t;
    (t = this.beans.colMoves) == null || t.moveHeader(e, this.eGui, this.column, this.rowCtrl.pinned, this);
  }
  getViewportAdjustedResizeDiff(e) {
    const t = this.getResizeDiff(e), { pinnedCols: i } = this.beans;
    return i ? i.getHeaderResizeDiff(t, this.column) : t;
  }
  getResizeDiff(e) {
    const { gos: t, column: i } = this;
    let s = e.key === P.LEFT !== t.get("enableRtl");
    const o = i.getPinned(), n = t.get("enableRtl");
    return o && n !== (o === "right") && (s = !s), (s ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    this.isResizing && (this.resizeToggleTimeout && (window.clearTimeout(this.resizeToggleTimeout), this.resizeToggleTimeout = 0), this.isResizing = !1, this.resizeMultiplier = 1, this.resizeToggleTimeout = window.setTimeout(() => {
      var e;
      (e = this.resizeFeature) == null || e.toggleColumnResizing(!1);
    }, 150));
  }
  handleKeyDown(e) {
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case P.PAGE_DOWN:
      case P.PAGE_UP:
      case P.PAGE_HOME:
      case P.PAGE_END:
        t && e.preventDefault();
    }
  }
  addDomData(e) {
    const t = ip, { eGui: i, gos: s } = this;
    Oi(s, i, t, this), e.addDestroyFunc(() => Oi(s, i, t, null));
  }
  focus(e) {
    if (!this.isAlive())
      return !1;
    const { eGui: t } = this;
    return t ? (t.focus(), this.lastFocusEvent = e || null) : this.reAttemptToFocus = !0, !0;
  }
  focusThis() {
    this.beans.focusSvc.focusedHeader = { headerRowIndex: this.rowCtrl.rowIndex, column: this.column };
  }
  removeDragSource() {
    var e;
    this.dragSource && ((e = this.beans.dragAndDrop) == null || e.removeDragSource(this.dragSource), this.dragSource = null);
  }
  handleContextMenuMouseEvent(e, t, i) {
    const s = e ?? t, { menuSvc: o, gos: n } = this.beans;
    n.get("preventDefaultOnContextMenu") && s.preventDefault(), o != null && o.isHeaderContextMenuEnabled(i) && o.showHeaderContextMenu(i, e, t), this.dispatchColumnMouseEvent("columnHeaderContextMenu", i);
  }
  dispatchColumnMouseEvent(e, t) {
    this.eventSvc.dispatchEvent({
      type: e,
      column: t
    });
  }
  setColHeaderHeight(e, t) {
    if (!e.setAutoHeaderHeight(t))
      return;
    const { eventSvc: i } = this;
    e.isColumn ? i.dispatchEvent({
      type: "columnHeaderHeightChanged",
      column: e,
      columns: [e],
      source: "autosizeColumnHeaderHeight"
    }) : i.dispatchEvent({
      type: "columnGroupHeaderHeightChanged",
      columnGroup: e,
      source: "autosizeColumnGroupHeaderHeight"
    });
  }
  clearComponent() {
    this.removeDragSource(), this.resizeFeature = null, this.comp = null, this.eGui = null;
  }
  destroy() {
    super.destroy(), this.column = null, this.lastFocusEvent = null, this.rowCtrl = null;
  }
}, Gy = class extends Jl {
  constructor() {
    super(...arguments), this.refreshFunctions = {}, this.userHeaderClasses = /* @__PURE__ */ new Set(), this.ariaDescriptionProperties = /* @__PURE__ */ new Map();
  }
  wireComp(e, t, i, s, o) {
    this.comp = e;
    const { rowCtrl: n, column: r, beans: a } = this, { colResize: l, context: d, colHover: c, rangeSvc: u } = a, h = No(this, d, o);
    this.setGui(t, h), this.updateState(), this.setupWidth(h), this.setupMovingCss(h), this.setupMenuClass(h), this.setupSortableClass(h), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight({
      wrapperElement: s,
      checkMeasuringCallback: (p) => this.setRefreshFunction("measuring", p),
      compBean: h
    }), this.addColumnHoverListener(h), this.setupFilterClass(h), this.setupStylesFromColDef(), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(h), this.setupSelectAll(h), this.setupUserComp(), this.refreshAria(), l ? this.resizeFeature = h.createManagedBean(
      l.createResizeFeature(n.pinned, r, i, e, this)
    ) : le(i, !1), c == null || c.createHoverFeature(h, [r], t), u == null || u.createRangeHighlightFeature(h, r, e), h.createManagedBean(new Zl(r, t, a)), h.createManagedBean(
      new Ts(t, {
        shouldStopEventPropagation: (p) => this.shouldStopEventPropagation(p),
        onTabKeyDown: () => null,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addResizeAndMoveKeyboardListeners(h), h.addManagedPropertyListeners(
      ["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader", "enableAdvancedFilter"],
      () => this.refresh()
    ), h.addManagedListeners(r, { colDefChanged: () => this.refresh() }), h.addManagedListeners(r, { headerHighlightChanged: this.onHeaderHighlightChanged.bind(this) });
    const g = () => this.checkDisplayName();
    h.addManagedEventListeners({
      columnValueChanged: g,
      columnRowGroupChanged: g,
      columnPivotChanged: g,
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    }), h.addDestroyFunc(() => {
      this.refreshFunctions = {}, this.selectAllFeature = null, this.dragSourceElement = void 0, this.userCompDetails = null, this.userHeaderClasses.clear(), this.ariaDescriptionProperties.clear(), this.clearComponent();
    });
  }
  resizeHeader(e, t) {
    var i;
    (i = this.beans.colResize) == null || i.resizeHeader(this.column, e, t);
  }
  getHeaderClassParams() {
    const { column: e, beans: t } = this, i = e.colDef;
    return W(t.gos, {
      colDef: i,
      column: e,
      floatingFilter: !1
    });
  }
  setupUserComp() {
    const e = this.lookupUserCompDetails();
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setUserCompDetails(e);
  }
  lookupUserCompDetails() {
    const e = this.createParams(), t = this.column.getColDef();
    return zv(this.beans.userCompFactory, t, e);
  }
  createParams() {
    const { menuSvc: e, sortSvc: t, colFilter: i, gos: s } = this.beans;
    return W(s, {
      column: this.column,
      displayName: this.displayName,
      enableSorting: this.column.isSortable(),
      enableMenu: this.menuEnabled,
      enableFilterButton: this.openFilterEnabled && !!(e != null && e.isHeaderFilterButtonEnabled(this.column)),
      enableFilterIcon: !!i && (!this.openFilterEnabled || $e(this.gos)),
      showColumnMenu: (n, r) => {
        e == null || e.showColumnMenu({
          column: this.column,
          buttonElement: n,
          positionBy: "button",
          onClosedCallback: r
        });
      },
      showColumnMenuAfterMouseClick: (n, r) => {
        e == null || e.showColumnMenu({
          column: this.column,
          mouseEvent: n,
          positionBy: "mouse",
          onClosedCallback: r
        });
      },
      showFilter: (n) => {
        e == null || e.showFilterMenu({
          column: this.column,
          buttonElement: n,
          containerType: "columnFilter",
          positionBy: "button"
        });
      },
      progressSort: (n) => {
        t == null || t.progressSort(this.column, !!n, "uiColumnSorted");
      },
      setSort: (n, r) => {
        t == null || t.setSortForColumn(this.column, n, !!r, "uiColumnSorted");
      },
      eGridHeader: this.eGui,
      setTooltip: (n, r) => {
        s.assertModuleRegistered("Tooltip", 3), this.setupTooltip(n, r);
      }
    });
  }
  setupSelectAll(e) {
    var i;
    const { selectionSvc: t } = this.beans;
    t && (this.selectAllFeature = e.createOptionalManagedBean(t.createSelectAllFeature(this.column)), (i = this.selectAllFeature) == null || i.setComp(this), e.addManagedPropertyListener("rowSelection", () => {
      var o;
      const s = t.createSelectAllFeature(this.column);
      s && !this.selectAllFeature ? (this.selectAllFeature = e.createManagedBean(s), (o = this.selectAllFeature) == null || o.setComp(this), this.comp.refreshSelectAllGui()) : this.selectAllFeature && !s && (this.comp.removeSelectAllGui(), this.selectAllFeature = this.destroyBean(this.selectAllFeature));
    }));
  }
  getSelectAllGui() {
    var e;
    return (e = this.selectAllFeature) == null ? void 0 : e.getCheckboxGui();
  }
  handleKeyDown(e) {
    var t;
    super.handleKeyDown(e), e.key === P.SPACE && ((t = this.selectAllFeature) == null || t.onSpaceKeyDown(e)), e.key === P.ENTER && this.onEnterKeyDown(e), e.key === P.DOWN && e.altKey && this.showMenuOnKeyPress(e, !1);
  }
  onEnterKeyDown(e) {
    var t;
    e.ctrlKey || e.metaKey ? this.showMenuOnKeyPress(e, !0) : this.sortable && ((t = this.beans.sortSvc) == null || t.progressSort(this.column, e.shiftKey, "uiColumnSorted"));
  }
  showMenuOnKeyPress(e, t) {
    const i = this.comp.getUserCompInstance();
    Cc(i) && i.onMenuKeyboardShortcut(t) && e.preventDefault();
  }
  onFocusIn(e) {
    this.eGui.contains(e.relatedTarget) || (this.focusThis(), this.announceAriaDescription()), gw() && this.setActiveHeader(!0);
  }
  onFocusOut(e) {
    this.eGui.contains(e.relatedTarget) || this.setActiveHeader(!1);
  }
  setupTooltip(e, t) {
    var i;
    this.tooltipFeature = (i = this.beans.tooltipSvc) == null ? void 0 : i.setupHeaderTooltip(
      this.tooltipFeature,
      this,
      e,
      t
    );
  }
  setupStylesFromColDef() {
    this.setRefreshFunction("headerStyles", this.refreshHeaderStyles.bind(this)), this.refreshHeaderStyles();
  }
  setupClassesFromColDef() {
    const e = () => {
      const t = this.column.getColDef(), i = Zg(t, this.gos, this.column, null), s = this.userHeaderClasses;
      this.userHeaderClasses = new Set(i), i.forEach((o) => {
        s.has(o) ? s.delete(o) : this.comp.toggleCss(o, !0);
      }), s.forEach((o) => this.comp.toggleCss(o, !1));
    };
    this.setRefreshFunction("headerClasses", e), e();
  }
  setDragSource(e) {
    var t;
    this.dragSourceElement = e, this.removeDragSource(), !(!e || !this.draggable) && (this.dragSource = ((t = this.beans.colMoves) == null ? void 0 : t.setDragSourceForHeader(e, this.column, this.displayName)) ?? null);
  }
  updateState() {
    const { menuSvc: e } = this.beans;
    this.menuEnabled = !!(e != null && e.isColumnMenuInHeaderEnabled(this.column)), this.openFilterEnabled = !!(e != null && e.isFilterMenuInHeaderEnabled(this.column)), this.sortable = this.column.isSortable(), this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
  }
  setRefreshFunction(e, t) {
    this.refreshFunctions[e] = t;
  }
  refresh() {
    this.updateState(), this.refreshHeaderComp(), this.refreshAria(), Object.values(this.refreshFunctions).forEach((e) => e());
  }
  refreshHeaderComp() {
    const e = this.lookupUserCompDetails();
    if (!e)
      return;
    (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == e.componentClass ? this.attemptHeaderCompRefresh(e.params) : !1) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(e);
  }
  attemptHeaderCompRefresh(e) {
    const t = this.comp.getUserCompInstance();
    return !t || !t.refresh ? !1 : t.refresh(e);
  }
  calculateDisplayName() {
    return this.beans.colNames.getDisplayNameForColumn(this.column, "header", !0);
  }
  checkDisplayName() {
    this.displayName !== this.calculateDisplayName() && this.refresh();
  }
  workOutDraggable() {
    const e = this.column.getColDef();
    return !!(!this.gos.get("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot;
  }
  setupWidth(e) {
    const t = () => {
      const i = this.column.getActualWidth();
      this.comp.setWidth(`${i}px`);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupMovingCss(e) {
    const t = () => {
      this.comp.toggleCss("ag-header-cell-moving", this.column.isMoving());
    };
    e.addManagedListeners(this.column, { movingChanged: t }), t();
  }
  setupMenuClass(e) {
    const t = () => {
      var i;
      (i = this.comp) == null || i.toggleCss("ag-column-menu-visible", this.column.isMenuVisible());
    };
    e.addManagedListeners(this.column, { menuVisibleChanged: t }), t();
  }
  setupSortableClass(e) {
    const t = () => {
      this.comp.toggleCss("ag-header-cell-sortable", !!this.sortable);
    };
    t(), this.setRefreshFunction("updateSortable", t), e.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
  }
  setupFilterClass(e) {
    const t = () => {
      const i = this.column.isFilterActive();
      this.comp.toggleCss("ag-header-cell-filtered", i), this.refreshAria();
    };
    e.addManagedListeners(this.column, { filterActiveChanged: t }), t();
  }
  setupWrapTextClass() {
    const e = () => {
      const t = !!this.column.getColDef().wrapHeaderText;
      this.comp.toggleCss("ag-header-cell-wrap-text", t);
    };
    e(), this.setRefreshFunction("wrapText", e);
  }
  onHeaderHighlightChanged() {
    const e = this.column.getHighlighted(), t = e === 0, i = e === 1;
    this.comp.toggleCss("ag-header-highlight-before", t), this.comp.toggleCss("ag-header-highlight-after", i);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged(), this.isAlive() && this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    var h;
    const { eGui: e, column: t, comp: i, beans: s } = this, o = Yl(this.beans), n = o.reduce((g, p) => g += p, 0) === 0;
    if (i.toggleCss("ag-header-parent-hidden", n), !t.isSpanHeaderHeight()) {
      e.style.removeProperty("top"), e.style.removeProperty("height"), i.toggleCss("ag-header-span-height", !1), i.toggleCss("ag-header-span-total", !1);
      return;
    }
    const { numberOfParents: r, isSpanningTotal: a } = this.column.getColumnGroupPaddingInfo();
    i.toggleCss("ag-header-span-height", r > 0);
    const l = Ql(s);
    if (r === 0) {
      i.toggleCss("ag-header-span-total", !1), e.style.setProperty("top", "0px"), e.style.setProperty("height", `${l}px`);
      return;
    }
    i.toggleCss("ag-header-span-total", a);
    const d = (((h = this.column.getFirstRealParent()) == null ? void 0 : h.getLevel()) ?? -1) + 1, c = o.length - d;
    let u = 0;
    for (let g = 0; g < c; g++)
      u += o[o.length - 1 - g];
    e.style.setProperty("top", `${-u}px`), e.style.setProperty("height", `${l + u}px`);
  }
  refreshAriaSort() {
    var e;
    if (this.sortable) {
      const t = this.getLocaleTextFunc(), i = ((e = this.beans.sortSvc) == null ? void 0 : e.getDisplaySortForColumn(this.column)) || null;
      this.comp.setAriaSort(Km(i)), this.setAriaDescriptionProperty("sort", t("ariaSortableColumn", "Press ENTER to sort"));
    } else
      this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null);
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const e = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else
      this.setAriaDescriptionProperty("menu", null);
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !$e(this.gos)) {
      const e = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty(
        "filterButton",
        e("ariaFilterColumn", "Press CTRL ENTER to open filter")
      );
    } else
      this.setAriaDescriptionProperty("filterButton", null);
  }
  refreshAriaFiltered() {
    const e = this.getLocaleTextFunc();
    this.column.isFilterActive() ? this.setAriaDescriptionProperty("filter", e("ariaColumnFiltered", "Column Filtered")) : this.setAriaDescriptionProperty("filter", null);
  }
  setAriaDescriptionProperty(e, t) {
    t != null ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e);
  }
  announceAriaDescription() {
    var t;
    if (!this.eGui.contains(he(this.beans)))
      return;
    const e = Array.from(this.ariaDescriptionProperties.keys()).sort((i, s) => i === "filter" ? -1 : s.charCodeAt(0) - i.charCodeAt(0)).map((i) => this.ariaDescriptionProperties.get(i)).join(". ");
    (t = this.beans.ariaAnnounce) == null || t.announceValue(e, "columnHeader");
  }
  refreshAria() {
    this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaFilterButton(), this.refreshAriaFiltered();
  }
  addColumnHoverListener(e) {
    var t;
    (t = this.beans.colHover) == null || t.addHeaderColumnHoverListener(e, this.comp, this.column);
  }
  addActiveHeaderMouseListeners(e) {
    const t = (o) => this.handleMouseOverChange(o.type === "mouseenter"), i = () => {
      this.setActiveHeader(!0), this.dispatchColumnMouseEvent("columnHeaderClicked", this.column);
    }, s = (o) => this.handleContextMenuMouseEvent(o, void 0, this.column);
    e.addManagedListeners(this.eGui, {
      mouseenter: t,
      mouseleave: t,
      click: i,
      contextmenu: s
    });
  }
  handleMouseOverChange(e) {
    this.setActiveHeader(e), this.eventSvc.dispatchEvent({
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column
    });
  }
  setActiveHeader(e) {
    this.comp.toggleCss("ag-header-active", e);
  }
  getAnchorElementForMenu(e) {
    const t = this.comp.getUserCompInstance();
    return Cc(t) ? t.getAnchorElementForMenu(e) : this.eGui;
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature), super.destroy();
  }
};
function Cc(e) {
  return typeof (e == null ? void 0 : e.getAnchorElementForMenu) == "function" && typeof e.onMenuKeyboardShortcut == "function";
}
var Vy = 0, ta = class extends E {
  constructor(e, t, i) {
    super(), this.rowIndex = e, this.pinned = t, this.type = i, this.instanceId = Vy++, this.comp = null, this.allCtrls = [];
    let s = "ag-header-row-column";
    i === "group" ? s = "ag-header-row-group" : i === "filter" && (s = "ag-header-row-filter"), this.headerRowClass = `ag-header-row ${s}`;
  }
  setRowIndex(e) {
    var t;
    this.rowIndex = e, (t = this.comp) == null || t.setRowIndex(this.getAriaRowIndex()), this.onRowHeightChanged();
  }
  postConstruct() {
    this.isPrintLayout = Me(this.gos, "print"), this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  /** Checks that every header cell that is currently visible has been rendered.
   * Can only be false under some circumstances when using React
   */
  areCellsRendered() {
    return this.comp ? this.allCtrls.every((e) => e.eGui != null) : !1;
  }
  /**
   *
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */
  setComp(e, t, i = !0) {
    this.comp = e, t = No(this, this.beans.context, t), i && (this.setRowIndex(this.rowIndex), this.onVirtualColumnsChanged()), this.setWidth(), this.addEventListeners(t);
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners(e) {
    const t = this.onRowHeightChanged.bind(this), i = this.onDisplayedColumnsChanged.bind(this);
    e.addManagedEventListeners({
      columnResized: this.setWidth.bind(this),
      displayedColumnsChanged: i,
      virtualColumnsChanged: (s) => this.onVirtualColumnsChanged(s.afterScroll),
      columnGroupHeaderHeightChanged: t,
      columnHeaderHeightChanged: t,
      gridStylesChanged: t,
      advancedFilterEnabledChanged: t
    }), e.addManagedPropertyListener("domLayout", i), e.addManagedPropertyListener("ensureDomOrder", (s) => this.isEnsureDomOrder = s.currentValue), e.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      t
    );
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = Me(this.gos, "print"), this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged();
  }
  setWidth() {
    if (!this.comp)
      return;
    const e = this.getWidthForRow();
    this.comp.setWidth(`${e}px`);
  }
  getWidthForRow() {
    const { visibleCols: e } = this.beans;
    return this.isPrintLayout ? this.pinned != null ? 0 : e.getContainerWidth("right") + e.getContainerWidth("left") + e.getContainerWidth(null) : e.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    if (!this.comp)
      return;
    const { topOffset: e, rowHeight: t } = this.getTopAndHeight();
    this.comp.setTop(e + "px"), this.comp.setHeight(t + "px");
  }
  getTopAndHeight() {
    let e = 0;
    const t = Yl(this.beans);
    for (let o = 0; o < t.length; o++) {
      if (o === this.rowIndex && this.type === "group")
        return { topOffset: e, rowHeight: t[o] };
      e += t[o];
    }
    const i = Ql(this.beans);
    if (this.type === "column")
      return { topOffset: e, rowHeight: i };
    e += i;
    const s = ep(this.beans);
    return { topOffset: e, rowHeight: s };
  }
  onVirtualColumnsChanged(e = !1) {
    if (!this.comp)
      return;
    const t = this.getUpdatedHeaderCtrls(), i = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(t, i, e);
  }
  /**
   * Recycles the header cell ctrls and creates new ones for the columns in the viewport
   * @returns The updated header cell ctrls
   */
  getUpdatedHeaderCtrls() {
    const e = this.ctrlsById;
    this.ctrlsById = /* @__PURE__ */ new Map();
    const t = this.getColumnsInViewport();
    for (const s of t)
      this.recycleAndCreateHeaderCtrls(s, this.ctrlsById, e);
    const i = (s) => {
      const { focusSvc: o, visibleCols: n } = this.beans;
      return o.isHeaderWrapperFocused(s) ? n.isVisible(s.column) : !1;
    };
    if (e)
      for (const [s, o] of e)
        i(o) ? this.ctrlsById.set(s, o) : this.destroyBean(o);
    return this.allCtrls = Array.from(this.ctrlsById.values()), this.allCtrls;
  }
  /** Get the current header cell ctrls */
  getHeaderCellCtrls() {
    return this.allCtrls;
  }
  recycleAndCreateHeaderCtrls(e, t, i) {
    if (e.isEmptyGroup())
      return;
    const s = e.getUniqueId();
    let o;
    if (i && (o = i.get(s), i.delete(s)), o && o.column != e && (this.destroyBean(o), o = void 0), o == null)
      switch (this.type) {
        case "filter": {
          o = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerFilterCellCtrl",
              !0,
              e,
              this
            )
          );
          break;
        }
        case "group":
          o = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerGroupCellCtrl",
              !0,
              e,
              this
            )
          );
          break;
        default:
          o = this.createBean(new Gy(e, this));
          break;
      }
    t.set(s, o);
  }
  getColumnsInViewport() {
    if (!this.isPrintLayout)
      return this.getComponentsToRender();
    if (this.pinned)
      return [];
    const e = [];
    return ["left", null, "right"].forEach((t) => {
      e.push(...this.getComponentsToRender(t));
    }), e;
  }
  getComponentsToRender(e = this.pinned) {
    return this.type === "group" ? this.beans.colViewport.getHeadersToRender(e, this.rowIndex) : this.beans.colViewport.getColumnHeadersToRender(e);
  }
  focusHeader(e, t) {
    const i = this.allCtrls.find((o) => o.column == e);
    return i ? i.focus(t) : !1;
  }
  destroy() {
    this.allCtrls = this.destroyBeans(this.allCtrls), this.ctrlsById = void 0, this.comp = null, super.destroy();
  }
}, Ny = class extends E {
  constructor(e) {
    super(), this.pinned = e, this.hidden = !1, this.includeFloatingFilter = !1, this.groupsRowCtrls = [];
  }
  setComp(e, t) {
    this.comp = e, this.eViewport = t;
    const { pinnedCols: i, ctrlsSvc: s, colModel: o, colMoves: n } = this.beans;
    this.setupCenterWidth(), i == null || i.setupHeaderPinnedWidth(this), this.setupDragAndDrop(n, this.eViewport);
    const r = this.refresh.bind(this, !0);
    this.addManagedEventListeners({
      displayedColumnsChanged: r,
      advancedFilterEnabledChanged: r
    });
    const a = `${typeof this.pinned == "string" ? this.pinned : "center"}Header`;
    s.register(a, this), o.ready && this.refresh();
  }
  getAllCtrls() {
    const e = [...this.groupsRowCtrls];
    return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e;
  }
  refresh(e = !1) {
    const { focusSvc: t, filterManager: i, visibleCols: s } = this.beans;
    let o = 0;
    const n = t.getFocusHeaderToUseAfterRefresh(), r = () => {
      const u = s.headerGroupRowCount;
      o = u;
      const h = this.groupsRowCtrls.length;
      if (h !== u) {
        if (h > u) {
          for (let g = u; g < h; g++)
            this.destroyBean(this.groupsRowCtrls[g]);
          this.groupsRowCtrls.length = u;
          return;
        }
        for (let g = h; g < u; g++) {
          const p = this.createBean(new ta(g, this.pinned, "group"));
          this.groupsRowCtrls.push(p);
        }
      }
    }, a = () => {
      const u = o++;
      if (this.hidden) {
        this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
        return;
      }
      this.columnsRowCtrl == null || !e ? (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl), this.columnsRowCtrl = this.createBean(new ta(u, this.pinned, "column"))) : this.columnsRowCtrl.rowIndex !== u && this.columnsRowCtrl.setRowIndex(u);
    }, l = () => {
      this.includeFloatingFilter = !!(i != null && i.hasFloatingFilters()) && !this.hidden;
      const u = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        u();
        return;
      }
      e || u();
      const h = o++;
      this.filtersRowCtrl ? this.filtersRowCtrl.rowIndex !== h && this.filtersRowCtrl.setRowIndex(h) : this.filtersRowCtrl = this.createBean(new ta(h, this.pinned, "filter"));
    }, d = this.getAllCtrls();
    r(), a(), l();
    const c = this.getAllCtrls();
    this.comp.setCtrls(c), this.restoreFocusOnHeader(t, n), d.length !== c.length && this.beans.eventSvc.dispatchEvent({
      type: "headerRowsChanged"
    });
  }
  getHeaderCtrlForColumn(e) {
    const t = (i) => i == null ? void 0 : i.getHeaderCellCtrls().find((s) => s.column === e);
    if (ai(e))
      return t(this.columnsRowCtrl);
    if (this.groupsRowCtrls.length !== 0)
      for (let i = 0; i < this.groupsRowCtrls.length; i++) {
        const s = t(this.groupsRowCtrls[i]);
        if (s)
          return s;
      }
  }
  getHtmlElementForColumnHeader(e) {
    var t;
    return ((t = this.getHeaderCtrlForColumn(e)) == null ? void 0 : t.eGui) ?? null;
  }
  getRowType(e) {
    var t;
    return (t = this.getAllCtrls()[e]) == null ? void 0 : t.type;
  }
  focusHeader(e, t, i) {
    const o = this.getAllCtrls()[e];
    return o ? o.focusHeader(t, i) : !1;
  }
  getGroupRowCount() {
    return this.groupsRowCtrls.length;
  }
  getGroupRowCtrlAtIndex(e) {
    return this.groupsRowCtrls[e];
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  setHorizontalScroll(e) {
    this.comp.setViewportScrollLeft(e);
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.eViewport, { scroll: e });
  }
  destroy() {
    this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl), this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl), this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls), super.destroy();
  }
  setupDragAndDrop(e, t) {
    const i = e == null ? void 0 : e.createBodyDropTarget(this.pinned, t);
    i && this.createManagedBean(i);
  }
  restoreFocusOnHeader(e, t) {
    if (!t)
      return;
    const { column: i } = t;
    i.getPinned() == this.pinned && e.focusHeaderPosition({ headerPosition: t });
  }
  setupCenterWidth() {
    this.pinned == null && this.createManagedBean(new jl((e) => this.comp.setCenterWidth(`${e}px`), !0));
  }
}, Wy = class extends E {
  constructor() {
    super(...arguments), this.beanName = "menuSvc";
  }
  postConstruct() {
    const { enterpriseMenuFactory: e, filterMenuFactory: t } = this.beans;
    this.activeMenuFactory = e ?? t;
  }
  showColumnMenu(e) {
    this.showColumnMenuCommon(this.activeMenuFactory, e, "columnMenu");
  }
  showFilterMenu(e) {
    this.showColumnMenuCommon(wc(this.beans), e, e.containerType, !0);
  }
  showHeaderContextMenu(e, t, i) {
    var s;
    (s = this.activeMenuFactory) == null || s.showMenuAfterContextMenuEvent(e, t, i);
  }
  hidePopupMenu() {
    var e, t;
    (e = this.beans.contextMenuSvc) == null || e.hideActiveMenu(), (t = this.activeMenuFactory) == null || t.hideActiveMenu();
  }
  hideFilterMenu() {
    var e;
    (e = wc(this.beans)) == null || e.hideActiveMenu();
  }
  isColumnMenuInHeaderEnabled(e) {
    var i;
    const { suppressHeaderMenuButton: t } = e.getColDef();
    return !t && !!((i = this.activeMenuFactory) != null && i.isMenuEnabled(e)) && ($e(this.gos) || !!this.beans.enterpriseMenuFactory);
  }
  isFilterMenuInHeaderEnabled(e) {
    var t;
    return !e.getColDef().suppressHeaderFilterButton && !!((t = this.beans.filterManager) != null && t.isFilterAllowed(e));
  }
  isHeaderContextMenuEnabled(e) {
    const t = e && ai(e) ? e.getColDef() : e == null ? void 0 : e.getColGroupDef();
    return !(t != null && t.suppressHeaderContextMenu) && this.gos.get("columnMenu") === "new";
  }
  isHeaderMenuButtonAlwaysShowEnabled() {
    return this.isSuppressMenuHide();
  }
  isHeaderMenuButtonEnabled() {
    const e = !this.isSuppressMenuHide();
    return !(Mi() && e);
  }
  isHeaderFilterButtonEnabled(e) {
    return this.isFilterMenuInHeaderEnabled(e) && !$e(this.gos) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFilterMenuItemEnabled(e) {
    var t;
    return !!((t = this.beans.filterManager) != null && t.isFilterAllowed(e)) && !$e(this.gos) && !this.isFilterMenuInHeaderEnabled(e) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFloatingFilterButtonEnabled(e) {
    return !e.getColDef().suppressFloatingFilterButton;
  }
  isFloatingFilterButtonDisplayed(e) {
    return !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e);
  }
  isSuppressMenuHide() {
    const e = this.gos, t = e.get("suppressMenuHide");
    return $e(e) ? e.exists("suppressMenuHide") ? t : !1 : t;
  }
  showColumnMenuCommon(e, t, i, s) {
    const { positionBy: o, onClosedCallback: n } = t, r = t.column;
    if (o === "button") {
      const { buttonElement: a } = t;
      e == null || e.showMenuAfterButtonClick(r, a, i, n, s);
    } else if (o === "mouse") {
      const { mouseEvent: a } = t;
      e == null || e.showMenuAfterMouseEvent(r, a, i, n, s);
    } else if (r) {
      const a = this.beans, l = a.ctrlsSvc;
      l.getScrollFeature().ensureColumnVisible(r, "auto"), $t(a, () => {
        var c;
        const d = (c = l.getHeaderRowContainerCtrl(r.getPinned())) == null ? void 0 : c.getHeaderCtrlForColumn(r);
        d && (e == null || e.showMenuAfterButtonClick(
          r,
          d.getAnchorElementForMenu(s),
          i,
          n,
          s
        ));
      });
    }
  }
};
function vc(e, t, i) {
  e.menuVisible !== t && (e.menuVisible = t, e.dispatchColEvent("menuVisibleChanged", i));
}
function wc(e) {
  const { enterpriseMenuFactory: t, filterMenuFactory: i, gos: s } = e;
  return t && $e(s) ? t : i;
}
var Rr = class extends Ol {
  constructor() {
    super(...arguments), this.errorMessages = null;
  }
  init(e) {
    this.params = e, this.initialiseEditor(e), this.eEditor.onValueChange(() => e.validate());
  }
  destroy() {
    this.errorMessages = null;
  }
}, sp = class extends te {
  constructor() {
    super();
  }
}, zy = {
  tag: "span",
  cls: "ag-overlay-loading-center"
}, Uy = class extends sp {
  init() {
    var t;
    const e = Vt((t = this.gos.get("overlayLoadingTemplate")) == null ? void 0 : t.trim());
    if (this.setTemplate(e ?? zy), !e) {
      const s = this.getLocaleTextFunc()("loadingOoo", "Loading...");
      this.getGui().textContent = s, this.beans.ariaAnnounce.announceValue(s, "overlay");
    }
  }
}, $y = { tag: "span", cls: "ag-overlay-no-rows-center" }, Ky = class extends sp {
  init() {
    var t;
    const e = Vt((t = this.gos.get("overlayNoRowsTemplate")) == null ? void 0 : t.trim());
    if (this.setTemplate(e ?? $y), !e) {
      const s = this.getLocaleTextFunc()("noRowsToShow", "No Rows To Show");
      this.getGui().textContent = s, this.beans.ariaAnnounce.announceValue(s, "overlay");
    }
  }
};
function jy(e, t, i) {
  const s = Ze(e, t, i);
  if (s) {
    const { className: n } = s;
    if (typeof n == "string" && n.indexOf("ag-icon") > -1 || typeof n == "object" && n["ag-icon"])
      return s;
  }
  const o = ye({ tag: "span" });
  return o.appendChild(s), o;
}
function Ze(e, t, i) {
  var n;
  let s = null;
  e === "smallDown" ? I(262) : e === "smallLeft" ? I(263) : e === "smallRight" && I(264);
  const o = i && i.getColDef().icons;
  if (o && (s = o[e]), t.gos && !s) {
    const r = t.gos.get("icons");
    r && (s = r[e]);
  }
  if (s) {
    let r;
    if (typeof s == "function")
      r = s();
    else if (typeof s == "string")
      r = s;
    else {
      I(38, { iconName: e });
      return;
    }
    if (typeof r == "string")
      return Pl(r);
    if (Tl(r))
      return r;
    I(133, { iconName: e });
    return;
  } else {
    const r = t.registry.getIcon(e);
    return r || (n = t.validation) == null || n.validateIcon(e), ye({
      tag: "span",
      cls: `ag-icon ag-icon-${r ?? e}`,
      role: "presentation",
      attrs: { unselectable: "on" }
    });
  }
}
var qy = (
  /*css*/
  ".ag-dnd-ghost{align-items:center;background-color:var(--ag-drag-and-drop-image-background-color);border:var(--ag-drag-and-drop-image-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-drag-and-drop-image-shadow);color:var(--ag-text-color);cursor:move;display:flex;font-weight:500;gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);text-overflow:ellipsis;transform:translateY(calc(var(--ag-spacing)*2));white-space:nowrap}.ag-dnd-ghost-not-allowed{border:var(--ag-drag-and-drop-image-not-allowed-border)}"
), Yy = {
  tag: "div",
  children: [
    {
      tag: "div",
      ref: "eGhost",
      cls: "ag-dnd-ghost ag-unselectable",
      children: [
        { tag: "span", ref: "eIcon", cls: "ag-dnd-ghost-icon ag-shake-left-to-right" },
        { tag: "div", ref: "eLabel", cls: "ag-dnd-ghost-label" }
      ]
    }
  ]
}, Qy = class extends te {
  constructor() {
    super(), this.dragSource = null, this.eIcon = _, this.eLabel = _, this.eGhost = _, this.registerCSS(qy);
  }
  postConstruct() {
    const e = (t) => jy(t, this.beans, null);
    this.dropIconMap = {
      pinned: e("columnMovePin"),
      hide: e("columnMoveHide"),
      move: e("columnMoveMove"),
      left: e("columnMoveLeft"),
      right: e("columnMoveRight"),
      group: e("columnMoveGroup"),
      aggregate: e("columnMoveValue"),
      pivot: e("columnMovePivot"),
      notAllowed: e("dropNotAllowed")
    };
  }
  init(e) {
    this.dragSource = e.dragSource, this.setTemplate(Yy), this.beans.environment.applyThemeClasses(this.eGhost);
  }
  destroy() {
    this.dragSource = null, super.destroy();
  }
  setIcon(e, t) {
    const { eGhost: i, eIcon: s, dragSource: o, dropIconMap: n, gos: r } = this;
    Te(s);
    let a = null;
    e || (e = o != null && o.getDefaultIconName ? o.getDefaultIconName() : "notAllowed"), a = n[e], i.classList.toggle("ag-dnd-ghost-not-allowed", e === "notAllowed"), s.classList.toggle("ag-shake-left-to-right", t), !(a === n.hide && r.get("suppressDragLeaveHidesColumns")) && a && s.appendChild(a);
  }
  setLabel(e) {
    this.eLabel.textContent = e;
  }
}, Xy = (
  /*css*/
  ".ag-checkbox-cell{height:100%}"
), Zy = {
  tag: "div",
  cls: "ag-cell-wrapper ag-checkbox-cell",
  role: "presentation",
  children: [
    {
      tag: "ag-checkbox",
      ref: "eCheckbox",
      role: "presentation"
    }
  ]
}, Jy = class extends te {
  constructor() {
    super(Zy, [Bl]), this.eCheckbox = _, this.registerCSS(Xy);
  }
  init(e) {
    this.refresh(e);
    const { eCheckbox: t, beans: i } = this, s = t.getInputElement();
    s.setAttribute("tabindex", "-1"), Fh(s, "polite"), this.addManagedListeners(s, {
      click: (o) => {
        if (Bi(o), t.isDisabled())
          return;
        const n = t.getValue();
        this.onCheckboxChanged(n);
      },
      dblclick: (o) => {
        Bi(o);
      }
    }), this.addManagedElementListeners(e.eGridCell, {
      keydown: (o) => {
        if (o.key === P.SPACE && !t.isDisabled()) {
          e.eGridCell === he(i) && t.toggle();
          const n = t.getValue();
          this.onCheckboxChanged(n), o.preventDefault();
        }
      }
    });
  }
  refresh(e) {
    return this.params = e, this.updateCheckbox(e), !0;
  }
  updateCheckbox(e) {
    let t, i = !0;
    const { value: s, column: o, node: n } = e;
    if (n.group && o)
      if (typeof s == "boolean")
        t = s;
      else {
        const u = o.getColId();
        u.startsWith(vr) ? t = s == null || s === "" ? void 0 : s === "true" : n.aggData && n.aggData[u] !== void 0 || n.sourceRowIndex >= 0 ? t = s ?? void 0 : i = !1;
      }
    else
      t = s ?? void 0;
    const { eCheckbox: r } = this;
    if (!i) {
      r.setDisplayed(!1);
      return;
    }
    r.setValue(t);
    const a = e.disabled ?? !(o != null && o.isCellEditable(n));
    r.setDisabled(a);
    const l = this.getLocaleTextFunc(), d = Cr(l, t), c = a ? d : `${l("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${d})`;
    r.setInputAriaLabel(c);
  }
  onCheckboxChanged(e) {
    var r, a, l, d;
    const { params: t } = this, { column: i, node: s, value: o } = t;
    (a = (r = this.beans) == null ? void 0 : r.editSvc) == null || a.setEditingCells(
      [
        {
          column: i,
          colId: i.getColId(),
          rowIndex: s.rowIndex,
          rowPinned: s.rowPinned,
          state: "changed",
          oldValue: o,
          newValue: o
        }
      ],
      { update: !0, forceRefreshOfEditCellsOnly: !0 }
    );
    const n = s.setDataValue(i, e, "renderer");
    (d = this.beans.editSvc) == null || d.stopEditing(
      {
        rowNode: s,
        column: i
      },
      { source: (l = this.beans.editSvc) != null && l.isBatchEditing() ? "ui" : "api" }
    ), n || this.updateCheckbox(t);
  }
}, bc = class {
  constructor(e, t) {
    this.beans = e, this.floating = t, this.all = /* @__PURE__ */ new Set(), this.visible = /* @__PURE__ */ new Set(), this.order = [], this.queued = /* @__PURE__ */ new Set();
  }
  size() {
    return this.visible.size;
  }
  add(e) {
    const { all: t, visible: i, order: s } = this;
    t.has(e) || (t.add(e), i.add(e), s.push(e), this.sort());
  }
  delete(e) {
    this.all.delete(e), this.visible.delete(e), this.queued.delete(e.id), tt(this.order, e);
  }
  has(e) {
    return this.visible.has(e);
  }
  forEach(e) {
    this.order.forEach(e);
  }
  getByIndex(e) {
    return this.order[e];
  }
  getById(e) {
    for (const t of this.visible)
      if (t.id == e)
        return t;
  }
  clear() {
    const { all: e, visible: t, order: i, queued: s } = this;
    e.clear(), s.clear(), t.clear(), i.length = 0;
  }
  sort() {
    const { sortSvc: e, rowNodeSorter: t, gos: i } = this.beans, s = (e == null ? void 0 : e.getSortOptions()) ?? [], o = iS(this.order);
    if (this.order.sort((r, a) => {
      var l, d;
      return (((l = r.pinnedSibling) == null ? void 0 : l.rowIndex) ?? 0) - (((d = a.pinnedSibling) == null ? void 0 : d.rowIndex) ?? 0);
    }), this.order = (t == null ? void 0 : t.doFullSort(this.order, s)) ?? this.order, !o)
      return;
    const n = Yh(i);
    n === "bottom" || n === "pinnedBottom" ? this.order.push(o) : this.order.unshift(o);
  }
  hide(e) {
    const { all: t, visible: i } = this;
    t.forEach((s) => e(s) ? i.delete(s) : i.add(s)), this.order = Array.from(i), this.sort();
  }
  queue(e) {
    this.queued.add(e);
  }
  unqueue(e) {
    this.queued.delete(e);
  }
  forEachQueued(e) {
    this.queued.forEach(e);
  }
};
function op(e) {
  var i;
  if (e.level === -1)
    return !0;
  const t = e.parent;
  return (i = t == null ? void 0 : t.childrenAfterSort) != null && i.some((s) => s == e) ? op(t) : !1;
}
function ia(e, t) {
  const { gos: i, rowModel: s, filterManager: o } = e;
  return Ds(i) ? !s.getRowNode(t.id) : o != null && o.isAnyFilterPresent() ? !op(t) : i.get("pivotMode") ? !t.group : !1;
}
function eS(e) {
  return !!e.footer && e.level === -1;
}
function tS(e) {
  return !!e.pinnedSibling && eS(e.pinnedSibling);
}
function iS(e) {
  var i;
  const t = e.findIndex(tS);
  if (t > -1)
    return (i = e.splice(t, 1)) == null ? void 0 : i[0];
}
var yc = class extends E {
  postConstruct() {
    const { gos: e, beans: t } = this;
    this.top = new bc(t, "top"), this.bottom = new bc(t, "bottom");
    const i = (o) => ia(t, o.pinnedSibling), s = () => {
      const o = e.get("isRowPinned");
      o && e.get("enableRowPinning") && t.rowModel.forEachNode((n) => this.pinRow(n, o(n)), !0), this.refreshRowPositions(), this.dispatchRowPinnedEvents();
    };
    this.addManagedEventListeners({
      gridStylesChanged: this.onGridStylesChanges.bind(this),
      modelUpdated: ({ keepRenderedRows: o }) => {
        this.tryToEmptyQueues(), this.pinGrandTotalRow(), this.forContainers((r) => r.hide(i));
        const n = this.refreshRowPositions();
        (!o || n) && this.dispatchRowPinnedEvents();
      },
      columnRowGroupChanged: () => {
        this.forContainers(oS), this.refreshRowPositions();
      },
      rowNodeDataChanged: ({ node: o }) => {
        const n = e.get("isRowPinnable");
        ((n == null ? void 0 : n(o)) ?? !0) || this.pinRow(o, null);
      },
      firstDataRendered: s
    }), this.addManagedPropertyListener("pivotMode", () => {
      this.forContainers((o) => o.hide(i)), this.dispatchRowPinnedEvents();
    }), this.addManagedPropertyListener("grandTotalRow", ({ currentValue: o }) => {
      this._grandTotalPinned = o === "pinnedBottom" ? "bottom" : o === "pinnedTop" ? "top" : null;
    }), this.addManagedPropertyListener("isRowPinned", s);
  }
  destroy() {
    this.reset(!1), super.destroy();
  }
  reset(e = !0) {
    this.forContainers((t) => {
      const i = [];
      t.forEach((s) => i.push(s)), i.forEach((s) => this.pinRow(s, null)), t.clear();
    }), e && this.dispatchRowPinnedEvents();
  }
  pinRow(e, t, i) {
    var r;
    if (e.footer && e.level > -1)
      return;
    if (e.footer && e.level === -1) {
      this._grandTotalPinned = t, rS(this.beans);
      return;
    }
    const s = e.rowPinned ?? ((r = e.pinnedSibling) == null ? void 0 : r.rowPinned);
    if (s != null && t != null && t != s) {
      const a = e.rowPinned ? e : e.pinnedSibling, l = e.rowPinned ? e.pinnedSibling : e;
      this.pinRow(a, null, i), this.pinRow(l, t, i);
      return;
    }
    const n = i && nS(this.beans, e, i);
    if (n) {
      n.forEach((a) => this.pinRow(a, t));
      return;
    }
    if (t == null) {
      const a = e.rowPinned ? e : e.pinnedSibling, l = this.findPinnedRowNode(a);
      if (!l)
        return;
      l.delete(a);
      const d = a.pinnedSibling;
      sa(a), this.refreshRowPositions(t), this.dispatchRowPinnedEvents(d);
    } else {
      const a = Sc(this.beans, e, t), l = this.getContainer(t);
      l.add(a), ia(this.beans, e) && l.hide((d) => ia(this.beans, d.pinnedSibling)), this.refreshRowPositions(t), this.dispatchRowPinnedEvents(e);
    }
  }
  isManual() {
    return !0;
  }
  isEmpty(e) {
    return this.getContainer(e).size() === 0;
  }
  isRowsToRender(e) {
    return !this.isEmpty(e);
  }
  ensureRowHeightsValid() {
    let e = !1, t = 0;
    const i = (s) => {
      if (s.rowHeightEstimated) {
        const o = ri(this.beans, s);
        s.setRowTop(t), s.setRowHeight(o.height), t += o.height, e = !0;
      }
    };
    return this.bottom.forEach(i), t = 0, this.top.forEach(i), this.eventSvc.dispatchEvent({
      type: "pinnedHeightChanged"
    }), e;
  }
  getPinnedTopTotalHeight() {
    return Rc(this.top);
  }
  getPinnedBottomTotalHeight() {
    return Rc(this.bottom);
  }
  getPinnedTopRowCount() {
    return this.top.size();
  }
  getPinnedBottomRowCount() {
    return this.bottom.size();
  }
  getPinnedTopRow(e) {
    return this.top.getByIndex(e);
  }
  getPinnedBottomRow(e) {
    return this.bottom.getByIndex(e);
  }
  getPinnedRowById(e, t) {
    return this.getContainer(t).getById(e);
  }
  forEachPinnedRow(e, t) {
    this.getContainer(e).forEach(t);
  }
  getPinnedState() {
    const e = (t) => {
      const i = [];
      return this.forEachPinnedRow(t, (s) => i.push(s.pinnedSibling.id)), i;
    };
    return {
      top: e("top"),
      bottom: e("bottom")
    };
  }
  setPinnedState(e) {
    this.forContainers((t, i) => {
      for (const s of e[i]) {
        const o = this.beans.rowModel.getRowNode(s);
        o ? this.pinRow(o, i) : t.queue(s);
      }
    });
  }
  getGrandTotalPinned() {
    return this._grandTotalPinned;
  }
  setGrandTotalPinned(e) {
    this._grandTotalPinned = e;
  }
  tryToEmptyQueues() {
    this.forContainers((e, t) => {
      const i = /* @__PURE__ */ new Set();
      e.forEachQueued((s) => {
        const o = this.beans.rowModel.getRowNode(s);
        o && i.add(o);
      });
      for (const s of i)
        e.unqueue(s.id), this.pinRow(s, t);
    });
  }
  pinGrandTotalRow() {
    var a;
    const { gos: e, beans: t, _grandTotalPinned: i } = this, s = t.rowModel;
    if (!xe(e))
      return;
    const o = (a = s.rootNode) == null ? void 0 : a.sibling;
    if (!o)
      return;
    const n = o.pinnedSibling, r = n && this.findPinnedRowNode(n);
    if (i) {
      if (r && r.floating !== i && (r.delete(n), sa(n)), !r || r.floating !== i) {
        const l = Sc(t, o, i);
        this.getContainer(i).add(l);
      }
    } else {
      if (!r)
        return;
      r.delete(n), sa(n);
    }
  }
  onGridStylesChanges(e) {
    e.rowHeightChanged && this.forContainers(
      (t) => t.forEach((i) => i.setRowHeight(i.rowHeight, !0))
    );
  }
  getContainer(e) {
    return e === "top" ? this.top : this.bottom;
  }
  findPinnedRowNode(e) {
    if (this.top.has(e))
      return this.top;
    if (this.bottom.has(e))
      return this.bottom;
  }
  refreshRowPositions(e) {
    const t = (s) => sS(this.beans, s);
    if (e)
      return t(this.getContainer(e));
    let i = !1;
    return this.forContainers((s) => {
      const o = t(s);
      i || (i = o);
    }), i;
  }
  forContainers(e) {
    e(this.top, "top"), e(this.bottom, "bottom");
  }
  dispatchRowPinnedEvents(e) {
    this.eventSvc.dispatchEvent({ type: "pinnedRowsChanged" }), e == null || e.dispatchRowEvent("rowPinned");
  }
};
function sS(e, t) {
  let i = 0, s = !1;
  return t.forEach((o, n) => {
    if (s || (s = o.rowTop !== i), o.setRowTop(i), o.rowHeightEstimated || o.rowHeight == null) {
      const r = ri(e, o).height;
      s || (s = o.rowHeight !== r), o.setRowHeight(r);
    }
    o.setRowIndex(n), i += o.rowHeight;
  }), s;
}
function Sc(e, t, i) {
  if (t.pinnedSibling)
    return t.pinnedSibling;
  const s = yb(t, e);
  s.setRowTop(null), s.setRowIndex(null), s.rowPinned = i;
  const o = i === "top" ? zl : Ul;
  return s.id = `${o}${i}-${t.id}`, s.pinnedSibling = t, t.pinnedSibling = s, s;
}
function sa(e) {
  if (!e.pinnedSibling)
    return;
  e.rowPinned = null, e.setRowTop(null), e.setRowIndex(null);
  const t = e.pinnedSibling;
  e.pinnedSibling = void 0, t && (t.pinnedSibling = void 0, t.rowPinned = null);
}
function oS(e) {
  const t = /* @__PURE__ */ new Set();
  e.forEach((i) => {
    i.group && t.add(i);
  }), t.forEach((i) => e.delete(i));
}
function nS(e, t, i) {
  var n;
  const { rowSpanSvc: s } = e, o = (i && (s == null ? void 0 : s.isCellSpanning(i, t))) ?? !1;
  if (i && o)
    return (n = s == null ? void 0 : s.getCellSpan(i, t)) == null ? void 0 : n.spannedNodes;
}
function Rc(e) {
  const t = e.size();
  if (t === 0)
    return 0;
  const i = e.getByIndex(t - 1);
  return i === void 0 ? 0 : i.rowTop + i.rowHeight;
}
function rS({ gos: e, rowModel: t }) {
  xe(e) && t.refreshModel({ step: "map" });
}
var xc = class extends E {
  constructor() {
    super(...arguments), this.nextId = 0, this.pinnedTopRows = { cache: {}, order: [] }, this.pinnedBottomRows = { cache: {}, order: [] };
  }
  postConstruct() {
    const e = this.gos;
    this.setPinnedRowData(e.get("pinnedTopRowData"), "top"), this.setPinnedRowData(e.get("pinnedBottomRowData"), "bottom"), this.addManagedPropertyListener("pinnedTopRowData", (t) => this.setPinnedRowData(t.currentValue, "top")), this.addManagedPropertyListener("pinnedBottomRowData", (t) => this.setPinnedRowData(t.currentValue, "bottom")), this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanges.bind(this) });
  }
  reset() {
  }
  isEmpty(e) {
    return this.getCache(e).order.length === 0;
  }
  isRowsToRender(e) {
    return !this.isEmpty(e);
  }
  isManual() {
    return !1;
  }
  pinRow(e, t) {
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      const t = (i) => {
        i.setRowHeight(i.rowHeight, !0);
      };
      Hs(this.pinnedBottomRows, t), Hs(this.pinnedTopRows, t);
    }
  }
  ensureRowHeightsValid() {
    let e = !1, t = 0;
    const i = (s) => {
      if (s.rowHeightEstimated) {
        const o = ri(this.beans, s);
        s.setRowTop(t), s.setRowHeight(o.height), t += o.height, e = !0;
      }
    };
    return Hs(this.pinnedBottomRows, i), t = 0, Hs(this.pinnedTopRows, i), this.eventSvc.dispatchEvent({
      type: "pinnedHeightChanged"
    }), e;
  }
  setPinnedRowData(e, t) {
    this.updateNodesFromRowData(e, t), this.eventSvc.dispatchEvent({
      type: "pinnedRowDataChanged"
    });
  }
  /**
   * Updates existing RowNode instances and creates new ones if necessary
   *
   * Setting data as `undefined` will clear row nodes
   */
  updateNodesFromRowData(e, t) {
    const i = this.getCache(t);
    if (e === void 0) {
      i.order.length = 0, i.cache = {};
      return;
    }
    const s = ws(this.gos), o = t === "top" ? zl : Ul, n = new Set(i.order), r = [], a = /* @__PURE__ */ new Set();
    let l = 0, d = -1;
    for (const c of e) {
      const u = (s == null ? void 0 : s({ data: c, level: 0, rowPinned: t })) ?? o + this.nextId++;
      if (a.has(u)) {
        I(96, { id: u, data: c });
        continue;
      }
      d++, a.add(u), r.push(u);
      const h = oo(i, u);
      if (h !== void 0)
        h.data !== c && h.updateData(c), l += this.setRowTopAndRowIndex(h, l, d), n.delete(u);
      else {
        const g = new Hi(this.beans);
        g.id = u, g.data = c, g.rowPinned = t, l += this.setRowTopAndRowIndex(g, l, d), i.cache[u] = g, i.order.push(u);
      }
    }
    n.forEach((c) => {
      var u;
      (u = oo(i, c)) == null || u.clearRowTopAndRowIndex(), delete i.cache[c];
    }), i.order = r;
  }
  setRowTopAndRowIndex(e, t, i) {
    return e.setRowTop(t), e.setRowHeight(ri(this.beans, e).height), e.setRowIndex(i), e.rowHeight;
  }
  getPinnedTopTotalHeight() {
    return Fc(this.pinnedTopRows);
  }
  getPinnedBottomTotalHeight() {
    return Fc(this.pinnedBottomRows);
  }
  getPinnedTopRowCount() {
    return Qa(this.pinnedTopRows);
  }
  getPinnedBottomRowCount() {
    return Qa(this.pinnedBottomRows);
  }
  getPinnedTopRow(e) {
    return Ya(this.pinnedTopRows, e);
  }
  getPinnedBottomRow(e) {
    return Ya(this.pinnedBottomRows, e);
  }
  getPinnedRowById(e, t) {
    return oo(this.getCache(t), e);
  }
  forEachPinnedRow(e, t) {
    return Hs(this.getCache(e), t);
  }
  getCache(e) {
    return e === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
  }
  getPinnedState() {
    return { top: [], bottom: [] };
  }
  setPinnedState() {
  }
  getGrandTotalPinned() {
  }
  setGrandTotalPinned() {
  }
};
function Fc(e) {
  const t = Qa(e);
  if (t === 0)
    return 0;
  const i = Ya(e, t - 1);
  return i === void 0 ? 0 : i.rowTop + i.rowHeight;
}
function oo(e, t) {
  return e.cache[t];
}
function Ya(e, t) {
  return oo(e, e.order[t]);
}
function Hs(e, t) {
  e.order.forEach((i, s) => {
    const o = oo(e, i);
    o && t(o, s);
  });
}
function Qa(e) {
  return e.order.length;
}
var aS = class extends E {
  constructor() {
    super(...arguments), this.beanName = "pinnedRowModel";
  }
  postConstruct() {
    const { gos: e } = this, t = () => {
      const i = e.get("enableRowPinning"), s = Yh(e), n = !!i || (s === "pinnedBottom" || s === "pinnedTop"), r = n ? this.inner instanceof xc : this.inner instanceof yc;
      this.inner && r && this.destroyBean(this.inner), (r || !this.inner) && (this.inner = this.createManagedBean(
        n ? new yc() : new xc()
      ));
    };
    this.addManagedPropertyListeners(["enableRowPinning", "grandTotalRow"], t), t();
  }
  reset() {
    return this.inner.reset();
  }
  isEmpty(e) {
    return this.inner.isEmpty(e);
  }
  isManual() {
    return this.inner.isManual();
  }
  isRowsToRender(e) {
    return this.inner.isRowsToRender(e);
  }
  pinRow(e, t, i) {
    return this.inner.pinRow(e, t, i);
  }
  ensureRowHeightsValid() {
    return this.inner.ensureRowHeightsValid();
  }
  getPinnedRowById(e, t) {
    return this.inner.getPinnedRowById(e, t);
  }
  getPinnedTopTotalHeight() {
    return this.inner.getPinnedTopTotalHeight();
  }
  getPinnedBottomTotalHeight() {
    return this.inner.getPinnedBottomTotalHeight();
  }
  getPinnedTopRowCount() {
    return this.inner.getPinnedTopRowCount();
  }
  getPinnedBottomRowCount() {
    return this.inner.getPinnedBottomRowCount();
  }
  getPinnedTopRow(e) {
    return this.inner.getPinnedTopRow(e);
  }
  getPinnedBottomRow(e) {
    return this.inner.getPinnedBottomRow(e);
  }
  forEachPinnedRow(e, t) {
    return this.inner.forEachPinnedRow(e, t);
  }
  getPinnedState() {
    return this.inner.getPinnedState();
  }
  setPinnedState(e) {
    return this.inner.setPinnedState(e);
  }
  setGrandTotalPinned(e) {
    return this.inner.setGrandTotalPinned(e);
  }
  getGrandTotalPinned() {
    return this.inner.getGrandTotalPinned();
  }
}, lS = "ROOT_NODE_ID", dS = class extends E {
  constructor() {
    super(...arguments), this.nextId = 0, this.allNodesMap = {}, this.rootNode = null;
  }
  getRowNode(e) {
    return this.allNodesMap[e];
  }
  extractRowData() {
    var e, t;
    return (t = (e = this.rootNode) == null ? void 0 : e.allLeafChildren) == null ? void 0 : t.map((i) => i.data);
  }
  activate(e) {
    this.rootNode = e, e.group = !0, e.level = -1, e.id = lS, e.allLeafChildren = [], e.childrenAfterGroup = [], e.childrenAfterSort = [], e.childrenAfterAggFilter = [], e.childrenAfterFilter = [], this.updateRootSiblingArrays(e);
  }
  deactivate() {
    this.rootNode && (this.allNodesMap = {}, this.rootNode = null);
  }
  destroy() {
    super.destroy(), this.allNodesMap = {}, this.rootNode = null;
  }
  setNewRowData(e) {
    const t = this.rootNode;
    t && (this.dispatchRowDataUpdateStartedEvent(e), t.childrenAfterFilter = null, t.childrenAfterGroup = null, t.childrenAfterAggFilter = null, t.childrenAfterSort = null, t.childrenMapped = null, t.updateHasChildren(), this.allNodesMap = {}, this.nextId = 0, this.loadNewRowData(e), this.updateRootSiblingArrays(t));
  }
  updateRootSiblingArrays(e) {
    const t = e.sibling;
    t && (t.childrenAfterFilter = e.childrenAfterFilter, t.childrenAfterGroup = e.childrenAfterGroup, t.childrenAfterAggFilter = e.childrenAfterAggFilter, t.childrenAfterSort = e.childrenAfterSort, t.childrenMapped = e.childrenMapped, t.allLeafChildren = e.allLeafChildren);
  }
  loadNewRowData(e) {
    this.rootNode.allLeafChildren = (e == null ? void 0 : e.map((t, i) => this.createRowNode(t, i))) ?? [];
  }
  setImmutableRowData(e, t) {
    var p;
    const i = ws(this.gos), s = !this.gos.get("suppressMaintainUnsortedOrder"), o = e.changedRowNodes, n = /* @__PURE__ */ new Set(), r = this.rootNode, a = r.allLeafChildren, l = a.length;
    let d = !1, c = !1, u = !1, h = !1;
    for (let f = 0, m = -1, C = t.length; f < C; f++) {
      const v = t[f];
      let R = this.getRowNode(
        i({ data: v, level: 0 })
      );
      if (!R)
        d = !0, R = this.createRowNode(v, -1), o.add(R);
      else {
        if (s) {
          const b = R.sourceRowIndex;
          h || (h = b <= m || // A node was moved up, so order changed
          d), m = b;
        }
        R.data !== v && (u = !0, R.updateData(v), o.update(R));
      }
      n.add(R);
    }
    const g = [];
    for (let f = 0; f < l; f++) {
      const m = a[f];
      n.has(m) || (c = !0, m.isSelected() && g.push(m), m.pinnedSibling && ((p = this.beans.pinnedRowModel) == null || p.pinRow(m.pinnedSibling, null)), this.rowNodeDeleted(m), o.remove(m));
    }
    if (d || c || h) {
      const f = new Array(n.size);
      let m = 0;
      if (!s)
        for (let v = 0; v < l; ++v) {
          const R = a[v];
          n.delete(R) && (R.sourceRowIndex = m, f[m++] = R);
        }
      for (const v of n)
        v.sourceRowIndex = m, f[m++] = v;
      r.allLeafChildren = f;
      const C = r.sibling;
      C && (C.allLeafChildren = f), e.rowNodesOrderChanged || (e.rowNodesOrderChanged = h);
    }
    (d || c || h || u) && (this.deselectNodes(g), e.rowDataUpdated = !0);
  }
  /** Called when a node needs to be deleted */
  rowNodeDeleted(e) {
    e.clearRowTopAndRowIndex();
    const t = e.id, i = this.allNodesMap;
    i[t] === e && delete i[t];
  }
  updateRowData(e, t) {
    this.dispatchRowDataUpdateStartedEvent(e.add);
    const i = {
      changedRowNodes: t,
      rowNodeTransaction: { remove: [], update: [], add: [] },
      rowsInserted: !1
    }, s = [], o = ws(this.gos);
    return this.executeRemove(o, e, i, s), this.executeUpdate(o, e, i, s), this.executeAdd(e, i), this.deselectNodes(s), i;
  }
  executeAdd(e, t) {
    const i = e.add;
    if (!(i != null && i.length))
      return;
    let s = this.rootNode.allLeafChildren, o = s.length;
    if (typeof e.addIndex == "number" && (o = this.sanitizeAddIndex(e.addIndex), o > 0 && this.gos.get("treeData") && this.gos.get("getDataPath")))
      for (let u = 0; u < s.length; u++) {
        const h = s[u];
        if ((h == null ? void 0 : h.rowIndex) == o - 1) {
          o = u + 1;
          break;
        }
      }
    const n = i.length, r = t.changedRowNodes, a = new Array(n);
    for (let c = 0; c < n; c++) {
      const u = this.createRowNode(i[c], o + c);
      r.add(u), a[c] = u;
    }
    const l = this.rootNode;
    if (o < s.length) {
      const c = s.slice(0, o), u = s.slice(o, s.length), h = c.length + a.length;
      for (let g = 0, p = u.length; g < p; ++g)
        u[g].sourceRowIndex = h + g;
      s = [...c, ...a, ...u], t.rowsInserted = !0;
    } else
      s = s.concat(a);
    l.allLeafChildren = s;
    const d = l.sibling;
    d && (d.allLeafChildren = s), t.rowNodeTransaction.add = a;
  }
  executeRemove(e, t, { changedRowNodes: i, rowNodeTransaction: s }, o) {
    var d, c;
    const { remove: n } = t;
    if (!(n != null && n.length))
      return;
    const r = {};
    n.forEach((u) => {
      var g;
      const h = this.lookupRowNode(e, u);
      h && (h.isSelected() && o.push(h), h.pinnedSibling && ((g = this.beans.pinnedRowModel) == null || g.pinRow(h.pinnedSibling, null)), h.clearRowTopAndRowIndex(), r[h.id] = !0, delete this.allNodesMap[h.id], s.remove.push(h), i.remove(h));
    });
    const a = this.rootNode;
    a.allLeafChildren = ((d = a.allLeafChildren) == null ? void 0 : d.filter((u) => !r[u.id])) ?? null, (c = a.allLeafChildren) == null || c.forEach((u, h) => {
      u.sourceRowIndex = h;
    });
    const l = a.sibling;
    l && (l.allLeafChildren = a.allLeafChildren);
  }
  executeUpdate(e, t, { changedRowNodes: i, rowNodeTransaction: s }, o) {
    const { update: n } = t;
    n != null && n.length && n.forEach((r) => {
      const a = this.lookupRowNode(e, r);
      a && (a.updateData(r), !a.selectable && a.isSelected() && o.push(a), s.update.push(a), i.update(a));
    });
  }
  dispatchRowDataUpdateStartedEvent(e) {
    this.eventSvc.dispatchEvent({
      type: "rowDataUpdateStarted",
      firstRowData: e != null && e.length ? e[0] : null
    });
  }
  deselectNodes(e) {
    var o;
    const t = "rowDataChanged", i = this.beans.selectionSvc, s = e.length > 0;
    s && (i == null || i.setNodesSelected({
      newValue: !1,
      nodes: e,
      suppressFinishActions: !0,
      source: t
    })), (o = i == null ? void 0 : i.updateGroupsFromChildrenSelections) == null || o.call(i, t), s && this.eventSvc.dispatchEvent({
      type: "selectionChanged",
      source: t,
      selectedNodes: (i == null ? void 0 : i.getSelectedNodes()) ?? null,
      serverSideState: null
    });
  }
  sanitizeAddIndex(e) {
    var i;
    const t = ((i = this.rootNode.allLeafChildren) == null ? void 0 : i.length) ?? 0;
    return e < 0 || e >= t || Number.isNaN(e) ? t : Math.ceil(e);
  }
  createRowNode(e, t) {
    const i = new Hi(this.beans);
    return i.parent = this.rootNode, i.level = 0, i.group = !1, i.expanded = !1, i.sourceRowIndex = t, i.setDataAndId(e, String(this.nextId)), this.allNodesMap[i.id] && I(2, { nodeId: i.id }), this.allNodesMap[i.id] = i, this.nextId++, i;
  }
  lookupRowNode(e, t) {
    var s, o;
    let i;
    if (e) {
      const n = e({ data: t, level: 0 });
      if (i = this.allNodesMap[n], !i)
        return Z(4, { id: n }), null;
    } else if (i = (o = (s = this.rootNode) == null ? void 0 : s.allLeafChildren) == null ? void 0 : o.find((n) => n.data === t), !i)
      return Z(5, { data: t }), null;
    return i || null;
  }
};
function $o(e) {
  return !!(e.rowPinned && e.pinnedSibling);
}
function Qe(e, t, i, s) {
  const o = t === "top";
  if (!i)
    return Qe(
      e,
      t,
      o ? e.getPinnedTopRow(0) : e.getPinnedBottomRow(0),
      s
    );
  if (!s) {
    const l = o ? e.getPinnedTopRowCount() : e.getPinnedBottomRowCount();
    return Qe(
      e,
      t,
      i,
      o ? e.getPinnedTopRow(l - 1) : e.getPinnedBottomRow(l - 1)
    );
  }
  let n = !1, r = !1;
  const a = [];
  return e.forEachPinnedRow(t, (l) => {
    if (l === i && !n) {
      n = !0, a.push(l);
      return;
    }
    if (n && l === s) {
      r = !0, a.push(l);
      return;
    }
    n && !r && a.push(l);
  }), a;
}
var cS = {
  tag: "div",
  cls: "ag-selection-checkbox",
  role: "presentation",
  children: [
    {
      tag: "ag-checkbox",
      ref: "eCheckbox",
      role: "presentation"
    }
  ]
}, uS = class extends te {
  constructor() {
    super(cS, [Bl]), this.eCheckbox = _;
  }
  postConstruct() {
    this.eCheckbox.setPassive(!0);
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const e = this.getLocaleTextFunc(), { rowNode: t, eCheckbox: i } = this, s = t.isSelected(), o = Cr(e, s), [n, r] = t.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"], a = e(n, r);
    i.setValue(s, !0), i.setInputAriaLabel(`${a} (${o})`);
  }
  init(e) {
    if (this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListeners(this.eCheckbox.getInputElement(), {
      // we don't want double click on this icon to open a group
      dblclick: Bi,
      click: (s) => {
        var o;
        Bi(s), (o = this.beans.selectionSvc) == null || o.handleSelectionEvent(s, this.rowNode, "checkboxSelected");
      }
    }), this.addManagedListeners(this.rowNode, {
      rowSelected: this.onSelectionChanged.bind(this),
      dataChanged: this.onDataChanged.bind(this),
      selectableChanged: this.onSelectableChanged.bind(this)
    }), this.addManagedPropertyListener("rowSelection", ({ currentValue: s, previousValue: o }) => {
      const n = typeof s == "object" ? Nr(s) : void 0, r = typeof o == "object" ? Nr(o) : void 0;
      n !== r && this.onSelectableChanged();
    }), _a(this.gos) || typeof this.getIsVisible() == "function") {
      const s = this.showOrHideSelect.bind(this);
      this.addManagedEventListeners({ displayedColumnsChanged: s }), this.addManagedListeners(this.rowNode, {
        dataChanged: s,
        cellChanged: s
      }), this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  showOrHideSelect() {
    const { column: e, rowNode: t, overrides: i, gos: s } = this, o = t.selectable, n = this.getIsVisible();
    let r;
    if (typeof n == "function") {
      const u = i == null ? void 0 : i.callbackParams;
      if (!e)
        r = n({ ...u, node: t, data: t.data });
      else {
        const h = e.createColumnFunctionCallbackParams(t);
        r = n({ ...u, ...h });
      }
    } else
      r = n ?? !1;
    const a = o && !r || !o && r, l = o || r, d = s.get("rowSelection"), c = d && typeof d != "string" ? !Nr(d) : !!(e != null && e.getColDef().showDisabledCheckboxes);
    if (this.setVisible(l && (a ? c : !0)), this.setDisplayed(l && (a ? c : !0)), l && this.eCheckbox.setDisabled(a), i != null && i.removeHidden) {
      this.setDisplayed(l);
      return;
    }
  }
  getIsVisible() {
    var i, s;
    const e = this.overrides;
    if (e)
      return e.isVisible;
    const t = this.gos.get("rowSelection");
    return t && typeof t != "string" ? ls(t) : (s = (i = this.column) == null ? void 0 : i.getColDef()) == null ? void 0 : s.checkboxSelection;
  }
}, hS = class {
  constructor(e, t) {
    this.rowModel = e, this.pinnedRowModel = t, this.selectAll = !1, this.rootId = null, this.endId = null, this.cachedRange = [];
  }
  reset() {
    this.rootId = null, this.endId = null, this.cachedRange.length = 0;
  }
  setRoot(e) {
    this.rootId = e.id, this.endId = null, this.cachedRange.length = 0;
  }
  setEndRange(e) {
    this.endId = e.id, this.cachedRange.length = 0;
  }
  getRange() {
    if (this.cachedRange.length === 0) {
      const e = this.getRoot(), t = this.getEnd();
      if (e == null || t == null)
        return this.cachedRange;
      this.cachedRange = this.getNodesInRange(e, t) ?? [];
    }
    return this.cachedRange;
  }
  isInRange(e) {
    return this.rootId === null ? !1 : this.getRange().some((t) => t.id === e.id);
  }
  getRoot(e) {
    if (this.rootId)
      return this.getRowNode(this.rootId);
    if (e)
      return this.setRoot(e), e;
  }
  getEnd() {
    if (this.endId)
      return this.getRowNode(this.endId);
  }
  getRowNode(e) {
    let t;
    const { rowModel: i, pinnedRowModel: s } = this;
    return t ?? (t = i.getRowNode(e)), s != null && s.isManual() && (t ?? (t = s.getPinnedRowById(e, "top")), t ?? (t = s.getPinnedRowById(e, "bottom"))), t;
  }
  /**
   * Truncates the range to the given node (assumed to be within the current range).
   * Returns nodes that remain in the current range and those that should be removed
   *
   * @param node - Node at which to truncate the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  truncate(e) {
    const t = this.getRange();
    if (t.length === 0)
      return { keep: [], discard: [] };
    const i = t[0].id === this.rootId, s = t.findIndex((o) => o.id === e.id);
    if (s > -1) {
      const o = t.slice(0, s), n = t.slice(s + 1);
      return this.setEndRange(e), i ? { keep: o, discard: n } : { keep: n, discard: o };
    } else
      return { keep: t, discard: [] };
  }
  /**
   * Extends the range to the given node. Returns nodes that remain in the current range
   * and those that should be removed.
   *
   * @param node - Node marking the new end of the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  extend(e, t = !1) {
    const i = this.getRoot();
    if (i == null) {
      const o = this.getRange().slice();
      return t && e.depthFirstSearch((n) => !n.group && o.push(n)), o.push(e), this.setRoot(e), { keep: o, discard: [] };
    }
    const s = this.getNodesInRange(i, e);
    if (!s)
      return this.setRoot(e), { keep: [e], discard: [] };
    if (s.find((o) => o.id === this.endId))
      return this.setEndRange(e), { keep: this.getRange(), discard: [] };
    {
      const o = this.getRange().slice();
      return this.setEndRange(e), { keep: this.getRange(), discard: o };
    }
  }
  getNodesInRange(e, t) {
    const { pinnedRowModel: i, rowModel: s } = this;
    if (!(i != null && i.isManual()))
      return s.getNodesInRangeForSelection(e, t);
    if (e.rowPinned === "top" && !t.rowPinned)
      return Qe(i, "top", e, void 0).concat(s.getNodesInRangeForSelection(s.getRow(0), t) ?? []);
    if (e.rowPinned === "bottom" && !t.rowPinned) {
      const o = Qe(i, "bottom", void 0, e), n = s.getRowCount(), r = s.getRow(n - 1);
      return (s.getNodesInRangeForSelection(t, r) ?? []).concat(o);
    }
    if (!e.rowPinned && !t.rowPinned)
      return s.getNodesInRangeForSelection(e, t);
    if (e.rowPinned === "top" && t.rowPinned === "top")
      return Qe(i, "top", e, t);
    if (e.rowPinned === "bottom" && t.rowPinned === "top") {
      const o = Qe(i, "top", t, void 0), n = Qe(i, "bottom", void 0, e), r = s.getRow(0), a = s.getRow(s.getRowCount() - 1);
      return o.concat(s.getNodesInRangeForSelection(r, a) ?? []).concat(n);
    }
    if (!e.rowPinned && t.rowPinned === "top")
      return Qe(i, "top", t, void 0).concat(s.getNodesInRangeForSelection(s.getRow(0), e) ?? []);
    if (e.rowPinned === "top" && t.rowPinned === "bottom") {
      const o = Qe(i, "top", e, void 0), n = Qe(i, "bottom", void 0, t), r = s.getRow(0), a = s.getRow(s.getRowCount() - 1);
      return o.concat(s.getNodesInRangeForSelection(r, a) ?? []).concat(n);
    }
    if (e.rowPinned === "bottom" && t.rowPinned === "bottom")
      return Qe(i, "bottom", e, t);
    if (!e.rowPinned && t.rowPinned === "bottom") {
      const o = Qe(i, "bottom", void 0, t), n = s.getRow(s.getRowCount());
      return (s.getNodesInRangeForSelection(e, n) ?? []).concat(o);
    }
    return null;
  }
}, gS = class extends E {
  constructor(e) {
    super(), this.column = e, this.cbSelectAllVisible = !1, this.processingEventFromCheckbox = !1;
  }
  onSpaceKeyDown(e) {
    const t = this.cbSelectAll;
    t.isDisplayed() && !t.getGui().contains(he(this.beans)) && (e.preventDefault(), t.setValue(!t.getValue()));
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(e) {
    this.headerCellCtrl = e;
    const t = this.createManagedBean(new Hl());
    this.cbSelectAll = t, t.addCss("ag-header-select-all"), oi(t.getGui(), "presentation"), this.showOrHideSelectAll();
    const i = this.updateStateOfCheckbox.bind(this);
    this.addManagedEventListeners({
      newColumnsLoaded: () => this.showOrHideSelectAll(),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      selectionChanged: i,
      paginationChanged: i,
      modelUpdated: i
    }), this.addManagedPropertyListener("rowSelection", ({ currentValue: s, previousValue: o }) => {
      const n = (r) => typeof r == "string" || !r || r.mode === "singleRow" ? void 0 : r.selectAll;
      n(s) !== n(o) && this.showOrHideSelectAll(), this.updateStateOfCheckbox();
    }), this.addManagedListeners(t, { fieldValueChanged: this.onCbSelectAll.bind(this) }), t.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
  }
  onDisplayedColumnsChanged(e) {
    this.isAlive() && this.showOrHideSelectAll(e.source === "uiColumnMoved");
  }
  showOrHideSelectAll(e = !1) {
    const t = this.isCheckboxSelection();
    this.cbSelectAllVisible = t, this.cbSelectAll.setDisplayed(t), t && (this.checkRightRowModelType("selectAllCheckbox"), this.checkSelectionType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel(e);
  }
  updateStateOfCheckbox() {
    if (!this.cbSelectAllVisible || this.processingEventFromCheckbox)
      return;
    this.processingEventFromCheckbox = !0;
    const e = this.getSelectAllMode(), t = this.beans.selectionSvc, i = this.cbSelectAll, s = t.getSelectAllState(e);
    i.setValue(s);
    const o = t.hasNodesToSelect(e);
    i.setDisabled(!o), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
  }
  refreshSelectAllLabel(e = !1) {
    const t = this.getLocaleTextFunc(), { headerCellCtrl: i, cbSelectAll: s, cbSelectAllVisible: o } = this, n = s.getValue(), r = Cr(t, n), a = t("ariaRowSelectAll", "Press Space to toggle all rows selection");
    i.setAriaDescriptionProperty(
      "selectAll",
      o ? `${a} (${r})` : null
    ), s.setInputAriaLabel(t("ariaHeaderSelection", "Column with Header Selection")), e || i.announceAriaDescription();
  }
  checkSelectionType(e) {
    return xo(this.gos) ? !0 : (I(128, { feature: e }), !1);
  }
  checkRightRowModelType(e) {
    const { gos: t, rowModel: i } = this.beans;
    return xe(t) || Ds(t) ? !0 : (I(129, { feature: e, rowModel: i.getType() }), !1);
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox || !this.cbSelectAllVisible)
      return;
    const e = this.cbSelectAll.getValue(), t = this.getSelectAllMode();
    let i = "uiSelectAll";
    t === "currentPage" ? i = "uiSelectAllCurrentPage" : t === "filtered" && (i = "uiSelectAllFiltered");
    const s = { source: i, selectAll: t }, o = this.beans.selectionSvc;
    e ? o.selectAllRowNodes(s) : o.deselectAllRowNodes(s);
  }
  /**
   * Checkbox is enabled when either the `headerCheckbox` option is enabled in the new selection API
   * or `headerCheckboxSelection` is enabled in the legacy API.
   */
  isCheckboxSelection() {
    const { column: e, gos: t, beans: i } = this, n = typeof t.get("rowSelection") == "object" ? "headerCheckbox" : "headerCheckboxSelection";
    return np(i, e) && this.checkRightRowModelType(n) && this.checkSelectionType(n);
  }
  getSelectAllMode() {
    const e = Jh(this.gos, !1);
    if (e)
      return e;
    const { headerCheckboxSelectionCurrentPageOnly: t, headerCheckboxSelectionFilteredOnly: i } = this.column.getColDef();
    return t ? "currentPage" : i ? "filtered" : "all";
  }
  destroy() {
    super.destroy(), this.cbSelectAll = void 0, this.headerCellCtrl = void 0;
  }
};
function np({ gos: e, selectionColSvc: t }, i) {
  const s = e.get("rowSelection"), o = i.getColDef(), { headerCheckboxSelection: n } = o;
  let r = !1;
  if (typeof s == "object") {
    const l = ui(i), d = kl(i);
    ($n(s) === "autoGroupColumn" && d || l && (t != null && t.isSelectionColumnEnabled())) && (r = Pn(s));
  } else
    typeof n == "function" ? r = n(W(e, { column: i, colDef: o })) : r = !!n;
  return r;
}
var pS = class extends E {
  postConstruct() {
    const { gos: e, beans: t } = this;
    this.selectionCtx = new hS(t.rowModel, t.pinnedRowModel), this.addManagedPropertyListeners(["isRowSelectable", "rowSelection"], () => {
      const i = _a(e);
      i !== this.isRowSelectable && (this.isRowSelectable = i, this.updateSelectable());
    }), this.isRowSelectable = _a(e), this.addManagedEventListeners({
      cellValueChanged: (i) => this.updateRowSelectable(i.node),
      rowNodeDataChanged: (i) => this.updateRowSelectable(i.node)
    });
  }
  destroy() {
    super.destroy(), this.selectionCtx.reset();
  }
  createCheckboxSelectionComponent() {
    return new uS();
  }
  createSelectAllFeature(e) {
    if (np(this.beans, e))
      return new gS(e);
  }
  isMultiSelect() {
    return xo(this.gos);
  }
  onRowCtrlSelected(e, t, i) {
    const s = !!e.rowNode.isSelected();
    e.forEachGui(i, (o) => {
      o.rowComp.toggleCss("ag-row-selected", s);
      const n = o.element;
      Dh(n, s), n.contains(he(this.beans)) && t(o);
    });
  }
  announceAriaRowSelection(e) {
    var o;
    if (this.isRowSelectionBlocked(e))
      return;
    const t = e.isSelected();
    if (!e.selectable)
      return;
    const s = this.getLocaleTextFunc()(
      t ? "ariaRowDeselect" : "ariaRowSelect",
      `Press SPACE to ${t ? "deselect" : "select"} this row`
    );
    (o = this.beans.ariaAnnounce) == null || o.announceValue(s, "rowSelection");
  }
  isRowSelectionBlocked(e) {
    return !e.selectable || e.rowPinned && !$o(e) || !Di(this.gos);
  }
  updateRowSelectable(e, t) {
    var s;
    const i = e.rowPinned && e.pinnedSibling ? (
      // If row node is pinned sibling, copy selectable status over from sibling row node
      e.pinnedSibling.selectable
    ) : (
      // otherwise calculate selectable state directly
      ((s = this.isRowSelectable) == null ? void 0 : s.call(this, e)) ?? !0
    );
    return this.setRowSelectable(e, i, t), i;
  }
  setRowSelectable(e, t, i) {
    if (e.selectable !== t) {
      if (e.selectable = t, e.dispatchRowEvent("selectableChanged"), i)
        return;
      if (Fo(this.gos)) {
        const o = this.calculateSelectedFromChildren(e);
        this.setNodesSelected({ nodes: [e], newValue: o ?? !1, source: "selectableChanged" });
        return;
      }
      e.isSelected() && !e.selectable && this.setNodesSelected({ nodes: [e], newValue: !1, source: "selectableChanged" });
    }
  }
  calculateSelectedFromChildren(e) {
    var s;
    let t = !1, i = !1;
    if (!((s = e.childrenAfterGroup) != null && s.length))
      return e.selectable ? e.__selected : null;
    for (let o = 0; o < e.childrenAfterGroup.length; o++) {
      const n = e.childrenAfterGroup[o];
      let r = n.isSelected();
      if (!n.selectable) {
        const a = this.calculateSelectedFromChildren(n);
        if (a === null)
          continue;
        r = a;
      }
      switch (r) {
        case !0:
          t = !0;
          break;
        case !1:
          i = !0;
          break;
        default:
          return;
      }
    }
    if (!(t && i))
      return t ? !0 : i ? !1 : e.selectable ? e.__selected : null;
  }
  selectRowNode(e, t, i, s = "api") {
    const o = !e.selectable && t, n = e.__selected === t;
    if (o || n)
      return !1;
    e.__selected = t, e.dispatchRowEvent("rowSelected");
    const r = e.sibling;
    r && r.footer && r.__localEventService && r.dispatchRowEvent("rowSelected");
    const a = e.pinnedSibling;
    return a && a.rowPinned && a.__localEventService && a.dispatchRowEvent("rowSelected"), this.eventSvc.dispatchEvent({
      ...wb(e, this.gos, "rowSelected"),
      event: i || null,
      source: s
    }), !0;
  }
  isCellCheckboxSelection(e, t) {
    const i = this.gos.get("rowSelection");
    if (i && typeof i != "string") {
      const s = ui(e) && ls(i);
      return e.isColumnFunc(t, s);
    } else
      return e.isColumnFunc(t, e.colDef.checkboxSelection);
  }
  inferNodeSelections(e, t, i, s) {
    const { gos: o, selectionCtx: n } = this, r = e.isSelected(), a = Fo(o), l = UC(o), d = $C(o), c = this.isMultiSelect(), u = s === "rowClicked";
    if (u && !(l || d))
      return null;
    if (t && i && c) {
      const h = n.getRoot();
      if (h)
        if (h.isSelected()) {
          const g = n.isInRange(e) ? n.truncate(e) : n.extend(e, a);
          return {
            deselect: g.discard,
            select: g.keep,
            reset: !1
          };
        } else {
          const g = n.extend(e, a);
          return {
            select: [],
            deselect: g.keep,
            reset: !1
          };
        }
      else return null;
    } else if (t && c) {
      const h = n.selectAll ? this.beans.rowModel.getRow(0) : void 0, g = n.getRoot(h), p = n.isInRange(e) ? n.truncate(e) : n.extend(e, a);
      return {
        select: p.keep,
        deselect: p.discard,
        reset: n.selectAll || !!(g && !g.isSelected())
      };
    } else if (i) {
      if (u) {
        const h = !r;
        return h && !l || !h && !d ? null : (n.setRoot(e), {
          node: e,
          newValue: h,
          clearSelection: !1
        });
      }
      return n.setRoot(e), {
        node: e,
        newValue: !r,
        clearSelection: !c
      };
    } else {
      n.setRoot(e);
      const h = KC(o), g = jn(o) === "filteredDescendants", p = u && (!h || !l);
      if (g && r === void 0 && xe(o))
        return {
          node: e,
          newValue: !1,
          checkFilteredNodes: !0,
          clearSelection: !c || p
        };
      if (u) {
        const f = r ? !h : l;
        return f === r && !p || f && !l || !f && !d ? null : {
          node: e,
          newValue: f,
          clearSelection: !c || p,
          keepDescendants: e.group && a
        };
      }
      return {
        node: e,
        newValue: !r,
        clearSelection: !c || p
      };
    }
  }
}, oa = {
  TAB_GUARD: "ag-tab-guard",
  TAB_GUARD_TOP: "ag-tab-guard-top",
  TAB_GUARD_BOTTOM: "ag-tab-guard-bottom"
}, fS = class extends E {
  constructor(e) {
    super(), this.skipTabGuardFocus = !1, this.forcingFocusOut = !1, this.allowFocus = !1;
    const {
      comp: t,
      eTopGuard: i,
      eBottomGuard: s,
      focusTrapActive: o,
      forceFocusOutWhenTabGuardsAreEmpty: n,
      isFocusableContainer: r,
      focusInnerElement: a,
      onFocusIn: l,
      onFocusOut: d,
      shouldStopEventPropagation: c,
      onTabKeyDown: u,
      handleKeyDown: h,
      isEmpty: g,
      eFocusableElement: p
    } = e;
    this.comp = t, this.eTopGuard = i, this.eBottomGuard = s, this.providedFocusInnerElement = a, this.eFocusableElement = p, this.focusTrapActive = !!o, this.forceFocusOutWhenTabGuardsAreEmpty = !!n, this.isFocusableContainer = !!r, this.providedFocusIn = l, this.providedFocusOut = d, this.providedShouldStopEventPropagation = c, this.providedOnTabKeyDown = u, this.providedHandleKeyDown = h, this.providedIsEmpty = g;
  }
  postConstruct() {
    this.createManagedBean(
      new Ts(this.eFocusableElement, {
        shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e)
      })
    ), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(
      (e) => this.addManagedElementListeners(e, { focus: this.onFocus.bind(this) })
    );
  }
  handleKeyDown(e) {
    this.providedHandleKeyDown && this.providedHandleKeyDown(e);
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
  }
  activateTabGuards() {
    if (this.forcingFocusOut)
      return;
    const e = this.gos.get("tabIndex");
    this.comp.setTabIndex(e.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget) && !this.allowFocus) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = !1;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty && (this.providedIsEmpty ? this.providedIsEmpty() : cs(this.eFocusableElement, ".ag-tab-guard").length === 0)) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget))
      return;
    const t = e.target === this.eBottomGuard;
    !(this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t)) && this.forceFocusOutWhenTabGuardsAreEmpty && this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
  }
  findNextElementOutsideAndFocus(e) {
    var l;
    const t = Ee(this.beans), i = cs(t.body, null, !0), s = i.indexOf(e ? this.eTopGuard : this.eBottomGuard);
    if (s === -1)
      return;
    let o, n;
    e ? (o = 0, n = s) : (o = s + 1, n = i.length);
    const r = i.slice(o, n), a = this.gos.get("tabIndex");
    r.sort((d, c) => {
      const u = parseInt(d.getAttribute("tabindex") || "0"), h = parseInt(c.getAttribute("tabindex") || "0");
      return h === a ? 1 : u === a ? -1 : u === 0 ? 1 : h === 0 ? -1 : u - h;
    }), (l = r[e ? r.length - 1 : 0]) == null || l.focus();
  }
  onFocusIn(e) {
    this.focusTrapActive || this.forcingFocusOut || (this.providedFocusIn && this.providedFocusIn(e), this.isFocusableContainer || this.deactivateTabGuards());
  }
  onFocusOut(e) {
    this.focusTrapActive || (this.providedFocusOut && this.providedFocusOut(e), this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards());
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive || e.defaultPrevented)
      return;
    const t = this.tabGuardsAreActive();
    t && this.deactivateTabGuards();
    const i = this.getNextFocusableElement(e.shiftKey);
    t && setTimeout(() => this.activateTabGuards(), 0), i && (i.focus(), e.preventDefault());
  }
  focusInnerElement(e = !1) {
    const t = cs(this.eFocusableElement);
    return this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length ? (t[e ? t.length - 1 : 0].focus({ preventScroll: !0 }), !0) : !1;
  }
  getNextFocusableElement(e) {
    return zi(this.beans, this.eFocusableElement, !1, e);
  }
  forceFocusOutOfContainer(e = !1) {
    if (this.forcingFocusOut)
      return;
    const t = e ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards(), this.skipTabGuardFocus = !0, this.forcingFocusOut = !0, t.focus(), window.setTimeout(() => {
      this.forcingFocusOut = !1, this.activateTabGuards();
    });
  }
  isTabGuard(e, t) {
    return e === this.eTopGuard && !t || e === this.eBottomGuard && (t ?? !0);
  }
  setAllowFocus(e) {
    this.allowFocus = e;
  }
}, mS = class extends E {
  constructor(e) {
    super(), this.comp = e;
  }
  initialiseTabGuard(e) {
    this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.comp.getFocusableElement();
    const { eTopGuard: t, eBottomGuard: i, eFocusableElement: s } = this, o = [t, i], n = {
      setTabIndex: (m) => {
        o.forEach(
          (C) => m != null ? C.setAttribute("tabindex", m) : C.removeAttribute("tabindex")
        );
      }
    };
    this.addTabGuards(t, i);
    const {
      focusTrapActive: r = !1,
      onFocusIn: a,
      onFocusOut: l,
      focusInnerElement: d,
      handleKeyDown: c,
      onTabKeyDown: u,
      shouldStopEventPropagation: h,
      isEmpty: g,
      forceFocusOutWhenTabGuardsAreEmpty: p,
      isFocusableContainer: f
    } = e;
    this.tabGuardCtrl = this.createManagedBean(
      new fS({
        comp: n,
        focusTrapActive: r,
        eTopGuard: t,
        eBottomGuard: i,
        eFocusableElement: s,
        onFocusIn: a,
        onFocusOut: l,
        focusInnerElement: d,
        handleKeyDown: c,
        onTabKeyDown: u,
        shouldStopEventPropagation: h,
        isEmpty: g,
        forceFocusOutWhenTabGuardsAreEmpty: p,
        isFocusableContainer: f
      })
    );
  }
  getTabGuardCtrl() {
    return this.tabGuardCtrl;
  }
  createTabGuard(e) {
    const t = Ee(this.beans).createElement("div"), i = e === "top" ? oa.TAB_GUARD_TOP : oa.TAB_GUARD_BOTTOM;
    return t.classList.add(oa.TAB_GUARD, i), oi(t, "presentation"), t;
  }
  addTabGuards(e, t) {
    const i = this.eFocusableElement;
    i.insertAdjacentElement("afterbegin", e), i.insertAdjacentElement("beforeend", t);
  }
  removeAllChildrenExceptTabGuards() {
    const e = [this.eTopGuard, this.eBottomGuard];
    Te(this.comp.getFocusableElement()), this.addTabGuards(...e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardCtrl.forceFocusOutOfContainer(e);
  }
  appendChild(e, t, i) {
    Tl(t) || (t = t.getGui());
    const { eBottomGuard: s } = this;
    s ? s.insertAdjacentElement("beforebegin", t) : e(t, i);
  }
  destroy() {
    const { eTopGuard: e, eBottomGuard: t } = this;
    dt(e), dt(t), super.destroy();
  }
}, rp = class extends te {
  initialiseTabGuard(e) {
    this.tabGuardFeature = this.createManagedBean(new mS(this)), this.tabGuardFeature.initialiseTabGuard(e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardFeature.forceFocusOutOfContainer(e);
  }
  appendChild(e, t) {
    this.tabGuardFeature.appendChild(super.appendChild.bind(this), e, t);
  }
}, bi = class {
  constructor(e, t = !1) {
    this.DOUBLE_TAP_MILLIS = 500, this.destroyFuncs = [], this.touching = !1, this.localEventService = new Li(), this.preventMouseClick = t;
    const i = this.onTouchStart.bind(this), s = this.onTouchMove.bind(this), o = this.onTouchEnd.bind(this);
    e.addEventListener("touchstart", i, { passive: !0 }), e.addEventListener("touchmove", s, { passive: !0 }), e.addEventListener("touchend", o, { passive: !1 }), this.destroyFuncs.push(() => {
      e.removeEventListener("touchstart", i, { passive: !0 }), e.removeEventListener("touchmove", s, { passive: !0 }), e.removeEventListener("touchend", o, { passive: !1 });
    });
  }
  getActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
  onTouchStart(e) {
    if (this.touching)
      return;
    this.touchStart = e.touches[0], this.touching = !0, this.moved = !1;
    const t = this.touchStart;
    window.setTimeout(() => {
      const i = this.touchStart === t;
      if (this.touching && i && !this.moved) {
        this.moved = !0;
        const s = {
          type: "longTap",
          touchStart: this.touchStart,
          touchEvent: e
        };
        this.localEventService.dispatchEvent(s);
      }
    }, 500);
  }
  onTouchMove(e) {
    if (!this.touching)
      return;
    const t = this.getActiveTouch(e.touches);
    if (!t)
      return;
    !Bh(t, this.touchStart, 4) && (this.moved = !0);
  }
  onTouchEnd(e) {
    if (this.touching) {
      if (!this.moved) {
        const t = {
          type: "tap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(t), this.checkForDoubleTap();
      }
      this.preventMouseClick && e.cancelable && e.preventDefault(), this.touching = !1;
    }
  }
  checkForDoubleTap() {
    const e = Date.now();
    if (this.lastTapTime && this.lastTapTime > 0)
      if (e - this.lastTapTime > this.DOUBLE_TAP_MILLIS) {
        const i = {
          type: "doubleTap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(i), this.lastTapTime = null;
      } else
        this.lastTapTime = e;
    else
      this.lastTapTime = e;
  }
  destroy() {
    this.destroyFuncs.forEach((e) => e());
  }
}, CS = class {
  constructor(e) {
    this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => !1), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => !1);
  }
  check(e, t = !1) {
    const i = t || this.shouldSkipVerticalScroll();
    if (i && this.shouldSkipHorizontalScroll())
      return;
    const s = this.scrollContainer.getBoundingClientRect(), o = this.scrollByTick;
    this.tickLeft = e.clientX < s.left + o, this.tickRight = e.clientX > s.right - o, this.tickUp = e.clientY < s.top + o && !i, this.tickDown = e.clientY > s.bottom - o && !i, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
  }
  ensureTickingStarted() {
    this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
  }
  doTick() {
    this.tickCount++;
    const e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
    if (this.scrollVertically) {
      const t = this.getVerticalPosition();
      this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
    }
    if (this.scrollHorizontally) {
      const t = this.getHorizontalPosition();
      this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e);
    }
    this.onScrollCallback && this.onScrollCallback();
  }
  ensureCleared() {
    this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
  }
}, ap = class {
  constructor(e = "javascript") {
    this.frameworkName = e, this.renderingEngine = "vanilla", this.batchFrameworkComps = !1, this.wrapIncoming = (t) => t(), this.wrapOutgoing = (t) => t(), this.baseDocLink = `${Nh}/${this.frameworkName}-data-grid`, kC(this.baseDocLink);
  }
  frameworkComponent(e) {
    return null;
  }
  isFrameworkComponent(e) {
    return !1;
  }
  getDocLink(e) {
    return `${this.baseDocLink}${e ? `/${e}` : ""}`;
  }
};
function vS(e) {
  return {
    beanName: "gridApi",
    bean: e.getBean("apiFunctionSvc").api
  };
}
var wS = [
  // Validate license first
  "licenseManager",
  // core beans only
  "environment",
  "eventSvc",
  "gos",
  "paginationAutoPageSizeSvc",
  "apiFunctionSvc",
  "gridApi",
  "registry",
  "agCompUtils",
  "userCompFactory",
  "rowContainerHeight",
  "horizontalResizeSvc",
  "localeSvc",
  "pinnedRowModel",
  "dragSvc",
  "colGroupSvc",
  "visibleCols",
  "popupSvc",
  "selectionSvc",
  "colFilter",
  "quickFilter",
  "filterManager",
  "colModel",
  "headerNavigation",
  "pageBounds",
  "pagination",
  "pageBoundsListener",
  "rowSpanSvc",
  "stickyRowSvc",
  "rowRenderer",
  "expressionSvc",
  "alignedGridsSvc",
  "navigation",
  "valueCache",
  "valueSvc",
  "autoWidthCalc",
  "filterMenuFactory",
  "dragAndDrop",
  "focusSvc",
  "cellNavigation",
  "cellStyles",
  "scrollVisibleSvc",
  "sortSvc",
  "colHover",
  "colAnimation",
  "autoColSvc",
  "selectionColSvc",
  "changeDetectionSvc",
  "animationFrameSvc",
  "undoRedo",
  "colDefFactory",
  "rowStyleSvc",
  "rowNodeBlockLoader",
  "rowNodeSorter",
  "ctrlsSvc",
  "pinnedCols",
  "dataTypeSvc",
  "syncSvc",
  "overlays",
  "stateSvc",
  "expansionSvc",
  "apiEventSvc",
  "ariaAnnounce",
  "menuSvc",
  "colMoves",
  "colAutosize",
  "colFlex",
  "colResize",
  "pivotColsSvc",
  "valueColsSvc",
  "rowGroupColsSvc",
  "colNames",
  "colViewport",
  "pivotResultCols",
  "showRowGroupCols",
  "validation"
  // Have validations run last
], Pc = Object.fromEntries(
  wS.map((e, t) => [e, t])
);
function bS(e, t) {
  const i = (e.beanName ? Pc[e.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER, s = (t.beanName ? Pc[t.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
  return i - s;
}
function yS(e, t) {
  return (e == null ? void 0 : e.beanName) === "gridDestroySvc" ? -1 : (t == null ? void 0 : t.beanName) === "gridDestroySvc" ? 1 : 0;
}
var SS = { tag: "div", cls: "ag-pinned-left-header", role: "rowgroup" }, RS = { tag: "div", cls: "ag-pinned-right-header", role: "rowgroup" }, xS = {
  tag: "div",
  cls: "ag-header-viewport",
  role: "rowgroup",
  attrs: { tabindex: "-1" },
  children: [{ tag: "div", ref: "eCenterContainer", cls: "ag-header-container", role: "presentation" }]
}, na = class extends te {
  constructor(e) {
    super(), this.eCenterContainer = _, this.headerRowComps = {}, this.rowCompsList = [], this.pinned = e;
  }
  postConstruct() {
    this.selectAndSetTemplate();
    const e = {
      setDisplayed: (i) => this.setDisplayed(i),
      setCtrls: (i) => this.setCtrls(i),
      // only gets called for center section
      setCenterWidth: (i) => this.eCenterContainer.style.width = i,
      setViewportScrollLeft: (i) => this.getGui().scrollLeft = i,
      // only gets called for pinned sections
      setPinnedContainerWidth: (i) => {
        const s = this.getGui();
        s.style.width = i, s.style.maxWidth = i, s.style.minWidth = i;
      }
    };
    this.createManagedBean(new Ny(this.pinned)).setComp(e, this.getGui());
  }
  selectAndSetTemplate() {
    const e = this.pinned == "left", t = this.pinned == "right", i = e ? SS : t ? RS : xS;
    this.setTemplate(i), this.eRowContainer = this.eCenterContainer !== _ ? this.eCenterContainer : this.getGui();
  }
  destroy() {
    this.setCtrls([]), super.destroy();
  }
  destroyRowComp(e) {
    this.destroyBean(e), this.eRowContainer.removeChild(e.getGui());
  }
  setCtrls(e) {
    const t = this.headerRowComps;
    this.headerRowComps = {}, this.rowCompsList = [];
    let i;
    const s = (o) => {
      const n = o.getGui();
      n.parentElement != this.eRowContainer && this.eRowContainer.appendChild(n), i && kh(this.eRowContainer, n, i), i = n;
    };
    e.forEach((o) => {
      const n = o.instanceId, r = t[n];
      delete t[n];
      const a = r || this.createBean(new Hy(o));
      this.headerRowComps[n] = a, this.rowCompsList.push(a), s(a);
    }), Object.values(t).forEach((o) => this.destroyRowComp(o));
  }
}, FS = { tag: "div", cls: "ag-header", role: "presentation" }, PS = class extends te {
  constructor() {
    super(FS);
  }
  postConstruct() {
    const e = {
      toggleCss: (s, o) => this.toggleCss(s, o),
      setHeightAndMinHeight: (s) => {
        this.getGui().style.height = s, this.getGui().style.minHeight = s;
      }
    };
    this.createManagedBean(new My()).setComp(e, this.getGui(), this.getFocusableElement());
    const i = (s) => {
      this.createManagedBean(s), this.appendChild(s);
    };
    i(new na("left")), i(new na(null)), i(new na("right"));
  }
}, ES = {
  selector: "AG-HEADER-ROOT",
  component: PS
}, DS = class extends te {
  constructor(e, t, i, s, o) {
    super(), this.cellCtrl = t, this.rendererVersion = 0, this.editorVersion = 0, this.beans = e, this.gos = e.gos, this.column = t.column, this.rowNode = t.rowNode, this.eRow = s;
    const n = ye({
      tag: "div",
      role: t.getCellAriaRole(),
      attrs: {
        "comp-id": `${this.getCompId()}`,
        "col-id": t.column.colIdSanitised
      }
    });
    this.eCell = n;
    let r;
    t.isCellSpanning() ? (r = ye({
      tag: "div",
      cls: "ag-spanned-cell-wrapper",
      role: "presentation"
    }), r.appendChild(n), this.setTemplateFromElement(r)) : this.setTemplateFromElement(n), this.cellCssManager = new fg(() => n), this.forceWrapper = t.isForceWrapper(), this.refreshWrapper(!1);
    const a = {
      toggleCss: (l, d) => this.cellCssManager.toggleCss(l, d),
      setUserStyles: (l) => Go(n, l),
      getFocusableElement: () => n,
      setIncludeSelection: (l) => this.includeSelection = l,
      setIncludeRowDrag: (l) => this.includeRowDrag = l,
      setIncludeDndSource: (l) => this.includeDndSource = l,
      setRenderDetails: (l, d, c) => this.setRenderDetails(l, d, c),
      setEditDetails: (l, d, c) => this.setEditDetails(l, d, c),
      getCellEditor: () => this.cellEditor || null,
      getCellRenderer: () => this.cellRenderer || null,
      getParentOfValue: () => this.getParentOfValue(),
      refreshEditStyles: (l, d) => this.refreshEditStyles(l, d)
    };
    t.setComp(a, n, r, this.eCellWrapper, i, o, void 0);
  }
  getParentOfValue() {
    return this.eCellValue ?? this.eCellWrapper ?? this.eCell;
  }
  setRenderDetails(e, t, i) {
    var n;
    if (this.cellEditor && !this.cellEditorPopupWrapper)
      return;
    this.firstRender = this.firstRender == null;
    const o = this.refreshWrapper(!1);
    this.refreshEditStyles(!1), e ? !(i || o) && this.refreshCellRenderer(e) || (this.destroyRenderer(), this.createCellRendererInstance(e)) : (this.destroyRenderer(), this.insertValueWithoutCellRenderer(t)), (n = this.rowDraggingComp) == null || n.refreshVisibility();
  }
  setEditDetails(e, t, i) {
    e ? this.createCellEditorInstance(e, t, i) : this.destroyEditor();
  }
  removeControls() {
    const e = this.beans.context;
    this.checkboxSelectionComp = e.destroyBean(this.checkboxSelectionComp), this.dndSourceComp = e.destroyBean(this.dndSourceComp), this.rowDraggingComp = e.destroyBean(this.rowDraggingComp);
  }
  // returns true if wrapper was changed
  refreshWrapper(e) {
    const t = this.includeRowDrag || this.includeDndSource || this.includeSelection, i = t || this.forceWrapper, s = i && this.eCellWrapper == null;
    s && (this.eCellWrapper = ye({ tag: "div", cls: "ag-cell-wrapper", role: "presentation" }), this.eCell.appendChild(this.eCellWrapper));
    const o = !i && this.eCellWrapper != null;
    o && (dt(this.eCellWrapper), this.eCellWrapper = void 0), this.cellCssManager.toggleCss("ag-cell-value", !i);
    const n = !e && i, r = n && this.eCellValue == null;
    r && (this.eCellValue = ye({ tag: "span", cls: "ag-cell-value", role: "presentation" }), this.eCellWrapper.appendChild(this.eCellValue));
    const a = !n && this.eCellValue != null;
    a && (dt(this.eCellValue), this.eCellValue = void 0);
    const l = s || o || r || a;
    return l && this.removeControls(), !e && t && this.addControls(), l;
  }
  addControls() {
    const { cellCtrl: e, eCellWrapper: t, eCellValue: i, includeRowDrag: s, includeDndSource: o, includeSelection: n } = this, r = (a) => {
      a && t.insertBefore(a.getGui(), i);
    };
    s && this.rowDraggingComp == null && (this.rowDraggingComp = e.createRowDragComp(), r(this.rowDraggingComp)), o && this.dndSourceComp == null && (this.dndSourceComp = e.createDndSource(), r(this.dndSourceComp)), n && this.checkboxSelectionComp == null && (this.checkboxSelectionComp = e.createSelectionCheckbox(), r(this.checkboxSelectionComp));
  }
  createCellEditorInstance(e, t, i) {
    const s = this.editorVersion, o = e.newAgStackInstance(), { params: n } = e;
    o.then((a) => this.afterCellEditorCreated(s, a, n, t, i)), de(this.cellEditor) && n.cellStartedEdit && this.cellCtrl.focusCell(!0);
  }
  insertValueWithoutCellRenderer(e) {
    const t = this.getParentOfValue();
    Te(t);
    const i = Es(e);
    i != null && (t.textContent = i);
  }
  destroyRenderer() {
    const { context: e } = this.beans;
    this.cellRenderer = e.destroyBean(this.cellRenderer), dt(this.cellRendererGui), this.cellRendererGui = null, this.rendererVersion++;
  }
  destroyEditor() {
    var i, s;
    const { context: e } = this.beans;
    (((i = this.cellEditorPopupWrapper) == null ? void 0 : i.getGui().contains(he(this.beans))) || this.cellCtrl.hasBrowserFocus()) && this.eCell.focus({ preventScroll: !0 }), (s = this.hideEditorPopup) == null || s.call(this), this.hideEditorPopup = void 0, this.cellEditor = e.destroyBean(this.cellEditor), this.cellEditorPopupWrapper = e.destroyBean(this.cellEditorPopupWrapper), dt(this.cellEditorGui), this.cellCtrl.disableEditorTooltipFeature(), this.cellEditorGui = null, this.editorVersion++;
  }
  refreshCellRenderer(e) {
    var i;
    if (((i = this.cellRenderer) == null ? void 0 : i.refresh) == null || this.cellRendererClass !== e.componentClass)
      return !1;
    const t = this.cellRenderer.refresh(e.params);
    return t === !0 || t === void 0;
  }
  createCellRendererInstance(e) {
    var n;
    const t = this.rendererVersion, i = (r) => (a) => {
      if (this.rendererVersion !== t || !this.isAlive())
        return;
      const d = r.newAgStackInstance(), c = this.afterCellRendererCreated.bind(
        this,
        t,
        r.componentClass
      );
      d == null || d.then(c);
    }, { animationFrameSvc: s } = this.beans;
    let o;
    if (s != null && s.active && this.firstRender ? o = (r, a = !1) => {
      s.createTask(
        i(r),
        this.rowNode.rowIndex,
        "p2",
        r.componentFromFramework,
        a
      );
    } : o = (r) => i(r)(), (n = e.params) != null && n.deferRender && !this.cellCtrl.rowNode.group) {
      const { loadingComp: r, onReady: a } = this.cellCtrl.getDeferLoadingCellRenderer();
      r && (o(r), a.then(() => o(e, !0)));
    } else
      o(e);
  }
  afterCellRendererCreated(e, t, i) {
    if (!this.isAlive() || e !== this.rendererVersion) {
      this.beans.context.destroyBean(i);
      return;
    }
    this.cellRenderer = i, this.cellRendererClass = t;
    const o = i.getGui();
    if (this.cellRendererGui = o, o != null) {
      const n = this.getParentOfValue();
      Te(n), n.appendChild(o);
    }
  }
  afterCellEditorCreated(e, t, i, s, o) {
    var d;
    const n = e !== this.editorVersion, { context: r } = this.beans;
    if (n) {
      r.destroyBean(t);
      return;
    }
    if (t.isCancelBeforeStart && t.isCancelBeforeStart()) {
      r.destroyBean(t), this.cellCtrl.stopEditing(!0);
      return;
    }
    if (!t.getGui) {
      I(97, { colId: this.column.getId() }), r.destroyBean(t);
      return;
    }
    this.cellEditor = t, this.cellEditorGui = t.getGui();
    const l = s || t.isPopup !== void 0 && t.isPopup();
    l ? this.addPopupCellEditor(i, o) : this.addInCellEditor(), this.refreshEditStyles(!0, l), (d = t.afterGuiAttached) == null || d.call(t), this.cellCtrl.enableEditorTooltipFeature(t), this.cellCtrl.cellEditorAttached();
  }
  refreshEditStyles(e, t) {
    const { cellCssManager: i } = this;
    i.toggleCss("ag-cell-inline-editing", e && !t), i.toggleCss("ag-cell-popup-editing", e && !!t), i.toggleCss("ag-cell-not-inline-editing", !e || !!t);
  }
  addInCellEditor() {
    const { eCell: e } = this;
    e.contains(he(this.beans)) && e.focus(), this.destroyRenderer(), this.refreshWrapper(!0), Te(this.getParentOfValue()), this.cellEditorGui && this.getParentOfValue().appendChild(this.cellEditorGui);
  }
  addPopupCellEditor(e, t) {
    var b;
    const { gos: i, context: s, popupSvc: o, editSvc: n } = this.beans;
    i.get("editType") === "fullRow" && I(98);
    const r = this.cellEditorPopupWrapper = s.createBean(
      n.createPopupEditorWrapper(e)
    ), { cellEditor: a, cellEditorGui: l, eCell: d, rowNode: c, column: u, cellCtrl: h } = this, g = r.getGui();
    l && g.appendChild(l);
    const p = i.get("stopEditingWhenCellsLoseFocus"), f = t ?? ((b = a.getPopupPosition) == null ? void 0 : b.call(a)) ?? "over", m = i.get("enableRtl"), C = {
      ePopup: g,
      column: u,
      rowNode: c,
      type: "popupCellEditor",
      eventSource: d,
      position: f,
      alignSide: m ? "right" : "left",
      keepWithinBounds: !0
    }, v = o.positionPopupByComponent.bind(o, C), R = o.addPopup({
      modal: p,
      eChild: g,
      closeOnEsc: !0,
      closedCallback: () => {
        h.onPopupEditorClosed();
      },
      anchorToElement: d,
      positionCallback: v,
      ariaOwns: d
    });
    R && (this.hideEditorPopup = R.hideFunc);
  }
  detach() {
    this.eRow.removeChild(this.getGui());
  }
  // if the row is also getting destroyed, then we don't need to remove from dom,
  // as the row will also get removed, so no need to take out the cells from the row
  // if the row is going (removing is an expensive operation, so only need to remove
  // the top part)
  //
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroy() {
    this.destroyRenderer(), this.destroyEditor(), this.removeControls(), super.destroy();
  }
}, TS = class extends te {
  constructor(e, t, i) {
    super(), this.cellComps = /* @__PURE__ */ new Map(), this.beans = t, this.rowCtrl = e;
    const s = ye({ tag: "div", role: "row", attrs: { "comp-id": `${this.getCompId()}` } });
    this.setInitialStyle(s, i), this.setTemplateFromElement(s);
    const o = s.style;
    this.domOrder = this.rowCtrl.getDomOrder();
    const n = {
      setDomOrder: (r) => this.domOrder = r,
      setCellCtrls: (r) => this.setCellCtrls(r),
      showFullWidth: (r) => this.showFullWidth(r),
      getFullWidthCellRenderer: () => this.fullWidthCellRenderer,
      getFullWidthCellRendererParams: () => this.fullWidthCellRendererParams,
      toggleCss: (r, a) => this.toggleCss(r, a),
      setUserStyles: (r) => Go(s, r),
      setTop: (r) => o.top = r,
      setTransform: (r) => o.transform = r,
      setRowIndex: (r) => s.setAttribute("row-index", r),
      setRowId: (r) => s.setAttribute("row-id", r),
      setRowBusinessKey: (r) => s.setAttribute("row-business-key", r),
      refreshFullWidth: (r) => {
        var l, d;
        const a = r();
        return this.fullWidthCellRendererParams = a, ((d = (l = this.fullWidthCellRenderer) == null ? void 0 : l.refresh) == null ? void 0 : d.call(l, a)) ?? !1;
      }
    };
    e.setComp(n, this.getGui(), i, void 0), this.addDestroyFunc(() => {
      e.unsetComp(i);
    });
  }
  setInitialStyle(e, t) {
    const i = this.rowCtrl.getInitialTransform(t);
    if (i)
      e.style.setProperty("transform", i);
    else {
      const s = this.rowCtrl.getInitialRowTop(t);
      s && e.style.setProperty("top", s);
    }
  }
  showFullWidth(e) {
    const t = (s) => {
      if (this.isAlive()) {
        const o = s.getGui();
        this.getGui().appendChild(o), this.rowCtrl.setupDetailRowAutoHeight(o), this.setFullWidthRowComp(s, e.params);
      } else
        this.beans.context.destroyBean(s);
    };
    e.newAgStackInstance().then(t);
  }
  setCellCtrls(e) {
    const t = new Map(this.cellComps);
    for (const i of e) {
      const s = i.instanceId;
      this.cellComps.has(s) ? t.delete(s) : this.newCellComp(i);
    }
    this.destroyCells(t), this.ensureDomOrder(e);
  }
  ensureDomOrder(e) {
    if (!this.domOrder)
      return;
    const t = [];
    for (const i of e) {
      const s = this.cellComps.get(i.instanceId);
      s && t.push(s.getGui());
    }
    Lh(this.getGui(), t);
  }
  newCellComp(e) {
    var s;
    const t = ((s = this.beans.editSvc) == null ? void 0 : s.isEditing(e, { withOpenEditor: !0 })) ?? !1, i = new DS(this.beans, e, this.rowCtrl.printLayout, this.getGui(), t);
    this.cellComps.set(e.instanceId, i), this.getGui().appendChild(i.getGui());
  }
  destroy() {
    super.destroy(), this.destroyCells(this.cellComps);
  }
  setFullWidthRowComp(e, t) {
    this.fullWidthCellRenderer = e, this.fullWidthCellRendererParams = t, this.addDestroyFunc(() => {
      this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer), this.fullWidthCellRendererParams = void 0;
    });
  }
  destroyCells(e) {
    for (const t of e.values()) {
      if (!t)
        return;
      const i = t.cellCtrl.instanceId;
      if (this.cellComps.get(i) !== t)
        return;
      t.detach(), t.destroy(), this.cellComps.delete(i);
    }
  }
};
function MS(e, t, i) {
  const s = !!i.gos.get("enableCellSpan") && !!t.getSpannedRowCtrls, o = {
    tag: "div",
    ref: "eContainer",
    cls: Mn(e),
    role: "rowgroup"
  };
  if (t.type === "center" || s) {
    const n = {
      tag: "div",
      ref: "eSpannedContainer",
      cls: `ag-spanning-container ${ey(e)}`,
      role: "presentation"
    };
    return o.role = "presentation", {
      tag: "div",
      ref: "eViewport",
      cls: `ag-viewport ${jg(e)}`,
      role: "rowgroup",
      children: [o, s ? n : null]
    };
  }
  return o;
}
var AS = class extends te {
  constructor(e) {
    super(), this.eViewport = _, this.eContainer = _, this.eSpannedContainer = _, this.rowCompsNoSpan = {}, this.rowCompsWithSpan = {}, this.name = e == null ? void 0 : e.name, this.options = zo(this.name);
  }
  postConstruct() {
    this.setTemplate(MS(this.name, this.options, this.beans));
    const e = {
      setHorizontalScroll: (i) => this.eViewport.scrollLeft = i,
      setViewportHeight: (i) => this.eViewport.style.height = i,
      setRowCtrls: ({ rowCtrls: i }) => this.setRowCtrls(i),
      setSpannedRowCtrls: (i) => this.setRowCtrls(i, !0),
      setDomOrder: (i) => {
        this.domOrder = i;
      },
      setContainerWidth: (i) => {
        this.eContainer.style.width = i, this.eSpannedContainer && (this.eSpannedContainer.style.width = i);
      },
      setOffsetTop: (i) => {
        const s = `translateY(${i})`;
        this.eContainer.style.transform = s, this.eSpannedContainer && (this.eSpannedContainer.style.transform = s);
      }
    };
    this.createManagedBean(new cy(this.name)).setComp(e, this.eContainer, this.eSpannedContainer, this.eViewport);
  }
  destroy() {
    this.setRowCtrls([]), this.setRowCtrls([], !0), super.destroy(), this.lastPlacedElement = null;
  }
  setRowCtrls(e, t) {
    const { beans: i, options: s } = this, o = t ? this.eSpannedContainer : this.eContainer, n = t ? { ...this.rowCompsWithSpan } : { ...this.rowCompsNoSpan }, r = {};
    t ? this.rowCompsWithSpan = r : this.rowCompsNoSpan = r, this.lastPlacedElement = null;
    const a = [];
    for (const l of e) {
      const d = l.instanceId, c = n[d];
      let u;
      if (c)
        u = c, delete n[d];
      else {
        if (!l.rowNode.displayed)
          continue;
        u = new TS(l, i, s.type);
      }
      r[d] = u, a.push([u, !c]);
    }
    this.removeOldRows(Object.values(n), o), this.addRowNodes(a, o);
  }
  addRowNodes(e, t) {
    const { domOrder: i } = this;
    for (const [s, o] of e) {
      const n = s.getGui();
      i ? this.ensureDomOrder(n, t) : o && t.appendChild(n);
    }
  }
  removeOldRows(e, t) {
    for (const i of e)
      t.removeChild(i.getGui()), i.destroy();
  }
  ensureDomOrder(e, t) {
    kh(t, e, this.lastPlacedElement), this.lastPlacedElement = e;
  }
}, IS = {
  selector: "AG-ROW-CONTAINER",
  component: AS
};
function Bs(e, t) {
  return t.map((i) => {
    const s = `e${i[0].toUpperCase() + i.substring(1)}RowContainer`;
    return e[s] = { name: i }, {
      tag: "ag-row-container",
      ref: s,
      attrs: { name: i }
    };
  });
}
function kS(e) {
  const t = {}, i = {
    tag: "div",
    ref: "eGridRoot",
    cls: "ag-root ag-unselectable",
    children: [
      { tag: "ag-header-root" },
      {
        tag: "div",
        ref: "eTop",
        cls: "ag-floating-top",
        role: "presentation",
        children: Bs(t, ["topLeft", "topCenter", "topRight", "topFullWidth"])
      },
      {
        tag: "div",
        ref: "eBody",
        cls: "ag-body",
        role: "presentation",
        children: [
          {
            tag: "div",
            ref: "eBodyViewport",
            cls: "ag-body-viewport",
            role: "presentation",
            children: Bs(t, ["left", "center", "right", "fullWidth"])
          },
          { tag: "ag-fake-vertical-scroll" }
        ]
      },
      {
        tag: "div",
        ref: "eStickyTop",
        cls: "ag-sticky-top",
        role: "presentation",
        children: Bs(t, [
          "stickyTopLeft",
          "stickyTopCenter",
          "stickyTopRight",
          "stickyTopFullWidth"
        ])
      },
      {
        tag: "div",
        ref: "eStickyBottom",
        cls: "ag-sticky-bottom",
        role: "presentation",
        children: Bs(t, [
          "stickyBottomLeft",
          "stickyBottomCenter",
          "stickyBottomRight",
          "stickyBottomFullWidth"
        ])
      },
      {
        tag: "div",
        ref: "eBottom",
        cls: "ag-floating-bottom",
        role: "presentation",
        children: Bs(t, [
          "bottomLeft",
          "bottomCenter",
          "bottomRight",
          "bottomFullWidth"
        ])
      },
      { tag: "ag-fake-horizontal-scroll" },
      e ? { tag: "ag-overlay-wrapper" } : null
    ]
  };
  return { paramsMap: t, elementParams: i };
}
var LS = class extends te {
  constructor() {
    super(...arguments), this.eGridRoot = _, this.eBodyViewport = _, this.eStickyTop = _, this.eStickyBottom = _, this.eTop = _, this.eBottom = _, this.eBody = _;
  }
  postConstruct() {
    const { overlays: e, rangeSvc: t } = this.beans, i = e == null ? void 0 : e.getOverlayWrapperSelector(), { paramsMap: s, elementParams: o } = kS(!!i);
    this.setTemplate(
      o,
      [
        ...i ? [i] : [],
        Cy,
        by,
        ES,
        IS
      ],
      s
    );
    const n = (a, l) => {
      const d = `${a}px`;
      l.style.minHeight = d, l.style.height = d;
    }, r = {
      setRowAnimationCssOnBodyViewport: (a, l) => this.setRowAnimationCssOnBodyViewport(a, l),
      setColumnCount: (a) => sC(this.getGui(), a),
      setRowCount: (a) => tC(this.getGui(), a),
      setTopHeight: (a) => n(a, this.eTop),
      setBottomHeight: (a) => n(a, this.eBottom),
      setTopInvisible: (a) => this.eTop.classList.toggle("ag-invisible", a),
      setBottomInvisible: (a) => this.eBottom.classList.toggle("ag-invisible", a),
      setStickyTopHeight: (a) => this.eStickyTop.style.height = a,
      setStickyTopTop: (a) => this.eStickyTop.style.top = a,
      setStickyTopWidth: (a) => this.eStickyTop.style.width = a,
      setStickyBottomHeight: (a) => {
        this.eStickyBottom.style.height = a, this.eStickyBottom.classList.toggle("ag-invisible", a === "0px");
      },
      setStickyBottomBottom: (a) => this.eStickyBottom.style.bottom = a,
      setStickyBottomWidth: (a) => this.eStickyBottom.style.width = a,
      setColumnMovingCss: (a, l) => this.toggleCss(a, l),
      updateLayoutClasses: (a, l) => {
        const d = [this.eBodyViewport.classList, this.eBody.classList];
        for (const c of d)
          c.toggle(lt.AUTO_HEIGHT, l.autoHeight), c.toggle(lt.NORMAL, l.normal), c.toggle(lt.PRINT, l.print);
        this.toggleCss(lt.AUTO_HEIGHT, l.autoHeight), this.toggleCss(lt.NORMAL, l.normal), this.toggleCss(lt.PRINT, l.print);
      },
      setAlwaysVerticalScrollClass: (a, l) => this.eBodyViewport.classList.toggle(Qg, l),
      registerBodyViewportResizeListener: (a) => {
        const l = di(this.beans, this.eBodyViewport, a);
        this.addDestroyFunc(() => l());
      },
      setPinnedTopBottomOverflowY: (a) => this.eTop.style.overflowY = this.eBottom.style.overflowY = a,
      setCellSelectableCss: (a, l) => {
        [this.eTop, this.eBodyViewport, this.eBottom].forEach(
          (d) => d.classList.toggle(a, l)
        );
      },
      setBodyViewportWidth: (a) => this.eBodyViewport.style.width = a,
      setGridRootRole: (a) => oi(this.eGridRoot, a)
    };
    this.ctrl = this.createManagedBean(new gy()), this.ctrl.setComp(
      r,
      this.getGui(),
      this.eBodyViewport,
      this.eTop,
      this.eBottom,
      this.eStickyTop,
      this.eStickyBottom
    ), (t && zt(this.gos) || xo(this.gos)) && eC(this.getGui(), !0);
  }
  setRowAnimationCssOnBodyViewport(e, t) {
    const i = this.eBodyViewport.classList;
    i.toggle("ag-row-animation", t), i.toggle("ag-row-no-animation", !t);
  }
}, OS = {
  selector: "AG-GRID-BODY",
  component: LS
}, _S = class extends E {
  constructor() {
    super(...arguments), this.additionalFocusableContainers = /* @__PURE__ */ new Set();
  }
  setComp(e, t, i) {
    this.view = e, this.eGridHostDiv = t, this.eGui = i, this.eGui.setAttribute("grid-id", this.beans.context.getId());
    const { dragAndDrop: s, ctrlsSvc: o } = this.beans;
    s == null || s.registerGridDropTarget(() => this.eGui, this), this.createManagedBean(new Kl(this.view)), this.view.setRtlClass(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr");
    const n = di(this.beans, this.eGridHostDiv, this.onGridSizeChanged.bind(this));
    this.addDestroyFunc(() => n()), o.register("gridCtrl", this);
  }
  isDetailGrid() {
    var t;
    const e = Fg(this.getGui());
    return ((t = e == null ? void 0 : e.getAttribute("row-id")) == null ? void 0 : t.startsWith("detail")) || !1;
  }
  getOptionalSelectors() {
    var t, i, s, o, n;
    const e = this.beans;
    return {
      paginationSelector: (t = e.pagination) == null ? void 0 : t.getPaginationSelector(),
      gridHeaderDropZonesSelector: (i = e.registry) == null ? void 0 : i.getSelector("AG-GRID-HEADER-DROP-ZONES"),
      sideBarSelector: (s = e.sideBar) == null ? void 0 : s.getSelector(),
      statusBarSelector: (o = e.registry) == null ? void 0 : o.getSelector("AG-STATUS-BAR"),
      watermarkSelector: (n = e.licenseManager) == null ? void 0 : n.getWatermarkSelector()
    };
  }
  onGridSizeChanged() {
    this.eventSvc.dispatchEvent({
      type: "gridSizeChanged",
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    });
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(e) {
    const { view: t } = this;
    if (e === !1)
      t.setCursor(null);
    else {
      const i = e === 1 ? "ew-resize" : "ns-resize";
      t.setCursor(i);
    }
  }
  disableUserSelect(e) {
    this.view.setUserSelect(e ? "none" : null);
  }
  focusNextInnerContainer(e) {
    const t = this.getFocusableContainers(), { indexWithFocus: i, nextIndex: s } = this.getNextFocusableIndex(t, e);
    if (s < 0 || s >= t.length)
      return !1;
    if (s === 0) {
      if (i > 0) {
        const { visibleCols: o, focusSvc: n } = this.beans, r = o.allCols, a = se(r);
        if (n.focusGridView({ column: a, backwards: !0 }))
          return !0;
      }
      return !1;
    }
    return this.focusContainer(t[s], e);
  }
  focusInnerElement(e) {
    const t = this.gos.getCallback("focusGridInnerElement");
    if (t && t({ fromBottom: !!e }))
      return !0;
    const i = this.getFocusableContainers(), { focusSvc: s, visibleCols: o } = this.beans, n = o.allCols;
    if (e) {
      if (i.length > 1)
        return this.focusContainer(se(i), e);
      const r = se(n);
      if (s.focusGridView({ column: r, backwards: e }))
        return !0;
    }
    if (this.gos.get("headerHeight") === 0 || Ai(this.beans)) {
      if (s.focusGridView({ column: n[0], backwards: e }))
        return !0;
      for (let r = 1; r < i.length; r++)
        if (_i(i[r].getGui(), e))
          return !0;
      return !1;
    }
    return s.focusFirstHeader();
  }
  forceFocusOutOfContainer(e = !1) {
    this.view.forceFocusOutOfContainer(e);
  }
  addFocusableContainer(e) {
    this.additionalFocusableContainers.add(e);
  }
  removeFocusableContainer(e) {
    this.additionalFocusableContainers.delete(e);
  }
  allowFocusForNextCoreContainer(e) {
    var n;
    const t = this.view.getFocusableContainers(), { nextIndex: i, indexWithFocus: s } = this.getNextFocusableIndex(t, e);
    if (s === -1 || i < 0 || i >= t.length)
      return;
    const o = t[i];
    (n = o.setAllowFocus) == null || n.call(o, !0), setTimeout(() => {
      var r;
      (r = o.setAllowFocus) == null || r.call(o, !1);
    });
  }
  isFocusable() {
    var t, i;
    const e = this.beans;
    return !Sr(e) || !Ai(e) || !!((i = (t = e.sideBar) == null ? void 0 : t.comp) != null && i.isDisplayed());
  }
  getNextFocusableIndex(e, t) {
    const i = he(this.beans), s = e.findIndex((n) => n.getGui().contains(i)), o = s + (t ? -1 : 1);
    return {
      indexWithFocus: s,
      nextIndex: o
    };
  }
  focusContainer(e, t) {
    var s, o;
    (s = e.setAllowFocus) == null || s.call(e, !0);
    const i = _i(e.getGui(), t, !1, !0);
    return (o = e.setAllowFocus) == null || o.call(e, !1), i;
  }
  getFocusableContainers() {
    return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers];
  }
  destroy() {
    this.additionalFocusableContainers.clear(), super.destroy();
  }
}, HS = class extends rp {
  constructor(e) {
    super(), this.gridBody = _, this.sideBar = _, this.pagination = _, this.rootWrapperBody = _, this.eGridDiv = e;
  }
  postConstruct() {
    const e = {
      destroyGridUi: () => this.destroyBean(this),
      setRtlClass: (n) => this.addCss(n),
      forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
      updateLayoutClasses: this.updateLayoutClasses.bind(this),
      getFocusableContainers: this.getFocusableContainers.bind(this),
      setUserSelect: (n) => {
        this.getGui().style.userSelect = n ?? "", this.getGui().style.webkitUserSelect = n ?? "";
      },
      setCursor: (n) => {
        this.getGui().style.cursor = n ?? "";
      }
    }, t = this.createManagedBean(new _S()), i = t.getOptionalSelectors(), s = this.createTemplate(i), o = [OS, ...Object.values(i).filter((n) => !!n)];
    this.setTemplate(s, o), t.setComp(e, this.eGridDiv, this.getGui()), this.insertGridIntoDom(), this.initialiseTabGuard({
      // we want to override the default behaviour to do nothing for onTabKeyDown
      onTabKeyDown: () => {
      },
      focusInnerElement: (n) => t.focusInnerElement(n),
      forceFocusOutWhenTabGuardsAreEmpty: !0,
      isEmpty: () => !t.isFocusable()
    });
  }
  insertGridIntoDom() {
    const e = this.getGui();
    this.eGridDiv.appendChild(e), this.addDestroyFunc(() => {
      this.eGridDiv.removeChild(e), ni(this.gos, "Grid removed from DOM");
    });
  }
  updateLayoutClasses(e, t) {
    const i = this.rootWrapperBody.classList, { AUTO_HEIGHT: s, NORMAL: o, PRINT: n } = lt, { autoHeight: r, normal: a, print: l } = t;
    i.toggle(s, r), i.toggle(o, a), i.toggle(n, l), this.toggleCss(s, r), this.toggleCss(o, a), this.toggleCss(n, l);
  }
  createTemplate(e) {
    const t = e.gridHeaderDropZonesSelector ? { tag: "ag-grid-header-drop-zones" } : null, i = e.sideBarSelector ? {
      tag: "ag-side-bar",
      ref: "sideBar"
    } : null, s = e.statusBarSelector ? { tag: "ag-status-bar" } : null, o = e.watermarkSelector ? { tag: "ag-watermark" } : null, n = e.paginationSelector ? { tag: "ag-pagination", ref: "pagination" } : null;
    return {
      tag: "div",
      cls: "ag-root-wrapper",
      role: "presentation",
      children: [
        t,
        {
          tag: "div",
          ref: "rootWrapperBody",
          cls: "ag-root-wrapper-body",
          role: "presentation",
          children: [{ tag: "ag-grid-body", ref: "gridBody" }, i]
        },
        s,
        n,
        o
      ]
    };
  }
  getFocusableElement() {
    return this.rootWrapperBody;
  }
  forceFocusOutOfContainer(e = !1) {
    var t;
    if (!e && ((t = this.pagination) != null && t.isDisplayed())) {
      this.pagination.forceFocusOutOfContainer(e);
      return;
    }
    super.forceFocusOutOfContainer(e);
  }
  getFocusableContainers() {
    const e = [this.gridBody];
    return [this.sideBar, this.pagination].forEach((t) => {
      t && e.push(t);
    }), e.filter((t) => Mt(t.getGui()));
  }
}, z = (e, t) => {
  for (const i of Object.keys(t))
    t[i] = e;
  return t;
}, Ec = {
  dispatchEvent: "CommunityCore",
  // this is always registered
  ...z("CommunityCore", {
    destroy: 0,
    getGridId: 0,
    getGridOption: 0,
    isDestroyed: 0,
    setGridOption: 0,
    updateGridOptions: 0,
    isModuleRegistered: 0
  }),
  ...z("GridState", {
    getState: 0,
    setState: 0
  }),
  ...z("SharedRowSelection", {
    setNodesSelected: 0,
    selectAll: 0,
    deselectAll: 0,
    selectAllFiltered: 0,
    deselectAllFiltered: 0,
    selectAllOnCurrentPage: 0,
    deselectAllOnCurrentPage: 0,
    getSelectedNodes: 0,
    getSelectedRows: 0
  }),
  ...z("RowApi", {
    redrawRows: 0,
    setRowNodeExpanded: 0,
    getRowNode: 0,
    addRenderedRowListener: 0,
    getRenderedNodes: 0,
    forEachNode: 0,
    getFirstDisplayedRowIndex: 0,
    getLastDisplayedRowIndex: 0,
    getDisplayedRowAtIndex: 0,
    getDisplayedRowCount: 0
  }),
  ...z("ScrollApi", {
    getVerticalPixelRange: 0,
    getHorizontalPixelRange: 0,
    ensureColumnVisible: 0,
    ensureIndexVisible: 0,
    ensureNodeVisible: 0
  }),
  ...z("KeyboardNavigation", {
    getFocusedCell: 0,
    clearFocusedCell: 0,
    setFocusedCell: 0,
    tabToNextCell: 0,
    tabToPreviousCell: 0,
    setFocusedHeader: 0
  }),
  ...z("EventApi", {
    addEventListener: 0,
    addGlobalListener: 0,
    removeEventListener: 0,
    removeGlobalListener: 0
  }),
  ...z("ValueCache", {
    expireValueCache: 0
  }),
  ...z("CellApi", {
    getCellValue: 0
  }),
  ...z("SharedMenu", {
    showColumnMenu: 0,
    hidePopupMenu: 0
  }),
  ...z("Sort", {
    onSortChanged: 0
  }),
  ...z("PinnedRow", {
    getPinnedTopRowCount: 0,
    getPinnedBottomRowCount: 0,
    getPinnedTopRow: 0,
    getPinnedBottomRow: 0,
    forEachPinnedRow: 0
  }),
  ...z("Overlay", {
    showLoadingOverlay: 0,
    showNoRowsOverlay: 0,
    hideOverlay: 0
  }),
  ...z("RenderApi", {
    setGridAriaProperty: 0,
    refreshCells: 0,
    refreshHeader: 0,
    isAnimationFrameQueueEmpty: 0,
    flushAllAnimationFrames: 0,
    getSizesForCurrentTheme: 0,
    getCellRendererInstances: 0
  }),
  ...z("HighlightChanges", {
    flashCells: 0
  }),
  ...z("RowDrag", {
    addRowDropZone: 0,
    removeRowDropZone: 0,
    getRowDropZoneParams: 0,
    getRowDropPositionIndicator: 0,
    setRowDropPositionIndicator: 0
  }),
  ...z("ColumnApi", {
    getColumnDefs: 0,
    getColumnDef: 0,
    getDisplayNameForColumn: 0,
    getColumn: 0,
    getColumns: 0,
    applyColumnState: 0,
    getColumnState: 0,
    resetColumnState: 0,
    isPinning: 0,
    isPinningLeft: 0,
    isPinningRight: 0,
    getDisplayedColAfter: 0,
    getDisplayedColBefore: 0,
    setColumnsVisible: 0,
    setColumnsPinned: 0,
    getAllGridColumns: 0,
    getDisplayedLeftColumns: 0,
    getDisplayedCenterColumns: 0,
    getDisplayedRightColumns: 0,
    getAllDisplayedColumns: 0,
    getAllDisplayedVirtualColumns: 0
  }),
  ...z("ColumnAutoSize", {
    sizeColumnsToFit: 0,
    autoSizeColumns: 0,
    autoSizeAllColumns: 0
  }),
  ...z("ColumnGroup", {
    setColumnGroupOpened: 0,
    getColumnGroup: 0,
    getProvidedColumnGroup: 0,
    getDisplayNameForColumnGroup: 0,
    getColumnGroupState: 0,
    setColumnGroupState: 0,
    resetColumnGroupState: 0,
    getLeftDisplayedColumnGroups: 0,
    getCenterDisplayedColumnGroups: 0,
    getRightDisplayedColumnGroups: 0,
    getAllDisplayedColumnGroups: 0
  }),
  ...z("ColumnMove", {
    moveColumnByIndex: 0,
    moveColumns: 0
  }),
  ...z("ColumnResize", {
    setColumnWidths: 0
  }),
  ...z("ColumnHover", {
    isColumnHovered: 0
  }),
  ...z("EditCore", {
    getCellEditorInstances: 0,
    getEditingCells: 0,
    getEditRowValues: 0,
    stopEditing: 0,
    startEditingCell: 0,
    isEditing: 0,
    validateEdit: 0
  }),
  ...z("BatchEdit", {
    startBatchEdit: 0,
    cancelBatchEdit: 0,
    commitBatchEdit: 0,
    isBatchEditing: 0
  }),
  ...z("UndoRedoEdit", {
    undoCellEditing: 0,
    redoCellEditing: 0,
    getCurrentUndoSize: 0,
    getCurrentRedoSize: 0
  }),
  ...z("FilterCore", {
    isAnyFilterPresent: 0,
    onFilterChanged: 0
  }),
  ...z("ColumnFilter", {
    isColumnFilterPresent: 0,
    getColumnFilterInstance: 0,
    destroyFilter: 0,
    setFilterModel: 0,
    getFilterModel: 0,
    getColumnFilterModel: 0,
    setColumnFilterModel: 0,
    showColumnFilter: 0,
    hideColumnFilter: 0,
    getColumnFilterHandler: 0,
    doFilterAction: 0
  }),
  ...z("QuickFilter", {
    isQuickFilterPresent: 0,
    getQuickFilter: 0,
    resetQuickFilter: 0
  }),
  ...z("Find", {
    findGetActiveMatch: 0,
    findGetTotalMatches: 0,
    findGoTo: 0,
    findNext: 0,
    findPrevious: 0,
    findGetNumMatches: 0,
    findGetParts: 0,
    findClearActive: 0,
    findRefresh: 0
  }),
  ...z("Pagination", {
    paginationIsLastPageFound: 0,
    paginationGetPageSize: 0,
    paginationGetCurrentPage: 0,
    paginationGetTotalPages: 0,
    paginationGetRowCount: 0,
    paginationGoToNextPage: 0,
    paginationGoToPreviousPage: 0,
    paginationGoToFirstPage: 0,
    paginationGoToLastPage: 0,
    paginationGoToPage: 0
  }),
  ...z("CsrmSsrmSharedApi", {
    expandAll: 0,
    collapseAll: 0
  }),
  ...z("SsrmInfiniteSharedApi", {
    setRowCount: 0,
    getCacheBlockState: 0,
    isLastRowIndexKnown: 0
  }),
  ...z("ClientSideRowModelApi", {
    onGroupExpandedOrCollapsed: 0,
    refreshClientSideRowModel: 0,
    isRowDataEmpty: 0,
    forEachLeafNode: 0,
    forEachNodeAfterFilter: 0,
    forEachNodeAfterFilterAndSort: 0,
    applyTransaction: 0,
    applyTransactionAsync: 0,
    flushAsyncTransactions: 0,
    getBestCostNodeSelection: 0,
    onRowHeightChanged: 0,
    resetRowHeights: 0
  }),
  ...z("CsvExport", {
    getDataAsCsv: 0,
    exportDataAsCsv: 0
  }),
  ...z("InfiniteRowModel", {
    refreshInfiniteCache: 0,
    purgeInfiniteCache: 0,
    getInfiniteRowCount: 0
  }),
  ...z("AdvancedFilter", {
    getAdvancedFilterModel: 0,
    setAdvancedFilterModel: 0,
    showAdvancedFilterBuilder: 0,
    hideAdvancedFilterBuilder: 0
  }),
  ...z("IntegratedCharts", {
    getChartModels: 0,
    getChartRef: 0,
    getChartImageDataURL: 0,
    downloadChart: 0,
    openChartToolPanel: 0,
    closeChartToolPanel: 0,
    createRangeChart: 0,
    createPivotChart: 0,
    createCrossFilterChart: 0,
    updateChart: 0,
    restoreChart: 0
  }),
  ...z("Clipboard", {
    copyToClipboard: 0,
    cutToClipboard: 0,
    copySelectedRowsToClipboard: 0,
    copySelectedRangeToClipboard: 0,
    copySelectedRangeDown: 0,
    pasteFromClipboard: 0
  }),
  ...z("ExcelExport", {
    getDataAsExcel: 0,
    exportDataAsExcel: 0,
    getSheetDataForExcel: 0,
    getMultipleSheetsAsExcel: 0,
    exportMultipleSheetsAsExcel: 0
  }),
  ...z("SharedMasterDetail", {
    addDetailGridInfo: 0,
    removeDetailGridInfo: 0,
    getDetailGridInfo: 0,
    forEachDetailGridInfo: 0
  }),
  ...z("ContextMenu", {
    showContextMenu: 0
  }),
  ...z("ColumnMenu", {
    showColumnChooser: 0,
    hideColumnChooser: 0
  }),
  ...z("CellSelection", {
    getCellRanges: 0,
    addCellRange: 0,
    clearRangeSelection: 0,
    clearCellSelection: 0
  }),
  ...z("SharedRowGrouping", {
    setRowGroupColumns: 0,
    removeRowGroupColumns: 0,
    addRowGroupColumns: 0,
    getRowGroupColumns: 0,
    moveRowGroupColumn: 0
  }),
  ...z("SharedAggregation", {
    addAggFuncs: 0,
    clearAggFuncs: 0,
    setColumnAggFunc: 0
  }),
  ...z("SharedPivot", {
    isPivotMode: 0,
    getPivotResultColumn: 0,
    setValueColumns: 0,
    getValueColumns: 0,
    removeValueColumns: 0,
    addValueColumns: 0,
    setPivotColumns: 0,
    removePivotColumns: 0,
    addPivotColumns: 0,
    getPivotColumns: 0,
    setPivotResultColumns: 0,
    getPivotResultColumns: 0
  }),
  ...z("ServerSideRowModelApi", {
    getServerSideSelectionState: 0,
    setServerSideSelectionState: 0,
    applyServerSideTransaction: 0,
    applyServerSideTransactionAsync: 0,
    applyServerSideRowData: 0,
    retryServerSideLoads: 0,
    flushServerSideAsyncTransactions: 0,
    refreshServerSide: 0,
    getServerSideGroupLevelState: 0,
    onRowHeightChanged: 0,
    resetRowHeights: 0
  }),
  ...z("SideBar", {
    isSideBarVisible: 0,
    setSideBarVisible: 0,
    setSideBarPosition: 0,
    openToolPanel: 0,
    closeToolPanel: 0,
    getOpenedToolPanel: 0,
    refreshToolPanel: 0,
    isToolPanelShowing: 0,
    getToolPanelInstance: 0,
    getSideBar: 0
  }),
  ...z("StatusBar", {
    getStatusPanel: 0
  })
}, ra = {
  isDestroyed: () => !0,
  destroy() {
  },
  preConstruct() {
  },
  postConstruct() {
  },
  preWireBeans() {
  },
  wireBeans() {
  }
}, BS = (e, t) => e.eventSvc.dispatchEvent(t), lp = class {
};
Reflect.defineProperty(lp, "name", { value: "GridApi" });
var GS = class extends E {
  constructor() {
    super(), this.beanName = "apiFunctionSvc", this.api = new lp(), this.fns = {
      ...ra,
      // dispatchEvent is used by frameworks, also used by aligned grids to identify a grid api instance
      dispatchEvent: BS
    }, this.preDestroyLink = "";
    const { api: e } = this;
    for (const t of Object.keys(Ec))
      e[t] = this.makeApi(t)[t];
  }
  postConstruct() {
    this.preDestroyLink = this.beans.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
  }
  addFunction(e, t) {
    var o;
    const { fns: i, beans: s } = this;
    i !== ra && (i[e] = ((o = s == null ? void 0 : s.validation) == null ? void 0 : o.validateApiFunction(e, t)) ?? t);
  }
  makeApi(e) {
    return {
      [e]: (...t) => {
        const {
          beans: i,
          fns: { [e]: s }
        } = this;
        return s ? s(i, ...t) : this.apiNotFound(e);
      }
    };
  }
  apiNotFound(e) {
    const { beans: t, gos: i, preDestroyLink: s } = this;
    if (!t)
      I(26, { fnName: e, preDestroyLink: s });
    else {
      const o = Ec[e];
      i.assertModuleRegistered(o, `api.${e}`) && I(27, { fnName: e, module: o });
    }
  }
  destroy() {
    super.destroy(), this.fns = ra, this.beans = null;
  }
};
function VS(e) {
  return e.context.getId();
}
function NS(e) {
  e.gridDestroySvc.destroy();
}
function WS(e) {
  return e.gridDestroySvc.destroyCalled;
}
function zS(e, t) {
  return e.gos.get(t);
}
function US(e, t, i) {
  dp(e, { [t]: i });
}
function dp(e, t) {
  e.gos.updateGridOptions({ options: t });
}
function $S(e, t) {
  const i = t.replace(/Module$/, "");
  return e.gos.isModuleRegistered(i);
}
var KS = { tag: "div", cls: "ag-drag-handle ag-row-drag", attrs: { draggable: "true" } }, jS = class extends te {
  constructor(e, t, i) {
    super(KS), this.rowNode = e, this.column = t, this.eCell = i;
  }
  postConstruct() {
    this.getGui().appendChild(Ze("rowDrag", this.beans, null)), this.addGuiEventListener("mousedown", (t) => {
      t.stopPropagation();
    }), this.addDragSource(), this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(e) {
    const { rowNode: t, column: i, eCell: s, gos: o } = this, n = i.getColDef().dndSourceOnRowDrag, r = e.dataTransfer;
    if (r.setDragImage(s, 0, 0), n) {
      const a = W(o, {
        rowNode: t,
        dragEvent: e
      });
      n(a);
    } else
      try {
        const a = JSON.stringify(t.data);
        r.setData("application/json", a), r.setData("text/plain", a);
      } catch {
      }
  }
  checkVisibility() {
    const e = this.column.isDndSource(this.rowNode);
    this.setDisplayed(e);
  }
};
function qS(e, t) {
  var i, s;
  (s = (i = e.rowDragSvc) == null ? void 0 : i.rowDragFeature) == null || s.addRowDropZone(t);
}
function YS(e, t) {
  var s, o;
  const i = (s = e.dragAndDrop) == null ? void 0 : s.findExternalZone(t.getContainer());
  i && ((o = e.dragAndDrop) == null || o.removeDropTarget(i));
}
function QS(e, t) {
  var i, s;
  return (s = (i = e.rowDragSvc) == null ? void 0 : i.rowDragFeature) == null ? void 0 : s.getRowDropZone(t);
}
function XS(e) {
  const t = e.rowDropHighlightSvc;
  return t ? { row: t.row, dropIndicatorPosition: t.position } : { row: null, dropIndicatorPosition: "none" };
}
function ZS(e, t) {
  const i = e.rowDropHighlightSvc;
  if (!i)
    return;
  const s = t == null ? void 0 : t.row;
  let o = t == null ? void 0 : t.dropIndicatorPosition;
  o !== "above" && o !== "below" && o !== "inside" && (o = "none");
  const n = s == null ? void 0 : s.rowIndex;
  n == null || o === "none" ? i.clear() : i.set(s, o);
}
var JS = class extends fb {
  shouldPreventMouseEvent(e) {
    return this.gos.get("enableCellTextSelection") && super.shouldPreventMouseEvent(e);
  }
}, eR = class extends E {
  constructor() {
    super(...arguments), this.beanName = "horizontalResizeSvc";
  }
  addResizeBar(e) {
    const t = {
      dragStartPixels: e.dragStartPixels || 0,
      eElement: e.eResizeBar,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this, e),
      onDragging: this.onDragging.bind(this, e),
      onDragCancel: this.onDragStop.bind(this, e),
      includeTouch: !0,
      stopPropagationForTouch: !0
    }, { dragSvc: i } = this.beans;
    return i.addDragSource(t), () => i.removeDragSource(t);
  }
  onDragStart(e, t) {
    this.dragStartX = t.clientX, this.setResizeIcons();
    const i = t instanceof MouseEvent && t.shiftKey === !0;
    e.onResizeStart(i);
  }
  setResizeIcons() {
    const e = this.beans.ctrlsSvc.get("gridCtrl");
    e.setResizeCursor(
      1
      /* Horizontal */
    ), e.disableUserSelect(!0);
  }
  onDragStop(e) {
    e.onResizeEnd(this.resizeAmount), this.resetIcons();
  }
  resetIcons() {
    const e = this.beans.ctrlsSvc.get("gridCtrl");
    e.setResizeCursor(!1), e.disableUserSelect(!1);
  }
  onDragging(e, t) {
    this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount);
  }
}, tR = {
  tag: "div",
  cls: "ag-drag-handle ag-row-drag",
  attrs: { "aria-hidden": "true" }
}, iR = class extends te {
  constructor(e, t, i, s, o, n = !1) {
    super(), this.cellValueFn = e, this.rowNode = t, this.column = i, this.customGui = s, this.dragStartPixels = o, this.alwaysVisible = n, this.dragSource = null;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    const { beans: e, customGui: t } = this;
    t ? this.setDragElement(t, this.dragStartPixels) : (this.setTemplate(tR), this.getGui().appendChild(Ze("rowDrag", e, null)), this.addDragSource()), this.alwaysVisible || this.initCellDrag();
  }
  initCellDrag() {
    const { beans: e, gos: t, rowNode: i } = this, s = this.refreshVisibility.bind(this);
    this.addManagedPropertyListener("suppressRowDrag", s), this.addManagedListeners(i, {
      dataChanged: s,
      cellChanged: s
    }), this.addManagedListeners(
      e.eventSvc,
      // For managed row drag, we do not show the component if sort, filter or grouping is active
      t.get("rowDragManaged") ? {
        sortChanged: s,
        filterChanged: s,
        columnRowGroupChanged: s,
        newColumnsLoaded: s
      } : { newColumnsLoaded: s }
    );
  }
  setDragElement(e, t) {
    this.setTemplateFromElement(e, void 0, void 0, !0), this.addDragSource(t);
  }
  refreshVisibility() {
    if (this.alwaysVisible)
      return;
    const e = { skipAriaHidden: !0 };
    if (this.isNeverDisplayed()) {
      this.setDisplayed(!1, e);
      return;
    }
    const t = this.column;
    let i = typeof (t == null ? void 0 : t.getColDef().rowDrag) == "function", s = !t || this.isCustomGui() || t.isRowDrag(this.rowNode);
    s && this.rowNode.footer && this.gos.get("rowDragManaged") && (s = !1, i = !0), this.setDisplayed(i || s, e), this.setVisible(s, e);
  }
  isNeverDisplayed() {
    var i, s;
    const { gos: e, beans: t } = this;
    return !!(e.get("suppressRowDrag") || e.get("rowDragManaged") && ((i = t.rowDragSvc.rowDragFeature) != null && i.shouldPreventRowMove()) && !((s = t.dragAndDrop) != null && s.hasExternalDropZones()));
  }
  getSelectedNodes() {
    var s;
    const e = this.rowNode;
    if (!this.gos.get("rowDragMultiRow"))
      return [e];
    const i = ((s = this.beans.selectionSvc) == null ? void 0 : s.getSelectedNodes()) ?? [];
    return i.indexOf(e) !== -1 ? i : [e];
  }
  getDragItem() {
    const { column: e, rowNode: t } = this;
    return {
      rowNode: t,
      rowNodes: this.getSelectedNodes(),
      columns: e ? [e] : void 0,
      defaultTextValue: this.cellValueFn()
    };
  }
  getRowDragText(e) {
    if (e) {
      const t = e.getColDef();
      if (t.rowDragText)
        return t.rowDragText;
    }
    return this.gos.get("rowDragText");
  }
  addDragSource(e = 4) {
    if (this.dragSource && this.removeDragSource(), this.gos.get("rowDragManaged") && this.rowNode.footer)
      return;
    const t = this.getGui();
    this.gos.get("enableCellTextSelection") && (this.removeMouseDownListener(), this.mouseDownListener = this.addManagedElementListeners(t, {
      mousedown: (s) => {
        s == null || s.preventDefault();
      }
    })[0]);
    const i = this.getLocaleTextFunc();
    this.dragSource = {
      type: 2,
      eElement: t,
      dragItemName: (s) => {
        var a, l;
        const o = (s == null ? void 0 : s.dragItem) || this.getDragItem(), n = (((a = s == null ? void 0 : s.dropTarget) == null ? void 0 : a.rows.length) ?? ((l = o.rowNodes) == null ? void 0 : l.length)) || 1, r = this.getRowDragText(this.column);
        return r ? r(o, n) : n === 1 ? this.cellValueFn() : `${n} ${i("rowDragRows", "rows")}`;
      },
      getDragItem: () => this.getDragItem(),
      dragStartPixels: e,
      dragSourceDomDataKey: this.gos.getDomDataKey()
    }, this.beans.dragAndDrop.addDragSource(this.dragSource, !0);
  }
  destroy() {
    this.removeDragSource(), this.removeMouseDownListener(), super.destroy();
  }
  removeDragSource() {
    this.dragSource && (this.beans.dragAndDrop.removeDragSource(this.dragSource), this.dragSource = null);
  }
  removeMouseDownListener() {
    this.mouseDownListener && (this.mouseDownListener(), this.mouseDownListener = void 0);
  }
};
function Kt(e) {
  const t = e.rowModel;
  return t.getType() === "clientSide" ? t : void 0;
}
function xr(e) {
  const t = e.rowModel;
  return t.getType() === "infinite" ? t : void 0;
}
function sR(e) {
  const t = e.rowModel;
  return t.getType() === "serverSide" ? t : void 0;
}
function oR(e) {
  const { rowIndex: t, rowPinned: i, column: s } = e;
  return `${t}.${i ?? "null"}.${s.getId()}`;
}
function cp(e, t) {
  const i = e.column === t.column, s = e.rowPinned === t.rowPinned, o = e.rowIndex === t.rowIndex;
  return i && s && o;
}
function nR(e, t) {
  switch (e.rowPinned) {
    case "top":
      if (t.rowPinned !== "top")
        return !0;
      break;
    case "bottom":
      if (t.rowPinned !== "bottom")
        return !1;
      break;
    default:
      if (H(t.rowPinned))
        return t.rowPinned !== "top";
      break;
  }
  return e.rowIndex < t.rowIndex;
}
function rR(e, t) {
  return !e && !t ? !0 : e && !t || !e && t ? !1 : e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned;
}
function aR(e) {
  let t = 0, i;
  const { pinnedRowModel: s, rowModel: o, pageBounds: n } = e;
  return s != null && s.getPinnedTopRowCount() ? i = "top" : o.getRowCount() ? (i = null, t = n.getFirstRow()) : s != null && s.getPinnedBottomRowCount() && (i = "bottom"), i === void 0 ? null : { rowIndex: t, rowPinned: i };
}
function lR(e) {
  let t, i = null;
  const { pinnedRowModel: s, pageBounds: o } = e, n = s == null ? void 0 : s.getPinnedBottomRowCount(), r = s == null ? void 0 : s.getPinnedTopRowCount();
  return n ? (i = "bottom", t = n - 1) : e.rowModel.getRowCount() ? (i = null, t = o.getLastRow()) : r && (i = "top", t = r - 1), t === void 0 ? null : { rowIndex: t, rowPinned: i };
}
function Ut(e, t) {
  var i, s;
  switch (t.rowPinned) {
    case "top":
      return (i = e.pinnedRowModel) == null ? void 0 : i.getPinnedTopRow(t.rowIndex);
    case "bottom":
      return (s = e.pinnedRowModel) == null ? void 0 : s.getPinnedBottomRow(t.rowIndex);
    default:
      return e.rowModel.getRow(t.rowIndex);
  }
}
function os(e, t) {
  var o;
  const i = (o = e.spannedRowRenderer) == null ? void 0 : o.getCellByPosition(t);
  if (i)
    return i;
  const s = e.rowRenderer.getRowByPosition(t);
  return s ? s.getCellCtrl(t.column) : null;
}
function dR(e, t, i) {
  const { rowModel: s, pinnedRowModel: o } = e;
  let n;
  return n ?? (n = s == null ? void 0 : s.getRowNode(t)), i ? n ?? (n = o == null ? void 0 : o.getPinnedRowById(t, i)) : (n ?? (n = o == null ? void 0 : o.getPinnedRowById(t, "top")), n ?? (n = o == null ? void 0 : o.getPinnedRowById(t, "bottom"))), n;
}
function ir(e, t, i = !1) {
  const { rowIndex: s, rowPinned: o } = t, { pageBounds: n, pinnedRowModel: r, rowModel: a } = e;
  if (s === 0)
    return o === "top" ? null : o === "bottom" && a.isRowsToRender() ? { rowIndex: n.getLastRow(), rowPinned: null } : r != null && r.isRowsToRender("top") ? { rowIndex: r.getPinnedTopRowCount() - 1, rowPinned: "top" } : null;
  if (i) {
    const l = o ? void 0 : a.getRow(s);
    return up(e, l, !0) ?? { rowIndex: s - 1, rowPinned: o };
  }
  return { rowIndex: s - 1, rowPinned: o };
}
function Dc(e, t, i = !1) {
  const { rowIndex: s, rowPinned: o } = t, { pageBounds: n, pinnedRowModel: r, rowModel: a } = e;
  if (cR(e, t))
    return o === "bottom" ? null : o === "top" && a.isRowsToRender() ? { rowIndex: n.getFirstRow(), rowPinned: null } : r != null && r.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
  if (i) {
    const l = o ? void 0 : a.getRow(s);
    return up(e, l) ?? { rowIndex: s + 1, rowPinned: o };
  }
  return { rowIndex: s + 1, rowPinned: o };
}
function up(e, t, i = !1) {
  const { gos: s, rowRenderer: o } = e;
  if (!(t != null && t.sticky) || !qh(s))
    return;
  const n = o.getStickyTopRowCtrls(), r = o.getStickyBottomRowCtrls(), a = !r.some((u) => u.rowNode.rowIndex === t.rowIndex), l = a ? n : r, d = (i ? -1 : 1) * (a ? -1 : 1);
  let c;
  for (let u = 0; u < l.length; u++)
    if (l[u].rowNode.rowIndex === t.rowIndex) {
      c = l[u + d];
      break;
    }
  return c ? { rowIndex: c.rowNode.rowIndex, rowPinned: null } : void 0;
}
function cR(e, t) {
  const { rowPinned: i, rowIndex: s } = t, { pinnedRowModel: o, pageBounds: n } = e;
  return i === "top" ? ((o == null ? void 0 : o.getPinnedTopRowCount()) ?? 0) - 1 <= s : i === "bottom" ? ((o == null ? void 0 : o.getPinnedBottomRowCount()) ?? 0) - 1 <= s : n.getLastRow() <= s;
}
var Do = class {
  constructor(e, t) {
    this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
      rowNode: t,
      children: null
    }, this.mapToItems[t.id] = this.pathRoot;
  }
  depthFirstSearchChangedPath(e, t) {
    const { rowNode: i, children: s } = e;
    if (s)
      for (let o = 0; o < s.length; ++o)
        this.depthFirstSearchChangedPath(s[o], t);
    t(i);
  }
  depthFirstSearchEverything(e, t, i) {
    const s = e.childrenAfterGroup;
    if (s)
      for (let o = 0, n = s.length; o < n; ++o) {
        const r = s[o];
        r.childrenAfterGroup ? this.depthFirstSearchEverything(r, t, i) : i && t(r);
      }
    t(e);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(e, t = !1, i = !1) {
    this.active && !i ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
  }
  executeFromRootNode(e) {
    e(this.pathRoot.rowNode);
  }
  createPathItems(e) {
    let t = e, i = 0;
    for (; !this.mapToItems[t.id]; ) {
      const s = {
        rowNode: t,
        children: null
      };
      this.mapToItems[t.id] = s, i++, t = t.parent;
    }
    return i;
  }
  populateColumnsMap(e, t) {
    if (!this.keepingColumns || !t)
      return;
    let i = e;
    for (; i; )
      this.nodeIdsToColumns[i.id] || (this.nodeIdsToColumns[i.id] = {}), t.forEach((s) => this.nodeIdsToColumns[i.id][s.getId()] = !0), i = i.parent;
  }
  linkPathItems(e, t) {
    let i = e;
    for (let s = 0; s < t; s++) {
      const o = this.mapToItems[i.id], n = this.mapToItems[i.parent.id];
      n.children || (n.children = []), n.children.push(o), i = i.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(e, t) {
    if (!e || e.isRowPinned())
      return;
    const i = this.createPathItems(e);
    this.linkPathItems(e, i), this.populateColumnsMap(e, t);
  }
  canSkip(e) {
    return this.active && !this.mapToItems[e.id];
  }
  getValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return t;
    const i = this.nodeIdsToColumns[e.id];
    return t.filter((o) => i[o.getId()]);
  }
  getNotValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return null;
    const i = this.nodeIdsToColumns[e.id];
    return t.filter((o) => !i[o.getId()]);
  }
}, uR = class {
  constructor(e, t) {
    this.beans = e, this.groupThrottled = !1, this.oldVScroll = null, this.groupTimer = null, this.groupTarget = null, this.onGroupThrottle = () => {
      var s;
      this.groupTimer = null, this.groupThrottled = !0, (s = this.beans.dragAndDrop) == null || s.nudge();
    };
    const i = () => t.scrollFeature.getVScrollPosition().top;
    this.autoScroll = new CS({
      scrollContainer: t.eBodyViewport,
      scrollAxis: "y",
      getVerticalPosition: i,
      setVerticalPosition: (s) => t.scrollFeature.setVerticalScrollPosition(s),
      onScrollCallback: () => {
        var n;
        const s = i(), o = this.oldVScroll;
        this.oldVScroll = s, o !== null && o !== s && ((n = this.beans.dragAndDrop) == null || n.nudge());
      }
    });
  }
  updateGroup(e, t) {
    var i, s;
    this.groupTarget && this.groupTarget !== e && this.clearGroup(), e && (t && this.groupThrottled && !e.expanded && ((i = e.childrenAfterSort) != null && i.length) && e.isExpandable() && e.setExpanded(!0, void 0, !0), e.expanded && ((s = e.childrenAfterSort) != null && s.length) && (this.groupThrottled = !0, this.groupTarget = e));
  }
  startGroup(e) {
    this.groupTarget = e, this.groupTimer === null && (this.groupTimer = window.setTimeout(this.onGroupThrottle, this.beans.gos.get("rowDragInsertDelay")));
  }
  clearGroup() {
    this.groupThrottled = !1, this.groupTarget = null;
    const e = this.groupTimer;
    e !== null && (this.groupTimer = null, window.clearTimeout(e));
  }
  clear() {
    this.clearGroup(), this.autoScroll.ensureCleared(), this.oldVScroll = null;
  }
}, hR = class extends E {
  constructor(e) {
    super(), this.eContainer = e, this.lastDraggingEvent = null, this.nudger = null;
  }
  postConstruct() {
    const e = this.beans;
    this.clientSideRowModel = Kt(e), e.ctrlsSvc.whenReady(this, (t) => {
      this.nudger = new uR(e, t.gridBodyCtrl);
    });
  }
  destroy() {
    var e;
    super.destroy(), (e = this.nudger) == null || e.clear(), this.nudger = null, this.lastDraggingEvent = null, this.eContainer = null;
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(e) {
    return e === 2;
  }
  getIconName(e) {
    var t;
    return ((t = e == null ? void 0 : e.dropTarget) == null ? void 0 : t.allowed) === !1 || this.gos.get("rowDragManaged") && this.shouldPreventRowMove() ? "notAllowed" : "move";
  }
  shouldPreventRowMove() {
    const { rowGroupColsSvc: e, filterManager: t, sortSvc: i } = this.beans;
    return !!(((e == null ? void 0 : e.columns) ?? []).length || (t == null ? void 0 : t.isAnyFilterPresent()) || (i == null ? void 0 : i.isSortActive()));
  }
  getRowNodes(e) {
    var i;
    if (!this.isFromThisGrid(e))
      return e.dragItem.rowNodes || [];
    const t = e.dragItem.rowNode;
    if (this.gos.get("rowDragMultiRow")) {
      const s = (i = this.beans.selectionSvc) == null ? void 0 : i.getSelectedNodes();
      if (s && s.indexOf(t) >= 0)
        return s.slice().sort(fR);
    }
    return [t];
  }
  onDragEnter(e) {
    this.dragging(e, !0);
  }
  onDragging(e) {
    this.dragging(e, !1);
  }
  dragging(e, t) {
    var r, a;
    const { lastDraggingEvent: i, beans: s } = this;
    if (t) {
      const l = this.getRowNodes(e);
      e.dragItem.rowNodes = l, Ac(l, !0);
    }
    this.lastDraggingEvent = e;
    const o = e.fromNudge, n = this.makeRowsDrop(i, e, o, !1);
    (r = s.rowDropHighlightSvc) == null || r.fromDrag(e), t && this.dispatchGridEvent("rowDragEnter", e), this.dispatchGridEvent("rowDragMove", e), !o && (n != null && n.rowDragManaged) && n.moved && n.allowed && n.sameGrid && !n.suppressMoveWhenRowDragging && this.dropRows(n), (a = this.nudger) == null || a.autoScroll.check(e.event);
  }
  isFromThisGrid(e) {
    return e.dragSource.dragSourceDomDataKey === this.gos.getDomDataKey();
  }
  makeRowsDrop(e, t, i, s) {
    var b;
    const { beans: o, gos: n, clientSideRowModel: r } = this, a = this.newRowsDrop(t, s);
    if (t.dropTarget = a, t.changed = !1, !a)
      return null;
    let { sameGrid: l, rootNode: d, source: c, target: u, rows: h } = a;
    u ?? (u = r.getRow(r.getRowCount() - 1) ?? null);
    const p = (
      // We don't yet support drag and drop with grouping
      eg(n) !== "group" && // We don't yet support moving tree rows from a different grid in a structured way
      l
    );
    let f = null;
    if (u != null && u.footer) {
      const w = An(r, -1, u) ?? An(r, 1, u);
      f = u.sibling ?? d, u = w ?? null;
    }
    u != null && u.detail && (u = u.parent), a.moved && (a.moved = c !== u);
    let m = 0.5;
    if (u && (l && a.moved && (f || !p) ? m = c.rowIndex > u.rowIndex ? -0.5 : 0.5 : m = (a.y - u.rowTop - u.rowHeight / 2) / u.rowHeight || 0), !p && l && u && a.moved) {
      const w = mR(r, a);
      w && (m = c.rowIndex > w.rowIndex ? -0.5 : 0.5, u = w, a.moved && (a.moved = c !== u));
    }
    const C = this.nudger;
    C == null || C.updateGroup(u, i), p && !f && C && (!u || m >= 0.5 && u.rowIndex === o.pageBounds.getLastRow() ? f = d : a.moved && this.targetShouldBeParent(u, m, h) && (C.groupThrottled && (f = u), !i && (!f || u && !u.expanded && ((b = u.childrenAfterSort) != null && b.length)) && C.startGroup(u)), f ?? (f = (u == null ? void 0 : u.parent) ?? d));
    let v = !1;
    if (f) {
      if (f === u && f !== d) {
        const w = f.expanded ? An(r, 1, u) : null;
        (w == null ? void 0 : w.parent) === f ? (u = w, m = -0.5) : v = !0;
      }
      if (u && !v) {
        let w = u;
        for (; w && w !== d && w !== f; )
          u = w, w = w.parent;
      }
    }
    a.target = u, a.newParent = f, a.moved && (a.moved = c !== u);
    const R = m < 0 ? "above" : "below";
    return a.position = a.moved ? v ? "inside" : R : "none", this.validateRowsDrop(a, p, R, s), t.changed || (t.changed = pR(e == null ? void 0 : e.dropTarget, a)), a;
  }
  newRowsDrop(e, t) {
    const { beans: i, gos: s, clientSideRowModel: o } = this, n = o.rootNode, r = s.get("rowDragManaged"), a = s.get("suppressMoveWhenRowDragging"), l = this.isFromThisGrid(e);
    let { rowNode: d, rowNodes: c } = e.dragItem;
    if (c || (c = d ? [d] : []), d || (d = c[0]), !d || !n)
      return null;
    const u = this.beans.dragAndDrop.isDropZoneWithinThisGrid(e);
    let h = !0;
    r && (!c.length || this.shouldPreventRowMove() || (a || !l) && !u) && (h = !1);
    const g = mc(i, e).y, p = this.getOverNode(g);
    return {
      api: i.gridApi,
      context: i.gridOptions.context,
      draggingEvent: e,
      rowDragManaged: r,
      suppressMoveWhenRowDragging: a,
      sameGrid: l,
      withinGrid: u,
      rootNode: n,
      moved: d !== p,
      y: g,
      overNode: p,
      overIndex: (p == null ? void 0 : p.rowIndex) ?? -1,
      position: "none",
      source: d,
      target: p ?? null,
      newParent: null,
      rows: c,
      allowed: h,
      highlight: !t && r && a && (u || !l)
    };
  }
  validateRowsDrop(e, t, i, s) {
    const { rowDragManaged: o, suppressMoveWhenRowDragging: n } = e;
    t || (e.newParent = null), n && !e.moved && (e.allowed = !1);
    const r = (!o || e.allowed) && this.gos.get("isRowValidDropPosition");
    if (r) {
      t && e.newParent && Tc(e.rows, e.newParent) && (e.newParent = null);
      const a = r(e);
      if (!a)
        e.allowed = !1;
      else if (typeof a == "object") {
        a.rows !== void 0 && (e.rows = a.rows ?? []), t && a.newParent !== void 0 && (e.newParent = a.newParent), a.target !== void 0 && (e.target = a.target), a.position && (e.position = a.position), a.allowed !== void 0 ? e.allowed = a.allowed : o || (e.allowed = !0);
        const l = e.draggingEvent;
        a.changed && l && (l.changed = !0), !s && a.highlight !== void 0 && (e.highlight = a.highlight);
      }
    }
    o && (e.rows = this.filterRows(e)), t && e.newParent && Tc(e.rows, e.newParent) && (e.newParent = null), n && (!e.rows.length || e.position === "none") && (e.allowed = !1), (!e.allowed || !e.newParent) && e.position === "inside" && (e.position = i);
  }
  targetShouldBeParent(e, t, i) {
    const s = e.rowIndex, o = 0.25;
    if (t < -0.5 + o)
      return !1;
    if (t < 0.5 - o)
      return !0;
    let n, r = s + 1;
    const a = this.clientSideRowModel;
    do
      n = a.getRow(r++);
    while (n && n.footer);
    const l = e.childrenAfterGroup;
    if (n && n.parent === e && (l != null && l.length)) {
      const d = new Set(i);
      for (const c of l)
        if (c.rowIndex !== null && !d.has(c))
          return !0;
    }
    return !1;
  }
  addRowDropZone(e) {
    if (!e.getContainer()) {
      I(55);
      return;
    }
    const t = this.beans.dragAndDrop;
    if (t.findExternalZone(e.getContainer())) {
      I(56);
      return;
    }
    const i = e.fromGrid ? e : {
      getContainer: e.getContainer,
      onDragEnter: e.onDragEnter && ((o) => e.onDragEnter(this.rowDragEvent("rowDragEnter", o))),
      onDragLeave: e.onDragLeave && ((o) => e.onDragLeave(this.rowDragEvent("rowDragLeave", o))),
      onDragging: e.onDragging && ((o) => e.onDragging(this.rowDragEvent("rowDragMove", o))),
      onDragStop: e.onDragStop && ((o) => e.onDragStop(this.rowDragEvent("rowDragEnd", o))),
      onDragCancel: e.onDragCancel && ((o) => e.onDragCancel(this.rowDragEvent("rowDragCancel", o)))
    }, s = {
      isInterestedIn: (o) => o === 2,
      getIconName: () => "move",
      external: !0,
      ...i
    };
    t.addDropTarget(s), this.addDestroyFunc(() => t.removeDropTarget(s));
  }
  getRowDropZone(e) {
    return {
      getContainer: this.getContainer.bind(this),
      onDragEnter: (i) => {
        var s;
        this.onDragEnter(i), (s = e == null ? void 0 : e.onDragEnter) == null || s.call(e, this.rowDragEvent("rowDragEnter", i));
      },
      onDragLeave: (i) => {
        var s;
        this.onDragLeave(i), (s = e == null ? void 0 : e.onDragLeave) == null || s.call(e, this.rowDragEvent("rowDragLeave", i));
      },
      onDragging: (i) => {
        var s;
        this.onDragging(i), (s = e == null ? void 0 : e.onDragging) == null || s.call(e, this.rowDragEvent("rowDragMove", i));
      },
      onDragStop: (i) => {
        var s;
        this.onDragStop(i), (s = e == null ? void 0 : e.onDragStop) == null || s.call(e, this.rowDragEvent("rowDragEnd", i));
      },
      onDragCancel: (i) => {
        var s;
        this.onDragCancel(i), (s = e == null ? void 0 : e.onDragCancel) == null || s.call(e, this.rowDragEvent("rowDragCancel", i));
      },
      fromGrid: !0
    };
  }
  getOverNode(e) {
    const { pageBounds: t, rowModel: i } = this.beans, o = e > t.getCurrentPagePixelRange().pageLastPixel ? -1 : i.getRowIndexAtPixel(e);
    return o >= 0 ? i.getRow(o) : void 0;
  }
  rowDragEvent(e, t) {
    const i = this.beans, { dragItem: s, dropTarget: o, event: n, vDirection: r } = t, a = (o == null ? void 0 : o.rootNode) === this.clientSideRowModel.rootNode, l = a ? o.y : mc(i, t).y, d = a ? o.overNode : this.getOverNode(l), c = a ? o.overIndex : (d == null ? void 0 : d.rowIndex) ?? -1;
    return {
      api: i.gridApi,
      context: i.gridOptions.context,
      type: e,
      event: n,
      node: s.rowNode,
      nodes: s.rowNodes,
      overIndex: c,
      overNode: d,
      y: l,
      vDirection: r,
      rowsDrop: o
    };
  }
  dispatchGridEvent(e, t) {
    const i = this.rowDragEvent(e, t);
    this.eventSvc.dispatchEvent(i);
  }
  onDragLeave(e) {
    this.dispatchGridEvent("rowDragLeave", e), this.stopDragging(e);
  }
  onDragStop(e) {
    const t = this.makeRowsDrop(this.lastDraggingEvent, e, !1, !0);
    this.dispatchGridEvent("rowDragEnd", e), t != null && t.allowed && t.rowDragManaged && (t.suppressMoveWhenRowDragging || !t.sameGrid) && this.dropRows(t), this.stopDragging(e);
  }
  onDragCancel(e) {
    this.dispatchGridEvent("rowDragCancel", e), this.stopDragging(e);
  }
  stopDragging(e) {
    var t, i;
    (t = this.nudger) == null || t.clear(), (i = this.beans.rowDropHighlightSvc) == null || i.fromDrag(null), Ac(e.dragItem.rowNodes, !1);
  }
  /** Drag and drop. Returns false if at least a row was moved, otherwise true */
  dropRows(e) {
    return e.sameGrid ? this.moveRows(e) : this.addRows(e);
  }
  addRows({ position: e, target: t, rows: i }) {
    const s = ws(this.gos), o = this.clientSideRowModel, n = i.filter(
      ({ data: a, rowPinned: l }) => !o.getRowNode((s == null ? void 0 : s({ data: a, level: 0, rowPinned: l })) ?? a.id)
    ).map(({ data: a }) => a);
    if (n.length === 0)
      return !1;
    const r = t ? Mc(t) + (e === "above" ? 0 : 1) : void 0;
    return o.updateRowData({ add: n, addIndex: r }), !0;
  }
  filterRows({ newParent: e, rows: t }) {
    const i = this.clientSideRowModel;
    let s;
    for (let o = 0, n = t.length; o < n; ++o) {
      let r = !0;
      const a = t[o];
      !a || a.footer || a.rowTop === null && a !== i.getRowNode(a.id) || e && a.parent !== e && gR(a, e) ? r = !1 : Xa(a) || (r = !1), r ? s == null || s.push(a) : s ?? (s = t.slice(0, o));
    }
    return s ?? t;
  }
  moveRows({ position: e, target: t, rows: i, newParent: s, rootNode: o }) {
    let n = !1;
    const r = /* @__PURE__ */ new Set();
    for (const c of i) {
      s && c.parent !== s && (c.treeParent = s, n = !0);
      const u = Xa(c);
      u && r.add(u);
    }
    if (!n && r.size === 0)
      return !1;
    const a = this.beans.focusSvc, l = a.getFocusedCell(), d = l && os(this.beans, l);
    return r.size && this.reorderLeafChildren(r, ...this.getMoveRowsBounds(r, t, e === "above")) && (n = !0), n ? (this.clientSideRowModel.refreshModel({
      step: "group",
      keepRenderedRows: !0,
      animate: !this.gos.get("suppressAnimationFrame"),
      changedPath: new Do(!1, o),
      rowNodesOrderChanged: !0
    }), d ? d.focusCell() : a.clearFocusedCell(), !0) : !1;
  }
  /** For reorderLeafChildren, returns min index of the rows to move, the target index and the max index of the rows to move. */
  getMoveRowsBounds(e, t, i) {
    var a;
    const s = ((a = this.clientSideRowModel.rootNode) == null ? void 0 : a.allLeafChildren.length) ?? 0;
    let o = Mc(t);
    o < 0 || o >= s ? o = s : i || ++o;
    let n = o, r = Math.min(o, s - 1);
    for (const l of e) {
      const d = l.sourceRowIndex;
      d < n && (n = d), d > r && (r = d);
    }
    return [n, o, r];
  }
  /** Reorders the children of the root node, so that the rows to move are in the correct order.
   * @param leafs The valid set of rows to move, as returned by getValidRowsToMove
   * @param firstAffectedLeafIdx The first index of the rows to move
   * @param targetPositionIdx The target index, where the rows will be moved
   * @param lastAffectedLeafIndex The last index of the rows to move
   * @returns True if the order of the rows changed, false otherwise
   */
  reorderLeafChildren(e, t, i, s) {
    var l;
    let o = !1;
    const n = (l = this.clientSideRowModel.rootNode) == null ? void 0 : l.allLeafChildren;
    if (!e.size || !n)
      return !1;
    let r = t;
    for (let d = t; d < i; ++d) {
      const c = n[d];
      e.has(c) || (c.sourceRowIndex !== r && (c.sourceRowIndex = r, n[r] = c, o = !0), ++r);
    }
    let a = s;
    for (let d = s; d >= i; --d) {
      const c = n[d];
      e.has(c) || (c.sourceRowIndex !== a && (c.sourceRowIndex = a, n[a] = c, o = !0), --a);
    }
    for (const d of e)
      d.sourceRowIndex !== r && (d.sourceRowIndex = r, n[r] = d, o = !0), ++r;
    return o;
  }
}, An = (e, t, i) => {
  if (i) {
    const s = e.getRowCount();
    let o = i.rowIndex + t;
    for (; o >= 0 && o < s; ) {
      const n = e.getRow(o);
      if (!n || !n.footer && !n.detail)
        return n;
      o += t;
    }
  }
}, gR = (e, t) => {
  let i = t;
  for (; i; ) {
    if (i === e)
      return !0;
    i = i.parent;
  }
  return !1;
}, Tc = (e, t) => {
  for (let i = 0, s = e.length; i < s; ++i)
    if (e[i].parent !== t)
      return !1;
  return !0;
}, Mc = (e) => {
  const t = Xa(e);
  return t !== void 0 ? t.sourceRowIndex : -1;
}, Xa = (e) => {
  for (; e; ) {
    if (e.sourceRowIndex >= 0)
      return e;
    const t = e.childrenAfterGroup;
    if (!(t != null && t.length))
      return;
    e = t[0];
  }
}, pR = (e, t) => e !== t && (!e || e.sameGrid !== t.sameGrid || e.allowed !== t.allowed || e.position !== t.position || e.target !== t.target || e.source !== t.source || e.newParent !== t.newParent || !ci(e.rows, t.rows)), fR = ({ rowIndex: e }, { rowIndex: t }) => e !== null && t !== null ? e - t : 0, Ac = (e, t) => {
  for (let i = 0, s = (e == null ? void 0 : e.length) || 0; i < s; ++i) {
    const o = e[i];
    o.dragging !== t && (o.dragging = t, o.dispatchRowEvent("draggingChanged"));
  }
}, mR = (e, t) => {
  let i = null, s = t.target;
  if (s && t.rows.indexOf(s) < 0)
    return null;
  const o = t.source;
  if (!s || !o)
    return null;
  let n = s.rowIndex - o.rowIndex;
  const r = n < 0 ? -1 : 1;
  n = t.suppressMoveWhenRowDragging ? Math.abs(n) : 1;
  const a = new Set(t.rows);
  do {
    const l = An(e, r, s);
    if (!l)
      break;
    a.has(l) || (i = l, --n), s = l;
  } while (n > 0);
  return i;
}, CR = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowDragSvc";
  }
  setupRowDrag(e, t) {
    const i = t.createManagedBean(new hR(e)), s = this.beans.dragAndDrop;
    s.addDropTarget(i), t.addDestroyFunc(() => s.removeDropTarget(i)), this.rowDragFeature = i;
  }
  createRowDragComp(e, t, i, s, o, n) {
    return new iR(e, t, i, s, o, n);
  }
  createRowDragCompForRow(e, t) {
    if (zt(this.gos))
      return;
    const i = this.getLocaleTextFunc();
    return this.createRowDragComp(
      () => `1 ${i("rowDragRow", "row")}`,
      e,
      void 0,
      t,
      void 0,
      !0
    );
  }
  createRowDragCompForCell(e, t, i, s, o, n) {
    const r = this.gos;
    return r.get("rowDragManaged") && (!xe(r) || r.get("pagination")) ? void 0 : this.createRowDragComp(
      i,
      e,
      t,
      s,
      o,
      n
    );
  }
}, vR = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowDropHighlightSvc", this.uiLevel = 0, this.dragging = !1, this.row = null, this.position = "none";
  }
  postConstruct() {
    this.addManagedEventListeners({
      modelUpdated: this.onModelUpdated.bind(this)
    });
  }
  onModelUpdated() {
    const e = this.row, t = this.dragging;
    !e || e.rowIndex === null || this.position === "none" ? this.clear() : this.set(e, this.position), this.dragging = t;
  }
  destroy() {
    this.clear(), super.destroy();
  }
  clear() {
    const e = this.row;
    this.dragging = !1, e && (this.uiLevel = 0, this.position = "none", this.row = null, e.dispatchRowEvent("rowHighlightChanged"));
  }
  set(e, t) {
    const i = e !== this.row, s = e.uiLevel, o = t !== this.position, n = s !== this.uiLevel;
    this.dragging = !1, (i || o || n) && (i && this.clear(), this.uiLevel = s, this.position = t, this.row = e, e.dispatchRowEvent("rowHighlightChanged"));
  }
  fromDrag(e) {
    const t = e == null ? void 0 : e.dropTarget;
    if (t) {
      const { highlight: i, target: s, position: o } = t;
      if (i && s && o !== "none") {
        this.set(s, o), this.dragging = !0;
        return;
      }
    }
    this.dragging && this.clear();
  }
}, hp = {
  moduleName: "Drag",
  version: B,
  beans: [JS]
}, wR = {
  moduleName: "DragAndDrop",
  version: B,
  dynamicBeans: {
    dndSourceComp: jS
  },
  icons: {
    // drag handle used to pick up draggable rows
    rowDrag: "grip"
  }
}, gp = {
  moduleName: "SharedDragAndDrop",
  version: B,
  beans: [Cb],
  dependsOn: [hp],
  userComponents: {
    agDragAndDropImage: Qy
  },
  icons: {
    // shown on drag and drop image component icon while dragging column to the side of the grid to pin
    columnMovePin: "pin",
    // shown on drag and drop image component icon while dragging over part of the page that is not a drop zone
    columnMoveHide: "eye-slash",
    // shown on drag and drop image component icon while dragging columns to reorder
    columnMoveMove: "arrows",
    // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
    columnMoveLeft: "left",
    // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
    columnMoveRight: "right",
    // shown on drag and drop image component icon while dragging over Row Groups drop zone
    columnMoveGroup: "group",
    // shown on drag and drop image component icon while dragging over Values drop zone
    columnMoveValue: "aggregation",
    // shown on drag and drop image component icon while dragging over pivot drop zone
    columnMovePivot: "pivot",
    // shown on drag and drop image component icon while dragging over drop zone that doesn't support it, e.g.
    // string column over aggregation drop zone
    dropNotAllowed: "not-allowed",
    // drag handle used to pick up draggable rows
    rowDrag: "grip"
  }
}, bR = {
  moduleName: "RowDrag",
  version: B,
  beans: [vR, CR],
  apiFunctions: {
    addRowDropZone: qS,
    removeRowDropZone: YS,
    getRowDropZoneParams: QS,
    getRowDropPositionIndicator: XS,
    setRowDropPositionIndicator: ZS
  },
  dependsOn: [gp]
}, yR = {
  moduleName: "HorizontalResize",
  version: B,
  beans: [eR],
  dependsOn: [hp]
}, SR = (
  /*css*/
  ":where(.ag-ltr) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:left .2s}.ag-header-group-cell{transition:left .2s,width .2s}}:where(.ag-rtl) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:right .2s}.ag-header-group-cell{transition:right .2s,width .2s}}"
), RR = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colAnimation", this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = !1, this.activeNext = !1, this.suppressAnimation = !1, this.animationThreadCount = 0;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => this.gridBodyCtrl = e.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(e) {
    this.suppressAnimation = e;
  }
  start() {
    if (this.active)
      return;
    const { gos: e } = this;
    e.get("suppressColumnMoveAnimation") || e.get("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = !0, this.activeNext = !0);
  }
  finish() {
    this.active && this.flush(
      () => this.activeNext = !1,
      () => this.active = !1
    );
  }
  executeNextVMTurn(e) {
    this.activeNext ? this.executeNextFuncs.push(e) : e();
  }
  executeLaterVMTurn(e) {
    this.active ? this.executeLaterFuncs.push(e) : e();
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const e = this.animationThreadCount, { gridBodyCtrl: t } = this;
    t.setColumnMovingCss(!0), this.executeLaterFuncs.push(() => {
      this.animationThreadCount === e && t.setColumnMovingCss(!1);
    });
  }
  flush(e, t) {
    const { executeNextFuncs: i, executeLaterFuncs: s } = this;
    if (i.length === 0 && s.length === 0) {
      e(), t();
      return;
    }
    const o = (n) => {
      for (; n.length; ) {
        const r = n.pop();
        r && r();
      }
    };
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        e(), o(i);
      }, 0), window.setTimeout(() => {
        t(), o(s);
      }, 200);
    });
  }
};
function xR(e, t, i) {
  var s;
  (s = e.colMoves) == null || s.moveColumnByIndex(t, i, "api");
}
function FR(e, t, i) {
  var s;
  (s = e.colMoves) == null || s.moveColumns(t, i, "api");
}
var PR = class extends E {
  constructor(e) {
    super(), this.pinned = e, this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [];
  }
  /** Callback for when drag enters */
  onDragEnter(e) {
    if (this.clearColumnsList(), this.gos.get("functionsReadOnly"))
      return;
    const t = e.dragItem.columns;
    t && t.forEach((i) => {
      i.isPrimary() && (i.isAnyFunctionActive() || (i.isAllowValue() ? this.columnsToAggregate.push(i) : i.isAllowRowGroup() ? this.columnsToGroup.push(i) : i.isAllowPivot() && this.columnsToPivot.push(i)));
    });
  }
  getIconName() {
    return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? "pinned" : "move" : null;
  }
  /** Callback for when drag leaves */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragLeave(e) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragging(e) {
  }
  /** Callback for when drag stops */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragStop(e) {
    const { valueColsSvc: t, rowGroupColsSvc: i, pivotColsSvc: s } = this.beans;
    this.columnsToAggregate.length > 0 && (t == null || t.addColumns(this.columnsToAggregate, "toolPanelDragAndDrop")), this.columnsToGroup.length > 0 && (i == null || i.addColumns(this.columnsToGroup, "toolPanelDragAndDrop")), this.columnsToPivot.length > 0 && (s == null || s.addColumns(this.columnsToPivot, "toolPanelDragAndDrop"));
  }
  onDragCancel() {
    this.clearColumnsList();
  }
};
function ER(e, t) {
  !t || t.length <= 1 || t.filter((s) => e.indexOf(s) < 0).length > 0 || t.sort((s, o) => {
    const n = e.indexOf(s), r = e.indexOf(o);
    return n - r;
  });
}
function DR(e) {
  const t = [...e];
  return e.forEach((i) => {
    var n;
    let s = null, o = i.getParent();
    for (; o != null && o.getDisplayedLeafColumns().length === 1; )
      s = o, o = o.getParent();
    s != null && (!!((n = s.getColGroupDef()) != null && n.marryChildren) ? (
      // when marry children is true, we also have to move hidden
      // columns within the group, so grab them from the `providedColumnGroup`
      s.getProvidedColumnGroup().getLeafColumns()
    ) : s.getLeafColumns()).forEach((l) => {
      t.includes(l) || t.push(l);
    });
  }), t;
}
function TR(e, t, i, s) {
  const o = s.allCols;
  let n = null, r = null;
  for (let a = 0; a < e.length; a++) {
    const l = e[a], d = i.getProposedColumnOrder(t, l);
    if (!i.doesOrderPassRules(d))
      continue;
    const c = d.filter((h) => o.includes(h));
    if (r === null)
      r = c;
    else if (!ci(c, r))
      break;
    const u = AR(d);
    (n === null || u < n.fragCount) && (n = { move: l, fragCount: u });
  }
  return n;
}
function pp(e) {
  const { isFromHeader: t, fromLeft: i, xPosition: s, fromEnter: o, fakeEvent: n, pinned: r, gos: a, colModel: l, colMoves: d, visibleCols: c } = e;
  let { allMovingColumns: u } = e;
  t && (u = DR(u));
  const h = u.slice();
  ER(l.getCols(), h);
  const g = kR({
    movingCols: h,
    draggingRight: i,
    xPosition: s,
    pinned: r,
    gos: a,
    colModel: l,
    visibleCols: c
  }), p = MR(h, l);
  if (g.length === 0)
    return;
  const f = g[0];
  if (p !== null && (t || !o) && !n && (!i && f >= p || i && f <= p))
    return;
  const C = TR(g, h, d, c);
  if (!C)
    return;
  const v = C.move;
  if (!(v > l.getCols().length - h.length))
    return { columns: h, toIndex: v };
}
function fp(e) {
  const { columns: t, toIndex: i } = pp(e) || {}, { finished: s, colMoves: o } = e;
  return !t || i == null ? null : (o.moveColumns(t, i, "uiColumnMoved", s), s ? null : { columns: t, toIndex: i });
}
function MR(e, t) {
  const i = t.getCols(), s = e.map((l) => i.indexOf(l)).sort((l, d) => l - d), o = s[0];
  return se(s) - o !== s.length - 1 ? null : o;
}
function AR(e) {
  function t(s) {
    const o = [];
    let n = s.getOriginalParent();
    for (; n != null; )
      o.push(n), n = n.getOriginalParent();
    return o;
  }
  let i = 0;
  for (let s = 0; s < e.length - 1; s++) {
    let o = t(e[s]), n = t(e[s + 1]);
    [o, n] = o.length > n.length ? [o, n] : [n, o], o.forEach((r) => {
      n.indexOf(r) === -1 && i++;
    });
  }
  return i;
}
function IR(e, t) {
  switch (t) {
    case "left":
      return e.leftCols;
    case "right":
      return e.rightCols;
    default:
      return e.centerCols;
  }
}
function kR(e) {
  const { movingCols: t, draggingRight: i, xPosition: s, pinned: o, gos: n, colModel: r, visibleCols: a } = e;
  if (n.get("suppressMovableColumns") || t.some((R) => R.getColDef().suppressMovable))
    return [];
  const d = IR(a, o), c = r.getCols(), u = d.filter((R) => t.includes(R)), h = d.filter((R) => !t.includes(R)), g = c.filter((R) => !t.includes(R));
  let p = 0, f = s;
  if (i) {
    let R = 0;
    u.forEach((b) => R += b.getActualWidth()), f -= R;
  }
  if (f > 0) {
    for (let R = 0; R < h.length; R++) {
      const b = h[R];
      if (f -= b.getActualWidth(), f < 0)
        break;
      p++;
    }
    i && p++;
  }
  let m;
  if (p > 0) {
    const R = h[p - 1];
    m = g.indexOf(R) + 1;
  } else
    m = g.indexOf(h[0]), m === -1 && (m = 0);
  const C = [m], v = (R, b) => R - b;
  if (i) {
    let R = m + 1;
    const b = c.length - 1;
    for (; R <= b; )
      C.push(R), R++;
    C.sort(v);
  } else {
    let R = m;
    const b = c.length - 1;
    let w = c[R];
    for (; R <= b && d.indexOf(w) < 0; )
      R++, C.push(R), w = c[R];
    R = m - 1;
    const x = 0;
    for (; R >= x; )
      C.push(R), R--;
    C.sort(v).reverse();
  }
  return C;
}
function Za(e) {
  var d;
  const { pinned: t, fromKeyboard: i, gos: s, ctrlsSvc: o, useHeaderRow: n, skipScrollPadding: r } = e;
  let a = (d = o.getHeaderRowContainerCtrl(t)) == null ? void 0 : d.eViewport, { x: l } = e;
  return a ? (i && (l -= a.getBoundingClientRect().left), s.get("enableRtl") && (n && (a = a.querySelector(".ag-header-row")), l = a.clientWidth - l), t == null && !r && (l += o.get("center").getCenterViewportScrollLeft()), l) : 0;
}
function aa(e, t) {
  for (const i of e)
    i.moving = t, i.dispatchColEvent("movingChanged", "uiColumnMoved");
}
var Ic = 7, Ja = 100, an = Ja / 2, LR = 5, OR = 100, _R = class extends E {
  constructor(e) {
    super(), this.pinned = e, this.needToMoveLeft = !1, this.needToMoveRight = !1, this.lastMovedInfo = null, this.isCenterContainer = !H(e);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  getIconName() {
    const { pinned: e, lastDraggingEvent: t } = this, { dragItem: i } = t || {}, s = (i == null ? void 0 : i.columns) ?? [];
    for (const o of s) {
      const n = o.getPinned();
      if (o.getColDef().lockPinned) {
        if (n == e)
          return "move";
        continue;
      }
      const r = i == null ? void 0 : i.containerType;
      if (r === e || !e)
        return "move";
      if (e && (!n || r !== e))
        return "pinned";
    }
    return "notAllowed";
  }
  onDragEnter(e) {
    const t = e.dragItem, i = t.columns;
    if (e.dragSource.type === 0)
      this.setColumnsVisible(i, !0, "uiColumnDragged");
    else {
      const o = t.visibleState, n = (i || []).filter(
        (r) => o[r.getId()] && !r.isVisible()
      );
      this.setColumnsVisible(n, !0, "uiColumnDragged");
    }
    this.gos.get("suppressMoveWhenColumnDragging") || this.attemptToPinColumns(i, this.pinned), this.onDragging(e, !0, !0);
  }
  onDragging(e = this.lastDraggingEvent, t = !1, i = !1, s = !1) {
    const { gos: o, ctrlsSvc: n } = this.beans, r = o.get("suppressMoveWhenColumnDragging");
    if (s && !r) {
      this.finishColumnMoving();
      return;
    }
    if (this.lastDraggingEvent = e, !e || !s && de(e.hDirection))
      return;
    const a = Za({
      x: e.x,
      pinned: this.pinned,
      gos: o,
      ctrlsSvc: n
    });
    t || this.checkCenterForScrolling(a), r ? this.handleColumnDragWhileSuppressingMovement(e, t, i, a, s) : this.handleColumnDragWhileAllowingMovement(e, t, i, a, s);
  }
  onDragLeave() {
    this.ensureIntervalCleared(), this.clearHighlighted(), this.updateDragItemContainerType(), this.lastMovedInfo = null;
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, !1, !0, !0), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  onDragCancel() {
    this.clearHighlighted(), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  setColumnsVisible(e, t, i) {
    if (!(e != null && e.length))
      return;
    const s = e.filter((o) => !o.getColDef().lockVisible);
    s.length && this.beans.colModel.setColsVisible(s, t, i);
  }
  finishColumnMoving() {
    this.clearHighlighted();
    const e = this.lastMovedInfo;
    if (!e)
      return;
    const { columns: t, toIndex: i } = e;
    this.beans.colMoves.moveColumns(t, i, "uiColumnMoved", !0);
  }
  updateDragItemContainerType() {
    const { lastDraggingEvent: e } = this;
    if (this.gos.get("suppressMoveWhenColumnDragging") || !e)
      return;
    const t = e.dragItem;
    t && (t.containerType = this.pinned);
  }
  handleColumnDragWhileSuppressingMovement(e, t, i, s, o) {
    const n = this.getAllMovingColumns(e, !0);
    if (o) {
      const r = this.isAttemptingToPin(n);
      r && this.attemptToPinColumns(n, void 0, !0);
      const { fromLeft: a, xPosition: l } = this.getNormalisedXPositionInfo(n, r) || {};
      if (a == null || l == null) {
        this.finishColumnMoving();
        return;
      }
      this.moveColumnsAfterHighlight({
        allMovingColumns: n,
        xPosition: l,
        fromEnter: t,
        fakeEvent: i,
        fromLeft: a
      });
    } else {
      if (!this.beans.dragAndDrop.isDropZoneWithinThisGrid(e))
        return;
      this.highlightHoveredColumn(n, s);
    }
  }
  handleColumnDragWhileAllowingMovement(e, t, i, s, o) {
    const n = this.getAllMovingColumns(e), r = this.normaliseDirection(e.hDirection) === "right", a = e.dragSource.type === 1, l = this.getMoveColumnParams({
      allMovingColumns: n,
      isFromHeader: a,
      xPosition: s,
      fromLeft: r,
      fromEnter: t,
      fakeEvent: i
    }), d = fp({ ...l, finished: o });
    d && (this.lastMovedInfo = d);
  }
  getAllMovingColumns(e, t = !1) {
    const i = e.dragSource.getDragItem();
    let s = null;
    t ? (s = i.columnsInSplit, s || (s = i.columns)) : s = i.columns;
    const o = (n) => n.getColDef().lockPinned ? n.getPinned() == this.pinned : !0;
    return s ? s.filter(o) : [];
  }
  getMoveColumnParams(e) {
    const { allMovingColumns: t, isFromHeader: i, xPosition: s, fromLeft: o, fromEnter: n, fakeEvent: r } = e, { gos: a, colModel: l, colMoves: d, visibleCols: c } = this.beans;
    return {
      allMovingColumns: t,
      isFromHeader: i,
      fromLeft: o,
      xPosition: s,
      pinned: this.pinned,
      fromEnter: n,
      fakeEvent: r,
      gos: a,
      colModel: l,
      colMoves: d,
      visibleCols: c
    };
  }
  highlightHoveredColumn(e, t) {
    var c;
    const { gos: i, colModel: s } = this.beans, o = i.get("enableRtl"), n = s.getCols().filter((u) => u.isVisible() && u.getPinned() === this.pinned);
    let r = null, a = null, l = null;
    for (const u of n) {
      if (a = u.getActualWidth(), r = this.getNormalisedColumnLeft(u, 0, o), r != null) {
        const h = r + a;
        if (r <= t && h >= t) {
          l = u;
          break;
        }
      }
      r = null, a = null;
    }
    if (l)
      e.indexOf(l) !== -1 && (l = null);
    else {
      for (let u = n.length - 1; u >= 0; u--) {
        const h = n[u], g = n[u].getParent();
        if (!g) {
          l = h;
          break;
        }
        const p = g == null ? void 0 : g.getDisplayedLeafColumns();
        if (p.length) {
          l = se(p);
          break;
        }
      }
      if (!l)
        return;
      r = this.getNormalisedColumnLeft(l, 0, o), a = l.getActualWidth();
    }
    if (((c = this.lastHighlightedColumn) == null ? void 0 : c.column) !== l && this.clearHighlighted(), l == null || r == null || a == null)
      return;
    let d;
    t - r < a / 2 !== o ? d = 0 : d = 1, kc(l, d), this.lastHighlightedColumn = { column: l, position: d };
  }
  getNormalisedXPositionInfo(e, t) {
    const { gos: i, visibleCols: s } = this.beans, o = i.get("enableRtl"), { firstMovingCol: n, column: r, position: a } = this.getColumnMoveAndTargetInfo(
      e,
      t,
      o
    );
    if (!n || !r || a == null)
      return;
    const l = s.allCols, d = l.indexOf(n), c = l.indexOf(r), u = a === 0 !== o, h = d < c || d === c && !u;
    let g = 0;
    if (u ? h && (g -= 1) : h || (g += 1), c + g === d)
      return;
    const p = l[c + g];
    if (!p)
      return;
    const f = this.getNormalisedColumnLeft(p, 20, o);
    return { fromLeft: h, xPosition: f };
  }
  getColumnMoveAndTargetInfo(e, t, i) {
    const s = this.lastHighlightedColumn || {}, { firstMovingCol: o, lastMovingCol: n } = HR(e);
    if (!o || !n || s.column || !t)
      return {
        firstMovingCol: o,
        ...s
      };
    const a = this.getPinDirection() === "left";
    return {
      firstMovingCol: o,
      position: a ? 1 : 0,
      column: a !== i ? o : n
    };
  }
  normaliseDirection(e) {
    if (this.gos.get("enableRtl"))
      switch (e) {
        case "left":
          return "right";
        case "right":
          return "left";
      }
    return e;
  }
  getNormalisedColumnLeft(e, t, i) {
    const { gos: s, ctrlsSvc: o } = this.beans, n = e.getLeft();
    if (n == null)
      return null;
    const r = e.getActualWidth();
    return Za({
      x: i ? n + r - t : n + t,
      pinned: e.getPinned(),
      useHeaderRow: i,
      skipScrollPadding: !0,
      gos: s,
      ctrlsSvc: o
    });
  }
  isAttemptingToPin(e) {
    const t = this.needToMoveLeft || this.needToMoveRight, i = this.failedMoveAttempts > Ic;
    return t && i || e.some((s) => s.getPinned() !== this.pinned);
  }
  moveColumnsAfterHighlight(e) {
    const { allMovingColumns: t, xPosition: i, fromEnter: s, fakeEvent: o, fromLeft: n } = e, r = this.getMoveColumnParams({
      allMovingColumns: t,
      isFromHeader: !0,
      xPosition: i,
      fromLeft: n,
      fromEnter: s,
      fakeEvent: o
    }), { columns: a, toIndex: l } = pp(r) || {};
    a && l != null && (this.lastMovedInfo = {
      columns: a,
      toIndex: l
    }), this.finishColumnMoving();
  }
  clearHighlighted() {
    const { lastHighlightedColumn: e } = this;
    e && (kc(e.column, null), this.lastHighlightedColumn = null);
  }
  checkCenterForScrolling(e) {
    if (!this.isCenterContainer)
      return;
    const t = this.beans.ctrlsSvc.get("center"), i = t.getCenterViewportScrollLeft(), s = i + t.getCenterWidth();
    let o, n;
    this.gos.get("enableRtl") ? (o = e < i + an, n = e > s - an) : (n = e < i + an, o = e > s - an), this.needToMoveRight = o, this.needToMoveLeft = n, n || o ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
  }
  ensureIntervalStarted() {
    this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), OR), this.beans.dragAndDrop.setDragImageCompIcon(this.needToMoveLeft ? "left" : "right", !0));
  }
  ensureIntervalCleared() {
    this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.failedMoveAttempts = 0, this.beans.dragAndDrop.setDragImageCompIcon(this.getIconName()));
  }
  moveInterval() {
    var s;
    let e;
    this.intervalCount++, e = 10 + this.intervalCount * LR, e > Ja && (e = Ja);
    let t = null;
    const i = this.gridBodyCon.scrollFeature;
    if (this.needToMoveLeft ? t = i.scrollHorizontally(-e) : this.needToMoveRight && (t = i.scrollHorizontally(e)), t !== 0)
      this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
    else {
      this.failedMoveAttempts++;
      const { pinnedCols: o, dragAndDrop: n, gos: r } = this.beans;
      if (this.failedMoveAttempts <= Ic + 1 || !o)
        return;
      if (n.setDragImageCompIcon("pinned"), !r.get("suppressMoveWhenColumnDragging")) {
        const a = (s = this.lastDraggingEvent) == null ? void 0 : s.dragItem.columns;
        this.attemptToPinColumns(a, void 0, !0);
      }
    }
  }
  getPinDirection() {
    if (this.needToMoveLeft || this.pinned === "left")
      return "left";
    if (this.needToMoveRight || this.pinned === "right")
      return "right";
  }
  attemptToPinColumns(e, t, i = !1) {
    const s = (e || []).filter((r) => !r.getColDef().lockPinned);
    if (!s.length)
      return 0;
    i && (t = this.getPinDirection());
    const { pinnedCols: o, dragAndDrop: n } = this.beans;
    return o == null || o.setColsPinned(s, t, "uiColumnDragged"), i && n.nudge(), s.length;
  }
  destroy() {
    super.destroy(), this.lastDraggingEvent = null, this.clearHighlighted(), this.lastMovedInfo = null;
  }
};
function kc(e, t) {
  e.highlighted !== t && (e.highlighted = t, e.dispatchColEvent("headerHighlightChanged", "uiColumnMoved"));
}
function HR(e) {
  const t = e.length;
  let i, s;
  for (let o = 0; o < t; o++) {
    if (!i) {
      const n = e[o];
      n.getLeft() != null && (i = n);
    }
    if (!s) {
      const n = e[t - 1 - o];
      n.getLeft() != null && (s = n);
    }
    if (i && s)
      break;
  }
  return { firstMovingCol: i, lastMovingCol: s };
}
var BR = class extends E {
  constructor(e, t) {
    super(), this.pinned = e, this.eContainer = t;
  }
  postConstruct() {
    const { ctrlsSvc: e, dragAndDrop: t } = this.beans, i = this.pinned;
    e.whenReady(this, (s) => {
      let o;
      const n = s.gridBodyCtrl.eBodyViewport;
      switch (i) {
        case "left":
          o = [
            [n, s.left.eContainer],
            [s.bottomLeft.eContainer],
            [s.topLeft.eContainer]
          ];
          break;
        case "right":
          o = [
            [n, s.right.eContainer],
            [s.bottomRight.eContainer],
            [s.topRight.eContainer]
          ];
          break;
        default:
          o = [
            [n, s.center.eViewport],
            [s.bottomCenter.eViewport],
            [s.topCenter.eViewport]
          ];
          break;
      }
      this.eSecondaryContainers = o;
    }), this.moveColumnFeature = this.createManagedBean(new _R(i)), this.bodyDropPivotTarget = this.createManagedBean(new PR(i)), t.addDropTarget(this), this.addDestroyFunc(() => t.removeDropTarget(this));
  }
  isInterestedIn(e) {
    return e === 1 || e === 0 && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(e) {
    return this.beans.colModel.isPivotMode() && e.dragSource.type === 0;
  }
  onDragEnter(e) {
    this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e);
  }
  onDragLeave(e) {
    this.currentDropListener.onDragLeave(e);
  }
  onDragging(e) {
    this.currentDropListener.onDragging(e);
  }
  onDragStop(e) {
    this.currentDropListener.onDragStop(e);
  }
  onDragCancel() {
    this.currentDropListener.onDragCancel();
  }
}, GR = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colMoves";
  }
  moveColumnByIndex(e, t, i) {
    const s = this.beans.colModel.getCols();
    if (!s)
      return;
    const o = s[e];
    this.moveColumns([o], t, i);
  }
  moveColumns(e, t, i, s = !0) {
    const { colModel: o, colAnimation: n, visibleCols: r, eventSvc: a } = this.beans, l = o.getCols();
    if (!l)
      return;
    if (t > l.length - e.length) {
      I(30, { toIndex: t });
      return;
    }
    n == null || n.start();
    const d = o.getColsForKeys(e);
    this.doesMovePassRules(d, t) && (Zd(o.getCols(), d, t), r.refresh(i), a.dispatchEvent({
      type: "columnMoved",
      columns: d,
      column: d.length === 1 ? d[0] : null,
      toIndex: t,
      finished: s,
      source: i
    })), n == null || n.finish();
  }
  doesMovePassRules(e, t) {
    const i = this.getProposedColumnOrder(e, t);
    return this.doesOrderPassRules(i);
  }
  doesOrderPassRules(e) {
    const { colModel: t, gos: i } = this.beans;
    return !(!dg(e, t.getColTree()) || !((o) => {
      const n = (d) => d ? d === "left" || d === !0 ? -1 : 1 : 0, r = i.get("enableRtl");
      let a = r ? 1 : -1, l = !0;
      return o.forEach((d) => {
        const c = n(d.getColDef().lockPosition);
        r ? c > a && (l = !1) : c < a && (l = !1), a = c;
      }), l;
    })(e));
  }
  getProposedColumnOrder(e, t) {
    const s = this.beans.colModel.getCols().slice();
    return Zd(s, e, t), s;
  }
  createBodyDropTarget(e, t) {
    return new BR(e, t);
  }
  moveHeader(e, t, i, s, o) {
    const { ctrlsSvc: n, gos: r, colModel: a, visibleCols: l, focusSvc: d } = this.beans, c = t.getBoundingClientRect(), u = c.left, h = be(i), g = h ? c.width : i.getActualWidth(), p = e === "left" !== r.get("enableRtl"), f = Za({
      x: p ? u - 20 : u + g + 20,
      pinned: s,
      fromKeyboard: !0,
      gos: r,
      ctrlsSvc: n
    }), m = d.focusedHeader;
    fp({
      allMovingColumns: h ? i.getLeafColumns() : [i],
      isFromHeader: !0,
      fromLeft: e === "right",
      xPosition: f,
      pinned: s,
      fromEnter: !1,
      fakeEvent: !1,
      gos: r,
      colModel: a,
      colMoves: this,
      visibleCols: l,
      finished: !0
    });
    let C;
    if (h) {
      const v = i.getDisplayedLeafColumns();
      C = p ? v[0] : se(v);
    } else
      C = i;
    if (n.getScrollFeature().ensureColumnVisible(C, "auto"), (!o.isAlive() || r.get("ensureDomOrder")) && m) {
      let v;
      if (h) {
        const R = i.getGroupId(), b = i.getLeafColumns();
        if (!b.length)
          return;
        const w = b[0].getParent();
        if (!w)
          return;
        v = VR(w, R);
      } else
        v = i;
      v && d.focusHeaderPosition({
        headerPosition: {
          ...m,
          column: v
        }
      });
    }
  }
  setDragSourceForHeader(e, t, i) {
    const { gos: s, colModel: o, dragAndDrop: n, visibleCols: r } = this.beans;
    let a = !s.get("suppressDragLeaveHidesColumns");
    const l = be(t), d = l ? t.getProvidedColumnGroup().getLeafColumns() : [t], u = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => a ? "hide" : "notAllowed",
      getDragItem: l ? () => WR(t, r.allCols) : () => NR(t),
      dragItemName: i,
      onDragStarted: () => {
        a = !s.get("suppressDragLeaveHidesColumns"), aa(d, !0);
      },
      onDragStopped: () => aa(d, !1),
      onDragCancelled: () => aa(d, !1),
      onGridEnter: (h) => {
        if (a) {
          const { columns: g = [], visibleState: p } = h ?? {}, f = l ? (C) => !p || p[C.getColId()] : () => !0, m = g.filter(
            (C) => !C.getColDef().lockVisible && f(C)
          );
          o.setColsVisible(m, !0, "uiColumnMoved");
        }
      },
      onGridExit: (h) => {
        var g;
        if (a) {
          const p = ((g = h == null ? void 0 : h.columns) == null ? void 0 : g.filter((f) => !f.getColDef().lockVisible)) || [];
          o.setColsVisible(p, !1, "uiColumnMoved");
        }
      }
    };
    return n.addDragSource(u, !0), u;
  }
};
function VR(e, t) {
  for (; e; ) {
    if (e.getGroupId() === t)
      return e;
    e = e.getParent();
  }
}
function NR(e) {
  const t = {};
  return t[e.getId()] = e.isVisible(), {
    columns: [e],
    visibleState: t,
    containerType: e.pinned
  };
}
function WR(e, t) {
  var a;
  const i = e.getProvidedColumnGroup().getLeafColumns(), s = {};
  i.forEach((l) => s[l.getId()] = l.isVisible());
  const o = [];
  t.forEach((l) => {
    i.indexOf(l) >= 0 && (o.push(l), tt(i, l));
  }), i.forEach((l) => o.push(l));
  const n = [], r = e.getLeafColumns();
  for (const l of o)
    r.indexOf(l) !== -1 && n.push(l);
  return {
    columns: o,
    columnsInSplit: n,
    visibleState: s,
    containerType: (a = n[0]) == null ? void 0 : a.pinned
  };
}
var zR = {
  moduleName: "ColumnMove",
  version: B,
  beans: [GR, RR],
  apiFunctions: {
    moveColumnByIndex: xR,
    moveColumns: FR
  },
  dependsOn: [gp],
  css: [SR]
}, UR = class extends E {
  constructor() {
    super(...arguments), this.beanName = "autoWidthCalc";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.centerRowContainerCtrl = e.center;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(e, t) {
    const i = this.getHeaderCellForColumn(e);
    if (!i)
      return -1;
    const s = this.beans.rowRenderer.getAllCellsNotSpanningForColumn(e);
    return t || s.push(i), this.getPreferredWidthForElements(s);
  }
  getPreferredWidthForColumnGroup(e) {
    const t = this.getHeaderCellForColumn(e);
    return t ? this.getPreferredWidthForElements([t]) : -1;
  }
  getPreferredWidthForElements(e, t) {
    const i = document.createElement("form");
    i.style.position = "fixed";
    const s = this.centerRowContainerCtrl.eContainer;
    e.forEach((n) => this.cloneItemIntoDummy(n, i)), s.appendChild(i);
    const o = i.offsetWidth;
    return s.removeChild(i), t = t ?? this.gos.get("autoSizePadding"), o + t;
  }
  getHeaderCellForColumn(e) {
    let t = null;
    return this.beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((i) => {
      const s = i.getHtmlElementForColumnHeader(e);
      s != null && (t = s);
    }), t;
  }
  cloneItemIntoDummy(e, t) {
    const i = e.cloneNode(!0);
    i.style.width = "", i.style.position = "static", i.style.left = "";
    const s = document.createElement("div"), o = s.classList;
    ["ag-header-cell", "ag-header-group-cell"].some((a) => i.classList.contains(a)) ? (o.add("ag-header", "ag-header-row"), s.style.position = "static") : o.add("ag-row");
    let r = e.parentElement;
    for (; r; ) {
      if (["ag-header-row", "ag-row"].some((l) => r.classList.contains(l))) {
        for (let l = 0; l < r.classList.length; l++) {
          const d = r.classList[l];
          d != "ag-row-position-absolute" && o.add(d);
        }
        break;
      }
      r = r.parentElement;
    }
    s.appendChild(i), t.appendChild(s);
  }
}, mp = {
  moduleName: "AutoWidth",
  version: B,
  beans: [UR]
};
function $R(e, t, i = !0, s = "api") {
  var o;
  (o = e.colResize) == null || o.setColumnWidths(t, !1, i, s);
}
var KR = class extends E {
  constructor(e, t, i, s) {
    super(), this.comp = e, this.eResize = t, this.pinned = i, this.columnGroup = s;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(!1);
      return;
    }
    const { horizontalResizeSvc: e, gos: t, colAutosize: i } = this.beans, s = e.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, !1),
      onResizeEnd: this.onResizing.bind(this, !0)
    });
    this.addDestroyFunc(s), !t.get("suppressAutoSize") && i && this.addDestroyFunc(
      i.addColumnGroupResize(
        this.eResize,
        this.columnGroup,
        () => this.resizeLeafColumnsToFit("uiColumnResized")
      )
    );
  }
  onResizeStart(e) {
    const {
      columnsToResize: t,
      resizeStartWidth: i,
      resizeRatios: s,
      groupAfterColumns: o,
      groupAfterStartWidth: n,
      groupAfterRatios: r
    } = this.getInitialValues(e);
    this.resizeCols = t, this.resizeStartWidth = i, this.resizeRatios = s, this.resizeTakeFromCols = o, this.resizeTakeFromStartWidth = n, this.resizeTakeFromRatios = r, this.toggleColumnResizing(!0);
  }
  onResizing(e, t, i = "uiColumnResized") {
    const s = this.normaliseDragChange(t), o = this.resizeStartWidth + s;
    this.resizeColumnsFromLocalValues(o, i, e);
  }
  getInitialValues(e) {
    var l;
    const t = (d) => d.reduce((c, u) => c + u.getActualWidth(), 0), i = (d, c) => d.map((u) => u.getActualWidth() / c), s = this.getColumnsToResize(), o = t(s), n = i(s, o), r = {
      columnsToResize: s,
      resizeStartWidth: o,
      resizeRatios: n
    };
    let a = null;
    if (e && (a = ((l = this.beans.colGroupSvc) == null ? void 0 : l.getGroupAtDirection(this.columnGroup, "After")) ?? null), a) {
      const d = a.getDisplayedLeafColumns(), c = r.groupAfterColumns = d.filter(
        (h) => h.isResizable()
      ), u = r.groupAfterStartWidth = t(c);
      r.groupAfterRatios = i(c, u);
    } else
      r.groupAfterColumns = void 0, r.groupAfterStartWidth = void 0, r.groupAfterRatios = void 0;
    return r;
  }
  resizeLeafColumnsToFit(e) {
    const t = this.beans.autoWidthCalc.getPreferredWidthForColumnGroup(this.columnGroup), i = this.getInitialValues();
    t > i.resizeStartWidth && this.resizeColumns(i, t, e, !0);
  }
  resizeColumnsFromLocalValues(e, t, i = !0) {
    if (!this.resizeCols || !this.resizeRatios)
      return;
    const s = {
      columnsToResize: this.resizeCols,
      resizeStartWidth: this.resizeStartWidth,
      resizeRatios: this.resizeRatios,
      groupAfterColumns: this.resizeTakeFromCols,
      groupAfterStartWidth: this.resizeTakeFromStartWidth,
      groupAfterRatios: this.resizeTakeFromRatios
    };
    this.resizeColumns(s, e, t, i);
  }
  resizeColumns(e, t, i, s = !0) {
    var u;
    const {
      columnsToResize: o,
      resizeStartWidth: n,
      resizeRatios: r,
      groupAfterColumns: a,
      groupAfterStartWidth: l,
      groupAfterRatios: d
    } = e, c = [];
    if (c.push({
      columns: o,
      ratios: r,
      width: t
    }), a) {
      const h = t - n;
      c.push({
        columns: a,
        ratios: d,
        width: l - h
      });
    }
    (u = this.beans.colResize) == null || u.resizeColumnSets({
      resizeSets: c,
      finished: s,
      source: i
    }), s && this.toggleColumnResizing(!1);
  }
  toggleColumnResizing(e) {
    this.comp.toggleCss("ag-column-resizing", e);
  }
  getColumnsToResize() {
    return this.columnGroup.getDisplayedLeafColumns().filter((t) => t.isResizable());
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(e) {
    let t = e;
    return this.gos.get("enableRtl") ? this.pinned !== "left" && (t *= -1) : this.pinned === "right" && (t *= -1), t;
  }
  destroy() {
    super.destroy(), this.resizeCols = void 0, this.resizeRatios = void 0, this.resizeTakeFromCols = void 0, this.resizeTakeFromRatios = void 0;
  }
}, jR = class extends E {
  constructor(e, t, i, s, o) {
    super(), this.pinned = e, this.column = t, this.eResize = i, this.comp = s, this.ctrl = o;
  }
  postConstruct() {
    const e = [];
    let t, i;
    const s = () => {
      if (le(this.eResize, t), !t)
        return;
      const { horizontalResizeSvc: r, colAutosize: a } = this.beans, l = r.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      e.push(l), i && a && e.push(a.addColumnAutosize(this.eResize, this.column));
    }, o = () => {
      e.forEach((r) => r()), e.length = 0;
    }, n = () => {
      const r = this.column.isResizable(), a = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      (r !== t || a !== i) && (t = r, i = a, o(), s());
    };
    n(), this.addDestroyFunc(o), this.ctrl.setRefreshFunction("resize", n);
  }
  onResizing(e, t) {
    const { column: i, lastResizeAmount: s, resizeStartWidth: o, beans: n } = this, r = this.normaliseResizeAmount(t), a = o + r, l = [{ key: i, newWidth: a }], { pinnedCols: d, ctrlsSvc: c, colResize: u } = n;
    if (this.column.getPinned()) {
      const h = (d == null ? void 0 : d.leftWidth) ?? 0, g = (d == null ? void 0 : d.rightWidth) ?? 0, p = So(c.getGridBodyCtrl().eBodyViewport) - 50;
      if (h + g + (r - s) > p)
        return;
    }
    this.lastResizeAmount = r, u == null || u.setColumnWidths(l, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.toggleColumnResizing(!1);
  }
  onResizeStart(e) {
    this.resizeStartWidth = this.column.getActualWidth(), this.lastResizeAmount = 0, this.resizeWithShiftKey = e, this.toggleColumnResizing(!0);
  }
  toggleColumnResizing(e) {
    this.column.resizing = e, this.comp.toggleCss("ag-column-resizing", e);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(e) {
    let t = e;
    const i = this.pinned !== "left", s = this.pinned === "right";
    return this.gos.get("enableRtl") ? i && (t *= -1) : s && (t *= -1), t;
  }
}, qR = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colResize";
  }
  setColumnWidths(e, t, i, s) {
    const o = [], { colModel: n, gos: r, visibleCols: a } = this.beans;
    e.forEach((l) => {
      const d = n.getColDefCol(l.key) || n.getCol(l.key);
      if (!d)
        return;
      if (o.push({
        width: l.newWidth,
        ratios: [1],
        columns: [d]
      }), r.get("colResizeDefault") === "shift" && (t = !t), t) {
        const u = a.getColAfter(d);
        if (!u)
          return;
        const h = d.getActualWidth() - l.newWidth, g = u.getActualWidth() + h;
        o.push({
          width: g,
          ratios: [1],
          columns: [u]
        });
      }
    }), o.length !== 0 && this.resizeColumnSets({
      resizeSets: o,
      finished: i,
      source: s
    });
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(e) {
    const { resizeSets: t, finished: i, source: s } = e;
    if (!(!t || t.every((c) => YR(c)))) {
      if (i) {
        const c = t && t.length > 0 ? t[0].columns : null;
        bs(this.eventSvc, c, i, s);
      }
      return;
    }
    const n = [], r = [];
    t.forEach((c) => {
      const { width: u, columns: h, ratios: g } = c, p = {}, f = {};
      h.forEach((v) => r.push(v));
      let m = !0, C = 0;
      for (; m; ) {
        if (C++, C > 1e3) {
          Z(31);
          break;
        }
        m = !1;
        const v = [];
        let R = 0, b = u;
        h.forEach((x, F) => {
          if (f[x.getId()])
            b -= p[x.getId()];
          else {
            v.push(x);
            const T = g[F];
            R += T;
          }
        });
        const w = 1 / R;
        v.forEach((x, F) => {
          const D = F === v.length - 1;
          let T;
          D ? T = b : (T = Math.round(g[F] * u * w), b -= T);
          const k = x.getMinWidth(), A = x.getMaxWidth();
          T < k ? (T = k, f[x.getId()] = !0, m = !0) : A > 0 && T > A && (T = A, f[x.getId()] = !0, m = !0), p[x.getId()] = T;
        });
      }
      h.forEach((v) => {
        const R = p[v.getId()];
        v.getActualWidth() !== R && (v.setActualWidth(R, s), n.push(v));
      });
    });
    const a = n.length > 0;
    let l = [];
    if (a) {
      const { colFlex: c, visibleCols: u, colViewport: h } = this.beans;
      l = (c == null ? void 0 : c.refreshFlexedColumns({
        resizingCols: r,
        skipSetLeft: !0
      })) ?? [], u.setLeftValues(s), u.updateBodyWidths(), h.checkViewportColumns();
    }
    const d = r.concat(l);
    (a || i) && bs(this.eventSvc, d, i, s, l);
  }
  resizeHeader(e, t, i) {
    if (!e.isResizable())
      return;
    const s = e.getActualWidth(), o = e.getMinWidth(), n = e.getMaxWidth(), r = Math.min(Math.max(s + t, o), n);
    this.setColumnWidths([{ key: e, newWidth: r }], i, !0, "uiColumnResized");
  }
  createResizeFeature(e, t, i, s, o) {
    return new jR(e, t, i, s, o);
  }
  createGroupResizeFeature(e, t, i, s) {
    return new KR(e, t, i, s);
  }
};
function YR(e) {
  const { columns: t, width: i } = e;
  let s = 0, o = 0, n = !0;
  t.forEach((l) => {
    const d = l.getMinWidth();
    s += d || 0;
    const c = l.getMaxWidth();
    c > 0 ? o += c : n = !1;
  });
  const r = i >= s, a = !n || i <= o;
  return r && a;
}
var QR = {
  moduleName: "ColumnResize",
  version: B,
  beans: [qR],
  apiFunctions: {
    setColumnWidths: $R
  },
  dependsOn: [yR, mp]
}, XR = class extends E {
  constructor(e, t) {
    super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e;
  }
  postConstruct() {
    this.addListenersToChildrenColumns(), this.addManagedListeners(this.columnGroup, {
      displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this)
    }), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const e = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      t.__addEventListener("widthChanged", e), t.__addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
        t.__removeEventListener("widthChanged", e), t.__removeEventListener("visibleChanged", e);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((e) => e()), this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns(), this.onWidthChanged();
  }
  onWidthChanged() {
    const e = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${e}px`), this.comp.toggleCss("ag-hidden", e === 0);
  }
}, ZR = class extends Jl {
  constructor() {
    super(...arguments), this.onSuppressColMoveChange = () => {
      !this.isAlive() || this.isSuppressMoving() ? this.removeDragSource() : this.dragSource || this.setDragSource(this.eGui);
    };
  }
  wireComp(e, t, i, s, o) {
    const { column: n, beans: r } = this, { context: a, colNames: l, colHover: d, rangeSvc: c, colResize: u } = r;
    this.comp = e, o = No(this, a, o), this.setGui(t, o), this.displayName = l.getDisplayNameForColumnGroup(n, "header"), this.refreshHeaderStyles(), this.addClasses(), this.setupMovingCss(o), this.setupExpandable(o), this.setupTooltip(), this.setupAutoHeight({
      wrapperElement: s,
      compBean: o
    }), this.setupUserComp(), this.addHeaderMouseListeners(o), this.addManagedPropertyListener("groupHeaderHeight", this.refreshMaxHeaderHeight.bind(this)), this.refreshMaxHeaderHeight();
    const h = this.rowCtrl.pinned, g = n.getProvidedColumnGroup().getLeafColumns();
    d == null || d.createHoverFeature(o, g, t), c == null || c.createRangeHighlightFeature(o, n, e), o.createManagedBean(new Zl(n, t, r)), o.createManagedBean(new XR(e, n)), u ? this.resizeFeature = o.createManagedBean(
      u.createGroupResizeFeature(e, i, h, n)
    ) : e.setResizableDisplayed(!1), o.createManagedBean(
      new Ts(t, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: () => {
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    ), this.addHighlightListeners(o, g), o.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange), this.addResizeAndMoveKeyboardListeners(o), o.addDestroyFunc(() => this.clearComponent());
  }
  getHeaderClassParams() {
    const { column: e, beans: t } = this, i = e.getDefinition();
    return W(t.gos, {
      colDef: i,
      columnGroup: e,
      floatingFilter: !1
    });
  }
  refreshMaxHeaderHeight() {
    const { gos: e, comp: t } = this, i = e.get("groupHeaderHeight");
    i != null ? i === 0 ? t.setHeaderWrapperHidden(!0) : t.setHeaderWrapperMaxHeight(i) : (t.setHeaderWrapperHidden(!1), t.setHeaderWrapperMaxHeight(null));
  }
  addHighlightListeners(e, t) {
    if (this.beans.gos.get("suppressMoveWhenColumnDragging"))
      for (const i of t)
        e.addManagedListeners(i, {
          headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(this, i)
        });
  }
  onLeafColumnHighlightChanged(e) {
    const t = this.column.getDisplayedLeafColumns(), i = t[0] === e, s = se(t) === e;
    if (!i && !s)
      return;
    const o = e.getHighlighted(), n = !!this.rowCtrl.getHeaderCellCtrls().find((l) => l.column.isMoving());
    let r = !1, a = !1;
    if (n) {
      const l = this.beans.gos.get("enableRtl"), d = o === 1, c = o === 0;
      i && (l ? a = d : r = c), s && (l ? r = c : a = d);
    }
    this.comp.toggleCss("ag-header-highlight-before", r), this.comp.toggleCss("ag-header-highlight-after", a);
  }
  resizeHeader(e, t) {
    const { resizeFeature: i } = this;
    if (!i)
      return;
    const s = i.getInitialValues(t);
    i.resizeColumns(s, s.resizeStartWidth + e, "uiColumnResized", !0);
  }
  resizeLeafColumnsToFit(e) {
    var t;
    (t = this.resizeFeature) == null || t.resizeLeafColumnsToFit(e);
  }
  setupUserComp() {
    const { colGroupSvc: e, userCompFactory: t, gos: i, enterpriseMenuFactory: s } = this.beans, o = this.column, n = o.getProvidedColumnGroup(), r = W(i, {
      displayName: this.displayName,
      columnGroup: o,
      setExpanded: (l) => {
        e.setColumnGroupOpened(n, l, "gridInitializing");
      },
      setTooltip: (l, d) => {
        i.assertModuleRegistered("Tooltip", 3), this.setupTooltip(l, d);
      },
      showColumnMenu: (l, d) => s == null ? void 0 : s.showMenuAfterButtonClick(
        n,
        l,
        "columnMenu",
        d
      ),
      showColumnMenuAfterMouseClick: (l, d) => s == null ? void 0 : s.showMenuAfterMouseEvent(
        n,
        l,
        "columnMenu",
        d
      ),
      eGridHeader: this.eGui
    }), a = $v(t, r);
    a && this.comp.setUserCompDetails(a);
  }
  addHeaderMouseListeners(e) {
    const t = (o) => this.handleMouseOverChange(o.type === "mouseenter"), i = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup()), s = (o) => this.handleContextMenuMouseEvent(o, void 0, this.column.getProvidedColumnGroup());
    e.addManagedListeners(this.eGui, {
      mouseenter: t,
      mouseleave: t,
      click: i,
      contextmenu: s
    });
  }
  handleMouseOverChange(e) {
    this.eventSvc.dispatchEvent({
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column.getProvidedColumnGroup()
    });
  }
  setupTooltip(e, t) {
    var i;
    this.tooltipFeature = (i = this.beans.tooltipSvc) == null ? void 0 : i.setupHeaderGroupTooltip(
      this.tooltipFeature,
      this,
      e,
      t
    );
  }
  setupExpandable(e) {
    const t = this.column.getProvidedColumnGroup();
    this.refreshExpanded();
    const i = this.refreshExpanded.bind(this);
    e.addManagedListeners(t, {
      expandedChanged: i,
      expandableChanged: i
    });
  }
  refreshExpanded() {
    const { column: e } = this;
    this.expandable = e.isExpandable();
    const t = e.isExpanded();
    this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0), this.refreshHeaderStyles();
  }
  addClasses() {
    const { column: e } = this, t = e.getColGroupDef(), i = Zg(t, this.gos, null, e);
    e.isPadding() ? (i.push("ag-header-group-cell-no-group"), e.getLeafColumns().every((o) => o.isSpanHeaderHeight()) && i.push("ag-header-span-height")) : (i.push("ag-header-group-cell-with-group"), t != null && t.wrapHeaderText && i.push("ag-header-cell-wrap-text")), i.forEach((s) => this.comp.toggleCss(s, !0));
  }
  setupMovingCss(e) {
    const { column: t } = this, s = t.getProvidedColumnGroup().getLeafColumns(), o = () => this.comp.toggleCss("ag-header-cell-moving", t.isMoving());
    s.forEach((n) => {
      e.addManagedListeners(n, { movingChanged: o });
    }), o();
  }
  onFocusIn(e) {
    this.eGui.contains(e.relatedTarget) || this.focusThis();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    if (!(!this.expandable || !t) && e.key === P.ENTER) {
      const i = this.column, s = !i.isExpanded();
      this.beans.colGroupSvc.setColumnGroupOpened(
        i.getProvidedColumnGroup(),
        s,
        "uiColumnExpanded"
      );
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(e) {
    var t;
    !this.isAlive() || this.isSuppressMoving() || (this.removeDragSource(), e && (this.dragSource = ((t = this.beans.colMoves) == null ? void 0 : t.setDragSourceForHeader(e, this.column, this.displayName)) ?? null));
  }
  isSuppressMoving() {
    return this.gos.get("suppressMovableColumns") || this.column.getLeafColumns().some((e) => e.getColDef().suppressMovable || e.getColDef().lockPosition);
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature), super.destroy();
  }
};
function JR(e, t, i) {
  var s;
  (s = e.colGroupSvc) == null || s.setColumnGroupOpened(t, i, "api");
}
function ex(e, t, i) {
  var s;
  return ((s = e.colGroupSvc) == null ? void 0 : s.getColumnGroup(t, i)) ?? null;
}
function tx(e, t) {
  var i;
  return ((i = e.colGroupSvc) == null ? void 0 : i.getProvidedColGroup(t)) ?? null;
}
function ix(e, t, i) {
  return e.colNames.getDisplayNameForColumnGroup(t, i) || "";
}
function sx(e) {
  var t;
  return ((t = e.colGroupSvc) == null ? void 0 : t.getColumnGroupState()) ?? [];
}
function ox(e, t) {
  var i;
  (i = e.colGroupSvc) == null || i.setColumnGroupState(t, "api");
}
function nx(e) {
  var t;
  (t = e.colGroupSvc) == null || t.resetColumnGroupState("api");
}
function rx(e) {
  return e.visibleCols.treeLeft;
}
function ax(e) {
  return e.visibleCols.treeCenter;
}
function lx(e) {
  return e.visibleCols.treeRight;
}
function dx(e) {
  return e.visibleCols.getAllTrees();
}
function cx(e, t) {
  for (let i = 0; i < t.length; i++) {
    const s = e.indexOf(t[i]);
    s >= 0 && (e[s] = e[e.length - 1], e.pop());
  }
}
var ux = class extends E {
  constructor() {
    super(...arguments), this.beanName = "visibleCols", this.colsAndGroupsMap = {}, this.leftCols = [], this.rightCols = [], this.centerCols = [], this.allCols = [], this.headerGroupRowCount = 0, this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.isBodyWidthDirty = !0;
  }
  refresh(e, t = !1) {
    const { colFlex: i, colModel: s, colGroupSvc: o, colViewport: n, selectionColSvc: r } = this.beans;
    t || this.buildTrees(s, o), o == null || o.updateOpenClosedVisibility(), this.leftCols = la(this.treeLeft), this.centerCols = la(this.treeCenter), this.rightCols = la(this.treeRight), r == null || r.refreshVisibility(this.leftCols, this.centerCols, this.rightCols), this.joinColsAriaOrder(s), this.joinCols(), this.headerGroupRowCount = this.getHeaderRowCount(), this.setLeftValues(e), this.autoHeightCols = this.allCols.filter((a) => a.isAutoHeight()), i == null || i.refreshFlexedColumns(), this.updateBodyWidths(), this.setFirstRightAndLastLeftPinned(s, this.leftCols, this.rightCols, e), n.checkViewportColumns(!1), this.eventSvc.dispatchEvent({
      type: "displayedColumnsChanged",
      source: e
    });
  }
  getHeaderRowCount() {
    if (!this.gos.get("hidePaddedHeaderRows"))
      return this.beans.colModel.cols.treeDepth;
    let e = 0;
    for (const t of this.allCols) {
      let i = t.getParent();
      for (; i; ) {
        if (!i.isPadding()) {
          const s = i.getProvidedColumnGroup().getLevel() + 1;
          s > e && (e = s);
          break;
        }
        i = i.getParent();
      }
    }
    return e;
  }
  // after setColumnWidth or updateGroupsAndPresentedCols
  updateBodyWidths() {
    const e = _t(this.centerCols), t = _t(this.leftCols), i = _t(this.rightCols);
    this.isBodyWidthDirty = this.bodyWidth !== e, (this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== i) && (this.bodyWidth = e, this.leftWidth = t, this.rightWidth = i, this.eventSvc.dispatchEvent({
      type: "columnContainerWidthChanged"
    }), this.eventSvc.dispatchEvent({
      type: "displayedColumnsWidthChanged"
    }));
  }
  // sets the left pixel position of each column
  setLeftValues(e) {
    this.setLeftValuesOfCols(e), this.setLeftValuesOfGroups();
  }
  setFirstRightAndLastLeftPinned(e, t, i, s) {
    let o, n;
    this.gos.get("enableRtl") ? (o = t ? t[0] : null, n = i ? se(i) : null) : (o = t ? se(t) : null, n = i ? i[0] : null), e.getCols().forEach((r) => {
      r.setLastLeftPinned(r === o, s), r.setFirstRightPinned(r === n, s);
    });
  }
  buildTrees(e, t) {
    const i = e.getColsToShow(), s = i.filter((l) => l.getPinned() == "left"), o = i.filter((l) => l.getPinned() == "right"), n = i.filter((l) => l.getPinned() != "left" && l.getPinned() != "right"), r = new pg(), a = (l) => t ? t.createColumnGroups(l) : l.columns;
    this.treeLeft = a({
      columns: s,
      idCreator: r,
      pinned: "left",
      oldDisplayedGroups: this.treeLeft
    }), this.treeRight = a({
      columns: o,
      idCreator: r,
      pinned: "right",
      oldDisplayedGroups: this.treeRight
    }), this.treeCenter = a({
      columns: n,
      idCreator: r,
      pinned: null,
      oldDisplayedGroups: this.treeCenter
    }), this.updateColsAndGroupsMap();
  }
  clear() {
    this.leftCols = [], this.rightCols = [], this.centerCols = [], this.allCols = [], this.ariaOrderColumns = [];
  }
  joinColsAriaOrder(e) {
    const t = e.getCols(), i = [], s = [], o = [];
    for (const n of t) {
      const r = n.getPinned();
      r ? r === !0 || r === "left" ? i.push(n) : o.push(n) : s.push(n);
    }
    this.ariaOrderColumns = i.concat(s).concat(o);
  }
  getAriaColIndex(e) {
    let t;
    return be(e) ? t = e.getLeafColumns()[0] : t = e, this.ariaOrderColumns.indexOf(t) + 1;
  }
  setLeftValuesOfGroups() {
    [this.treeLeft, this.treeRight, this.treeCenter].forEach((e) => {
      e.forEach((t) => {
        be(t) && t.checkLeft();
      });
    });
  }
  setLeftValuesOfCols(e) {
    const { colModel: t } = this.beans;
    if (!t.getColDefCols())
      return;
    const s = t.getCols().slice(0), o = this.gos.get("enableRtl");
    [this.leftCols, this.rightCols, this.centerCols].forEach((n) => {
      if (o) {
        let r = _t(n);
        n.forEach((a) => {
          r -= a.getActualWidth(), a.setLeft(r, e);
        });
      } else {
        let r = 0;
        n.forEach((a) => {
          a.setLeft(r, e), r += a.getActualWidth();
        });
      }
      cx(s, n);
    }), s.forEach((n) => {
      n.setLeft(null, e);
    });
  }
  joinCols() {
    this.gos.get("enableRtl") ? this.allCols = this.rightCols.concat(this.centerCols).concat(this.leftCols) : this.allCols = this.leftCols.concat(this.centerCols).concat(this.rightCols);
  }
  getAllTrees() {
    return this.treeLeft && this.treeRight && this.treeCenter ? this.treeLeft.concat(this.treeCenter).concat(this.treeRight) : null;
  }
  // gridPanel -> ensureColumnVisible
  isColDisplayed(e) {
    return this.allCols.indexOf(e) >= 0;
  }
  getLeftColsForRow(e) {
    const {
      leftCols: t,
      beans: { colModel: i }
    } = this;
    return i.colSpanActive ? this.getColsForRow(e, t) : t;
  }
  getRightColsForRow(e) {
    const {
      rightCols: t,
      beans: { colModel: i }
    } = this;
    return i.colSpanActive ? this.getColsForRow(e, t) : t;
  }
  getColsForRow(e, t, i, s) {
    const o = [];
    let n = null;
    for (let r = 0; r < t.length; r++) {
      const a = t[r], l = t.length - r, d = Math.min(a.getColSpan(e), l), c = [a];
      if (d > 1) {
        const h = d - 1;
        for (let g = 1; g <= h; g++)
          c.push(t[r + g]);
        r += h;
      }
      let u;
      i ? (u = !1, c.forEach((h) => {
        i(h) && (u = !0);
      })) : u = !0, u && (o.length === 0 && n && (s && s(a)) && o.push(n), o.push(a)), n = a;
    }
    return o;
  }
  getContainerWidth(e) {
    switch (e) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  getColBefore(e) {
    const t = this.allCols, i = t.indexOf(e);
    return i > 0 ? t[i - 1] : null;
  }
  isPinningLeft() {
    return this.leftCols.length > 0;
  }
  isPinningRight() {
    return this.rightCols.length > 0;
  }
  updateColsAndGroupsMap() {
    this.colsAndGroupsMap = {};
    const e = (t) => {
      this.colsAndGroupsMap[t.getUniqueId()] = t;
    };
    Ii(this.treeCenter, !1, e), Ii(this.treeLeft, !1, e), Ii(this.treeRight, !1, e);
  }
  isVisible(e) {
    return this.colsAndGroupsMap[e.getUniqueId()] === e;
  }
  getFirstColumn() {
    const e = this.gos.get("enableRtl"), t = ["leftCols", "centerCols", "rightCols"];
    e && t.reverse();
    for (let i = 0; i < t.length; i++) {
      const s = this[t[i]];
      if (s.length)
        return e ? se(s) : s[0];
    }
    return null;
  }
  // used by:
  // + rowRenderer -> for navigation
  getColAfter(e) {
    const t = this.allCols, i = t.indexOf(e);
    return i < t.length - 1 ? t[i + 1] : null;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getColsLeftWidth() {
    return _t(this.leftCols);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return _t(this.rightCols);
  }
  isColAtEdge(e, t) {
    const i = this.allCols;
    if (!i.length)
      return !1;
    const s = t === "first";
    let o;
    if (be(e)) {
      const n = e.getDisplayedLeafColumns();
      if (!n.length)
        return !1;
      o = s ? n[0] : se(n);
    } else
      o = e;
    return (s ? i[0] : se(i)) === o;
  }
};
function Ii(e, t, i) {
  if (e)
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (be(o)) {
        const n = t ? o.getDisplayedChildren() : o.getChildren();
        Ii(n, t, i);
      }
      i(o);
    }
}
function la(e) {
  const t = [];
  return Ii(e, !0, (i) => {
    ai(i) && t.push(i);
  }), t;
}
var hx = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colGroupSvc";
  }
  getColumnGroupState() {
    const e = [], t = this.beans.colModel.getColTree();
    return Nt(null, t, (i) => {
      Oe(i) && e.push({
        groupId: i.getGroupId(),
        open: i.isExpanded()
      });
    }), e;
  }
  resetColumnGroupState(e) {
    const t = this.beans.colModel.getColDefColTree();
    if (!t)
      return;
    const i = [];
    Nt(null, t, (s) => {
      if (Oe(s)) {
        const o = s.getColGroupDef(), n = {
          groupId: s.getGroupId(),
          open: o ? o.openByDefault : void 0
        };
        i.push(n);
      }
    }), this.setColumnGroupState(i, e);
  }
  setColumnGroupState(e, t) {
    const { colModel: i, colAnimation: s, visibleCols: o, eventSvc: n } = this.beans;
    if (!i.getColTree().length)
      return;
    s == null || s.start();
    const a = [];
    e.forEach((l) => {
      const d = l.groupId, c = l.open, u = this.getProvidedColGroup(d);
      u && u.isExpanded() !== c && (u.setExpanded(c), a.push(u));
    }), o.refresh(t, !0), a.length && n.dispatchEvent({
      type: "columnGroupOpened",
      columnGroup: a.length === 1 ? a[0] : void 0,
      columnGroups: a
    }), s == null || s.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(e, t, i) {
    let s;
    Oe(e) ? s = e.getId() : s = e || "", this.setColumnGroupState([{ groupId: s, open: t }], i);
  }
  getProvidedColGroup(e) {
    let t = null;
    return Nt(null, this.beans.colModel.getColTree(), (i) => {
      Oe(i) && i.getId() === e && (t = i);
    }), t;
  }
  getGroupAtDirection(e, t) {
    const i = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(), s = e.getDisplayedLeafColumns(), o = t === "After" ? se(s) : s[0], n = `getCol${t}`;
    for (; ; ) {
      const r = this.beans.visibleCols[n](o);
      if (!r)
        return null;
      const a = this.getColGroupAtLevel(r, i);
      if (a !== e)
        return a;
    }
  }
  getColGroupAtLevel(e, t) {
    let i = e.getParent(), s, o;
    for (; s = i.getProvidedColumnGroup().getLevel(), o = i.getPaddingLevel(), !(s + o <= t); )
      i = i.getParent();
    return i;
  }
  updateOpenClosedVisibility() {
    const e = this.beans.visibleCols.getAllTrees();
    Ii(e, !1, (t) => {
      be(t) && t.calculateDisplayedColumns();
    });
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(e, t) {
    if (!e)
      return null;
    if (be(e))
      return e;
    const i = this.beans.visibleCols.getAllTrees(), s = typeof t == "number";
    let o = null;
    return Ii(i, !1, (n) => {
      if (be(n)) {
        const r = n;
        let a;
        s ? a = e === r.getGroupId() && t === r.getPartId() : a = e === r.getGroupId(), a && (o = r);
      }
    }), o;
  }
  createColumnGroups(e) {
    const { columns: t, idCreator: i, pinned: s, oldDisplayedGroups: o, isStandaloneStructure: n } = e, r = this.mapOldGroupsById(o), a = [];
    let l = t;
    for (; l.length; ) {
      const d = l;
      l = [];
      let c = 0;
      const u = (h) => {
        const g = c;
        c = h;
        const p = d[g], m = (be(p) ? p.getProvidedColumnGroup() : p).getOriginalParent();
        if (m == null) {
          for (let v = g; v < h; v++)
            a.push(d[v]);
          return;
        }
        const C = this.createColumnGroup(
          m,
          i,
          r,
          s,
          n
        );
        for (let v = g; v < h; v++)
          C.addChild(d[v]);
        l.push(C);
      };
      for (let h = 1; h < d.length; h++) {
        const g = d[h], f = (be(g) ? g.getProvidedColumnGroup() : g).getOriginalParent(), m = d[c], v = (be(m) ? m.getProvidedColumnGroup() : m).getOriginalParent();
        f !== v && u(h);
      }
      c < d.length && u(d.length);
    }
    return n || this.setupParentsIntoCols(a, null), a;
  }
  createProvidedColumnGroup(e, t, i, s, o, n, r) {
    const a = o.getUniqueKey(t.groupId || null, null), l = Qd(this.beans, t, a), d = new En(l, a, !1, i);
    this.createBean(d);
    const c = this.findExistingGroup(t, n);
    c && n.splice(c.idx, 1);
    const u = c == null ? void 0 : c.group;
    u && d.setExpanded(u.isExpanded());
    const h = rg(
      this.beans,
      l.children,
      i + 1,
      e,
      s,
      o,
      n,
      r
    );
    return d.setChildren(h), d;
  }
  balanceColumnTree(e, t, i, s) {
    const o = [];
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (Oe(r)) {
        const a = r, l = this.balanceColumnTree(
          a.getChildren(),
          t + 1,
          i,
          s
        );
        a.setChildren(l), o.push(a);
      } else {
        let a, l;
        for (let d = t; d < i; d++) {
          const c = s.getUniqueKey(null, null), u = Qd(this.beans, null, c), h = new En(u, c, !0, d);
          this.createBean(h), l && l.setChildren([h]), l = h, a || (a = l);
        }
        if (a && l)
          if (o.push(a), e.some((c) => Oe(c))) {
            l.setChildren([r]);
            continue;
          } else {
            l.setChildren(e);
            break;
          }
        o.push(r);
      }
    }
    return o;
  }
  findDepth(e) {
    let t = 0, i = e;
    for (; i && i[0] && Oe(i[0]); )
      t++, i = i[0].getChildren();
    return t;
  }
  findMaxDepth(e, t) {
    let i = t;
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if (Oe(o)) {
        const n = o, r = this.findMaxDepth(n.getChildren(), t + 1);
        i < r && (i = r);
      }
    }
    return i;
  }
  /**
   * Inserts dummy group columns in the hierarchy above auto-generated columns
   * in order to ensure auto-generated columns are leaf nodes (and therefore are
   * displayed correctly)
   */
  balanceTreeForAutoCols(e, t) {
    const i = [];
    return e.forEach((s) => {
      let o = s;
      for (let n = t - 1; n >= 0; n--) {
        const r = new En(null, `FAKE_PATH_${s.getId()}}_${n}`, !0, n);
        this.createBean(r), r.setChildren([o]), o.originalParent = r, o = r;
      }
      t === 0 && (s.originalParent = null), i.push(o);
    }), i;
  }
  findExistingGroup(e, t) {
    if (e.groupId != null)
      for (let s = 0; s < t.length; s++) {
        const o = t[s];
        if (o.getColGroupDef() && o.getId() === e.groupId)
          return { idx: s, group: o };
      }
  }
  createColumnGroup(e, t, i, s, o) {
    const n = e.getGroupId(), r = t.getInstanceIdForKey(n), a = Hg(n, r);
    let l = i[a];
    return l && l.getProvidedColumnGroup() !== e && (l = null), H(l) ? l.reset() : (l = new Eo(e, n, r, s), o || this.createBean(l)), l;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(e) {
    const t = {}, i = (s) => {
      s.forEach((o) => {
        if (be(o)) {
          const n = o;
          t[o.getUniqueId()] = n, i(n.getChildren());
        }
      });
    };
    return e && i(e), t;
  }
  setupParentsIntoCols(e, t) {
    e.forEach((i) => {
      if (i.parent !== t && (this.beans.colViewport.colsWithinViewportHash = ""), i.parent = t, be(i)) {
        const s = i;
        this.setupParentsIntoCols(s.getChildren(), s);
      }
    });
  }
}, gx = {
  moduleName: "ColumnGroup",
  version: B,
  dynamicBeans: { headerGroupCellCtrl: ZR },
  beans: [hx],
  apiFunctions: {
    getAllDisplayedColumnGroups: dx,
    getCenterDisplayedColumnGroups: ax,
    getColumnGroup: ex,
    getColumnGroupState: sx,
    getDisplayNameForColumnGroup: ix,
    getLeftDisplayedColumnGroups: rx,
    getProvidedColumnGroup: tx,
    getRightDisplayedColumnGroups: lx,
    resetColumnGroupState: nx,
    setColumnGroupOpened: JR,
    setColumnGroupState: ox
  }
}, px = { tag: "div", cls: "ag-skeleton-container" }, fx = class extends te {
  constructor() {
    super(px);
  }
  init(e) {
    const t = `ag-cell-skeleton-renderer-${this.getCompId()}`;
    this.getGui().setAttribute("id", t), this.addDestroyFunc(() => bo(e.eParentOfValue)), bo(e.eParentOfValue, t), e.deferRender ? this.setupLoading(e) : e.node.failedLoad ? this.setupFailed() : this.setupLoading(e);
  }
  setupFailed() {
    const e = this.getLocaleTextFunc();
    this.getGui().textContent = e("loadingError", "ERR");
    const t = e("ariaSkeletonCellLoadingFailed", "Row failed to load");
    vs(this.getGui(), t);
  }
  setupLoading(e) {
    const t = ye({
      tag: "div",
      cls: "ag-skeleton-effect"
    }), i = e.node.rowIndex;
    if (i != null) {
      const n = 75 + 25 * (i % 2 === 0 ? Math.sin(i) : Math.cos(i));
      t.style.width = `${n}%`;
    }
    this.getGui().appendChild(t);
    const s = this.getLocaleTextFunc(), o = e.deferRender ? s("ariaDeferSkeletonCellLoading", "Cell is loading") : s("ariaSkeletonCellLoading", "Row data is loading");
    vs(this.getGui(), o);
  }
  refresh(e) {
    return !1;
  }
}, mx = {
  moduleName: "CheckboxCellRenderer",
  version: B,
  userComponents: {
    agCheckboxCellRenderer: Jy
  }
}, Cx = {
  moduleName: "SkeletonCellRenderer",
  version: B,
  userComponents: {
    agSkeletonCellRenderer: fx
  }
};
function vx(e, t) {
  const i = e.colModel.getColDefCol(t);
  return i ? i.getColDef() : null;
}
function wx(e) {
  return e.colModel.getColumnDefs();
}
function bx(e, t, i) {
  return e.colNames.getDisplayNameForColumn(t, i) || "";
}
function yx(e, t) {
  return e.colModel.getColDefCol(t);
}
function Sx(e) {
  return e.colModel.getColDefCols();
}
function Rx(e, t) {
  return ut(e, t, "api");
}
function xx(e) {
  return Qn(e);
}
function Fx(e) {
  mv(e, "api");
}
function Px(e) {
  return e.visibleCols.isPinningLeft() || e.visibleCols.isPinningRight();
}
function Ex(e) {
  return e.visibleCols.isPinningLeft();
}
function Dx(e) {
  return e.visibleCols.isPinningRight();
}
function Tx(e, t) {
  return e.visibleCols.getColAfter(t);
}
function Mx(e, t) {
  return e.visibleCols.getColBefore(t);
}
function Ax(e, t, i) {
  e.colModel.setColsVisible(t, i, "api");
}
function Ix(e, t, i) {
  var s;
  (s = e.pinnedCols) == null || s.setColsPinned(t, i, "api");
}
function kx(e) {
  return e.colModel.getCols();
}
function Lx(e) {
  return e.visibleCols.leftCols;
}
function Ox(e) {
  return e.visibleCols.centerCols;
}
function _x(e) {
  return e.visibleCols.rightCols;
}
function Hx(e) {
  return e.visibleCols.allCols;
}
function Bx(e) {
  return e.colViewport.getViewportColumns();
}
function el(e, t) {
  if (!e)
    return;
  const i = e, s = {};
  return Object.keys(i).forEach((o) => {
    if (t && t.indexOf(o) >= 0 || Vh.has(o))
      return;
    const n = i[o];
    typeof n == "object" && n !== null && n.constructor === Object ? s[o] = el(n) : s[o] = n;
  }), s;
}
var Gx = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colDefFactory";
  }
  wireBeans(e) {
    this.rowGroupColsSvc = e.rowGroupColsSvc, this.pivotColsSvc = e.pivotColsSvc;
  }
  getColumnDefs(e, t, i, s) {
    var a, l;
    const o = e.slice();
    t ? o.sort((d, c) => i.indexOf(d) - i.indexOf(c)) : i && o.sort((d, c) => s.indexOf(d) - s.indexOf(c));
    const n = (a = this.rowGroupColsSvc) == null ? void 0 : a.columns, r = (l = this.pivotColsSvc) == null ? void 0 : l.columns;
    return this.buildColumnDefs(o, n, r);
  }
  buildColumnDefs(e, t = [], i = []) {
    const s = [], o = {};
    return e.forEach((n) => {
      const r = this.createDefFromColumn(n, t, i);
      let a = !0, l = r, d = n.getOriginalParent(), c = null;
      for (; d; ) {
        let u = null;
        if (d.isPadding()) {
          d = d.getOriginalParent();
          continue;
        }
        const h = o[d.getGroupId()];
        if (h) {
          h.children.push(l), a = !1;
          break;
        }
        if (u = this.createDefFromGroup(d), u && (u.children = [l], o[u.groupId] = u, l = u, d = d.getOriginalParent()), d != null && c === d) {
          a = !1;
          break;
        }
        c = d;
      }
      a && s.push(l);
    }), s;
  }
  createDefFromGroup(e) {
    const t = el(e.getColGroupDef(), ["children"]);
    return t && (t.groupId = e.getGroupId()), t;
  }
  createDefFromColumn(e, t, i) {
    const s = el(e.getColDef());
    return s.colId = e.getColId(), s.width = e.getActualWidth(), s.rowGroup = e.isRowGroupActive(), s.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, s.pivot = e.isPivotActive(), s.pivotIndex = e.isPivotActive() ? i.indexOf(e) : null, s.aggFunc = e.isValueActive() ? e.getAggFunc() : null, s.hide = e.isVisible() ? void 0 : !0, s.pinned = e.isPinned() ? e.getPinned() : null, s.sort = e.getSort() ? e.getSort() : null, s.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, s;
  }
}, Vx = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colFlex";
  }
  refreshFlexedColumns(e = {}) {
    const t = e.source ?? "flex";
    e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth);
    const i = this.flexViewportWidth, { visibleCols: s, colDelayRenderSvc: o } = this.beans, n = s.centerCols;
    let r = -1;
    if (e.resizingCols) {
      const f = new Set(e.resizingCols);
      for (let m = n.length - 1; m >= 0; m--)
        if (f.has(n[m])) {
          r = m;
          break;
        }
    }
    let a = !1;
    const l = n.map((f, m) => {
      const C = f.getFlex(), v = C != null && C > 0 && m > r;
      return a || (a = v), {
        col: f,
        isFlex: v,
        flex: Math.max(0, C ?? 0),
        initialSize: f.getActualWidth(),
        min: f.getMinWidth(),
        max: f.getMaxWidth(),
        targetSize: 0
      };
    });
    if (a && (o == null || o.hideColumns("colFlex")), !i || !a)
      return [];
    let d = l.length, c = l.reduce((f, m) => f + m.flex, 0), u = i;
    const h = (f, m) => {
      f.frozenSize = m, f.col.setActualWidth(m, t), u -= m, c -= f.flex, d -= 1;
    }, g = (f) => f.frozenSize != null;
    for (const f of l)
      f.isFlex || h(f, f.initialSize);
    for (; d > 0; ) {
      const f = Math.round(c < 1 ? u * c : u);
      let m, C = 0, v = 0;
      for (const w of l) {
        if (g(w))
          continue;
        m = w, v += f * (w.flex / c);
        const x = v - C, F = Math.round(x);
        w.targetSize = F, C += F;
      }
      m && (m.targetSize += f - C);
      let R = 0;
      for (const w of l) {
        if (g(w))
          continue;
        const x = w.targetSize, F = Math.min(Math.max(x, w.min), w.max);
        R += F - x, w.violationType = F === x ? void 0 : F < x ? "max" : "min", w.targetSize = F;
      }
      const b = R === 0 ? "all" : R > 0 ? "min" : "max";
      for (const w of l)
        g(w) || (b === "all" || w.violationType === b) && h(w, w.targetSize);
    }
    e.skipSetLeft || s.setLeftValues(t), e.updateBodyWidths && s.updateBodyWidths();
    const p = l.filter((f) => f.isFlex && !f.violationType).map((f) => f.col);
    if (e.fireResizedEvent) {
      const f = l.filter((C) => C.initialSize !== C.frozenSize).map((C) => C.col), m = l.filter((C) => C.flex).map((C) => C.col);
      bs(this.eventSvc, f, !0, t, m);
    }
    return o == null || o.revealColumns("colFlex"), p;
  }
  initCol(e) {
    const { flex: t, initialFlex: i } = e.colDef;
    t !== void 0 ? e.flex = t : i !== void 0 && (e.flex = i);
  }
  // this method should only be used by the colModel to
  // change flex when required by the applyColumnState method.
  setColFlex(e, t) {
    e.flex = t ?? null, e.dispatchStateUpdatedEvent("flex");
  }
};
function no(e, t, i) {
  if (!t || !e)
    return;
  if (!i)
    return e[t];
  const s = t.split(".");
  let o = e;
  for (let n = 0; n < s.length; n++) {
    if (o == null)
      return;
    o = o[s[n]];
  }
  return o;
}
var Nx = [
  "dateTimeString",
  "dateString",
  "text",
  "number",
  "boolean",
  "date"
], Wx = class extends E {
  constructor() {
    super(...arguments), this.beanName = "dataTypeSvc", this.dataTypeDefinitions = {}, this.isPendingInference = !1, this.isColumnTypeOverrideInDataTypeDefinitions = !1, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = [], this.columnDefinitionPropsPerDataType = {
      number() {
        return { cellEditor: "agNumberCellEditor" };
      },
      boolean() {
        return {
          cellEditor: "agCheckboxCellEditor",
          cellRenderer: "agCheckboxCellRenderer",
          getFindText: () => null,
          suppressKeyboardEvent: (e) => !!e.colDef.editable && e.event.key === P.SPACE
        };
      },
      date({ formatValue: e }) {
        return { cellEditor: "agDateCellEditor", keyCreator: e };
      },
      dateString({ formatValue: e }) {
        return { cellEditor: "agDateStringCellEditor", keyCreator: e };
      },
      dateTime(e) {
        return this.date(e);
      },
      dateTimeString(e) {
        return this.dateString(e);
      },
      object({ formatValue: e, colModel: t, colId: i }) {
        return {
          cellEditorParams: {
            useFormatter: !0
          },
          comparator: (s, o) => {
            const n = t.getColDefCol(i), r = n == null ? void 0 : n.getColDef();
            if (!n || !r)
              return 0;
            const a = s == null ? "" : e({ column: n, node: null, value: s }), l = o == null ? "" : e({ column: n, node: null, value: o });
            return a === l ? 0 : a > l ? 1 : -1;
          },
          keyCreator: e
        };
      },
      text() {
        return {};
      }
    };
  }
  wireBeans(e) {
    this.colModel = e.colModel;
  }
  postConstruct() {
    this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", (e) => {
      this.processDataTypeDefinitions(), this.colModel.recreateColumnDefs(e);
    });
  }
  processDataTypeDefinitions() {
    const e = this.getDefaultDataTypes(), t = {}, i = {}, s = (c) => (u) => {
      const { column: h, node: g, value: p } = u;
      let f = h.getColDef().valueFormatter;
      return f === c.groupSafeValueFormatter && (f = c.valueFormatter), this.beans.valueSvc.formatValue(h, g, p, f);
    };
    for (const c of Object.keys(e)) {
      const u = e[c], h = {
        ...u,
        groupSafeValueFormatter: _c(u, this.gos)
      };
      t[c] = h, i[c] = s(h);
    }
    const o = this.gos.get("dataTypeDefinitions") ?? {}, n = {};
    for (const c of Object.keys(o)) {
      const u = o[c], h = this.processDataTypeDefinition(
        u,
        o,
        [c],
        e
      );
      h && (t[c] = h, u.dataTypeMatcher && (n[c] = u.dataTypeMatcher), i[c] = s(h));
    }
    const { valueParser: r, valueFormatter: a } = e.object, { valueParser: l, valueFormatter: d } = t.object;
    this.hasObjectValueParser = l !== r, this.hasObjectValueFormatter = d !== a, this.formatValueFuncs = i, this.dataTypeDefinitions = t, this.dataTypeMatchers = this.sortKeysInMatchers(n, e);
  }
  /**
   * Sorts the keys in the matchers object.
   * Does not mutate the original object, creates a copy of it with sorted keys instead.
   */
  sortKeysInMatchers(e, t) {
    const i = { ...e };
    for (const s of Nx)
      delete i[s], i[s] = e[s] ?? t[s].dataTypeMatcher;
    return i;
  }
  processDataTypeDefinition(e, t, i, s) {
    let o;
    const n = e.extendsDataType;
    if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0), e.extendsDataType === e.baseDataType) {
      let r = s[n];
      const a = t[n];
      if (r && a && (r = a), !Oc(e, r, n))
        return;
      o = Lc(r, e);
    } else {
      if (i.includes(n)) {
        I(44);
        return;
      }
      const r = t[n];
      if (!Oc(e, r, n))
        return;
      const a = this.processDataTypeDefinition(
        r,
        t,
        [...i, n],
        s
      );
      if (!a)
        return;
      o = Lc(a, e);
    }
    return {
      ...o,
      groupSafeValueFormatter: _c(o, this.gos)
    };
  }
  updateColDefAndGetColumnType(e, t, i) {
    let { cellDataType: s } = t;
    const { field: o } = t;
    if (s === void 0 && (s = e.cellDataType), (s == null || s === !0) && (s = this.canInferCellDataType(e, t) ? this.inferCellDataType(o, i) : !1), !s) {
      e.cellDataType = !1;
      return;
    }
    const n = this.dataTypeDefinitions[s];
    if (!n) {
      I(47, { cellDataType: s });
      return;
    }
    return e.cellDataType = s, n.groupSafeValueFormatter && (e.valueFormatter = n.groupSafeValueFormatter), n.valueParser && (e.valueParser = n.valueParser), n.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, s, n, i), n.columnTypes;
  }
  addColumnListeners(e) {
    if (!this.isPendingInference)
      return;
    const t = this.columnStateUpdatesPendingInference[e.getColId()];
    if (!t)
      return;
    const i = (s) => {
      t.add(s.key);
    };
    e.__addEventListener("columnStateUpdated", i), this.columnStateUpdateListenerDestroyFuncs.push(
      () => e.__removeEventListener("columnStateUpdated", i)
    );
  }
  canInferCellDataType(e, t) {
    const { gos: i } = this;
    if (!xe(i))
      return !1;
    const s = { cellRenderer: !0, valueGetter: !0, valueParser: !0, refData: !0 };
    if (da(t, s))
      return !1;
    const o = t.type === null ? e.type : t.type;
    if (o) {
      const n = i.get("columnTypes") ?? {};
      if (Yn(o).some((a) => {
        const l = n[a.trim()];
        return l && da(l, s);
      }))
        return !1;
    }
    return !da(e, s);
  }
  inferCellDataType(e, t) {
    if (!e)
      return;
    let i;
    const s = this.getInitialData();
    if (s) {
      const n = e.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      i = no(s, e, n);
    } else
      this.initWaitForRowData(t);
    return i == null ? void 0 : Object.keys(this.dataTypeMatchers).find(
      (n) => this.dataTypeMatchers[n](i)
    ) ?? "object";
  }
  getInitialData() {
    var t;
    const e = this.gos.get("rowData");
    if (e != null && e.length)
      return e[0];
    if (this.initialData)
      return this.initialData;
    {
      const i = (t = this.beans.rowModel.rootNode) == null ? void 0 : t.allLeafChildren;
      if (i != null && i.length)
        return i[0].data;
    }
    return null;
  }
  initWaitForRowData(e) {
    if (this.columnStateUpdatesPendingInference[e] = /* @__PURE__ */ new Set(), this.isPendingInference)
      return;
    this.isPendingInference = !0;
    const t = this.isColumnTypeOverrideInDataTypeDefinitions, { colAutosize: i, eventSvc: s } = this.beans;
    t && i && (i.shouldQueueResizeOperations = !0);
    const [o] = this.addManagedEventListeners({
      rowDataUpdateStarted: (n) => {
        const { firstRowData: r } = n;
        r && (o == null || o(), this.isPendingInference = !1, this.processColumnsPendingInference(r, t), this.columnStateUpdatesPendingInference = {}, t && (i == null || i.processResizeOperations()), s.dispatchEvent({
          type: "dataTypesInferred"
        }));
      }
    });
  }
  processColumnsPendingInference(e, t) {
    this.initialData = e;
    const i = [];
    this.destroyColumnStateUpdateListeners();
    const s = {}, o = {};
    for (const n of Object.keys(this.columnStateUpdatesPendingInference)) {
      const r = this.columnStateUpdatesPendingInference[n], a = this.colModel.getCol(n);
      if (!a)
        return;
      const l = a.getColDef();
      if (!this.resetColDefIntoCol(a, "cellDataTypeInferred"))
        return;
      const d = a.getColDef();
      if (t && d.type && d.type !== l.type) {
        const c = Ux(a, r);
        c.rowGroup && c.rowGroupIndex == null && (s[n] = c), c.pivot && c.pivotIndex == null && (o[n] = c), i.push(c);
      }
    }
    t && i.push(
      ...this.generateColumnStateForRowGroupAndPivotIndexes(
        s,
        o
      )
    ), i.length && ut(this.beans, { state: i }, "cellDataTypeInferred"), this.initialData = null;
  }
  generateColumnStateForRowGroupAndPivotIndexes(e, t) {
    const i = {}, { rowGroupColsSvc: s, pivotColsSvc: o } = this.beans;
    return s == null || s.restoreColumnOrder(i, e), o == null || o.restoreColumnOrder(i, t), Object.values(i);
  }
  resetColDefIntoCol(e, t) {
    const i = e.getUserProvidedColDef();
    if (!i)
      return !1;
    const s = Ha(this.beans, i, e.getColId());
    return e.setColDef(s, i, t), !0;
  }
  getDateStringTypeDefinition(e) {
    const { dateString: t } = this.dataTypeDefinitions;
    return e ? this.getDataTypeDefinition(e) ?? t : t;
  }
  getDateParserFunction(e) {
    return this.getDateStringTypeDefinition(e).dateParser;
  }
  getDateFormatterFunction(e) {
    return this.getDateStringTypeDefinition(e).dateFormatter;
  }
  getDateIncludesTimeFlag(e) {
    return e === "dateTime" || e === "dateTimeString";
  }
  getDataTypeDefinition(e) {
    const t = e.getColDef();
    if (t.cellDataType)
      return this.dataTypeDefinitions[t.cellDataType];
  }
  getBaseDataType(e) {
    var t;
    return (t = this.getDataTypeDefinition(e)) == null ? void 0 : t.baseDataType;
  }
  checkType(e, t) {
    var s;
    if (t == null)
      return !0;
    const i = (s = this.getDataTypeDefinition(e)) == null ? void 0 : s.dataTypeMatcher;
    return i ? i(t) : !0;
  }
  validateColDef(e) {
    const t = (i) => I(48, { property: i });
    if (e.cellDataType === "object") {
      const { object: i } = this.dataTypeDefinitions;
      e.valueFormatter === i.groupSafeValueFormatter && !this.hasObjectValueFormatter && t("Formatter"), e.editable && e.valueParser === i.valueParser && !this.hasObjectValueParser && t("Parser");
    }
  }
  postProcess(e) {
    var r;
    const t = e.cellDataType;
    if (!t || typeof t != "string")
      return;
    const { dataTypeDefinitions: i, beans: s, formatValueFuncs: o } = this, n = i[t];
    n && ((r = s.colFilter) == null || r.setColDefPropsForDataType(e, n, o[t]));
  }
  // noinspection JSUnusedGlobalSymbols
  getFormatValue(e) {
    return this.formatValueFuncs[e];
  }
  isColPendingInference(e) {
    return this.isPendingInference && !!this.columnStateUpdatesPendingInference[e];
  }
  setColDefPropertiesForBaseDataType(e, t, i, s) {
    const o = this.formatValueFuncs[t], n = this.columnDefinitionPropsPerDataType[i.baseDataType]({
      colDef: e,
      cellDataType: t,
      colModel: this.colModel,
      dataTypeDefinition: i,
      colId: s,
      formatValue: o
    });
    Object.assign(e, n);
  }
  getDateObjectTypeDef(e) {
    const t = this.getLocaleTextFunc(), i = this.getDateIncludesTimeFlag(e);
    return {
      baseDataType: e,
      valueParser: (s) => ze(s.newValue && String(s.newValue)),
      valueFormatter: (s) => s.value == null ? "" : !(s.value instanceof Date) || isNaN(s.value.getTime()) ? t("invalidDate", "Invalid Date") : Ke(s.value, i) ?? "",
      dataTypeMatcher: (s) => s instanceof Date
    };
  }
  getDateStringTypeDef(e) {
    const t = this.getDateIncludesTimeFlag(e);
    return {
      baseDataType: e,
      dateParser: (i) => ze(i) ?? void 0,
      dateFormatter: (i) => Ke(i ?? null, t) ?? void 0,
      valueParser: (i) => Dn(String(i.newValue)) ? i.newValue : null,
      valueFormatter: (i) => Dn(String(i.value)) ? String(i.value) : "",
      dataTypeMatcher: (i) => typeof i == "string" && Dn(i)
    };
  }
  getDefaultDataTypes() {
    const e = this.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        // can be empty space with legacy copy
        valueParser: (t) => {
          var i, s;
          return ((s = (i = t.newValue) == null ? void 0 : i.trim) == null ? void 0 : s.call(i)) === "" ? null : Number(t.newValue);
        },
        valueFormatter: (t) => t.value == null ? "" : typeof t.value != "number" || isNaN(t.value) ? e("invalidNumber", "Invalid Number") : String(t.value),
        dataTypeMatcher: (t) => typeof t == "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (t) => t.newValue === "" ? null : Ma(t.newValue),
        dataTypeMatcher: (t) => typeof t == "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (t) => {
          var i, s;
          return t.newValue == null ? t.newValue : ((s = (i = t.newValue) == null ? void 0 : i.trim) == null ? void 0 : s.call(i)) === "" ? null : String(t.newValue).toLowerCase() === "true";
        },
        valueFormatter: (t) => t.value == null ? "" : String(t.value),
        dataTypeMatcher: (t) => typeof t == "boolean"
      },
      date: this.getDateObjectTypeDef("date"),
      dateString: this.getDateStringTypeDef("dateString"),
      dateTime: this.getDateObjectTypeDef("dateTime"),
      dateTimeString: {
        ...this.getDateStringTypeDef("dateTimeString"),
        dataTypeMatcher: (t) => typeof t == "string" && lw(t)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (t) => Ma(t.value) ?? ""
      }
    };
  }
  destroyColumnStateUpdateListeners() {
    this.columnStateUpdateListenerDestroyFuncs.forEach((e) => e()), this.columnStateUpdateListenerDestroyFuncs = [];
  }
  destroy() {
    this.dataTypeDefinitions = {}, this.dataTypeMatchers = {}, this.formatValueFuncs = {}, this.columnStateUpdatesPendingInference = {}, this.destroyColumnStateUpdateListeners(), super.destroy();
  }
};
function Lc(e, t) {
  const i = {
    ...e,
    ...t
  };
  return e.columnTypes && t.columnTypes && t.appendColumnTypes && (i.columnTypes = [
    ...Yn(e.columnTypes),
    ...Yn(t.columnTypes)
  ]), i;
}
function Oc(e, t, i) {
  return t ? t.baseDataType !== e.baseDataType ? (I(46), !1) : !0 : (I(45, { parentCellDataType: i }), !1);
}
function _c(e, t) {
  if (e.valueFormatter)
    return (i) => {
      var s, o;
      if ((s = i.node) != null && s.group) {
        const n = (i.colDef.pivotValueColumn ?? i.column).getAggFunc();
        if (n) {
          if (n === "first" || n === "last")
            return e.valueFormatter(i);
          if (e.baseDataType === "number" && n !== "count") {
            if (typeof i.value == "number")
              return e.valueFormatter(i);
            if (typeof i.value == "object") {
              if (!i.value)
                return;
              if ("toNumber" in i.value)
                return e.valueFormatter({
                  ...i,
                  value: i.value.toNumber()
                });
              if ("value" in i.value)
                return e.valueFormatter({
                  ...i,
                  value: i.value.value
                });
            }
          }
          return;
        }
      } else if (t.get("groupHideOpenParents") && i.column.isRowGroupActive() && typeof i.value == "string" && !((o = e.dataTypeMatcher) != null && o.call(e, i.value)))
        return;
      return e.valueFormatter(i);
    };
}
function zx(e, t, i, s) {
  if (!t[i])
    return !1;
  const o = e[i];
  return o === null ? (t[i] = !1, !1) : s === void 0 ? !!o : o === s;
}
function da(e, t) {
  return [
    ["cellRenderer", "agSparklineCellRenderer"],
    ["valueGetter", void 0],
    ["valueParser", void 0],
    ["refData", void 0]
  ].some(
    ([i, s]) => zx(e, t, i, s)
  );
}
function Ux(e, t) {
  const i = gg(e);
  return t.forEach((s) => {
    delete i[s], s === "rowGroup" ? delete i.rowGroupIndex : s === "pivot" && delete i.pivotIndex;
  }), i;
}
var $x = {
  moduleName: "DataType",
  version: B,
  beans: [Wx],
  dependsOn: [mx]
}, Kx = {
  moduleName: "ColumnFlex",
  version: B,
  beans: [Vx]
}, Cp = {
  moduleName: "ColumnApi",
  version: B,
  beans: [Gx],
  apiFunctions: {
    getColumnDef: vx,
    getDisplayNameForColumn: bx,
    getColumn: yx,
    getColumns: Sx,
    applyColumnState: Rx,
    getColumnState: xx,
    resetColumnState: Fx,
    isPinning: Px,
    isPinningLeft: Ex,
    isPinningRight: Dx,
    getDisplayedColAfter: Tx,
    getDisplayedColBefore: Mx,
    setColumnsVisible: Ax,
    setColumnsPinned: Ix,
    getAllGridColumns: kx,
    getDisplayedLeftColumns: Lx,
    getDisplayedCenterColumns: Ox,
    getDisplayedRightColumns: _x,
    getAllDisplayedColumns: Hx,
    getAllDisplayedVirtualColumns: Bx,
    getColumnDefs: wx
  }
};
function jx(e) {
  if (!e || e == null)
    return null;
  const t = /([a-z])([A-Z])/g, i = /([A-Z]+)([A-Z])([a-z])/g;
  return e.replace(t, "$1 $2").replace(i, "$1 $2$3").replace(/\./g, " ").split(" ").map((o) => o.substring(0, 1).toUpperCase() + (o.length > 1 ? o.substring(1, o.length) : "")).join(" ");
}
var qx = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colNames";
  }
  getDisplayNameForColumn(e, t, i = !1) {
    if (!e)
      return null;
    const s = this.getHeaderName(e.getColDef(), e, null, null, t), { aggColNameSvc: o } = this.beans;
    return i && o ? o.getHeaderName(e, s) : s;
  }
  getDisplayNameForProvidedColumnGroup(e, t, i) {
    const s = t == null ? void 0 : t.getColGroupDef();
    return s ? this.getHeaderName(s, null, e, t, i) : null;
  }
  getDisplayNameForColumnGroup(e, t) {
    return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(e, t, i, s, o) {
    var r;
    const n = e.headerValueGetter;
    if (n) {
      const a = W(this.gos, {
        colDef: e,
        column: t,
        columnGroup: i,
        providedColumnGroup: s,
        location: o
      });
      return typeof n == "function" ? n(a) : typeof n == "string" ? ((r = this.beans.expressionSvc) == null ? void 0 : r.evaluate(n, a)) ?? null : "";
    } else {
      if (e.headerName != null)
        return e.headerName;
      if (e.field)
        return jx(e.field);
    }
    return "";
  }
}, Yx = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colViewport", this.colsWithinViewport = [], this.headerColsWithinViewport = [], this.colsWithinViewportHash = "", this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {}, this.columnsToRenderLeft = [], this.columnsToRenderRight = [], this.columnsToRenderCenter = [];
  }
  wireBeans(e) {
    this.visibleCols = e.visibleCols, this.colModel = e.colModel;
  }
  postConstruct() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
  }
  setScrollPosition(e, t, i = !1) {
    const { visibleCols: s } = this, o = s.isBodyWidthDirty;
    if (!(e === this.scrollWidth && t === this.scrollPosition && !o)) {
      if (this.scrollWidth = e, this.scrollPosition = t, s.isBodyWidthDirty = !0, this.gos.get("enableRtl")) {
        const r = s.bodyWidth;
        this.viewportLeft = r - t - e, this.viewportRight = r - t;
      } else
        this.viewportLeft = t, this.viewportRight = e + t;
      this.colModel.ready && this.checkViewportColumns(i);
    }
  }
  /**
   * Returns the columns that are currently rendered in the viewport.
   */
  getColumnHeadersToRender(e) {
    switch (e) {
      case "left":
        return this.columnsToRenderLeft;
      case "right":
        return this.columnsToRenderRight;
      default:
        return this.columnsToRenderCenter;
    }
  }
  /**
   * Returns the column groups that are currently rendered in the viewport at a specific header row index.
   */
  getHeadersToRender(e, t) {
    let i;
    switch (e) {
      case "left":
        i = this.rowsOfHeadersToRenderLeft[t];
        break;
      case "right":
        i = this.rowsOfHeadersToRenderRight[t];
        break;
      default:
        i = this.rowsOfHeadersToRenderCenter[t];
        break;
    }
    return i ?? [];
  }
  extractViewportColumns() {
    const e = this.visibleCols.centerCols;
    this.isColumnVirtualisationSuppressed() ? (this.colsWithinViewport = e, this.headerColsWithinViewport = e) : (this.colsWithinViewport = e.filter(this.isColumnInRowViewport.bind(this)), this.headerColsWithinViewport = e.filter(this.isColumnInHeaderViewport.bind(this)));
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  clear() {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {}, this.colsWithinViewportHash = "";
  }
  isColumnInHeaderViewport(e) {
    return e.isAutoHeaderHeight() || Qx(e) ? !0 : this.isColumnInRowViewport(e);
  }
  isColumnInRowViewport(e) {
    if (e.isAutoHeight())
      return !0;
    const t = e.getLeft() || 0, i = t + e.getActualWidth(), s = this.viewportLeft - 200, o = this.viewportRight + 200, n = t < s && i < s, r = t > o && i > o;
    return !n && !r;
  }
  // used by Grid API only
  getViewportColumns() {
    const { leftCols: e, rightCols: t } = this.visibleCols;
    return this.colsWithinViewport.concat(e).concat(t);
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getColsWithinViewport(e) {
    if (!this.colModel.colSpanActive)
      return this.colsWithinViewport;
    const t = (n) => {
      const r = n.getLeft();
      return H(r) && r > this.viewportLeft;
    }, i = this.isColumnVirtualisationSuppressed() ? void 0 : this.isColumnInRowViewport.bind(this), { visibleCols: s } = this, o = s.centerCols;
    return s.getColsForRow(e, o, i, t);
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns(e = !1) {
    this.extractViewport() && this.eventSvc.dispatchEvent({
      type: "virtualColumnsChanged",
      afterScroll: e
    });
  }
  calculateHeaderRows() {
    const { leftCols: e, rightCols: t } = this.visibleCols;
    this.columnsToRenderLeft = e, this.columnsToRenderRight = t, this.columnsToRenderCenter = this.colsWithinViewport;
    const i = (s) => {
      const o = /* @__PURE__ */ new Set(), n = {};
      for (const r of s) {
        let a = r.getParent();
        const l = r.isSpanHeaderHeight();
        for (; a && !o.has(a); ) {
          if (l && a.isPadding()) {
            a = a.getParent();
            continue;
          }
          const c = a.getProvidedColumnGroup().getLevel();
          n[c] ?? (n[c] = []), n[c].push(a), o.add(a), a = a.getParent();
        }
      }
      return n;
    };
    this.rowsOfHeadersToRenderLeft = i(e), this.rowsOfHeadersToRenderRight = i(t), this.rowsOfHeadersToRenderCenter = i(this.headerColsWithinViewport);
  }
  extractViewport() {
    const e = (s) => `${s.getId()}-${s.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const t = this.getViewportColumns().map(e).join("#"), i = this.colsWithinViewportHash !== t;
    return i && (this.colsWithinViewportHash = t, this.calculateHeaderRows()), i;
  }
};
function Qx(e) {
  for (; e; ) {
    if (e.isAutoHeaderHeight())
      return !0;
    e = e.getParent();
  }
  return !1;
}
var Xx = class extends E {
  constructor() {
    super(...arguments), this.beanName = "agCompUtils";
  }
  adaptFunction(e, t) {
    if (!e.cellRenderer)
      return null;
    class i {
      refresh() {
        return !1;
      }
      getGui() {
        return this.eGui;
      }
      init(o) {
        const n = t(o), r = typeof n;
        if (r === "string" || r === "number" || r === "boolean") {
          this.eGui = Pl("<span>" + n + "</span>");
          return;
        }
        if (n == null) {
          this.eGui = ye({ tag: "span" });
          return;
        }
        this.eGui = n;
      }
    }
    return i;
  }
}, Zx = {
  moduleName: "CellRendererFunction",
  version: B,
  beans: [Xx]
}, Jx = class extends rb {
  constructor() {
    super(...arguments), this.agGridDefaults = {}, this.agGridDefaultOverrides = {}, this.jsComps = {}, this.selectors = {}, this.icons = {};
  }
  postConstruct() {
    const t = this.gos.get("components");
    if (t != null)
      for (const i of Object.keys(t))
        this.jsComps[i] = t[i];
  }
  registerModule(t) {
    const { icons: i, userComponents: s, dynamicBeans: o, selectors: n } = t;
    if (s) {
      const r = (a, l, d, c) => {
        this.agGridDefaults[a] = l, (d || c) && (this.agGridDefaultOverrides[a] = { params: d, processParams: c });
      };
      for (const a of Object.keys(s)) {
        let l = s[a];
        if (sw(l) && (l = l.getComp(this.beans)), typeof l == "object") {
          const { classImp: d, params: c, processParams: u } = l;
          r(a, d, c, u);
        } else
          r(a, l);
      }
    }
    if (this.registerDynamicBeans(o), n == null || n.forEach((r) => {
      this.selectors[r.selector] = r;
    }), i)
      for (const r of Object.keys(i))
        this.icons[r] = i[r];
  }
  getUserComponent(t, i) {
    var l;
    const s = (d, c, u, h) => ({
      componentFromFramework: c,
      component: d,
      params: u,
      processParams: h
    }), { frameworkOverrides: o } = this.beans, n = o.frameworkComponent(i, this.gos.get("components"));
    if (n != null)
      return s(n, !0);
    const r = this.jsComps[i];
    if (r) {
      const d = o.isFrameworkComponent(r);
      return s(r, d);
    }
    const a = this.agGridDefaults[i];
    if (a) {
      const d = this.agGridDefaultOverrides[i];
      return s(a, !1, d == null ? void 0 : d.params, d == null ? void 0 : d.processParams);
    }
    return (l = this.beans.validation) == null || l.missingUserComponent(t, i, this.agGridDefaults, this.jsComps), null;
  }
  getSelector(t) {
    return this.selectors[t];
  }
  getIcon(t) {
    return this.icons[t];
  }
  getDynamicError(t, i) {
    var s;
    return i ? Pt(279, { name: t }) : ((s = this.beans.validation) == null ? void 0 : s.missingDynamicBean(t)) ?? Pt(256);
  }
}, eF = 23, tF = class extends E {
  constructor() {
    super(...arguments), this.beanName = "ctrlsSvc", this.params = {}, this.ready = !1, this.readyCallbacks = [];
  }
  postConstruct() {
    var e, t;
    this.addEventListener(
      "ready",
      () => {
        this.updateReady(), this.ready && (this.readyCallbacks.forEach((i) => i(this.params)), this.readyCallbacks.length = 0);
      },
      ((t = (e = this.beans.frameworkOverrides).runWhenReadyAsync) == null ? void 0 : t.call(e)) ?? !1
    );
  }
  updateReady() {
    const e = Object.values(this.params);
    this.ready = e.length === eF && e.every((t) => (t == null ? void 0 : t.isAlive()) ?? !1);
  }
  whenReady(e, t) {
    this.ready ? t(this.params) : this.readyCallbacks.push(t), e.addDestroyFunc(() => {
      const i = this.readyCallbacks.indexOf(t);
      i >= 0 && this.readyCallbacks.splice(i, 1);
    });
  }
  register(e, t) {
    this.params[e] = t, this.updateReady(), this.ready && this.dispatchLocalEvent({ type: "ready" }), t.addDestroyFunc(() => {
      this.updateReady();
    });
  }
  get(e) {
    return this.params[e];
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    const { leftHeader: e, centerHeader: t, rightHeader: i } = this.params;
    return [e, i, t];
  }
  getHeaderRowContainerCtrl(e) {
    const t = this.params;
    switch (e) {
      case "left":
        return t.leftHeader;
      case "right":
        return t.rightHeader;
      default:
        return t.centerHeader;
    }
  }
  getScrollFeature() {
    return this.getGridBodyCtrl().scrollFeature;
  }
}, vp = /* @__PURE__ */ new Set(), sr = {}, hs = {}, In, wp = !1, bp = !1, iF = !1;
function sF(e) {
  const [t, i] = e.version.split(".") || [], [s, o] = In.split(".") || [];
  return t === s && i === o;
}
function oF(e) {
  In || (In = e.version);
  const t = (i) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${i} Please update all modules to the same version.`;
  if (e.version ? sF(e) || ns(
    t(
      `'${e.moduleName}' is version ${e.version} but the other modules are version ${In}.`
    )
  ) : ns(t(`'${e.moduleName}' is incompatible.`)), e.validate) {
    const i = e.validate();
    i.isValid || ns(`${i.message}`);
  }
}
function or(e, t, i = !1) {
  i || (wp = !0), oF(e);
  const s = e.rowModels ?? ["all"];
  vp.add(e);
  let o;
  t !== void 0 ? (bp = !0, hs[t] === void 0 && (hs[t] = {}), o = hs[t]) : o = sr, s.forEach((n) => {
    o[n] === void 0 && (o[n] = {}), o[n][e.moduleName] = e;
  }), e.dependsOn && e.dependsOn.forEach((n) => or(n, t, i));
}
function nF(e) {
  delete hs[e];
}
function tl(e, t, i) {
  const s = (o) => {
    var n, r, a;
    return !!((n = sr[o]) != null && n[e]) || !!((a = (r = hs[t]) == null ? void 0 : r[o]) != null && a[e]);
  };
  return s(i) || s("all");
}
function ed() {
  return bp;
}
function rF(e, t) {
  const i = hs[e] ?? {};
  return [
    ...Object.values(sr.all ?? {}),
    ...Object.values(i.all ?? {}),
    ...Object.values(sr[t] ?? {}),
    ...Object.values(i[t] ?? {})
  ];
}
function aF() {
  return new Set(vp);
}
function lF() {
  return wp;
}
function dF() {
  return iF;
}
var cF = (
  /*css*/
  '.ag-aria-description-container{border:0;z-index:9999;clip:rect(1px,1px,1px,1px);height:1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ag-unselectable{-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-selectable{-webkit-user-select:text;-moz-user-select:text;user-select:text}.ag-tab-guard{display:block;height:0;position:absolute;width:0}:where(.ag-virtual-list-viewport) .ag-tab-guard{position:sticky}.ag-tab-guard-top{top:1px}.ag-tab-guard-bottom{bottom:1px}.ag-shake-left-to-right{animation-direction:alternate;animation-duration:.2s;animation-iteration-count:infinite;animation-name:ag-shake-left-to-right}@keyframes ag-shake-left-to-right{0%{padding-left:6px;padding-right:2px}to{padding-left:2px;padding-right:6px}}.ag-body-horizontal-scroll-viewport,.ag-body-vertical-scroll-viewport,.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport,.ag-virtual-list-viewport{flex:1 1 auto;height:100%;min-width:0;overflow:hidden;position:relative}.ag-viewport{position:relative}.ag-spanning-container{position:absolute;top:0;z-index:1}.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport{overflow-x:auto;-ms-overflow-style:none!important;scrollbar-width:none!important;&::-webkit-scrollbar{display:none!important}}.ag-body-viewport{display:flex;overflow-x:hidden;&:where(.ag-layout-normal){overflow-y:auto;-webkit-overflow-scrolling:touch}}.ag-floating-bottom-container,.ag-floating-top-container,.ag-sticky-bottom-container,.ag-sticky-top-container{min-height:1px}.ag-center-cols-viewport{min-height:100%;width:100%}.ag-body-horizontal-scroll-viewport{overflow-x:scroll}.ag-body-vertical-scroll-viewport{overflow-y:scroll}.ag-virtual-list-viewport{overflow:auto;width:100%}.ag-body-container,.ag-body-horizontal-scroll-container,.ag-body-vertical-scroll-container,.ag-center-cols-container,.ag-floating-bottom-container,.ag-floating-bottom-full-width-container,.ag-floating-top-container,.ag-full-width-container,.ag-header-container,.ag-pinned-left-cols-container,.ag-pinned-right-cols-container,.ag-sticky-bottom-container,.ag-sticky-top-container,.ag-virtual-list-container{position:relative}.ag-floating-bottom-container,.ag-floating-top-container,.ag-header-container,.ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top,.ag-sticky-bottom-container,.ag-sticky-top-container{height:100%;white-space:nowrap}.ag-center-cols-container,.ag-pinned-right-cols-container{display:block}.ag-body-horizontal-scroll-container{height:100%}.ag-body-vertical-scroll-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container,.ag-full-width-container,.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{pointer-events:none;position:absolute;top:0}:where(.ag-ltr) .ag-floating-bottom-full-width-container,:where(.ag-ltr) .ag-floating-top-full-width-container,:where(.ag-ltr) .ag-full-width-container,:where(.ag-ltr) .ag-sticky-bottom-full-width-container,:where(.ag-ltr) .ag-sticky-top-full-width-container{left:0}:where(.ag-rtl) .ag-floating-bottom-full-width-container,:where(.ag-rtl) .ag-floating-top-full-width-container,:where(.ag-rtl) .ag-full-width-container,:where(.ag-rtl) .ag-sticky-bottom-full-width-container,:where(.ag-rtl) .ag-sticky-top-full-width-container{right:0}.ag-full-width-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container{display:inline-block;height:100%;overflow:hidden;width:100%}.ag-virtual-list-container{overflow:hidden}.ag-body{display:flex;flex:1 1 auto;flex-direction:row!important;min-height:0;position:relative}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:flex;min-height:0;min-width:0;position:relative;&:where(.ag-scrollbar-invisible){bottom:0;position:absolute;&:where(.ag-apple-scrollbar){opacity:0;transition:opacity .4s;visibility:hidden;&:where(.ag-scrollbar-scrolling,.ag-scrollbar-active){opacity:1;visibility:visible}}}}.ag-body-horizontal-scroll{width:100%;&:where(.ag-scrollbar-invisible){left:0;right:0}}.ag-body-vertical-scroll{height:100%;&:where(.ag-scrollbar-invisible){top:0;z-index:10}}:where(.ag-ltr) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){right:0}}:where(.ag-rtl) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){left:0}}.ag-force-vertical-scroll{overflow-y:scroll!important}.ag-horizontal-left-spacer,.ag-horizontal-right-spacer{height:100%;min-width:0;overflow-x:scroll;&:where(.ag-scroller-corner){overflow-x:hidden}}:where(.ag-row-animation) .ag-row{transition:transform .4s,top .4s,opacity .2s;&:where(.ag-after-created){transition:transform .4s,top .4s,height .4s,opacity .2s}}:where(.ag-row-animation.ag-prevent-animation) .ag-row{transition:none!important;&:where(.ag-row.ag-after-created){transition:none!important}}:where(.ag-row-no-animation) .ag-row{transition:none}.ag-row-loading{align-items:center;display:flex}.ag-row-position-absolute{position:absolute}.ag-row-position-relative{position:relative}.ag-full-width-row{overflow:hidden;pointer-events:all}.ag-row-inline-editing{z-index:1}.ag-row-dragging{z-index:2}.ag-stub-cell{align-items:center;display:flex}.ag-cell{display:inline-block;height:100%;position:absolute;white-space:nowrap;&:focus-visible{box-shadow:none}}.ag-cell-value{flex:1 1 auto}.ag-cell-value,.ag-group-value{overflow:hidden;text-overflow:ellipsis}.ag-cell-wrap-text{white-space:normal;word-break:break-word}:where(.ag-cell) .ag-icon{display:inline-block;vertical-align:middle}.ag-floating-top{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-top:not(.ag-invisible)){border-bottom:var(--ag-pinned-row-border)}.ag-floating-bottom{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-bottom:not(.ag-invisible)){border-top:var(--ag-pinned-row-border)}.ag-sticky-bottom,.ag-sticky-top{background-color:var(--ag-background-color);display:flex;height:0;overflow:hidden;position:absolute;width:100%;z-index:1}.ag-opacity-zero{opacity:0!important}.ag-cell-label-container{align-items:center;display:flex;flex-direction:row-reverse;height:100%;justify-content:space-between;width:100%}:where(.ag-right-aligned-header){.ag-cell-label-container{flex-direction:row}.ag-header-cell-text{text-align:end}}.ag-column-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr){direction:ltr;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row}}:where(.ag-rtl){direction:rtl;text-align:right;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row-reverse}.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{display:block}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(180deg)}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(-180deg)}}.ag-measurement-container{height:0;overflow:hidden;visibility:hidden;width:0}.ag-measurement-element-border{display:inline-block;&:before{border-left:var(--ag-internal-measurement-border);content:"";display:block}}.ag-group{position:relative;width:100%}.ag-group-title-bar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-title{display:inline;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-group-title-bar) .ag-group-title{cursor:default}.ag-group-toolbar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-container{display:flex}.ag-disabled .ag-group-container{pointer-events:none}.ag-disabled-group-container,.ag-disabled-group-title-bar{opacity:.5}.ag-group-container-horizontal{flex-flow:row wrap}.ag-group-container-vertical{flex-direction:column}.ag-group-title-bar-icon{cursor:pointer;flex:none}:where(.ag-ltr) .ag-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-group-title-bar-icon{margin-left:var(--ag-spacing)}:where(.ag-group-item-alignment-stretch) .ag-group-item{align-items:stretch}:where(.ag-group-item-alignment-start) .ag-group-item{align-items:flex-start}:where(.ag-group-item-alignment-end) .ag-group-item{align-items:flex-end}:where(.ag-ltr) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-left:var(--ag-row-group-indent-size)}:where(.ag-rtl) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-right:var(--ag-row-group-indent-size)}:where(.ag-ltr) .ag-row-group-leaf-indent{margin-left:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}:where(.ag-rtl) .ag-row-group-leaf-indent{margin-right:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}.ag-value-change-delta{padding:0 2px}.ag-value-change-delta-up{color:var(--ag-value-change-delta-up-color)}.ag-value-change-delta-down{color:var(--ag-value-change-delta-down-color)}.ag-value-change-value{background-color:transparent;border-radius:1px;padding-left:1px;padding-right:1px;transition:background-color 1s}.ag-value-change-value-highlight{background-color:var(--ag-value-change-value-highlight-background-color);transition:background-color .1s}.ag-cell-data-changed{background-color:var(--ag-value-change-value-highlight-background-color)!important}.ag-cell-data-changed-animation{background-color:transparent}.ag-cell-highlight{background-color:var(--ag-range-selection-highlight-color)!important}.ag-row,.ag-spanned-row{color:var(--ag-cell-text-color);font-family:var(--ag-cell-font-family);font-size:var(--ag-data-font-size);white-space:nowrap;--ag-internal-content-line-height:calc(min(var(--ag-row-height), var(--ag-line-height, 1000px)) - var(--ag-internal-row-border-width, 1px) - 2px)}.ag-row{background-color:var(--ag-background-color);border-bottom:var(--ag-row-border);height:var(--ag-row-height);width:100%;&.ag-row-editing-invalid{background-color:var(--ag-full-row-edit-invalid-background-color)}}:where(.ag-body-vertical-content-no-gap>div>div>div,.ag-body-vertical-content-no-gap>div>div>div>div)>.ag-row-last{border-bottom-color:transparent}.ag-sticky-bottom{border-top:var(--ag-row-border);box-sizing:content-box!important}.ag-group-contracted,.ag-group-expanded{cursor:pointer}.ag-cell,.ag-full-width-row .ag-cell-wrapper.ag-row-group{border:1px solid transparent;line-height:var(--ag-internal-content-line-height);-webkit-font-smoothing:subpixel-antialiased}:where(.ag-ltr) .ag-cell{border-right:var(--ag-column-border)}:where(.ag-rtl) .ag-cell{border-left:var(--ag-column-border)}.ag-spanned-cell-wrapper{background-color:var(--ag-background-color);position:absolute}.ag-spanned-cell-wrapper>.ag-spanned-cell{display:block;position:relative}:where(.ag-ltr) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-right-color:transparent}:where(.ag-rtl) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-left-color:transparent}.ag-cell-wrapper{align-items:center;display:flex;>:where(:not(.ag-cell-value,.ag-group-value)){align-items:center;display:flex;height:var(--ag-internal-content-line-height)}&:where(.ag-row-group){align-items:flex-start}:where(.ag-full-width-row) &:where(.ag-row-group){align-items:center;height:100%}}:where(.ag-ltr) .ag-cell-wrapper{padding-left:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-rtl) .ag-cell-wrapper{padding-right:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-cell-wrap-text:not(.ag-cell-auto-height)) .ag-cell-wrapper{align-items:normal;height:100%;:where(.ag-cell-value){height:100%}}:where(.ag-ltr) .ag-row>.ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-row>.ag-cell-wrapper.ag-row-group{padding-right:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-cell-focus:not(.ag-cell-range-selected):focus-within,.ag-cell-range-single-cell,.ag-cell-range-single-cell.ag-cell-range-handle,.ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),.ag-context-menu-open .ag-full-width-row.ag-row-focus .ag-cell-wrapper.ag-row-group,.ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group{border:1px solid;border-color:var(--ag-range-selection-border-color);border-style:var(--ag-range-selection-border-style);outline:initial}.ag-full-width-row.ag-row-focus:focus{box-shadow:none}:where(.ag-ltr) .ag-group-contracted,:where(.ag-ltr) .ag-group-expanded,:where(.ag-ltr) .ag-row-drag,:where(.ag-ltr) .ag-selection-checkbox{margin-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-group-contracted,:where(.ag-rtl) .ag-group-expanded,:where(.ag-rtl) .ag-row-drag,:where(.ag-rtl) .ag-selection-checkbox{margin-left:var(--ag-cell-widget-spacing)}:where(.ag-ltr) .ag-group-child-count{margin-left:3px}:where(.ag-rtl) .ag-group-child-count{margin-right:3px}.ag-row-highlight-above:after,.ag-row-highlight-below:after,.ag-row-highlight-inside:after{background-color:var(--ag-range-selection-border-color);content:"";height:1px;pointer-events:none;position:absolute;width:calc(100% - 1px)}:where(.ag-ltr) .ag-row-highlight-above:after,:where(.ag-ltr) .ag-row-highlight-below:after,:where(.ag-ltr) .ag-row-highlight-inside:after{left:1px}:where(.ag-rtl) .ag-row-highlight-above:after,:where(.ag-rtl) .ag-row-highlight-below:after,:where(.ag-rtl) .ag-row-highlight-inside:after{right:1px}.ag-row-highlight-above:after{top:0}.ag-row-highlight-below:after{bottom:0}.ag-row-highlight-indent:after{display:block;width:auto}:where(.ag-ltr) .ag-row-highlight-indent:after{left:calc((var(--ag-cell-widget-spacing) + var(--ag-icon-size))*2 + var(--ag-cell-horizontal-padding) + var(--ag-row-highlight-level)*var(--ag-row-group-indent-size));right:1px}:where(.ag-rtl) .ag-row-highlight-indent:after{left:1px;right:calc((var(--ag-cell-widget-spacing) + var(--ag-icon-size))*2 + var(--ag-cell-horizontal-padding) + var(--ag-row-highlight-level)*var(--ag-row-group-indent-size))}.ag-row-highlight-inside:after{background-color:var(--ag-selected-row-background-color);border:1px solid var(--ag-range-selection-border-color);display:block;height:auto;inset:0;width:auto}.ag-row-odd{background-color:var(--ag-odd-row-background-color)}.ag-row-selected:before{background-color:var(--ag-selected-row-background-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-full-width-row.ag-row-group:before,.ag-row-hover:not(.ag-full-width-row):before{background-color:var(--ag-row-hover-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-row-selected:before{background-color:var(--ag-row-hover-color);background-image:linear-gradient(var(--ag-selected-row-background-color),var(--ag-selected-row-background-color))}.ag-row.ag-full-width-row.ag-row-group>*{position:relative}.ag-column-hover{background-color:var(--ag-column-hover-color)}.ag-header-range-highlight{background-color:var(--ag-range-header-highlight-color)}.ag-right-aligned-cell{font-variant-numeric:tabular-nums}:where(.ag-ltr) .ag-right-aligned-cell{text-align:right}:where(.ag-rtl) .ag-right-aligned-cell{text-align:left}.ag-right-aligned-cell .ag-cell-value,.ag-right-aligned-cell .ag-group-value{margin-left:auto}:where(.ag-ltr) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-ltr) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level));padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}:where(.ag-rtl) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-rtl) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-row>.ag-cell-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}.ag-row-dragging{cursor:move;opacity:.5}.ag-details-row{background-color:var(--ag-background-color);padding:calc(var(--ag-spacing)*3.75)}.ag-layout-auto-height,.ag-layout-print{.ag-center-cols-container,.ag-center-cols-viewport{min-height:150px}}.ag-overlay-loading-wrapper{background-color:var(--ag-modal-overlay-background-color)}.ag-skeleton-container{align-content:center;height:100%;width:100%}.ag-skeleton-effect{animation:ag-skeleton-loading 1.5s ease-in-out .5s infinite;background-color:var(--ag-row-loading-skeleton-effect-color);border-radius:.25rem;height:1em;width:100%}:where(.ag-ltr) .ag-right-aligned-cell .ag-skeleton-effect{margin-left:auto}:where(.ag-rtl) .ag-right-aligned-cell .ag-skeleton-effect{margin-right:auto}@keyframes ag-skeleton-loading{0%{background-color:var(--ag-row-loading-skeleton-effect-color)}50%{background-color:color-mix(in srgb,transparent,var(--ag-row-loading-skeleton-effect-color) 40%)}to{background-color:var(--ag-row-loading-skeleton-effect-color)}}.ag-loading{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-loading{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-loading{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-ltr) .ag-loading-icon{padding-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-loading-icon{padding-left:var(--ag-cell-widget-spacing)}.ag-icon-loading{animation-duration:1s;animation-iteration-count:infinite;animation-name:spin;animation-timing-function:linear}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.ag-header{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);color:var(--ag-header-text-color);display:flex;font-family:var(--ag-header-font-family);font-size:var(--ag-header-font-size);font-weight:var(--ag-header-font-weight);overflow:hidden;white-space:nowrap;width:100%}.ag-header-row{height:var(--ag-header-height);position:absolute}.ag-floating-filter-button-button,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,:where(.ag-header-cell-sortable) .ag-header-cell-label{cursor:pointer}:where(.ag-ltr) .ag-header-expand-icon{margin-left:4px}:where(.ag-rtl) .ag-header-expand-icon{margin-right:4px}.ag-header-row:where(:not(:first-child)){:where(.ag-header-cell:not(.ag-header-span-height.ag-header-span-total,.ag-header-parent-hidden),.ag-header-group-cell.ag-header-group-cell-with-group){border-top:var(--ag-header-row-border)}}.ag-header-row:where(:not(.ag-header-row-column-group)){overflow:hidden}:where(.ag-header.ag-header-allow-overflow) .ag-header-row{overflow:visible}.ag-header-cell{display:inline-flex;overflow:hidden}.ag-header-group-cell{contain:paint;display:flex}.ag-header-cell,.ag-header-group-cell{align-items:center;gap:var(--ag-cell-widget-spacing);height:100%;padding:0 var(--ag-cell-horizontal-padding);position:absolute}@property --ag-internal-moving-color{syntax:"<color>";inherits:false;initial-value:transparent}@property --ag-internal-hover-color{syntax:"<color>";inherits:false;initial-value:transparent}.ag-header-cell:where(:not(.ag-floating-filter)),.ag-header-group-cell{&:before{background-image:linear-gradient(var(--ag-internal-hover-color),var(--ag-internal-hover-color)),linear-gradient(var(--ag-internal-moving-color),var(--ag-internal-moving-color));content:"";inset:0;position:absolute;--ag-internal-moving-color:transparent;--ag-internal-hover-color:transparent;transition:--ag-internal-moving-color var(--ag-header-cell-background-transition-duration),--ag-internal-hover-color var(--ag-header-cell-background-transition-duration)}&:where(:hover):before{--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}&:where(.ag-header-cell-moving):before{--ag-internal-moving-color:var(--ag-header-cell-moving-background-color);--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}}:where(.ag-header-cell:not(.ag-floating-filter) *,.ag-header-group-cell *){position:relative;z-index:1}.ag-header-cell-menu-button:where(:not(.ag-header-menu-always-show)){opacity:0;transition:opacity .2s}.ag-header-cell-filter-button,:where(.ag-header-cell.ag-header-active) .ag-header-cell-menu-button{opacity:1}.ag-header-cell-label,.ag-header-group-cell-label{align-items:center;align-self:stretch;display:flex;flex:1 1 auto;overflow:hidden;padding:5px 0}:where(.ag-ltr) .ag-sort-indicator-icon{padding-left:var(--ag-spacing)}:where(.ag-rtl) .ag-sort-indicator-icon{padding-right:var(--ag-spacing)}.ag-header-cell-label{text-overflow:ellipsis}.ag-header-group-cell-label.ag-sticky-label{flex:none;max-width:100%;overflow:visible;position:sticky}:where(.ag-ltr) .ag-header-group-cell-label.ag-sticky-label{left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-header-group-cell-label.ag-sticky-label{right:var(--ag-cell-horizontal-padding)}.ag-header-cell-text,.ag-header-group-text{overflow:hidden;text-overflow:ellipsis}.ag-header-cell-text{word-break:break-word}.ag-header-cell-comp-wrapper{width:100%}:where(.ag-header-group-cell) .ag-header-cell-comp-wrapper{display:flex}:where(.ag-header-cell:not(.ag-header-cell-auto-height)) .ag-header-cell-comp-wrapper{align-items:center;display:flex;height:100%}.ag-header-cell-wrap-text .ag-header-cell-comp-wrapper{white-space:normal}.ag-header-cell-comp-wrapper-limited-height>*{overflow:hidden}:where(.ag-right-aligned-header) .ag-header-cell-label{flex-direction:row-reverse}:where(.ag-ltr) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-ltr) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}.ag-header-cell:after,.ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{content:"";height:var(--ag-header-column-border-height);position:absolute;top:calc(50% - var(--ag-header-column-border-height)*.5);z-index:1}:where(.ag-ltr) .ag-header-cell:after,:where(.ag-ltr) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-right:var(--ag-header-column-border);right:0}:where(.ag-rtl) .ag-header-cell:after,:where(.ag-rtl) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-left:var(--ag-header-column-border);left:0}.ag-header-highlight-after:after,.ag-header-highlight-before:after{background-color:var(--ag-accent-color);content:"";height:100%;position:absolute;width:1px}:where(.ag-ltr) .ag-header-highlight-before:after{left:0}:where(.ag-rtl) .ag-header-highlight-before:after{right:0}:where(.ag-ltr) .ag-header-highlight-after:after{right:0;:where(.ag-pinned-left-header) &{right:1px}}:where(.ag-rtl) .ag-header-highlight-after:after{left:0;:where(.ag-pinned-left-header) &{left:1px}}.ag-header-cell-resize{align-items:center;cursor:ew-resize;display:flex;height:100%;position:absolute;top:0;width:8px;z-index:2;&:after{background-color:var(--ag-header-column-resize-handle-color);content:"";height:var(--ag-header-column-resize-handle-height);position:absolute;top:calc(50% - var(--ag-header-column-resize-handle-height)*.5);width:var(--ag-header-column-resize-handle-width);z-index:1}}:where(.ag-ltr) .ag-header-cell-resize{right:-3px;&:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-rtl) .ag-header-cell-resize{left:-3px;&:after{right:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-header-cell.ag-header-span-height) .ag-header-cell-resize:after{height:calc(100% - var(--ag-spacing)*4);top:calc(var(--ag-spacing)*2)}.ag-header-group-cell-no-group:where(.ag-header-span-height){display:none}.ag-sort-indicator-container{display:flex;gap:var(--ag-spacing)}.ag-layout-print{&.ag-body{display:block;height:unset}&.ag-root-wrapper{display:inline-block}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:none}&.ag-force-vertical-scroll{overflow-y:visible!important}}@media print{.ag-root-wrapper.ag-layout-print{display:table;.ag-body-horizontal-scroll-viewport,.ag-body-viewport,.ag-center-cols-container,.ag-center-cols-viewport,.ag-root,.ag-root-wrapper-body,.ag-virtual-list-viewport{display:block!important;height:auto!important;overflow:hidden!important}.ag-cell,.ag-row{-moz-column-break-inside:avoid;break-inside:avoid}}}ag-grid,ag-grid-angular{display:block}.ag-root-wrapper{border:var(--ag-wrapper-border);border-radius:var(--ag-wrapper-border-radius);display:flex;flex-direction:column;overflow:hidden;position:relative;&.ag-layout-normal{height:100%}}.ag-root-wrapper-body{display:flex;flex-direction:row;&.ag-layout-normal{flex:1 1 auto;height:0;min-height:0}}.ag-root{display:flex;flex-direction:column;position:relative;&.ag-layout-auto-height,&.ag-layout-normal{flex:1 1 auto;overflow:hidden;width:0}&.ag-layout-normal{height:100%}}.ag-virtual-list-item{height:var(--ag-list-item-height);position:absolute;width:100%}.ag-list-item-hovered:after{background-color:var(--ag-accent-color);content:"";height:1px;left:0;position:absolute;right:0}.ag-item-highlight-top:after{top:0}.ag-item-highlight-bottom:after{bottom:0}.ag-drag-handle{color:var(--ag-drag-handle-color);cursor:grab;:where(.ag-icon){color:var(--ag-drag-handle-color)}}.ag-chart-menu-icon,.ag-chart-settings-next,.ag-chart-settings-prev,.ag-column-group-icons,.ag-column-select-header-icon,.ag-filter-toolpanel-expand,.ag-floating-filter-button-button,.ag-group-title-bar-icon,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,.ag-panel-title-bar-button-icon,.ag-set-filter-group-icons,:where(.ag-group-contracted) .ag-icon,:where(.ag-group-expanded) .ag-icon{background-color:var(--ag-icon-button-background-color);border-radius:var(--ag-icon-button-border-radius);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-background-color);color:var(--ag-icon-button-color);&:hover{background-color:var(--ag-icon-button-hover-background-color);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-hover-background-color);color:var(--ag-icon-button-hover-color)}}.ag-filter-active{background-image:linear-gradient(var(--ag-icon-button-active-background-color),var(--ag-icon-button-active-background-color));border-radius:1px;outline:solid var(--ag-icon-button-background-spread) var(--ag-icon-button-active-background-color);position:relative;&:after{background-color:var(--ag-icon-button-active-indicator-color);border-radius:50%;content:"";height:6px;position:absolute;top:-1px;width:6px}:where(.ag-icon-filter){clip-path:path("M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z");color:var(--ag-icon-button-active-color)}}:where(.ag-ltr) .ag-filter-active{&:after{right:-1px}}:where(.ag-rtl) .ag-filter-active{&:after{left:-1px}}.ag-menu{background-color:var(--ag-menu-background-color);border:var(--ag-menu-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-menu-shadow);color:var(--ag-menu-text-color);max-height:100%;overflow-y:auto;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}'
), uF = {
  wrapperBorder: !0,
  rowBorder: !0,
  headerRowBorder: !0,
  footerRowBorder: {
    ref: "rowBorder"
  },
  columnBorder: {
    style: "solid",
    width: 1,
    color: "transparent"
  },
  headerColumnBorder: !1,
  headerColumnBorderHeight: "100%",
  pinnedColumnBorder: !0,
  pinnedRowBorder: !0,
  sidePanelBorder: !0,
  sideBarPanelWidth: 250,
  sideBarBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  sideButtonBarBackgroundColor: {
    ref: "sideBarBackgroundColor"
  },
  sideButtonBarTopPadding: 0,
  sideButtonSelectedUnderlineWidth: 2,
  sideButtonSelectedUnderlineColor: "transparent",
  sideButtonSelectedUnderlineTransitionDuration: 0,
  sideButtonBackgroundColor: "transparent",
  sideButtonTextColor: { ref: "textColor" },
  sideButtonHoverBackgroundColor: { ref: "sideButtonBackgroundColor" },
  sideButtonHoverTextColor: { ref: "sideButtonTextColor" },
  sideButtonSelectedBackgroundColor: We,
  sideButtonSelectedTextColor: { ref: "sideButtonTextColor" },
  sideButtonBorder: "solid 1px transparent",
  sideButtonSelectedBorder: !0,
  sideButtonLeftPadding: { ref: "spacing" },
  sideButtonRightPadding: { ref: "spacing" },
  sideButtonVerticalPadding: { calc: "spacing * 3" },
  headerBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  headerFontFamily: {
    ref: "fontFamily"
  },
  cellFontFamily: {
    ref: "fontFamily"
  },
  headerFontWeight: 500,
  headerFontSize: {
    ref: "fontSize"
  },
  dataFontSize: {
    ref: "fontSize"
  },
  headerTextColor: {
    ref: "textColor"
  },
  headerCellHoverBackgroundColor: "transparent",
  headerCellMovingBackgroundColor: { ref: "headerCellHoverBackgroundColor" },
  headerCellBackgroundTransitionDuration: "0.2s",
  cellTextColor: {
    ref: "textColor"
  },
  rangeSelectionBorderStyle: "solid",
  rangeSelectionBorderColor: Bt,
  rangeSelectionBackgroundColor: yt(0.2),
  rangeSelectionChartBackgroundColor: "#0058FF1A",
  rangeSelectionChartCategoryBackgroundColor: "#00FF841A",
  rangeSelectionHighlightColor: yt(0.5),
  rangeHeaderHighlightColor: Gw(0.08),
  rowNumbersSelectedColor: yt(0.5),
  rowHoverColor: yt(0.08),
  columnHoverColor: yt(0.05),
  selectedRowBackgroundColor: yt(0.12),
  modalOverlayBackgroundColor: {
    ref: "backgroundColor",
    mix: 0.66
  },
  oddRowBackgroundColor: We,
  wrapperBorderRadius: 8,
  cellHorizontalPadding: {
    calc: "spacing * 2 * cellHorizontalPaddingScale"
  },
  cellWidgetSpacing: {
    calc: "spacing * 1.5"
  },
  cellHorizontalPaddingScale: 1,
  rowGroupIndentSize: {
    calc: "cellWidgetSpacing + iconSize"
  },
  valueChangeDeltaUpColor: "#43a047",
  valueChangeDeltaDownColor: "#e53935",
  valueChangeValueHighlightBackgroundColor: "#16a08580",
  rowHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 3.25 * rowVerticalPaddingScale"
  },
  rowVerticalPaddingScale: 1,
  headerHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 4 * headerVerticalPaddingScale"
  },
  headerVerticalPaddingScale: 1,
  paginationPanelHeight: {
    ref: "rowHeight",
    calc: "max(rowHeight, 22px)"
  },
  dragHandleColor: Ye(0.7),
  headerColumnResizeHandleHeight: "30%",
  headerColumnResizeHandleWidth: 2,
  headerColumnResizeHandleColor: {
    ref: "borderColor"
  },
  widgetContainerHorizontalPadding: {
    calc: "spacing * 1.5"
  },
  widgetContainerVerticalPadding: {
    calc: "spacing * 1.5"
  },
  widgetHorizontalSpacing: {
    calc: "spacing * 1.5"
  },
  widgetVerticalSpacing: {
    ref: "spacing"
  },
  iconButtonColor: { ref: "iconColor" },
  iconButtonBackgroundColor: "transparent",
  iconButtonBackgroundSpread: 4,
  iconButtonBorderRadius: 1,
  iconButtonHoverColor: { ref: "iconButtonColor" },
  iconButtonHoverBackgroundColor: Ye(0.1),
  iconButtonActiveColor: Bt,
  iconButtonActiveBackgroundColor: yt(0.28),
  iconButtonActiveIndicatorColor: Bt,
  menuBorder: {
    color: Ye(0.2)
  },
  menuBackgroundColor: Xe(0.03),
  menuTextColor: Xe(0.95),
  menuShadow: {
    ref: "popupShadow"
  },
  menuSeparatorColor: {
    ref: "borderColor"
  },
  setFilterIndentSize: {
    ref: "iconSize"
  },
  chartMenuPanelWidth: 260,
  chartMenuLabelColor: Ye(0.8),
  dialogShadow: {
    ref: "popupShadow"
  },
  cellEditingBorder: {
    color: Bt
  },
  cellEditingShadow: { ref: "cardShadow" },
  fullRowEditInvalidBackgroundColor: {
    ref: "invalidColor",
    onto: "backgroundColor",
    mix: 0.25
  },
  dialogBorder: {
    color: Ye(0.2)
  },
  panelBackgroundColor: We,
  panelTitleBarBackgroundColor: {
    ref: "headerBackgroundColor"
  },
  panelTitleBarIconColor: {
    ref: "headerTextColor"
  },
  panelTitleBarTextColor: {
    ref: "headerTextColor"
  },
  panelTitleBarFontWeight: {
    ref: "headerFontWeight"
  },
  panelTitleBarBorder: !0,
  columnSelectIndentSize: {
    ref: "iconSize"
  },
  toolPanelSeparatorBorder: !0,
  columnDropCellBackgroundColor: Ye(0.07),
  columnDropCellTextColor: {
    ref: "textColor"
  },
  columnDropCellDragHandleColor: {
    ref: "textColor"
  },
  columnDropCellBorder: {
    color: Ye(0.13)
  },
  selectCellBackgroundColor: Ye(0.07),
  selectCellBorder: {
    color: Ye(0.13)
  },
  advancedFilterBuilderButtonBarBorder: !0,
  advancedFilterBuilderIndentSize: {
    calc: "spacing * 2 + iconSize"
  },
  advancedFilterBuilderJoinPillColor: "#f08e8d",
  advancedFilterBuilderColumnPillColor: "#a6e194",
  advancedFilterBuilderOptionPillColor: "#f3c08b",
  advancedFilterBuilderValuePillColor: "#85c0e4",
  filterPanelApplyButtonColor: We,
  filterPanelApplyButtonBackgroundColor: Bt,
  filterPanelCardSubtleColor: {
    ref: "textColor",
    mix: 0.7
  },
  filterPanelCardSubtleHoverColor: { ref: "textColor" },
  findMatchColor: is,
  findMatchBackgroundColor: "#ffff00",
  findActiveMatchColor: is,
  findActiveMatchBackgroundColor: "#ffa500",
  filterToolPanelGroupIndent: {
    ref: "spacing"
  },
  rowLoadingSkeletonEffectColor: Ye(0.15),
  statusBarLabelColor: is,
  statusBarLabelFontWeight: 500,
  statusBarValueColor: is,
  statusBarValueFontWeight: 500,
  pinnedSourceRowTextColor: {
    ref: "textColor"
  },
  pinnedSourceRowBackgroundColor: {
    ref: "backgroundColor"
  },
  pinnedSourceRowFontWeight: 600,
  pinnedRowFontWeight: 600,
  pinnedRowBackgroundColor: {
    ref: "backgroundColor"
  },
  pinnedRowTextColor: {
    ref: "textColor"
  }
}, hF = (
  /*css*/
  ".ag-cell-batch-edit{background-color:var(--ag-cell-batch-edit-background-color);color:var(--ag-cell-batch-edit-text-color);display:inherit}.ag-row-batch-edit{background-color:var(--ag-row-batch-edit-background-color);color:var(--ag-row-batch-edit-text-color)}"
), yp = {
  cellBatchEditBackgroundColor: "rgba(220 181 139 / 16%)",
  cellBatchEditTextColor: "#422f00",
  rowBatchEditBackgroundColor: {
    ref: "cellBatchEditBackgroundColor"
  },
  rowBatchEditTextColor: {
    ref: "cellBatchEditTextColor"
  }
}, gF = {
  ...yp,
  cellBatchEditTextColor: "#f3d0b3"
}, pF = () => Dt({
  feature: "batchEditStyle",
  params: yp,
  css: hF
}), fF = /* @__PURE__ */ pF(), mF = (
  /*css*/
  ":where(.ag-button){background:none;border:none;color:inherit;cursor:pointer;font-family:inherit;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0;text-indent:inherit;text-shadow:inherit;text-transform:inherit;word-spacing:inherit;&:disabled{cursor:default}&:focus-visible{box-shadow:var(--ag-focus-shadow);outline:none}}.ag-standard-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--ag-button-background-color);border:var(--ag-button-border);border-radius:var(--ag-button-border-radius);color:var(--ag-button-text-color);cursor:pointer;font-weight:var(--ag-button-font-weight);padding:var(--ag-button-vertical-padding) var(--ag-button-horizontal-padding);&:hover{background-color:var(--ag-button-hover-background-color);border:var(--ag-button-hover-border);color:var(--ag-button-hover-text-color)}&:active{background-color:var(--ag-button-active-background-color);border:var(--ag-button-active-border);color:var(--ag-button-active-text-color)}&:disabled{background-color:var(--ag-button-disabled-background-color);border:var(--ag-button-disabled-border);color:var(--ag-button-disabled-text-color)}}"
), CF = {
  buttonTextColor: "inherit",
  buttonFontWeight: "normal",
  buttonBackgroundColor: "transparent",
  buttonBorder: !1,
  buttonBorderRadius: { ref: "borderRadius" },
  buttonHorizontalPadding: { calc: "spacing * 2" },
  buttonVerticalPadding: { ref: "spacing" },
  buttonHoverTextColor: { ref: "buttonTextColor" },
  buttonHoverBackgroundColor: { ref: "buttonBackgroundColor" },
  buttonHoverBorder: { ref: "buttonBorder" },
  buttonActiveTextColor: { ref: "buttonHoverTextColor" },
  buttonActiveBackgroundColor: { ref: "buttonHoverBackgroundColor" },
  buttonActiveBorder: { ref: "buttonHoverBorder" },
  buttonDisabledTextColor: { ref: "inputDisabledTextColor" },
  buttonDisabledBackgroundColor: { ref: "inputDisabledBackgroundColor" },
  buttonDisabledBorder: { ref: "inputDisabledBorder" }
}, vF = () => Dt({
  feature: "buttonStyle",
  params: {
    ...CF,
    buttonBackgroundColor: We,
    buttonBorder: !0,
    buttonHoverBackgroundColor: { ref: "rowHoverColor" },
    buttonActiveBorder: { color: Bt }
  },
  css: mF
}), wF = /* @__PURE__ */ vF(), bF = (
  /*css*/
  ".ag-column-drop-vertical-empty-message{align-items:center;border:dashed var(--ag-border-width);border-color:var(--ag-border-color);display:flex;inset:0;justify-content:center;margin:calc(var(--ag-spacing)*1.5) calc(var(--ag-spacing)*2);overflow:hidden;padding:calc(var(--ag-spacing)*2);position:absolute}"
), yF = () => Dt({
  feature: "columnDropStyle",
  css: bF
}), Sp = /* @__PURE__ */ yF(), SF = {
  warn: (...e) => {
    I(e[0], e[1]);
  },
  error: (...e) => {
    Z(e[0], e[1]);
  },
  preInitErr: (...e) => {
    qs(e[0], e[2], e[1]);
  }
}, RF = () => Qw(SF).withParams(uF).withPart(wF).withPart(Sp).withPart(fF), xF = (
  /*css*/
  '.ag-checkbox-input-wrapper,.ag-radio-button-input-wrapper{background-color:var(--ag-checkbox-unchecked-background-color);border:solid var(--ag-checkbox-border-width) var(--ag-checkbox-unchecked-border-color);flex:none;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);:where(input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-icon-size);margin:0;opacity:0;width:var(--ag-icon-size)}&:after{content:"";display:block;inset:0;-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;pointer-events:none;position:absolute}&:where(.ag-checked){background-color:var(--ag-checkbox-checked-background-color);border-color:var(--ag-checkbox-checked-border-color);&:after{background-color:var(--ag-checkbox-checked-shape-color)}}&:where(:focus-within,:active){box-shadow:var(--ag-focus-shadow)}&:where(.ag-disabled){filter:grayscale();opacity:.5}}.ag-checkbox-input-wrapper{border-radius:var(--ag-checkbox-border-radius);&:where(.ag-checked):after{-webkit-mask-image:var(--ag-checkbox-checked-shape-image);mask-image:var(--ag-checkbox-checked-shape-image)}&:where(.ag-indeterminate){background-color:var(--ag-checkbox-indeterminate-background-color);border-color:var(--ag-checkbox-indeterminate-border-color);&:after{background-color:var(--ag-checkbox-indeterminate-shape-color);-webkit-mask-image:var(--ag-checkbox-indeterminate-shape-image);mask-image:var(--ag-checkbox-indeterminate-shape-image)}}}.ag-cell-editing-error .ag-checkbox-input-wrapper:focus-within{box-shadow:var(--ag-focus-error-shadow)}.ag-radio-button-input-wrapper{border-radius:100%;&:where(.ag-checked):after{-webkit-mask-image:var(--ag-radio-checked-shape-image);mask-image:var(--ag-radio-checked-shape-image)}}'
), FF = () => Dt({
  feature: "checkboxStyle",
  params: {
    checkboxBorderWidth: 1,
    checkboxBorderRadius: {
      ref: "borderRadius"
    },
    checkboxUncheckedBackgroundColor: We,
    checkboxUncheckedBorderColor: Xe(0.3),
    checkboxCheckedBackgroundColor: Bt,
    checkboxCheckedBorderColor: { ref: "checkboxCheckedBackgroundColor" },
    checkboxCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="7" fill="none"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.75" d="M1 3.5 3.5 6l5-5"/></svg>'
    },
    checkboxCheckedShapeColor: We,
    checkboxIndeterminateBackgroundColor: Xe(0.3),
    checkboxIndeterminateBorderColor: { ref: "checkboxIndeterminateBackgroundColor" },
    checkboxIndeterminateShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="2" fill="none"><rect width="10" height="2" fill="#000" rx="1"/></svg>'
    },
    checkboxIndeterminateShapeColor: We,
    radioCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="6" height="6" fill="none"><circle cx="3" cy="3" r="3" fill="#000"/></svg>'
    }
  },
  css: xF
}), PF = /* @__PURE__ */ FF(), Rp = () => ({
  ...Jn,
  ...gF,
  backgroundColor: "hsl(217, 0%, 17%)",
  foregroundColor: "#FFF",
  chromeBackgroundColor: Xe(0.05),
  rowHoverColor: yt(0.15),
  selectedRowBackgroundColor: yt(0.2),
  menuBackgroundColor: Xe(0.1),
  browserColorScheme: "dark",
  popupShadow: "0 0px 20px #000A",
  cardShadow: "0 1px 4px 1px #000A",
  advancedFilterBuilderJoinPillColor: "#7a3a37",
  advancedFilterBuilderColumnPillColor: "#355f2d",
  advancedFilterBuilderOptionPillColor: "#5a3168",
  advancedFilterBuilderValuePillColor: "#374c86",
  filterPanelApplyButtonColor: is,
  findMatchColor: We,
  findActiveMatchColor: We,
  checkboxUncheckedBorderColor: Xe(0.4),
  toggleButtonOffBackgroundColor: Xe(0.4),
  rowBatchEditBackgroundColor: Xe(0.1)
}), EF = () => ({
  ...Rp(),
  backgroundColor: "#1f2836"
}), DF = () => Dt({
  feature: "colorScheme",
  params: Jn,
  modeParams: {
    light: Jn,
    dark: Rp(),
    "dark-blue": EF()
  }
}), TF = /* @__PURE__ */ DF(), xp = {
  aggregation: '<path d="M18 7V4H6l6 8-6 8h12v-3"/>',
  arrows: '<polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/>',
  asc: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  cancel: '<path d="m18 6-12 12"/><path d="m6 6 12 12"/>',
  chart: '<line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/>',
  "color-picker": '<path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/><path d="m5 2 5 5"/><path d="M2 13h15"/><path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z"/>',
  columns: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"/>',
  contracted: '<path d="m9 18 6-6-6-6"/>',
  copy: '<rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>',
  cross: '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>',
  csv: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  cut: '<circle cx="6" cy="6" r="3"/><path d="M8.12 8.12 12 12"/><path d="M20 4 8.12 15.88"/><circle cx="6" cy="18" r="3"/><path d="M14.8 14.8 20 20"/>',
  desc: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  down: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  excel: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  expanded: '<path d="m15 18-6-6 6-6"/>',
  "eye-slash": '<path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/>',
  eye: '<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>',
  filter: '<path d="M3 6h18"/><path d="M7 12h10"/><path d="M10 18h4"/>',
  first: '<path d="m17 18-6-6 6-6"/><path d="M7 6v12"/>',
  group: '<path d="M16 12H3"/><path d="M16 18H3"/><path d="M10 6H3"/><path d="M21 18V8a2 2 0 0 0-2-2h-5"/><path d="m16 8-2-2 2-2"/>',
  last: '<path d="m7 18 6-6-6-6"/><path d="M17 6v12"/>',
  left: '<path d="m12 19-7-7 7-7"/><path d="M19 12H5"/>',
  linked: '<path d="M9 17H7A5 5 0 0 1 7 7h2"/><path d="M15 7h2a5 5 0 1 1 0 10h-2"/><line x1="8" x2="16" y1="12" y2="12"/>',
  loading: '<line x1="12" x2="12" y1="2" y2="6"/><line x1="12" x2="12" y1="18" y2="22"/><line x1="4.93" x2="7.76" y1="4.93" y2="7.76"/><line x1="16.24" x2="19.07" y1="16.24" y2="19.07"/><line x1="2" x2="6" y1="12" y2="12"/><line x1="18" x2="22" y1="12" y2="12"/><line x1="4.93" x2="7.76" y1="19.07" y2="16.24"/><line x1="16.24" x2="19.07" y1="7.76" y2="4.93"/>',
  maximize: '<polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/>',
  menu: '<line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/>',
  "menu-alt": '<circle cx="12" cy="5" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="12" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="19" r="0.75" fill="#D9D9D9"/>',
  minimize: '<polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/>',
  minus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/>',
  next: '<path d="m9 18 6-6-6-6"/>',
  none: '<path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/>',
  "not-allowed": '<circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/>',
  paste: '<path d="M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z"/><path d="M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10"/><path d="m17 10 4 4-4 4"/>',
  pin: '<line x1="12" x2="12" y1="17" y2="22"/><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z"/>',
  pivot: '<path d="M15 3v18"/><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M21 9H3"/><path d="M21 15H3"/>',
  plus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/>',
  previous: '<path d="m15 18-6-6 6-6"/>',
  right: '<path d="M5 12h14"/><path d="m12 5 7 7-7 7"/>',
  save: '<path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/>',
  "small-left": '<path d="m15 18-6-6 6-6"/>',
  "small-right": '<path d="m9 18 6-6-6-6"/>',
  tick: '<path d="M20 6 9 17l-5-5"/>',
  "tree-closed": '<path d="m9 18 6-6-6-6"/>',
  "tree-indeterminate": '<path d="M5 12h14"/>',
  "tree-open": '<path d="m6 9 6 6 6-6"/>',
  unlinked: '<path d="M9 17H7A5 5 0 0 1 7 7"/><path d="M15 7h2a5 5 0 0 1 4 8"/><line x1="8" x2="12" y1="12" y2="12"/><line x1="2" x2="22" y1="2" y2="22"/>',
  up: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  grip: '<circle cx="5" cy="8" r="0.5"/><circle cx="12" cy="8" r="0.5"/><circle cx="19" cy="8" r="0.5"/><circle cx="5" cy="16" r="0.5"/><circle cx="12" cy="16" r="0.5"/><circle cx="19" cy="16" r="0.5"/><g stroke="none" fill="currentColor"><circle cx="5" cy="8" r="1"/><circle cx="12" cy="8" r="1"/><circle cx="19" cy="8" r="1"/><circle cx="5" cy="16" r="1"/><circle cx="12" cy="16" r="1"/><circle cx="19" cy="16" r="1"/></g>',
  settings: '<path d="M20 7h-9"/><path d="M14 17H5"/><circle cx="17" cy="17" r="3"/><circle cx="7" cy="7" r="3"/>'
}, Fp = {
  "column-arrow": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" viewBox="0 0 32 32"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 26C0 28.2092 1.79086 30 4 30H14C16.2091 30 18 28.2092 18 26V15H25.8786L24.4394 16.4393C23.8536 17.0251 23.8536 17.9749 24.4394 18.5607C25.0252 19.1464 25.9748 19.1464 26.5606 18.5607L30.5606 14.5607C31.1464 13.9749 31.1464 13.0251 30.5606 12.4393L26.5606 8.43934C25.9748 7.85356 25.0252 7.85356 24.4394 8.43934C23.8536 9.02512 23.8536 9.97488 24.4394 10.5607L25.8786 12H18V6C18 3.79086 16.2091 2 14 2H4C1.79086 2 0 3.79086 0 6V26ZM14 5H10.5V12H15V6C15 5.44772 14.5523 5 14 5ZM4 5H7.5V12H3V6C3 5.44772 3.44772 5 4 5ZM10.5 15H15V26C15 26.5522 14.5523 27 14 27H10.5V15ZM4 27H7.5V15H3V26C3 26.5522 3.44772 27 4 27Z" fill="currentColor"/></svg>',
  "small-down": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 10.667 16 21.334l8.667-10.667H7.334Z"/></svg>',
  "small-up": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 21.333 16 10.666l8.667 10.667H7.334Z"/></svg>',
  "pinned-top": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="M12.53 3.72A.75.75 0 0 1 12 5H4a.75.75 0 0 1 0-1.5h8a.75.75 0 0 1 .53.22ZM3.269 10.744a.75.75 0 0 1 .2-.524l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 1 1-1.06 1.06L8.75 8.56V14a.75.75 0 0 1-1.5 0V8.56l-2.72 2.72a.75.75 0 0 1-1.26-.536Z"/></svg>',
  "pinned-bottom": '<svg xmlns="http://www.w3.org/2000/svg" fill="none" class="ag-icon" viewBox="0 0 16 16"><path fill="currentColor" d="M3.47 12.28A.75.75 0 0 1 4 11h8a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.53-.22ZM12.731 5.256a.75.75 0 0 1-.2.524l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 1 1 1.06-1.06l2.72 2.72V2a.75.75 0 0 1 1.5 0v5.44l2.72-2.72a.75.75 0 0 1 1.26.536Z"/></svg>',
  "un-pin": '<svg xmlns="http://www.w3.org/2000/svg" fill="none" class="ag-icon" viewBox="0 0 16 16"><path fill="currentColor" d="M8 11a.75.75 0 0 0-.75.75v3.333a.75.75 0 1 0 1.5 0V11.75A.75.75 0 0 0 8 11Z"/><path fill="currentColor" d="M13.11 1.436a.75.75 0 0 0-1.22-.872l-10 14a.75.75 0 1 0 1.22.872L5.207 12.5h7.376a.75.75 0 0 0 .75-.75v-1.174a2.08 2.08 0 0 0-1.153-1.863l-1.185-.599-.005-.002a.58.58 0 0 1-.323-.522V5.165a2.083 2.083 0 0 0 1.854-2.904l.589-.825Zm-3.943 5.52v.634a2.08 2.08 0 0 0 1.153 1.863l1.185.6.005.002a.58.58 0 0 1 .323.522V11H6.28l2.887-4.044ZM9.277 1H5.25a2.084 2.084 0 0 0-.083 4.165v1.676l1.5-2.132v-.292a.75.75 0 0 0-.75-.75H5.25a.584.584 0 0 1 0-1.167h2.972L9.277 1Z"/></svg>',
  "chevron-down": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 6L8 10L4 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  "chevron-up": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 10L8 6L12 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  "chevron-left": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  "chevron-right": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 12L10 8L6 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  "filter-add": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.12126 7.75L10.8517 7.75" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M6.65934 11.748L9.32778 11.748" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M12.2943 1.04872V6.19184M14.9886 3.74341H9.68478" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M8.25488 3C8.04799 3.18323 7.91706 3.45099 7.91699 3.74902C7.91713 4.04868 8.04988 4.31681 8.25879 4.5H2C1.58579 4.5 1.25 4.16421 1.25 3.75C1.25 3.33579 1.58579 3 2 3H8.25488Z" fill="currentColor"/></svg>',
  edit: '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 10.6262V12.5012H5.375L10.905 6.97122L9.03 5.09622L3.5 10.6262ZM12.355 5.52122C12.4014 5.47497 12.4381 5.42002 12.4632 5.35953C12.4883 5.29905 12.5012 5.23421 12.5012 5.16872C12.5012 5.10324 12.4883 5.0384 12.4632 4.97791C12.4381 4.91742 12.4014 4.86248 12.355 4.81622L11.185 3.64622C11.1387 3.59987 11.0838 3.5631 11.0233 3.53801C10.9628 3.51291 10.898 3.5 10.8325 3.5C10.767 3.5 10.7022 3.51291 10.6417 3.53801C10.5812 3.5631 10.5263 3.59987 10.48 3.64622L9.565 4.56122L11.44 6.43622L12.355 5.52122Z" fill="currentColor"/></svg>'
}, MF = (e = {}) => {
  let t = "";
  for (const i of [...Object.keys(xp), ...Object.keys(Fp)]) {
    const s = AF(i, e.strokeWidth);
    t += `.ag-icon-${i}::before { mask-image: url('data:image/svg+xml,${encodeURIComponent(s)}'); }
`;
  }
  return t;
}, AF = (e, t = 1.5) => {
  const i = Fp[e];
  if (i)
    return i;
  const s = xp[e];
  if (!s)
    throw new Error(`Missing icon data for ${e}`);
  return `<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="black" stroke-width="${t}" viewBox="0 0 24 24"><style>* { vector-effect: non-scaling-stroke; }</style>` + s + "</svg>";
}, IF = (e = {}) => Dt({
  feature: "iconSet",
  css: () => MF(e)
}), kF = /* @__PURE__ */ IF(), LF = (
  /*css*/
  ':where(.ag-input-field-input[type=number]:not(.ag-number-field-input-stepper)){-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield;&::-webkit-inner-spin-button,&::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}}.ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);color:var(--ag-input-text-color);font-family:inherit;font-size:inherit;line-height:inherit;margin:0;min-height:var(--ag-input-height);padding:0;&:where(:disabled){background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}&:where(:focus){background-color:var(--ag-input-focus-background-color);border:var(--ag-input-focus-border);box-shadow:var(--ag-input-focus-shadow);color:var(--ag-input-focus-text-color);outline:none}&:where(:invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&::-moz-placeholder{color:var(--ag-input-placeholder-text-color)}&::placeholder{color:var(--ag-input-placeholder-text-color)}}:where(.ag-ltr) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-left:var(--ag-input-padding-start)}:where(.ag-rtl) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-right:var(--ag-input-padding-start)}:where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{background-color:currentcolor;color:var(--ag-input-icon-color);content:"";display:block;height:12px;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;opacity:.5;position:absolute;width:12px}}:where(.ag-ltr) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{margin-left:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-left:calc(var(--ag-spacing)*1.5 + 12px)}}:where(.ag-rtl) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{margin-right:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-right:calc(var(--ag-spacing)*1.5 + 12px)}}'
), OF = (
  /*css*/
  ".ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){&:focus{box-shadow:var(--ag-focus-shadow);&:where(.invalid),&:where(:invalid){box-shadow:var(--ag-focus-error-shadow)}}}"
), _F = {
  inputBackgroundColor: "transparent",
  inputBorder: !1,
  inputBorderRadius: 0,
  inputTextColor: {
    ref: "textColor"
  },
  inputPlaceholderTextColor: {
    ref: "inputTextColor",
    mix: 0.5
  },
  inputPaddingStart: 0,
  inputHeight: {
    calc: "max(iconSize, fontSize) + spacing * 2"
  },
  inputFocusBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputFocusBorder: {
    ref: "inputBorder"
  },
  inputFocusShadow: "none",
  inputFocusTextColor: {
    ref: "inputTextColor"
  },
  inputDisabledBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputDisabledBorder: {
    ref: "inputBorder"
  },
  inputDisabledTextColor: {
    ref: "inputTextColor"
  },
  inputInvalidBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputInvalidBorder: {
    ref: "inputBorder"
  },
  inputInvalidTextColor: {
    ref: "inputTextColor"
  },
  inputIconColor: {
    ref: "inputTextColor"
  },
  pickerButtonBorder: !1,
  pickerButtonFocusBorder: { ref: "inputFocusBorder" },
  pickerButtonBackgroundColor: { ref: "backgroundColor" },
  pickerButtonFocusBackgroundColor: { ref: "backgroundColor" },
  pickerListBorder: !1,
  pickerListBackgroundColor: { ref: "backgroundColor" },
  colorPickerThumbSize: 18,
  colorPickerTrackSize: 12,
  colorPickerThumbBorderWidth: 3,
  colorPickerTrackBorderRadius: 12,
  colorPickerColorBorderRadius: 4
}, HF = () => Dt({
  feature: "inputStyle",
  params: {
    ..._F,
    inputBackgroundColor: We,
    inputBorder: !0,
    inputBorderRadius: {
      ref: "borderRadius"
    },
    inputPaddingStart: {
      ref: "spacing"
    },
    inputFocusBorder: {
      color: Bt
    },
    inputFocusShadow: {
      ref: "focusShadow"
    },
    inputDisabledBackgroundColor: Xe(0.06),
    inputDisabledTextColor: {
      ref: "textColor",
      mix: 0.5
    },
    inputInvalidBorder: {
      color: { ref: "invalidColor" }
    },
    pickerButtonBorder: !0,
    pickerListBorder: !0
  },
  css: () => LF + OF
}), BF = /* @__PURE__ */ HF(), GF = (
  /*css*/
  '.ag-tabs-header{background-color:var(--ag-tab-bar-background-color);border-bottom:var(--ag-tab-bar-border);display:flex;flex:1;gap:var(--ag-tab-spacing);padding:var(--ag-tab-bar-top-padding) var(--ag-tab-bar-horizontal-padding) 0}.ag-tabs-header-wrapper{display:flex}.ag-tabs-close-button-wrapper{align-items:center;border:0;display:flex;padding:var(--ag-spacing)}:where(.ag-ltr) .ag-tabs-close-button-wrapper{border-right:solid var(--ag-border-width) var(--ag-border-color)}:where(.ag-rtl) .ag-tabs-close-button-wrapper{border-left:solid var(--ag-border-width) var(--ag-border-color)}.ag-tabs-close-button{background-color:unset;border:0;cursor:pointer;padding:0}.ag-tab{align-items:center;background-color:var(--ag-tab-background-color);border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;color:var(--ag-tab-text-color);cursor:pointer;display:flex;flex:1;justify-content:center;padding:var(--ag-tab-top-padding) var(--ag-tab-horizontal-padding) var(--ag-tab-bottom-padding);position:relative;&:hover{background-color:var(--ag-tab-hover-background-color);color:var(--ag-tab-hover-text-color)}&.ag-tab-selected{background-color:var(--ag-tab-selected-background-color);color:var(--ag-tab-selected-text-color)}&:after{background-color:var(--ag-tab-selected-underline-color);bottom:0;content:"";display:block;height:var(--ag-tab-selected-underline-width);left:0;opacity:0;position:absolute;right:0;transition:opacity var(--ag-tab-selected-underline-transition-duration)}&.ag-tab-selected:after{opacity:1}}:where(.ag-ltr) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-left-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-right-color:var(--ag-tab-selected-border-color)}}}:where(.ag-rtl) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-right-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-left-color:var(--ag-tab-selected-border-color)}}}'
), VF = {
  tabBarBackgroundColor: "transparent",
  tabBarHorizontalPadding: 0,
  tabBarTopPadding: 0,
  tabBackgroundColor: "transparent",
  tabTextColor: {
    ref: "textColor"
  },
  tabHorizontalPadding: {
    ref: "spacing"
  },
  tabTopPadding: {
    ref: "spacing"
  },
  tabBottomPadding: {
    ref: "spacing"
  },
  tabSpacing: "0",
  tabHoverBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabHoverTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabSelectedTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBorderWidth: { ref: "borderWidth" },
  tabSelectedBorderColor: "transparent",
  tabSelectedUnderlineColor: "transparent",
  tabSelectedUnderlineWidth: 0,
  tabSelectedUnderlineTransitionDuration: 0,
  tabBarBorder: !1
}, NF = () => Dt({
  feature: "tabStyle",
  params: {
    ...VF,
    tabBarBorder: !0,
    tabBarBackgroundColor: Ye(0.05),
    tabTextColor: {
      ref: "textColor",
      mix: 0.7
    },
    tabSelectedTextColor: {
      ref: "textColor"
    },
    tabHoverTextColor: {
      ref: "textColor"
    },
    tabSelectedBorderColor: {
      ref: "borderColor"
    },
    tabSelectedBackgroundColor: We
  },
  css: GF
}), WF = /* @__PURE__ */ NF(), zF = () => RF().withPart(PF).withPart(TF).withPart(kF).withPart(WF).withPart(BF).withPart(Sp).withParams({
  fontFamily: [
    { googleFont: "IBM Plex Sans" },
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu"
  ]
}), UF = /* @__PURE__ */ zF(), $F = {
  cssName: "--ag-cell-horizontal-padding",
  changeKey: "cellHorizontalPaddingChanged",
  defaultValue: 16
}, KF = {
  cssName: "--ag-indentation-level",
  changeKey: "indentationLevelChanged",
  defaultValue: 0,
  noWarn: !0,
  cacheDefault: !0
}, jF = {
  cssName: "--ag-row-group-indent-size",
  changeKey: "rowGroupIndentSizeChanged",
  defaultValue: 0
}, Hc = {
  cssName: "--ag-row-height",
  changeKey: "rowHeightChanged",
  defaultValue: 42
}, Bc = {
  cssName: "--ag-header-height",
  changeKey: "headerHeightChanged",
  defaultValue: 48
}, Gc = {
  cssName: "--ag-list-item-height",
  changeKey: "listItemHeightChanged",
  defaultValue: 24
}, ca = {
  cssName: "--ag-row-border",
  changeKey: "rowBorderWidthChanged",
  defaultValue: 1,
  border: !0
}, Vc = {
  cssName: "--ag-pinned-row-border",
  changeKey: "pinnedRowBorderWidthChanged",
  defaultValue: 1,
  border: !0
};
function qF(e, t) {
  t.sort((i, s) => i.moduleName.localeCompare(s.moduleName)).forEach((i) => {
    const s = i.css;
    s && e.set(`module-${i.moduleName}`, s);
  });
}
var YF = class extends nb {
  constructor() {
    super(...arguments), this.sizeEls = /* @__PURE__ */ new Map(), this.lastKnownValues = /* @__PURE__ */ new Map(), this.sizesMeasured = !1;
  }
  initVariables() {
    this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable()), this.getSizeEl(Hc), this.getSizeEl(Bc), this.getSizeEl(Gc), this.getSizeEl(ca), this.getSizeEl(Vc), this.refreshRowBorderWidthVariable();
  }
  getPinnedRowBorderWidth() {
    return this.getCSSVariablePixelValue(Vc);
  }
  getRowBorderWidth() {
    return this.getCSSVariablePixelValue(ca);
  }
  getDefaultRowHeight() {
    return this.getCSSVariablePixelValue(Hc);
  }
  getDefaultHeaderHeight() {
    return this.getCSSVariablePixelValue(Bc);
  }
  getDefaultCellHorizontalPadding() {
    return this.getCSSVariablePixelValue($F);
  }
  getCellPaddingLeft() {
    const e = this.getDefaultCellHorizontalPadding(), t = this.getCSSVariablePixelValue(KF), i = this.getCSSVariablePixelValue(jF);
    return e - 1 + i * t;
  }
  getCellPadding() {
    const e = this.getDefaultCellHorizontalPadding() - 1;
    return this.getCellPaddingLeft() + e;
  }
  getDefaultColumnMinWidth() {
    return Math.min(36, this.getDefaultRowHeight());
  }
  getDefaultListItemHeight() {
    return this.getCSSVariablePixelValue(Gc);
  }
  refreshRowHeightVariable() {
    const { eRootDiv: e } = this, t = e.style.getPropertyValue("--ag-line-height").trim(), i = this.gos.get("rowHeight");
    if (i == null || isNaN(i) || !isFinite(i))
      return t !== null && e.style.setProperty("--ag-line-height", null), -1;
    const s = `${i}px`;
    return t != s ? (e.style.setProperty("--ag-line-height", s), i) : t != "" ? parseFloat(t) : -1;
  }
  getCSSVariablePixelValue(e) {
    const t = this.lastKnownValues.get(e);
    if (t != null)
      return t;
    const i = this.measureSizeEl(e);
    return i === "detached" || i === "no-styles" ? (e.cacheDefault && this.lastKnownValues.set(e, e.defaultValue), e.defaultValue) : (this.lastKnownValues.set(e, i), i);
  }
  measureSizeEl(e) {
    const t = this.getSizeEl(e);
    if (t.offsetParent == null)
      return "detached";
    const i = t.offsetWidth;
    return i === ua ? "no-styles" : (this.sizesMeasured = !0, i);
  }
  getMeasurementContainer() {
    let e = this.eMeasurementContainer;
    return e || (e = this.eMeasurementContainer = ye({ tag: "div", cls: "ag-measurement-container" }), this.eRootDiv.appendChild(e)), e;
  }
  getSizeEl(e) {
    let t = this.sizeEls.get(e);
    if (t)
      return t;
    const i = this.getMeasurementContainer();
    t = ye({ tag: "div" });
    const { border: s, noWarn: o } = e;
    s ? (t.className = "ag-measurement-element-border", t.style.setProperty(
      "--ag-internal-measurement-border",
      `var(${e.cssName}, solid ${ua}px)`
    )) : t.style.width = `var(${e.cssName}, ${ua}px)`, i.appendChild(t), this.sizeEls.set(e, t);
    let n = this.measureSizeEl(e);
    n === "no-styles" && !o && I(9, { variable: e });
    const r = di(this.beans, t, () => {
      const a = this.measureSizeEl(e);
      a === "detached" || a === "no-styles" || (this.lastKnownValues.set(e, a), a !== n && (n = a, this.fireStylesChangedEvent(e.changeKey)));
    });
    return this.addDestroyFunc(() => r()), t;
  }
  fireStylesChangedEvent(e) {
    e === "rowBorderWidthChanged" && this.refreshRowBorderWidthVariable(), this.eventSvc.dispatchEvent({
      type: "gridStylesChanged",
      [e]: !0
    });
  }
  refreshRowBorderWidthVariable() {
    const e = this.getCSSVariablePixelValue(ca);
    this.eRootDiv.style.setProperty("--ag-internal-row-border-width", `${e}px`);
  }
  postProcessThemeChange(e, t) {
    e && getComputedStyle(this.getMeasurementContainer()).getPropertyValue("--ag-legacy-styles-loaded") && Z(t ? 106 : 239);
  }
  getAdditionalCss() {
    const e = /* @__PURE__ */ new Map();
    return e.set("core", [cF]), qF(e, Array.from(aF())), e;
  }
  getDefaultTheme() {
    return UF;
  }
  themeError(e) {
    Z(240, { theme: e });
  }
}, ua = 15538, QF = class extends ab {
  postConstruct() {
    const { globalListener: e, globalSyncListener: t } = this.beans;
    e && this.addGlobalListener(e, !0), t && this.addGlobalListener(t, !1);
  }
};
function Pp(e, t, i) {
  const s = e.visibleCols.headerGroupRowCount;
  if (i >= s)
    return {
      column: t,
      headerRowIndex: i
    };
  let o = t.getParent();
  for (; o && o.getProvidedColumnGroup().getLevel() > i; )
    o = o.getParent();
  const n = t.isSpanHeaderHeight();
  return !o || n && o.isPadding() ? {
    column: t,
    headerRowIndex: s
  } : {
    column: o,
    headerRowIndex: o.getProvidedColumnGroup().getLevel()
  };
}
var XF = class extends E {
  constructor() {
    super(...arguments), this.beanName = "headerNavigation", this.currentHeaderRowWithoutSpan = -1;
  }
  postConstruct() {
    const e = this.beans;
    e.ctrlsSvc.whenReady(this, (i) => {
      this.gridBodyCon = i.gridBodyCtrl;
    });
    const t = Ee(e);
    this.addManagedElementListeners(t, {
      mousedown: () => {
        this.currentHeaderRowWithoutSpan = -1;
      }
    });
  }
  getHeaderPositionForColumn(e, t) {
    let i;
    const { colModel: s, colGroupSvc: o, ctrlsSvc: n } = this.beans;
    if (typeof e == "string" ? (i = s.getCol(e), i || (i = (o == null ? void 0 : o.getColumnGroup(e)) ?? null)) : i = e, !i)
      return null;
    const r = n.getHeaderRowContainerCtrl(), a = r == null ? void 0 : r.getAllCtrls(), l = se(a || []).type === "filter", d = xt(this.beans) - 1;
    let c = -1, u = i;
    for (; u; )
      c++, u = u.getParent();
    let h = c;
    return t && l && h === d - 1 && h++, h === -1 ? null : {
      headerRowIndex: h,
      column: i
    };
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(e, t) {
    const { focusSvc: i, visibleCols: s } = this.beans, { focusedHeader: o } = i;
    if (!o)
      return !1;
    const { headerRowIndex: n } = o, r = o.column, a = xt(this.beans), l = this.getHeaderRowType(n), d = s.headerGroupRowCount;
    let {
      headerRowIndex: c,
      column: u,
      headerRowIndexWithoutSpan: h
    } = e === "UP" ? ZF(l, r, n) : JF(r, n, d), g = !1;
    return c < 0 && (c = 0, u = r, g = !0), c >= a ? (c = -1, this.currentHeaderRowWithoutSpan = -1) : h !== void 0 && (this.currentHeaderRowWithoutSpan = h), !g && !u ? !1 : i.focusHeaderPosition({
      headerPosition: { headerRowIndex: c, column: u },
      allowUserOverride: !0,
      event: t
    });
  }
  /*
   * This method navigates grid header horizontally
   * @returns {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(e, t = !1, i) {
    const { focusSvc: s, gos: o } = this.beans, n = { ...s.focusedHeader };
    let r, a;
    this.currentHeaderRowWithoutSpan !== -1 ? n.headerRowIndex = this.currentHeaderRowWithoutSpan : this.currentHeaderRowWithoutSpan = n.headerRowIndex, e === "LEFT" !== o.get("enableRtl") ? (a = "Before", r = this.findHeader(n, a)) : (a = "After", r = this.findHeader(n, a));
    const l = o.getCallback("tabToNextHeader");
    if (t && l) {
      const d = s.focusHeaderPositionFromUserFunc({
        userFunc: l,
        headerPosition: r,
        direction: a
      });
      if (d) {
        const { headerRowIndex: c } = s.focusedHeader || {};
        c != null && c != n.headerRowIndex && (this.currentHeaderRowWithoutSpan = c);
      }
      return d;
    }
    return r || !t ? s.focusHeaderPosition({
      headerPosition: r,
      direction: a,
      fromTab: t,
      allowUserOverride: !0,
      event: i
    }) : this.focusNextHeaderRow(n, a, i);
  }
  focusNextHeaderRow(e, t, i) {
    const s = this.beans, o = e.headerRowIndex;
    let n = null, r;
    const a = xt(s), l = this.beans.visibleCols.allCols;
    if (t === "Before") {
      if (o <= 0)
        return !1;
      n = se(l), r = o - 1, this.currentHeaderRowWithoutSpan -= 1;
    } else
      n = l[0], r = o + 1, this.currentHeaderRowWithoutSpan < a ? this.currentHeaderRowWithoutSpan += 1 : this.currentHeaderRowWithoutSpan = -1;
    let { column: d, headerRowIndex: c } = Pp(this.beans, n, r);
    return c >= a && (c = -1), s.focusSvc.focusHeaderPosition({
      headerPosition: { column: d, headerRowIndex: c },
      direction: t,
      fromTab: !0,
      allowUserOverride: !0,
      event: i
    });
  }
  scrollToColumn(e, t = "After") {
    if (e.getPinned())
      return;
    let i;
    if (be(e)) {
      const s = e.getDisplayedLeafColumns();
      i = t === "Before" ? se(s) : s[0];
    } else
      i = e;
    this.gridBodyCon.scrollFeature.ensureColumnVisible(i);
  }
  findHeader(e, t) {
    const { colGroupSvc: i, visibleCols: s } = this.beans;
    let o = e.column;
    if (o instanceof Eo) {
      const l = o.getDisplayedLeafColumns();
      o = t === "Before" ? l[0] : l[l.length - 1];
    }
    const n = t === "Before" ? s.getColBefore(o) : s.getColAfter(o);
    if (!n)
      return;
    const r = s.headerGroupRowCount;
    if (e.headerRowIndex >= r)
      return {
        headerRowIndex: e.headerRowIndex,
        column: n
      };
    const a = i == null ? void 0 : i.getColGroupAtLevel(n, e.headerRowIndex);
    return a ? a.isPadding() && n.isSpanHeaderHeight() ? {
      headerRowIndex: s.headerGroupRowCount,
      column: n
    } : {
      headerRowIndex: e.headerRowIndex,
      column: a ?? n
    } : {
      headerRowIndex: n instanceof Wi && n.isSpanHeaderHeight() ? s.headerGroupRowCount : e.headerRowIndex,
      column: n
    };
  }
  getHeaderRowType(e) {
    const t = this.beans.ctrlsSvc.getHeaderRowContainerCtrl();
    if (t)
      return t.getRowType(e);
  }
};
function ZF(e, t, i) {
  const s = i - 1;
  if (e !== "filter") {
    const o = t instanceof Wi && t.isSpanHeaderHeight();
    let n = t.getParent();
    for (; n && // skip if row isn't visible or col is padding and spanned
    (n.getProvidedColumnGroup().getLevel() > s || o && n.isPadding()); )
      n = n.getParent();
    if (n)
      return o ? {
        column: n,
        headerRowIndex: n.getProvidedColumnGroup().getLevel(),
        headerRowIndexWithoutSpan: s
      } : {
        column: n,
        headerRowIndex: s,
        headerRowIndexWithoutSpan: s
      };
  }
  return {
    column: t,
    headerRowIndex: s,
    headerRowIndexWithoutSpan: s
  };
}
function JF(e, t, i) {
  const s = t + 1, o = {
    column: e,
    headerRowIndex: s,
    headerRowIndexWithoutSpan: s
  };
  if (e instanceof Eo) {
    if (s >= i)
      return {
        column: e.getDisplayedLeafColumns()[0],
        headerRowIndex: i,
        headerRowIndexWithoutSpan: s
      };
    let r = e.getDisplayedChildren()[0];
    if (r instanceof Eo && r.isPadding()) {
      const l = r.getDisplayedLeafColumns()[0];
      l.isSpanHeaderHeight() && (r = l);
    }
    o.column = r, r instanceof Wi && r.isSpanHeaderHeight() && (o.headerRowIndex = i, o.headerRowIndexWithoutSpan = s);
  }
  return o;
}
var e0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "focusSvc", this.focusFallbackTimeout = null, this.needsFocusRestored = !1;
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.visibleCols = e.visibleCols, this.rowRenderer = e.rowRenderer, this.navigation = e.navigation, this.filterManager = e.filterManager, this.overlays = e.overlays;
  }
  postConstruct() {
    const e = this.clearFocusedCell.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: e,
      newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
      columnGroupOpened: e,
      columnRowGroupChanged: e
    }), this.addDestroyFunc(hw(this.beans));
  }
  attemptToRecoverFocus() {
    this.needsFocusRestored = !0, this.focusFallbackTimeout != null && clearTimeout(this.focusFallbackTimeout), this.focusFallbackTimeout = window.setTimeout(this.setFocusRecovered.bind(this), 100);
  }
  setFocusRecovered() {
    this.needsFocusRestored = !1, this.focusFallbackTimeout != null && (clearTimeout(this.focusFallbackTimeout), this.focusFallbackTimeout = null);
  }
  /**
   * Specifies whether to take focus, as grid either already has focus, or lost it due
   * to a destroyed cell
   * @returns true if the grid should re-take focus, otherwise false
   */
  shouldTakeFocus() {
    return this.gos.get("suppressFocusAfterRefresh") ? (this.setFocusRecovered(), !1) : this.needsFocusRestored ? (this.setFocusRecovered(), !0) : this.doesRowOrCellHaveBrowserFocus();
  }
  onColumnEverythingChanged() {
    if (!this.focusedCell)
      return;
    const e = this.focusedCell.column, t = this.colModel.getCol(e.getId());
    e !== t && this.clearFocusedCell();
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    const { gos: e, focusedCell: t } = this;
    return e.get("suppressFocusAfterRefresh") || e.get("suppressCellFocus") || !t || !this.doesRowOrCellHaveBrowserFocus() ? null : t;
  }
  getFocusHeaderToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeader || !this.isDomDataPresentInHierarchy(he(this.beans), ip) ? null : this.focusedHeader;
  }
  /**
   * Check for both cells and rows, as a row might be destroyed and the dom data removed before the cell if the
   * row is animating out.
   */
  doesRowOrCellHaveBrowserFocus() {
    const e = he(this.beans);
    return this.isDomDataPresentInHierarchy(e, er) ? !0 : this.isDomDataPresentInHierarchy(e, tr);
  }
  isDomDataPresentInHierarchy(e, t) {
    let i = e;
    for (; i; ) {
      if (jh(this.gos, i, t))
        return !0;
      i = i.parentNode;
    }
    return !1;
  }
  getFocusedCell() {
    return this.focusedCell;
  }
  getFocusEventParams(e) {
    const { rowIndex: t, rowPinned: i, column: s } = e, o = {
      rowIndex: t,
      rowPinned: i,
      column: s,
      isFullWidthCell: !1
    }, n = this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: i });
    return n && (o.isFullWidthCell = n.isFullWidth()), o;
  }
  clearFocusedCell() {
    if (this.focusedCell == null)
      return;
    const e = this.getFocusEventParams(this.focusedCell);
    this.focusedCell = null, this.eventSvc.dispatchEvent({
      type: "cellFocusCleared",
      ...e
    });
  }
  setFocusedCell(e) {
    this.setFocusRecovered();
    const {
      column: t,
      rowIndex: i,
      rowPinned: s,
      forceBrowserFocus: o = !1,
      preventScrollOnBrowserFocus: n = !1,
      sourceEvent: r
    } = e, a = this.colModel.getCol(t);
    if (!a) {
      this.focusedCell = null;
      return;
    }
    this.focusedCell = {
      rowIndex: i,
      rowPinned: Vt(s),
      column: a
    };
    const l = this.getFocusEventParams(this.focusedCell);
    this.eventSvc.dispatchEvent({
      type: "cellFocused",
      ...l,
      ...this.previousCellFocusParams && { previousParams: this.previousCellFocusParams },
      forceBrowserFocus: o,
      preventScrollOnBrowserFocus: n,
      sourceEvent: r
    }), this.previousCellFocusParams = l;
  }
  isCellFocused(e) {
    return this.focusedCell == null ? !1 : cp(e, this.focusedCell);
  }
  isHeaderWrapperFocused(e) {
    if (this.focusedHeader == null)
      return !1;
    const {
      column: t,
      rowCtrl: { rowIndex: i, pinned: s }
    } = e, { column: o, headerRowIndex: n } = this.focusedHeader;
    return t === o && i === n && s == o.getPinned();
  }
  focusHeaderPosition(e) {
    var l;
    if (this.setFocusRecovered(), Ai(this.beans))
      return !1;
    const { direction: t, fromTab: i, allowUserOverride: s, event: o, fromCell: n, rowWithoutSpanValue: r } = e;
    let { headerPosition: a } = e;
    if (n && ((l = this.filterManager) != null && l.isAdvFilterHeaderActive()))
      return this.focusAdvancedFilter(a);
    if (s) {
      const d = this.focusedHeader, c = xt(this.beans);
      if (i) {
        const u = this.gos.getCallback("tabToNextHeader");
        u && (a = this.getHeaderPositionFromUserFunc({
          userFunc: u,
          direction: t,
          currentPosition: d,
          headerPosition: a,
          headerRowCount: c
        }));
      } else {
        const u = this.gos.getCallback("navigateToNextHeader");
        if (u && o) {
          const h = {
            key: o.key,
            previousHeaderPosition: d,
            nextHeaderPosition: a,
            headerRowCount: c,
            event: o
          };
          a = u(h);
        }
      }
    }
    return a ? this.focusProvidedHeaderPosition({
      headerPosition: a,
      direction: t,
      event: o,
      fromCell: n,
      rowWithoutSpanValue: r
    }) : !1;
  }
  focusHeaderPositionFromUserFunc(e) {
    if (Ai(this.beans))
      return !1;
    const { userFunc: t, headerPosition: i, direction: s, event: o } = e, n = this.focusedHeader, r = xt(this.beans), a = this.getHeaderPositionFromUserFunc({
      userFunc: t,
      direction: s,
      currentPosition: n,
      headerPosition: i,
      headerRowCount: r
    });
    return !!a && this.focusProvidedHeaderPosition({
      headerPosition: a,
      direction: s,
      event: o
    });
  }
  getHeaderPositionFromUserFunc(e) {
    const { userFunc: t, direction: i, currentPosition: s, headerPosition: o, headerRowCount: n } = e, a = t({
      backwards: i === "Before",
      previousHeaderPosition: s,
      nextHeaderPosition: o,
      headerRowCount: n
    });
    return a === !0 ? s : a === !1 ? null : a;
  }
  focusProvidedHeaderPosition(e) {
    const { headerPosition: t, direction: i, fromCell: s, rowWithoutSpanValue: o, event: n } = e, { column: r, headerRowIndex: a } = t, { filterManager: l, ctrlsSvc: d, headerNavigation: c } = this.beans;
    if (a === -1)
      return l != null && l.isAdvFilterHeaderActive() ? this.focusAdvancedFilter(t) : this.focusGridView({ column: r, event: n });
    c == null || c.scrollToColumn(r, i);
    const u = d.getHeaderRowContainerCtrl(r.getPinned()), h = (u == null ? void 0 : u.focusHeader(t.headerRowIndex, r, n)) || !1;
    return c && h && (o != null || s) && (c.currentHeaderRowWithoutSpan = o ?? -1), h;
  }
  focusFirstHeader() {
    var i;
    if ((i = this.overlays) != null && i.isExclusive() && this.focusOverlay())
      return !0;
    const e = this.visibleCols.allCols[0];
    if (!e)
      return !1;
    const t = Pp(this.beans, e, 0);
    return this.focusHeaderPosition({
      headerPosition: t,
      rowWithoutSpanValue: 0
    });
  }
  focusLastHeader(e) {
    var s;
    if ((s = this.overlays) != null && s.isExclusive() && this.focusOverlay(!0))
      return !0;
    const t = xt(this.beans) - 1, i = se(this.visibleCols.allCols);
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex: t, column: i },
      rowWithoutSpanValue: -1,
      event: e
    });
  }
  focusPreviousFromFirstCell(e) {
    var t;
    return (t = this.filterManager) != null && t.isAdvFilterHeaderActive() ? this.focusAdvancedFilter(null) : this.focusLastHeader(e);
  }
  isAnyCellFocused() {
    return !!this.focusedCell;
  }
  isRowFocused(e, t) {
    return this.focusedCell == null ? !1 : this.focusedCell.rowIndex === e && this.focusedCell.rowPinned === Vt(t);
  }
  focusOverlay(e) {
    var i, s;
    const t = ((i = this.overlays) == null ? void 0 : i.isVisible()) && ((s = this.overlays.eWrapper) == null ? void 0 : s.getGui());
    return !!t && _i(t, e);
  }
  focusGridView(e) {
    var n, r, a, l, d, c;
    const { backwards: t = !1, canFocusOverlay: i = !0, event: s } = e;
    if ((n = this.overlays) != null && n.isExclusive())
      return i && this.focusOverlay(t);
    if (Sr(this.beans))
      return t && !Ai(this.beans) ? this.focusLastHeader() : i && this.focusOverlay(t) ? !0 : t ? !1 : Ss(this.beans, t);
    const o = t ? lR(this.beans) : aR(this.beans);
    if (o) {
      const u = e.column ?? ((r = this.focusedHeader) == null ? void 0 : r.column), { rowIndex: h, rowPinned: g } = o, p = Ut(this.beans, o);
      if (!u || !p || h == null)
        return !1;
      if (u.isSuppressNavigable(p)) {
        const f = this.gos.get("enableRtl");
        let m;
        return !s || s.key === P.TAB ? m = f ? P.LEFT : P.RIGHT : m = s.key, (a = this.beans.navigation) == null || a.navigateToNextCell(
          null,
          m,
          { rowIndex: h, column: u, rowPinned: g || null },
          !0
        ), !0;
      }
      if ((l = this.navigation) == null || l.ensureCellVisible({ rowIndex: h, column: u, rowPinned: g }), t) {
        const f = this.rowRenderer.getRowByPosition(o);
        if (f != null && f.isFullWidth() && ((d = this.navigation) != null && d.tryToFocusFullWidthRow(o, t)))
          return !0;
      }
      return this.setFocusedCell({
        rowIndex: h,
        column: u,
        rowPinned: Vt(g),
        forceBrowserFocus: !0
      }), (c = this.beans.rangeSvc) == null || c.setRangeToCell({ rowIndex: h, rowPinned: g, column: u }), !0;
    }
    return !!(i && this.focusOverlay(t) || t && this.focusLastHeader());
  }
  focusAdvancedFilter(e) {
    var t;
    return this.advFilterFocusColumn = e == null ? void 0 : e.column, ((t = this.beans.advancedFilter) == null ? void 0 : t.getCtrl().focusHeaderComp()) ?? !1;
  }
  focusNextFromAdvancedFilter(e, t) {
    var s;
    const i = (t ? void 0 : this.advFilterFocusColumn) ?? ((s = this.visibleCols.allCols) == null ? void 0 : s[0]);
    return e ? this.focusHeaderPosition({
      headerPosition: {
        column: i,
        headerRowIndex: xt(this.beans) - 1
      }
    }) : this.focusGridView({ column: i });
  }
  clearAdvancedFilterColumn() {
    this.advFilterFocusColumn = void 0;
  }
}, t0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "scrollVisibleSvc";
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.colAnimation = e.colAnimation;
  }
  postConstruct() {
    this.horizontalScrollShowing = this.gos.get("alwaysShowHorizontalScroll") === !0, this.verticalScrollShowing = this.gos.get("alwaysShowVerticalScroll") === !0, this.getScrollbarWidth(), this.addManagedEventListeners({
      displayedColumnsChanged: this.updateScrollVisible.bind(this),
      displayedColumnsWidthChanged: this.updateScrollVisible.bind(this)
    });
  }
  updateScrollVisible() {
    const { colAnimation: e } = this;
    e != null && e.isActive() ? e.executeLaterVMTurn(() => {
      e.executeLaterVMTurn(() => this.updateScrollVisibleImpl());
    }) : this.updateScrollVisibleImpl();
  }
  updateScrollVisibleImpl() {
    var i;
    const e = this.ctrlsSvc.get("center");
    if (!e || (i = this.colAnimation) != null && i.isActive())
      return;
    const t = {
      horizontalScrollShowing: e.isHorizontalScrollShowing(),
      verticalScrollShowing: this.verticalScrollShowing
    };
    this.setScrollsVisible(t), this.updateScrollGap();
  }
  updateScrollGap() {
    const e = this.ctrlsSvc.get("center"), t = e.hasHorizontalScrollGap(), i = e.hasVerticalScrollGap();
    (this.horizontalScrollGap !== t || this.verticalScrollGap !== i) && (this.horizontalScrollGap = t, this.verticalScrollGap = i, this.eventSvc.dispatchEvent({
      type: "scrollGapChanged"
    }));
  }
  setScrollsVisible(e) {
    (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) && (this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing, this.eventSvc.dispatchEvent({
      type: "scrollVisibilityChanged"
    }));
  }
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const e = this.gos.get("scrollbarWidth"), i = typeof e == "number" && e >= 0 ? e : nw();
      i != null && (this.scrollbarWidth = i, this.eventSvc.dispatchEvent({
        type: "scrollbarWidthChanged"
      }));
    }
    return this.scrollbarWidth;
  }
}, i0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "gridDestroySvc", this.destroyCalled = !1;
  }
  destroy() {
    var s;
    if (this.destroyCalled)
      return;
    const { stateSvc: e, ctrlsSvc: t, context: i } = this.beans;
    this.eventSvc.dispatchEvent({
      type: "gridPreDestroyed",
      state: (e == null ? void 0 : e.getState()) ?? {}
    }), this.destroyCalled = !0, (s = t.get("gridCtrl")) == null || s.destroyGridUi(), i.destroy(), super.destroy();
  }
}, ro = /* @__PURE__ */ new Set(["gridPreDestroyed", "fillStart", "pasteStart"]), s0 = [
  "columnEverythingChanged",
  "newColumnsLoaded",
  "columnPivotModeChanged",
  "pivotMaxColumnsExceeded",
  "columnRowGroupChanged",
  "expandOrCollapseAll",
  "columnPivotChanged",
  "gridColumnsChanged",
  "columnValueChanged",
  "columnMoved",
  "columnVisible",
  "columnPinned",
  "columnGroupOpened",
  "columnResized",
  "displayedColumnsChanged",
  "virtualColumnsChanged",
  "columnHeaderMouseOver",
  "columnHeaderMouseLeave",
  "columnHeaderClicked",
  "columnHeaderContextMenu",
  "asyncTransactionsFlushed",
  "rowGroupOpened",
  "rowDataUpdated",
  "pinnedRowDataChanged",
  "pinnedRowsChanged",
  "rangeSelectionChanged",
  "cellSelectionChanged",
  "chartCreated",
  "chartRangeSelectionChanged",
  "chartOptionsChanged",
  "chartDestroyed",
  "toolPanelVisibleChanged",
  "toolPanelSizeChanged",
  "modelUpdated",
  "cutStart",
  "cutEnd",
  "pasteStart",
  "pasteEnd",
  "fillStart",
  "fillEnd",
  "cellSelectionDeleteStart",
  "cellSelectionDeleteEnd",
  "rangeDeleteStart",
  "rangeDeleteEnd",
  "undoStarted",
  "undoEnded",
  "redoStarted",
  "redoEnded",
  "cellClicked",
  "cellDoubleClicked",
  "cellMouseDown",
  "cellContextMenu",
  "cellValueChanged",
  "cellEditRequest",
  "rowValueChanged",
  "headerFocused",
  "cellFocused",
  "rowSelected",
  "selectionChanged",
  "tooltipShow",
  "tooltipHide",
  "cellKeyDown",
  "cellMouseOver",
  "cellMouseOut",
  "filterChanged",
  "filterModified",
  "filterUiChanged",
  "filterOpened",
  "floatingFilterUiChanged",
  "advancedFilterBuilderVisibleChanged",
  "sortChanged",
  "virtualRowRemoved",
  "rowClicked",
  "rowDoubleClicked",
  "gridReady",
  "gridPreDestroyed",
  "gridSizeChanged",
  "viewportChanged",
  "firstDataRendered",
  "dragStarted",
  "dragStopped",
  "dragCancelled",
  "rowEditingStarted",
  "rowEditingStopped",
  "cellEditingStarted",
  "cellEditingStopped",
  "bodyScroll",
  "bodyScrollEnd",
  "paginationChanged",
  "componentStateChanged",
  "storeRefreshed",
  "stateUpdated",
  "columnMenuVisibleChanged",
  "contextMenuVisibleChanged",
  "rowDragEnter",
  "rowDragMove",
  "rowDragLeave",
  "rowDragEnd",
  "rowDragCancel",
  "findChanged",
  "rowResizeStarted",
  "rowResizeEnded",
  "columnsReset",
  "bulkEditingStarted",
  "bulkEditingStopped",
  "batchEditingStarted",
  "batchEditingStopped"
], Fr = s0.reduce(
  (e, t) => (e[t] = YC(t), e),
  {}
), Gs = (e, t) => ({
  tag: "span",
  ref: `eSort${e}`,
  cls: `ag-sort-indicator-icon ag-sort-${t} ag-hidden`,
  attrs: { "aria-hidden": "true" }
}), o0 = {
  tag: "span",
  cls: "ag-sort-indicator-container",
  children: [
    Gs("Order", "order"),
    Gs("Asc", "ascending-icon"),
    Gs("Desc", "descending-icon"),
    Gs("Mixed", "mixed-icon"),
    Gs("None", "none-icon")
  ]
}, td = class extends te {
  constructor(e) {
    super(), this.eSortOrder = _, this.eSortAsc = _, this.eSortDesc = _, this.eSortMixed = _, this.eSortNone = _, e || this.setTemplate(o0);
  }
  attachCustomElements(e, t, i, s, o) {
    this.eSortOrder = e, this.eSortAsc = t, this.eSortDesc = i, this.eSortMixed = s, this.eSortNone = o;
  }
  setupSort(e, t = !1) {
    if (this.column = e, this.suppressOrder = t, this.setupMultiSortIndicator(), !e.isSortable() && !e.getColDef().showRowGroup)
      return;
    this.addInIcon("sortAscending", this.eSortAsc, e), this.addInIcon("sortDescending", this.eSortDesc, e), this.addInIcon("sortUnSort", this.eSortNone, e);
    const i = this.updateIcons.bind(this), s = this.onSortChanged.bind(this);
    this.addManagedPropertyListener("unSortIcon", i), this.addManagedEventListeners({
      newColumnsLoaded: i,
      // Watch global events, as row group columns can effect their display column.
      sortChanged: s,
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: s
    }), this.onSortChanged();
  }
  addInIcon(e, t, i) {
    if (t == null)
      return;
    const s = Ze(e, this.beans, i);
    s && t.appendChild(s);
  }
  onSortChanged() {
    this.updateIcons(), this.suppressOrder || this.updateSortOrder();
  }
  updateIcons() {
    const { eSortAsc: e, eSortDesc: t, eSortNone: i, column: s, gos: o, beans: n } = this, r = n.sortSvc.getDisplaySortForColumn(s);
    if (e && le(e, r === "asc", { skipAriaHidden: !0 }), t && le(t, r === "desc", { skipAriaHidden: !0 }), i) {
      const a = !s.getColDef().unSortIcon && !o.get("unSortIcon"), l = r == null;
      le(i, !a && l, { skipAriaHidden: !0 });
    }
  }
  setupMultiSortIndicator() {
    const { eSortMixed: e, column: t, gos: i } = this;
    this.addInIcon("sortUnSort", e, t);
    const s = t.getColDef().showRowGroup;
    St(i) && s && (this.addManagedEventListeners({
      // Watch global events, as row group columns can effect their display column.
      sortChanged: this.updateMultiSortIndicator.bind(this),
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
    }), this.updateMultiSortIndicator());
  }
  updateMultiSortIndicator() {
    const { eSortMixed: e, beans: t, column: i } = this;
    if (e) {
      const s = t.sortSvc.getDisplaySortForColumn(i) === "mixed";
      le(e, s, { skipAriaHidden: !0 });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    const {
      eSortOrder: e,
      column: t,
      beans: { sortSvc: i }
    } = this;
    if (!e)
      return;
    const s = i.getColumnsWithSortingOrdered(), o = i.getDisplaySortIndexForColumn(t) ?? -1, n = s.some(
      (a) => i.getDisplaySortIndexForColumn(a) ?? !1
    ), r = o >= 0 && n;
    le(e, r, { skipAriaHidden: !0 }), o >= 0 ? e.textContent = (o + 1).toString() : Te(e);
  }
}, n0 = {
  selector: "AG-SORT-INDICATOR",
  component: td
}, To = ["asc", "desc", null], r0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "sortSvc";
  }
  progressSort(e, t, i) {
    const s = this.getNextSortDirection(e);
    this.setSortForColumn(e, s, t, i);
  }
  progressSortFromEvent(e, t) {
    const s = this.gos.get("multiSortKey") === "ctrl" ? t.ctrlKey || t.metaKey : t.shiftKey;
    this.progressSort(e, s, "uiColumnSorted");
  }
  setSortForColumn(e, t, i, s) {
    var c;
    t !== "asc" && t !== "desc" && (t = null);
    const { gos: o, showRowGroupCols: n } = this.beans, r = St(o);
    let a = [e];
    if (r && e.getColDef().showRowGroup) {
      const u = (c = n == null ? void 0 : n.getSourceColumnsForGroupColumn) == null ? void 0 : c.call(n, e), h = u == null ? void 0 : u.filter((g) => g.isSortable());
      h && (a = [e, ...h]);
    }
    a.forEach((u) => this.setColSort(u, t, s));
    const l = (i || o.get("alwaysMultiSort")) && !o.get("suppressMultiSort"), d = [];
    if (!l) {
      const u = this.clearSortBarTheseColumns(a, s);
      d.push(...u);
    }
    this.updateSortIndex(e), d.push(...a), this.dispatchSortChangedEvents(s, d);
  }
  updateSortIndex(e) {
    const { gos: t, colModel: i, showRowGroupCols: s } = this.beans, o = St(t), n = s == null ? void 0 : s.getShowRowGroupCol(e.getId()), r = o && n || e, a = this.getColumnsWithSortingOrdered();
    i.forAllCols((c) => this.setColSortIndex(c, null));
    const l = a.filter((c) => o && c.getColDef().showRowGroup ? !1 : c !== r);
    (r.getSort() ? [...l, r] : l).forEach((c, u) => this.setColSortIndex(c, u));
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(e, t) {
    this.dispatchSortChangedEvents(e, t);
  }
  isSortActive() {
    let e = !1;
    return this.beans.colModel.forAllCols((t) => {
      t.getSort() && (e = !0);
    }), e;
  }
  dispatchSortChangedEvents(e, t) {
    const i = {
      type: "sortChanged",
      source: e
    };
    t && (i.columns = t), this.eventSvc.dispatchEvent(i);
  }
  clearSortBarTheseColumns(e, t) {
    const i = [];
    return this.beans.colModel.forAllCols((s) => {
      e.includes(s) || (s.getSort() && i.push(s), this.setColSort(s, void 0, t));
    }), i;
  }
  getNextSortDirection(e) {
    const t = e.getColDef().sortingOrder ?? this.gos.get("sortingOrder") ?? To, i = t.indexOf(e.getSort()), s = i < 0, o = i == t.length - 1;
    return s || o ? t[0] : t[i + 1];
  }
  /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    const { gos: e, colModel: t, showRowGroupCols: i, rowGroupColsSvc: s } = this.beans;
    let o = [];
    if (t.forAllCols((d) => {
      d.getSort() && o.push(d);
    }), t.isPivotMode()) {
      const d = St(e);
      o = o.filter((c) => {
        const u = !!c.getAggFunc(), h = !c.isPrimary(), g = d ? i == null ? void 0 : i.getShowRowGroupCol(c.getId()) : c.getColDef().showRowGroup;
        return u || h || g;
      });
    }
    const n = (s == null ? void 0 : s.columns.filter((d) => !!d.getSort())) ?? [], r = {};
    o.forEach((d, c) => r[d.getId()] = c), o.sort((d, c) => {
      const u = d.getSortIndex(), h = c.getSortIndex();
      if (u != null && h != null)
        return u - h;
      if (u == null && h == null) {
        const g = r[d.getId()], p = r[c.getId()];
        return g > p ? 1 : -1;
      } else return h == null ? -1 : 1;
    });
    const a = St(e) && !!n.length;
    a && (o = [
      ...new Set(
        // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
        o.map((d) => (i == null ? void 0 : i.getShowRowGroupCol(d.getId())) ?? d)
      )
    ]);
    const l = /* @__PURE__ */ new Map();
    return o.forEach((d, c) => l.set(d, c)), a && n.forEach((d) => {
      const c = i.getShowRowGroupCol(d.getId());
      l.set(d, l.get(c));
    }), l;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([, e], [, t]) => e - t).map(([e]) => e);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      colId: e.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      column: e
    }));
  }
  canColumnDisplayMixedSort(e) {
    const t = St(this.gos), i = !!e.getColDef().showRowGroup;
    return t && i;
  }
  getDisplaySortForColumn(e) {
    var r;
    const t = (r = this.beans.showRowGroupCols) == null ? void 0 : r.getSourceColumnsForGroupColumn(e);
    if (!this.canColumnDisplayMixedSort(e) || !(t != null && t.length))
      return e.getSort();
    const s = e.getColDef().field != null || !!e.getColDef().valueGetter ? [e, ...t] : t, o = s[0].getSort();
    return s.every((a) => a.getSort() == o) ? o : "mixed";
  }
  getDisplaySortIndexForColumn(e) {
    return this.getIndexedSortMap().get(e);
  }
  setupHeader(e, t, i) {
    let s = 0;
    e.addManagedListeners(t, {
      movingChanged: () => {
        s = Date.now();
      }
    }), i && e.addManagedElementListeners(i, {
      click: (n) => {
        const r = t.isMoving(), l = Date.now() - s < 50;
        r || l || this.progressSortFromEvent(t, n);
      }
    });
    const o = () => {
      var r;
      const n = t.getSort();
      if (e.toggleCss("ag-header-cell-sorted-asc", n === "asc"), e.toggleCss("ag-header-cell-sorted-desc", n === "desc"), e.toggleCss("ag-header-cell-sorted-none", !n), t.getColDef().showRowGroup) {
        const a = (r = this.beans.showRowGroupCols) == null ? void 0 : r.getSourceColumnsForGroupColumn(t), d = !(a == null ? void 0 : a.every(
          (c) => t.getSort() == c.getSort()
        ));
        e.toggleCss("ag-header-cell-sorted-mixed", d);
      }
    };
    e.addManagedEventListeners({
      sortChanged: o,
      columnRowGroupChanged: o
    });
  }
  initCol(e) {
    const { sort: t, initialSort: i, sortIndex: s, initialSortIndex: o } = e.colDef;
    t !== void 0 ? (t === "asc" || t === "desc") && (e.sort = t) : (i === "asc" || i === "desc") && (e.sort = i), s !== void 0 ? s !== null && (e.sortIndex = s) : o !== null && (e.sortIndex = o);
  }
  updateColSort(e, t, i) {
    t !== void 0 && (t === "desc" || t === "asc" ? this.setColSort(e, t, i) : this.setColSort(e, void 0, i));
  }
  setColSort(e, t, i) {
    e.sort !== t && (e.sort = t, e.dispatchColEvent("sortChanged", i)), e.dispatchStateUpdatedEvent("sort");
  }
  setColSortIndex(e, t) {
    e.sortIndex = t, e.dispatchStateUpdatedEvent("sortIndex");
  }
  createSortIndicator(e) {
    return new td(e);
  }
  getSortIndicatorSelector() {
    return n0;
  }
}, gs = {
  agSetColumnFilter: "SetFilter",
  agSetColumnFloatingFilter: "SetFilter",
  agMultiColumnFilter: "MultiFilter",
  agMultiColumnFloatingFilter: "MultiFilter",
  agGroupColumnFilter: "GroupFilter",
  agGroupColumnFloatingFilter: "GroupFilter",
  agGroupCellRenderer: "GroupCellRenderer",
  agGroupRowRenderer: "GroupCellRenderer",
  agRichSelect: "RichSelect",
  agRichSelectCellEditor: "RichSelect",
  agDetailCellRenderer: "SharedMasterDetail",
  agSparklineCellRenderer: "Sparklines",
  agDragAndDropImage: "SharedDragAndDrop",
  agColumnHeader: "ColumnHeaderComp",
  agColumnGroupHeader: "ColumnGroupHeaderComp",
  agSortIndicator: "Sort",
  agAnimateShowChangeCellRenderer: "HighlightChanges",
  agAnimateSlideCellRenderer: "HighlightChanges",
  agLoadingCellRenderer: "LoadingCellRenderer",
  agSkeletonCellRenderer: "SkeletonCellRenderer",
  agCheckboxCellRenderer: "CheckboxCellRenderer",
  agLoadingOverlay: "Overlay",
  agNoRowsOverlay: "Overlay",
  agTooltipComponent: "Tooltip",
  agReadOnlyFloatingFilter: "CustomFilter",
  agTextColumnFilter: "TextFilter",
  agNumberColumnFilter: "NumberFilter",
  agDateColumnFilter: "DateFilter",
  agDateInput: "DateFilter",
  agTextColumnFloatingFilter: "TextFilter",
  agNumberColumnFloatingFilter: "NumberFilter",
  agDateColumnFloatingFilter: "DateFilter",
  agCellEditor: "TextEditor",
  agSelectCellEditor: "SelectEditor",
  agTextCellEditor: "TextEditor",
  agNumberCellEditor: "NumberEditor",
  agDateCellEditor: "DateEditor",
  agDateStringCellEditor: "DateEditor",
  agCheckboxCellEditor: "CheckboxEditor",
  agLargeTextCellEditor: "LargeTextEditor",
  agMenuItem: "MenuItem",
  agColumnsToolPanel: "ColumnsToolPanel",
  agFiltersToolPanel: "FiltersToolPanel",
  agNewFiltersToolPanel: "NewFiltersToolPanel",
  agAggregationComponent: "StatusBar",
  agSelectedRowCountComponent: "StatusBar",
  agTotalRowCountComponent: "StatusBar",
  agFilteredRowCountComponent: "StatusBar",
  agTotalAndFilteredRowCountComponent: "StatusBar",
  agFindCellRenderer: "Find"
}, a0 = () => ({
  checkboxSelection: { version: "32.2", message: "Use `rowSelection.checkboxes` in `GridOptions` instead." },
  headerCheckboxSelection: {
    version: "32.2",
    message: "Use `rowSelection.headerCheckbox = true` in `GridOptions` instead."
  },
  headerCheckboxSelectionFilteredOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "filtered"` in `GridOptions` instead.'
  },
  headerCheckboxSelectionCurrentPageOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "currentPage"` in `GridOptions` instead.'
  },
  showDisabledCheckboxes: {
    version: "32.2",
    message: "Use `rowSelection.hideDisabledCheckboxes = true` in `GridOptions` instead."
  }
}), l0 = {
  aggFunc: "SharedAggregation",
  autoHeight: "RowAutoHeight",
  cellClass: "CellStyle",
  cellClassRules: "CellStyle",
  cellEditor: ({ cellEditor: e, editable: t }) => t ? typeof e == "string" ? gs[e] ?? "CustomEditor" : "CustomEditor" : null,
  cellRenderer: ({ cellRenderer: e }) => typeof e != "string" ? null : gs[e],
  cellStyle: "CellStyle",
  columnChooserParams: "ColumnMenu",
  contextMenuItems: "ContextMenu",
  dndSource: "DragAndDrop",
  dndSourceOnRowDrag: "DragAndDrop",
  editable: ({ editable: e, cellEditor: t }) => e && !t ? "TextEditor" : null,
  enableCellChangeFlash: "HighlightChanges",
  enablePivot: "SharedPivot",
  enableRowGroup: "SharedRowGrouping",
  enableValue: "SharedAggregation",
  filter: ({ filter: e }) => e && typeof e != "string" && typeof e != "boolean" ? "CustomFilter" : typeof e == "string" ? gs[e] ?? "ColumnFilter" : "ColumnFilter",
  floatingFilter: "ColumnFilter",
  getQuickFilterText: "QuickFilter",
  headerTooltip: "Tooltip",
  mainMenuItems: "ColumnMenu",
  menuTabs: (e) => {
    var i;
    const t = ["columnsMenuTab", "generalMenuTab"];
    return (i = e.menuTabs) != null && i.some((s) => t.includes(s)) ? "ColumnMenu" : null;
  },
  pivot: "SharedPivot",
  pivotIndex: "SharedPivot",
  rowDrag: "RowDrag",
  rowGroup: "SharedRowGrouping",
  rowGroupIndex: "SharedRowGrouping",
  tooltipField: "Tooltip",
  tooltipValueGetter: "Tooltip",
  spanRows: "CellSpan",
  rowGroupingHierarchy: "SharedRowGrouping"
}, d0 = () => ({
  autoHeight: {
    supportedRowModels: ["clientSide", "serverSide"],
    validate: (t, { paginationAutoPageSize: i }) => i ? "colDef.autoHeight is not supported with paginationAutoPageSize." : null
  },
  cellRendererParams: {
    validate: (t) => (t.rowGroup != null || t.rowGroupIndex != null || t.cellRenderer === "agGroupCellRenderer") && "checkbox" in t.cellRendererParams ? 'Since v33.0, `cellRendererParams.checkbox` has been deprecated. Use `rowSelection.checkboxLocation = "autoGroupColumn"` instead.' : null
  },
  flex: {
    validate: (t, i) => i.autoSizeStrategy ? "colDef.flex is not supported with gridOptions.autoSizeStrategy" : null
  },
  headerCheckboxSelection: {
    supportedRowModels: ["clientSide", "serverSide"],
    validate: (t, { rowSelection: i }) => i === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionCurrentPageOnly: {
    supportedRowModels: ["clientSide"],
    validate: (t, { rowSelection: i }) => i === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionFilteredOnly: {
    supportedRowModels: ["clientSide"],
    validate: (t, { rowSelection: i }) => i === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
  },
  headerValueGetter: {
    validate: (t) => {
      const i = t.headerValueGetter;
      return typeof i == "function" || typeof i == "string" ? null : "headerValueGetter must be a function or a valid string expression";
    }
  },
  icons: {
    validate: ({ icons: t }) => {
      if (t) {
        if (t.smallDown)
          return Pt(262);
        if (t.smallLeft)
          return Pt(263);
        if (t.smallRight)
          return Pt(264);
      }
      return null;
    }
  },
  sortingOrder: {
    validate: (t) => {
      const i = t.sortingOrder;
      if (Array.isArray(i) && i.length > 0) {
        const s = i.filter((o) => !To.includes(o));
        if (s.length > 0)
          return `sortingOrder must be an array with elements from [${To.map(Un).join()}], currently it includes [${s.map(Un).join()}]`;
      } else if (!Array.isArray(i) || i.length <= 0)
        return `sortingOrder must be an array with at least one element, currently it's ${i}`;
      return null;
    }
  },
  type: {
    validate: (t) => {
      const i = t.type;
      return i instanceof Array ? i.some((o) => typeof o != "string") ? "if colDef.type is supplied an array it should be of type 'string[]'" : null : typeof i == "string" ? null : "colDef.type should be of type 'string' | 'string[]'";
    }
  },
  rowSpan: {
    validate: (t, { suppressRowTransform: i }) => i ? null : "colDef.rowSpan requires suppressRowTransform to be enabled."
  },
  spanRows: {
    dependencies: {
      editable: { required: [!1, void 0] },
      rowDrag: { required: [!1, void 0] },
      colSpan: { required: [void 0] },
      rowSpan: { required: [void 0] }
    },
    validate: (t, {
      rowSelection: i,
      cellSelection: s,
      suppressRowTransform: o,
      enableCellSpan: n,
      rowDragEntireRow: r,
      enableCellTextSelection: a
    }) => typeof i == "object" && (i == null ? void 0 : i.mode) === "singleRow" && i != null && i.enableClickSelection ? "colDef.spanRows is not supported with rowSelection.clickSelection" : s ? "colDef.spanRows is not supported with cellSelection." : o ? "colDef.spanRows is not supported with suppressRowTransform." : n ? r ? "colDef.spanRows is not supported with rowDragEntireRow." : a ? "colDef.spanRows is not supported with enableCellTextSelection." : null : "colDef.spanRows requires enableCellSpan to be enabled."
  },
  rowGroupingHierarchy: {
    validate(t, { groupHierarchyConfig: i = {} }, s) {
      var r;
      const o = /* @__PURE__ */ new Set([
        "year",
        "quarter",
        "month",
        "formattedMonth",
        "day",
        "hour",
        "minute",
        "second"
      ]), n = [];
      if ((r = t.rowGroupingHierarchy) == null || r.forEach((a) => {
        var l;
        if (typeof a == "object")
          return (l = s.validation) == null || l.validateColDef(a), null;
        !o.has(a) && !(a in i) && n.push(a);
      }), n.length > 0) {
        const a = `The following parts of colDef.rowGroupingHierarchy are not recognised: ${n.map((d) => `"${d}"`).join(", ")}.`, l = `Choose one of ${[...o].map((d) => `"${d}"`).join(", ")}, or define your own parts in gridOptions.groupHierarchyConfig.`;
        return `${a}
${l}`;
      }
      return null;
    }
  }
}), c0 = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerStyle: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellAriaRole: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnChooserParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressHeaderMenuButton: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  spanRows: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0,
  mainMenuItems: void 0,
  contextMenuItems: void 0,
  suppressFloatingFilterButton: void 0,
  suppressHeaderFilterButton: void 0,
  suppressHeaderContextMenu: void 0,
  loadingCellRenderer: void 0,
  loadingCellRendererParams: void 0,
  loadingCellRendererSelector: void 0,
  context: void 0,
  dateComponent: void 0,
  dateComponentParams: void 0,
  getFindText: void 0,
  rowGroupingHierarchy: void 0
}, u0 = () => Object.keys(c0), h0 = () => ({
  objectName: "colDef",
  allProperties: u0(),
  docsUrl: "column-properties/",
  deprecations: a0(),
  validations: d0()
}), g0 = [
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "groupDisplayType",
  "treeDataDisplayType",
  "treeDataChildrenField",
  "treeDataParentIdField",
  "colResizeDefault",
  "tooltipTrigger",
  "serverSidePivotResultFieldSeparator",
  "columnMenu",
  "tooltipShowMode",
  "invalidEditValueMode",
  "grandTotalRow",
  "themeCssLayer",
  "findSearchValue",
  "styleNonce",
  "renderingMode"
], p0 = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "dragAndDropImageComponentParams",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "themeStyleContainer",
  "statusBar",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions",
  "advancedFilterParent",
  "advancedFilterBuilderParams",
  "advancedFilterParams",
  "initialState",
  "autoSizeStrategy",
  "selectionColumnDef",
  "findOptions",
  "filterHandlers",
  "groupHierarchyConfig"
], f0 = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass",
  "paginationPageSizeSelector"
], Ep = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "groupLockGroupColumns",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "pivotDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDuration",
  "cellFadeDuration",
  "tabIndex",
  "pivotMaxGeneratedColumns",
  "rowDragInsertDelay"
], m0 = ["theme", "rowSelection"], C0 = [
  "cellSelection",
  "sideBar",
  "rowNumbers",
  "suppressGroupChangesColumnVisibility",
  "groupAggFiltering",
  "suppressStickyTotalRow",
  "groupHideParentOfSingleChild",
  "enableRowPinning"
], Dp = [
  "loadThemeGoogleFonts",
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHeaderFocus",
  "suppressHorizontalScroll",
  "groupSelectsChildren",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressColumnMoveAnimation",
  "suppressMoveWhenColumnDragging",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "enableCellSpan",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "includeHiddenColumnsInAdvancedFilter",
  "suppressMultiRangeSelection",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "tooltipInteraction",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideSortAllLevels",
  "serverSideEnableClientSideSort",
  "serverSideOnlyRefreshFilteredGroups",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressCutToClipboard",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "enableAdvancedFilter",
  "masterDetail",
  "treeData",
  "reactiveCustomComponents",
  "applyQuickFilterBeforePivotOrAgg",
  "suppressServerSideFullWidthLoadingRow",
  "suppressAdvancedFilterEval",
  "loading",
  "maintainColumnOrder",
  "enableStrictPivotColumnOrder",
  "suppressSetFilterByDefault",
  "enableFilterHandlers",
  "suppressStartEditOnTab",
  "hidePaddedHeaderRows",
  "ssrmExpandAllAffectsAllRows"
], v0 = [
  "doesExternalFilterPass",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "dragAndDropImageComponent",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer",
  "quickFilterParser",
  "quickFilterMatcher",
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getFullRowEditValidationErrors",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "focusGridInnerElement",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processUnpinnedColumns",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "loadingCellRendererSelector",
  "getRowId",
  "chartMenuItems",
  "groupTotalRow",
  "alwaysPassFilter",
  "isRowPinnable",
  "isRowPinned",
  "isRowValidDropPosition"
], il = () => [
  ...f0,
  ...p0,
  ...g0,
  ...Ep,
  ...v0,
  ...Dp,
  ...C0,
  ...m0
], w0 = () => ({
  suppressLoadingOverlay: { version: "32", message: "Use `loading`=false instead." },
  enableFillHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeSelection: { version: "32.2", message: "Use `cellSelection = true` instead." },
  suppressMultiRangeSelection: {
    version: "32.2",
    message: "Use `cellSelection.suppressMultiRanges` instead."
  },
  suppressClearOnFillReduction: {
    version: "32.2",
    message: "Use `cellSelection.handle.suppressClearOnFillReduction` instead."
  },
  fillHandleDirection: { version: "32.2", message: "Use `cellSelection.handle.direction` instead." },
  fillOperation: { version: "32.2", message: "Use `cellSelection.handle.setFillValue` instead." },
  suppressRowClickSelection: {
    version: "32.2",
    message: "Use `rowSelection.enableClickSelection` instead."
  },
  suppressRowDeselection: { version: "32.2", message: "Use `rowSelection.enableClickSelection` instead." },
  rowMultiSelectWithClick: {
    version: "32.2",
    message: "Use `rowSelection.enableSelectionWithoutKeys` instead."
  },
  groupSelectsChildren: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "descendants"` instead.'
  },
  groupSelectsFiltered: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "filteredDescendants"` instead.'
  },
  isRowSelectable: { version: "32.2", message: "Use `selectionOptions.isRowSelectable` instead." },
  suppressCopySingleCellRanges: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  suppressCopyRowsToClipboard: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  onRangeSelectionChanged: { version: "32.2", message: "Use `onCellSelectionChanged` instead." },
  onRangeDeleteStart: { version: "32.2", message: "Use `onCellSelectionDeleteStart` instead." },
  onRangeDeleteEnd: { version: "32.2", message: "Use `onCellSelectionDeleteEnd` instead." },
  suppressBrowserResizeObserver: {
    version: "32.2",
    message: "The grid always uses the browser's ResizeObserver, this grid option has no effect."
  },
  onColumnEverythingChanged: {
    version: "32.2",
    message: "Either use `onDisplayedColumnsChanged` which is fired at the same time, or use one of the more specific column events."
  },
  groupRemoveSingleChildren: {
    version: "33",
    message: "Use `groupHideParentOfSingleChild` instead."
  },
  groupRemoveLowestSingleChildren: {
    version: "33",
    message: 'Use `groupHideParentOfSingleChild: "leafGroupsOnly"` instead.'
  },
  suppressRowGroupHidesColumns: {
    version: "33",
    message: 'Use `suppressGroupChangesColumnVisibility: "suppressHideOnGroup"` instead.'
  },
  suppressMakeColumnVisibleAfterUnGroup: {
    version: "33",
    message: 'Use `suppressGroupChangesColumnVisibility: "suppressShowOnUngroup"` instead.'
  },
  unSortIcon: { version: "33", message: "Use `defaultColDef.unSortIcon` instead." },
  sortingOrder: { version: "33", message: "Use `defaultColDef.sortingOrder` instead." },
  suppressPropertyNamesCheck: {
    version: "33",
    message: "`gridOptions` and `columnDefs` both have a `context` property that should be used for arbitrary user data. This means that column definitions and gridOptions should only contain valid properties making this property redundant."
  },
  suppressAdvancedFilterEval: {
    version: "34",
    message: "Advanced filter no longer uses function evaluation, so this option has no effect."
  }
});
function Ct(e, t, i) {
  return typeof t == "number" || t == null ? t == null || t >= i ? null : `${e}: value should be greater than or equal to ${i}` : `${e}: value should be a number`;
}
var b0 = {
  alignedGrids: "AlignedGrids",
  allowContextMenuWithControlKey: "ContextMenu",
  autoSizeStrategy: "ColumnAutoSize",
  cellSelection: "CellSelection",
  columnHoverHighlight: "ColumnHover",
  datasource: "InfiniteRowModel",
  doesExternalFilterPass: "ExternalFilter",
  editType: "EditCore",
  invalidEditValueMode: "EditCore",
  enableAdvancedFilter: "AdvancedFilter",
  enableCellSpan: "CellSpan",
  enableCharts: "IntegratedCharts",
  enableRangeSelection: "CellSelection",
  enableRowPinning: "PinnedRow",
  findSearchValue: "Find",
  getFullRowEditValidationErrors: "EditCore",
  getContextMenuItems: "ContextMenu",
  getLocaleText: "Locale",
  getMainMenuItems: "ColumnMenu",
  getRowClass: "RowStyle",
  getRowStyle: "RowStyle",
  groupTotalRow: "SharedRowGrouping",
  grandTotalRow: "SharedRowGrouping",
  initialState: "GridState",
  isExternalFilterPresent: "ExternalFilter",
  isRowPinnable: "PinnedRow",
  isRowPinned: "PinnedRow",
  localeText: "Locale",
  masterDetail: "SharedMasterDetail",
  pagination: "Pagination",
  pinnedBottomRowData: "PinnedRow",
  pinnedTopRowData: "PinnedRow",
  pivotMode: "SharedPivot",
  pivotPanelShow: "RowGroupingPanel",
  quickFilterText: "QuickFilter",
  rowClass: "RowStyle",
  rowClassRules: "RowStyle",
  rowData: "ClientSideRowModel",
  rowDragManaged: "RowDrag",
  rowGroupPanelShow: "RowGroupingPanel",
  rowNumbers: "RowNumbers",
  rowSelection: "SharedRowSelection",
  rowStyle: "RowStyle",
  serverSideDatasource: "ServerSideRowModel",
  sideBar: "SideBar",
  statusBar: "StatusBar",
  treeData: "SharedTreeData",
  undoRedoCellEditing: "UndoRedoEdit",
  valueCache: "ValueCache",
  viewportDatasource: "ViewportRowModel"
}, y0 = () => {
  const e = {
    autoSizePadding: {
      validate({ autoSizePadding: i }) {
        return Ct("autoSizePadding", i, 0);
      }
    },
    cacheBlockSize: {
      supportedRowModels: ["serverSide", "infinite"],
      validate({ cacheBlockSize: i }) {
        return Ct("cacheBlockSize", i, 1);
      }
    },
    cacheOverflowSize: {
      validate({ cacheOverflowSize: i }) {
        return Ct("cacheOverflowSize", i, 1);
      }
    },
    datasource: {
      supportedRowModels: ["infinite"]
    },
    domLayout: {
      validate: (i) => {
        const s = i.domLayout, o = ["autoHeight", "normal", "print"];
        return s && !o.includes(s) ? `domLayout must be one of [${o.join()}], currently it's ${s}` : null;
      }
    },
    enableFillHandle: {
      dependencies: {
        enableRangeSelection: { required: [!0] }
      }
    },
    enableRangeHandle: {
      dependencies: {
        enableRangeSelection: { required: [!0] }
      }
    },
    enableRangeSelection: {
      dependencies: {
        rowDragEntireRow: { required: [!1, void 0] }
      }
    },
    enableRowPinning: {
      supportedRowModels: ["clientSide"],
      validate({ enableRowPinning: i, pinnedTopRowData: s, pinnedBottomRowData: o }) {
        return i && (s || o) ? "Manual row pinning cannot be used together with pinned row data. Either set `enableRowPinning` to `false`, or remove `pinnedTopRowData` and `pinnedBottomRowData`." : null;
      }
    },
    isRowPinnable: {
      supportedRowModels: ["clientSide"],
      validate({ enableRowPinning: i, isRowPinnable: s, pinnedTopRowData: o, pinnedBottomRowData: n }) {
        return s && (o || n) ? "Manual row pinning cannot be used together with pinned row data. Either remove `isRowPinnable`, or remove `pinnedTopRowData` and `pinnedBottomRowData`." : !i && s ? "`isRowPinnable` requires `enableRowPinning` to be set." : null;
      }
    },
    isRowPinned: {
      supportedRowModels: ["clientSide"],
      validate({ enableRowPinning: i, isRowPinned: s, pinnedTopRowData: o, pinnedBottomRowData: n }) {
        return s && (o || n) ? "Manual row pinning cannot be used together with pinned row data. Either remove `isRowPinned`, or remove `pinnedTopRowData` and `pinnedBottomRowData`." : !i && s ? "`isRowPinned` requires `enableRowPinning` to be set." : null;
      }
    },
    groupDefaultExpanded: {
      supportedRowModels: ["clientSide"]
    },
    groupHideOpenParents: {
      supportedRowModels: ["clientSide", "serverSide"],
      dependencies: {
        groupTotalRow: { required: [void 0, "bottom"] },
        treeData: {
          required: [void 0, !1],
          reason: "Tree Data has values at the group level so it doesn't make sense to hide them."
        }
      }
    },
    groupHideParentOfSingleChild: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, !1] }
      }
    },
    groupRemoveLowestSingleChildren: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, !1] },
        groupRemoveSingleChildren: { required: [void 0, !1] }
      }
    },
    groupRemoveSingleChildren: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, !1] },
        groupRemoveLowestSingleChildren: { required: [void 0, !1] }
      }
    },
    groupSelectsChildren: {
      dependencies: {
        rowSelection: { required: ["multiple"] }
      }
    },
    groupHierarchyConfig: {
      validate({ groupHierarchyConfig: i = {} }, s, o) {
        var n;
        for (const r of Object.keys(i))
          (n = o.validation) == null || n.validateColDef(i[r]);
        return null;
      }
    },
    icons: {
      validate: ({ icons: i }) => {
        if (i) {
          if (i.smallDown)
            return Pt(262);
          if (i.smallLeft)
            return Pt(263);
          if (i.smallRight)
            return Pt(264);
        }
        return null;
      }
    },
    infiniteInitialRowCount: {
      validate({ infiniteInitialRowCount: i }) {
        return Ct("infiniteInitialRowCount", i, 1);
      }
    },
    initialGroupOrderComparator: {
      supportedRowModels: ["clientSide"]
    },
    ssrmExpandAllAffectsAllRows: {
      validate: (i) => {
        if (typeof i.ssrmExpandAllAffectsAllRows == "boolean") {
          if (i.rowModelType !== "serverSide")
            return "'ssrmExpandAllAffectsAllRows' is only supported with the Server Side Row Model.";
          if (i.ssrmExpandAllAffectsAllRows && typeof i.getRowId != "function")
            return "'getRowId' callback must be provided for Server Side Row Model grouping to work correctly.";
        }
        return null;
      }
    },
    keepDetailRowsCount: {
      validate({ keepDetailRowsCount: i }) {
        return Ct("keepDetailRowsCount", i, 1);
      }
    },
    paginationPageSize: {
      validate({ paginationPageSize: i }) {
        return Ct("paginationPageSize", i, 1);
      }
    },
    paginationPageSizeSelector: {
      validate: (i) => {
        const s = i.paginationPageSizeSelector;
        return typeof s == "boolean" || s == null || s.length ? null : `'paginationPageSizeSelector' cannot be an empty array.
                    If you want to hide the page size selector, set paginationPageSizeSelector to false.`;
      }
    },
    pivotMode: {
      dependencies: {
        treeData: {
          required: [!1, void 0],
          reason: "Pivot Mode is not supported with Tree Data."
        }
      }
    },
    quickFilterText: {
      supportedRowModels: ["clientSide"]
    },
    rowBuffer: {
      validate({ rowBuffer: i }) {
        return Ct("rowBuffer", i, 0);
      }
    },
    rowClass: {
      validate: (i) => typeof i.rowClass == "function" ? "rowClass should not be a function, please use getRowClass instead" : null
    },
    rowData: {
      supportedRowModels: ["clientSide"]
    },
    rowDragManaged: {
      supportedRowModels: ["clientSide"],
      dependencies: {
        pagination: {
          required: [!1, void 0]
        }
      }
    },
    rowSelection: {
      validate({ rowSelection: i }) {
        return i && typeof i == "string" ? 'As of version 32.2.1, using `rowSelection` with the values "single" or "multiple" has been deprecated. Use the object value instead.' : i && typeof i != "object" ? "Expected `RowSelectionOptions` object for the `rowSelection` property." : i && i.mode !== "multiRow" && i.mode !== "singleRow" ? `Selection mode "${i.mode}" is invalid. Use one of 'singleRow' or 'multiRow'.` : null;
      }
    },
    rowStyle: {
      validate: (i) => {
        const s = i.rowStyle;
        return s && typeof s == "function" ? "rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead" : null;
      }
    },
    serverSideDatasource: {
      supportedRowModels: ["serverSide"]
    },
    serverSideInitialRowCount: {
      supportedRowModels: ["serverSide"],
      validate({ serverSideInitialRowCount: i }) {
        return Ct("serverSideInitialRowCount", i, 1);
      }
    },
    serverSideOnlyRefreshFilteredGroups: {
      supportedRowModels: ["serverSide"]
    },
    serverSideSortAllLevels: {
      supportedRowModels: ["serverSide"]
    },
    sortingOrder: {
      validate: (i) => {
        const s = i.sortingOrder;
        if (Array.isArray(s) && s.length > 0) {
          const o = s.filter((n) => !To.includes(n));
          if (o.length > 0)
            return `sortingOrder must be an array with elements from [${To.map(Un).join()}], currently it includes [${o.map(Un).join()}]`;
        } else if (!Array.isArray(s) || s.length <= 0)
          return `sortingOrder must be an array with at least one element, currently it's ${s}`;
        return null;
      }
    },
    tooltipHideDelay: {
      validate: (i) => i.tooltipHideDelay && i.tooltipHideDelay < 0 ? "tooltipHideDelay should not be lower than 0" : null
    },
    tooltipShowDelay: {
      validate: (i) => i.tooltipShowDelay && i.tooltipShowDelay < 0 ? "tooltipShowDelay should not be lower than 0" : null
    },
    treeData: {
      supportedRowModels: ["clientSide", "serverSide"],
      validate: (i) => {
        const s = i.rowModelType ?? "clientSide";
        switch (s) {
          case "clientSide": {
            const { treeDataChildrenField: o, treeDataParentIdField: n, getDataPath: r, getRowId: a } = i;
            if (!o && !n && !r)
              return "treeData requires either 'treeDataChildrenField' or 'treeDataParentIdField' or 'getDataPath' in the clientSide row model.";
            if (o) {
              if (r)
                return "Cannot use both 'treeDataChildrenField' and 'getDataPath' at the same time.";
              if (n)
                return "Cannot use both 'treeDataChildrenField' and 'treeDataParentIdField' at the same time.";
            }
            if (n) {
              if (!a)
                return "getRowId callback not provided, tree data with parent id cannot be built.";
              if (r)
                return "Cannot use both 'treeDataParentIdField' and 'getDataPath' at the same time.";
            }
            return null;
          }
          case "serverSide": {
            const o = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${s} row model.`;
            return i.isServerSideGroup && i.getServerSideGroupKey ? null : o;
          }
        }
        return null;
      }
    },
    viewportDatasource: {
      supportedRowModels: ["viewport"]
    },
    viewportRowModelBufferSize: {
      validate({ viewportRowModelBufferSize: i }) {
        return Ct("viewportRowModelBufferSize", i, 0);
      }
    },
    viewportRowModelPageSize: {
      validate({ viewportRowModelPageSize: i }) {
        return Ct("viewportRowModelPageSize", i, 1);
      }
    },
    rowDragEntireRow: {
      dependencies: {
        cellSelection: { required: [void 0] }
      }
    },
    autoGroupColumnDef: {
      validate({ autoGroupColumnDef: i, showOpenedGroup: s }) {
        return i != null && i.field && s ? "autoGroupColumnDef.field and showOpenedGroup are not supported when used together." : i != null && i.valueGetter && s ? "autoGroupColumnDef.valueGetter and showOpenedGroup are not supported when used together." : null;
      }
    },
    renderingMode: {
      validate: (i) => {
        const s = i.renderingMode, o = ["default", "legacy"];
        return s && !o.includes(s) ? `renderingMode must be one of [${o.join()}], currently it's ${s}` : null;
      }
    }
  }, t = {};
  return Dp.forEach((i) => {
    t[i] = { expectedType: "boolean" };
  }), Ep.forEach((i) => {
    t[i] = { expectedType: "number" };
  }), Be(t, e), t;
}, S0 = () => ({
  objectName: "gridOptions",
  allProperties: [...il(), ...Object.values(Fr)],
  propertyExceptions: ["api"],
  docsUrl: "grid-options/",
  deprecations: w0(),
  validations: y0()
}), R0 = 0, x0 = 0, Nc = "__ag_grid_instance", F0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "gos", this.domDataKey = "__AG_" + Math.random().toString(), this.instanceId = x0++, this.gridReadyFired = !1, this.queueEvents = [], this.propEventSvc = new Li(), this.globalEventHandlerFactory = (e) => (t, i) => {
      if (!this.isAlive())
        return;
      const s = ro.has(t);
      if (s && !e || !s && e || !P0(t))
        return;
      const o = (n, r) => {
        const a = Fr[n], l = this.gridOptions[a];
        typeof l == "function" && this.beans.frameworkOverrides.wrapOutgoing(() => l(r));
      };
      if (this.gridReadyFired)
        o(t, i);
      else if (t === "gridReady") {
        o(t, i), this.gridReadyFired = !0;
        for (const n of this.queueEvents)
          o(n.eventName, n.event);
        this.queueEvents = [];
      } else
        this.queueEvents.push({ eventName: t, event: i });
    };
  }
  wireBeans(e) {
    this.gridOptions = e.gridOptions, this.validation = e.validation, this.api = e.gridApi, this.gridId = e.context.getId();
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get gridOptionsContext() {
    return this.gridOptions.context;
  }
  postConstruct() {
    this.validateGridOptions(this.gridOptions), this.eventSvc.addGlobalListener(this.globalEventHandlerFactory().bind(this), !0), this.eventSvc.addGlobalListener(this.globalEventHandlerFactory(!0).bind(this), !1), this.propEventSvc.setFrameworkOverrides(this.beans.frameworkOverrides), this.addManagedEventListeners({
      gridOptionsChanged: ({ options: e }) => {
        this.updateGridOptions({ options: e, force: !0, source: "optionsUpdated" });
      }
    });
  }
  destroy() {
    super.destroy(), this.queueEvents = [];
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(e) {
    return this.gridOptions[e] ?? AC[e];
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(e) {
    return this.mergeGridCommonParams(this.gridOptions[e]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(e) {
    return H(this.gridOptions[e]);
  }
  /**
   * Wrap the user callback and attach the api and context to the params object on the way through.
   * @param callback User provided callback
   * @returns Wrapped callback where the params object not require api and context
   */
  mergeGridCommonParams(e) {
    return e && ((i) => e(this.addCommon(i)));
  }
  updateGridOptions({
    options: e,
    force: t,
    source: i = "api"
  }) {
    const s = { id: R0++, properties: [] }, o = [], { gridOptions: n, validation: r } = this;
    for (const a of Object.keys(e)) {
      const l = e[a];
      r == null || r.warnOnInitialPropertyUpdate(i, a);
      const d = t || typeof l == "object" && i === "api", c = n[a];
      if (d || c !== l) {
        n[a] = l;
        const u = {
          type: a,
          currentValue: l,
          previousValue: c,
          changeSet: s,
          source: i
        };
        o.push(u);
      }
    }
    this.validateGridOptions(this.gridOptions), s.properties = o.map((a) => a.type), o.forEach((a) => {
      ni(this, `Updated property ${a.type} from`, a.previousValue, " to ", a.currentValue), this.propEventSvc.dispatchEvent(a);
    });
  }
  addPropertyEventListener(e, t) {
    this.propEventSvc.addEventListener(e, t);
  }
  removePropertyEventListener(e, t) {
    this.propEventSvc.removeEventListener(e, t);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  /** Prefer _addGridCommonParams from gridOptionsUtils for bundle size savings */
  addCommon(e) {
    return e.api = this.api, e.context = this.gridOptionsContext, e;
  }
  validateOptions(e, t) {
    for (const i of Object.keys(e)) {
      const s = e[i];
      if (s == null || s === !1)
        continue;
      let o = t[i];
      typeof o == "function" && (o = o(e, this.gridOptions, this.beans)), o && this.assertModuleRegistered(o, i);
    }
  }
  validateGridOptions(e) {
    var t;
    this.validateOptions(e, b0), (t = this.validation) == null || t.processGridOptions(e);
  }
  validateColDef(e, t, i) {
    var s, o;
    (i || !((s = this.beans.dataTypeSvc) != null && s.isColPendingInference(t))) && (this.validateOptions(e, l0), (o = this.validation) == null || o.validateColDef(e));
  }
  assertModuleRegistered(e, t) {
    const i = Array.isArray(e) ? e.some((s) => this.isModuleRegistered(s)) : this.isModuleRegistered(e);
    return i || Z(200, {
      ...this.getModuleErrorParams(),
      moduleName: e,
      reasonOrId: t
    }), i;
  }
  getModuleErrorParams() {
    return {
      gridId: this.gridId,
      gridScoped: ed(),
      rowModelType: this.get("rowModelType"),
      isUmd: dF()
    };
  }
  isModuleRegistered(e) {
    return tl(e, this.gridId, this.get("rowModelType"));
  }
  setInstanceDomData(e) {
    e[Nc] = this.instanceId;
  }
  isElementInThisInstance(e) {
    let t = e;
    for (; t; ) {
      const i = t[Nc];
      if (H(i))
        return i === this.instanceId;
      t = t.parentElement;
    }
    return !1;
  }
};
function P0(e) {
  return !!Fr[e];
}
function Tp(e) {
  const t = { "aria-hidden": "true" };
  return {
    tag: "div",
    cls: "ag-cell-label-container",
    role: "presentation",
    children: [
      {
        tag: "span",
        ref: "eMenu",
        cls: "ag-header-icon ag-header-cell-menu-button",
        attrs: t
      },
      {
        tag: "span",
        ref: "eFilterButton",
        cls: "ag-header-icon ag-header-cell-filter-button",
        attrs: t
      },
      {
        tag: "div",
        ref: "eLabel",
        cls: "ag-header-cell-label",
        role: "presentation",
        children: [
          { tag: "span", ref: "eText", cls: "ag-header-cell-text" },
          {
            tag: "span",
            ref: "eFilter",
            cls: "ag-header-icon ag-header-label-icon ag-filter-icon",
            attrs: t
          },
          e ? { tag: "ag-sort-indicator", ref: "eSortIndicator" } : null
        ]
      }
    ]
  };
}
var E0 = Tp(!0), D0 = Tp(!1), T0 = class extends te {
  constructor() {
    super(...arguments), this.eFilter = _, this.eFilterButton = _, this.eSortIndicator = _, this.eMenu = _, this.eLabel = _, this.eText = _, this.eSortOrder = _, this.eSortAsc = _, this.eSortDesc = _, this.eSortMixed = _, this.eSortNone = _, this.isLoadingInnerComponent = !1;
  }
  refresh(e) {
    var i, s, o;
    const t = this.params;
    if (this.params = e, this.workOutTemplate(e, !!((i = this.beans) != null && i.sortSvc)) != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || e.enableSorting != this.currentSort || this.currentSuppressMenuHide != null && this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || t.enableFilterButton != e.enableFilterButton || t.enableFilterIcon != e.enableFilterIcon)
      return !1;
    if (this.innerHeaderComponent) {
      const n = { ...e };
      Be(n, e.innerHeaderComponentParams), (o = (s = this.innerHeaderComponent).refresh) == null || o.call(s, n);
    } else
      this.setDisplayName(e);
    return !0;
  }
  workOutTemplate(e, t) {
    const i = e.template;
    return i ? i != null && i.trim ? i.trim() : i : t ? E0 : D0;
  }
  init(e) {
    this.params = e;
    const { sortSvc: t, touchSvc: i, rowNumbersSvc: s, userCompFactory: o } = this.beans, n = t == null ? void 0 : t.getSortIndicatorSelector();
    this.currentTemplate = this.workOutTemplate(e, !!n), this.setTemplate(this.currentTemplate, n ? [n] : void 0), i == null || i.setupForHeader(this), this.setMenu(), this.setupSort(), s == null || s.setupForHeader(this), this.setupFilterIcon(), this.setupFilterButton(), this.workOutInnerHeaderComponent(o, e), this.setDisplayName(e);
  }
  workOutInnerHeaderComponent(e, t) {
    const i = Uv(e, t, t);
    i && (this.isLoadingInnerComponent = !0, i.newAgStackInstance().then((s) => {
      this.isLoadingInnerComponent = !1, s && (this.isAlive() ? (this.innerHeaderComponent = s, this.eText && this.eText.appendChild(s.getGui())) : this.destroyBean(s));
    }));
  }
  setDisplayName(e) {
    const { displayName: t } = e, i = this.currentDisplayName;
    this.currentDisplayName = t, !(!this.eText || i === t || this.innerHeaderComponent || this.isLoadingInnerComponent) && (this.eText.textContent = Es(t));
  }
  addInIcon(e, t, i) {
    const s = Ze(e, this.beans, i);
    s && t.appendChild(s);
  }
  workOutShowMenu() {
    var e;
    return this.params.enableMenu && !!((e = this.beans.menuSvc) != null && e.isHeaderMenuButtonEnabled());
  }
  shouldSuppressMenuHide() {
    var e;
    return !!((e = this.beans.menuSvc) != null && e.isHeaderMenuButtonAlwaysShowEnabled());
  }
  setMenu() {
    if (!this.eMenu)
      return;
    if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
      dt(this.eMenu), this.eMenu = void 0;
      return;
    }
    const { gos: e, eMenu: t, params: i } = this, s = $e(e);
    this.addInIcon(s ? "menu" : "menuAlt", t, i.column), t.classList.toggle("ag-header-menu-icon", !s);
    const o = this.shouldSuppressMenuHide();
    this.currentSuppressMenuHide = o, this.addManagedElementListeners(t, { click: () => this.showColumnMenu(this.eMenu) }), this.toggleMenuAlwaysShow(o);
  }
  toggleMenuAlwaysShow(e) {
    var t;
    (t = this.eMenu) == null || t.classList.toggle("ag-header-menu-always-show", e);
  }
  showColumnMenu(e) {
    const { currentSuppressMenuHide: t, params: i } = this;
    t || this.toggleMenuAlwaysShow(!0), i.showColumnMenu(e, () => {
      t || this.toggleMenuAlwaysShow(!1);
    });
  }
  onMenuKeyboardShortcut(e) {
    var l;
    const { params: t, gos: i, beans: s, eMenu: o, eFilterButton: n } = this, r = t.column, a = $e(i);
    if (e && !a) {
      if ((l = s.menuSvc) != null && l.isFilterMenuInHeaderEnabled(r))
        return t.showFilter(n ?? o ?? this.getGui()), !0;
    } else if (t.enableMenu)
      return this.showColumnMenu(o ?? n ?? this.getGui()), !0;
    return !1;
  }
  setupSort() {
    const { sortSvc: e } = this.beans;
    if (!e)
      return;
    const { enableSorting: t, column: i } = this.params;
    if (this.currentSort = t, !this.eSortIndicator) {
      this.eSortIndicator = this.createBean(e.createSortIndicator(!0));
      const { eSortIndicator: s, eSortOrder: o, eSortAsc: n, eSortDesc: r, eSortMixed: a, eSortNone: l } = this;
      s.attachCustomElements(o, n, r, a, l);
    }
    this.eSortIndicator.setupSort(i), this.currentSort && e.setupHeader(this, i, this.eLabel);
  }
  setupFilterIcon() {
    const { eFilter: e, params: t } = this;
    if (!e)
      return;
    const i = () => {
      const s = t.column.isFilterActive();
      le(e, s, { skipAriaHidden: !0 });
    };
    this.configureFilter(t.enableFilterIcon, e, i, "filterActive");
  }
  setupFilterButton() {
    const { eFilterButton: e, params: t } = this;
    if (!e)
      return;
    this.configureFilter(
      t.enableFilterButton,
      e,
      this.onFilterChangedButton.bind(this),
      "filter"
    ) ? this.addManagedElementListeners(e, {
      click: () => t.showFilter(e)
    }) : this.eFilterButton = void 0;
  }
  configureFilter(e, t, i, s) {
    if (!e)
      return dt(t), !1;
    const o = this.params.column;
    return this.addInIcon(s, t, o), this.addManagedListeners(o, { filterChanged: i }), i(), !0;
  }
  onFilterChangedButton() {
    const e = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", e);
  }
  getAnchorElementForMenu(e) {
    const { eFilterButton: t, eMenu: i } = this;
    return e ? t ?? i ?? this.getGui() : i ?? t ?? this.getGui();
  }
  destroy() {
    super.destroy(), this.innerHeaderComponent && (this.destroyBean(this.innerHeaderComponent), this.innerHeaderComponent = void 0);
  }
}, M0 = {
  tag: "div",
  cls: "ag-header-group-cell-label",
  role: "presentation",
  children: [
    { tag: "span", ref: "agLabel", cls: "ag-header-group-text", role: "presentation" },
    { tag: "span", ref: "agOpened", cls: "ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded" },
    { tag: "span", ref: "agClosed", cls: "ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed" }
  ]
}, A0 = class extends te {
  constructor() {
    super(M0), this.agOpened = _, this.agClosed = _, this.agLabel = _, this.isLoadingInnerComponent = !1;
  }
  init(e) {
    const { userCompFactory: t, touchSvc: i } = this.beans;
    this.params = e, this.checkWarnings(), this.workOutInnerHeaderGroupComponent(t, e), this.setupLabel(e), this.addGroupExpandIcon(e), this.setupExpandIcons(), i == null || i.setupForHeaderGroup(this);
  }
  checkWarnings() {
    this.params.template && I(89);
  }
  workOutInnerHeaderGroupComponent(e, t) {
    const i = Kv(e, t, t);
    i && (this.isLoadingInnerComponent = !0, i.newAgStackInstance().then((s) => {
      this.isLoadingInnerComponent = !1, s && (this.isAlive() ? (this.innerHeaderGroupComponent = s, this.agLabel.appendChild(s.getGui())) : this.destroyBean(s));
    }));
  }
  setupExpandIcons() {
    const {
      agOpened: e,
      agClosed: t,
      params: { columnGroup: i },
      beans: s
    } = this;
    this.addInIcon("columnGroupOpened", e), this.addInIcon("columnGroupClosed", t);
    const o = (l) => {
      if (Wt(l))
        return;
      const d = !i.isExpanded();
      s.colGroupSvc.setColumnGroupOpened(
        i.getProvidedColumnGroup(),
        d,
        "uiColumnExpanded"
      );
    };
    this.addTouchAndClickListeners(s, t, o), this.addTouchAndClickListeners(s, e, o);
    const n = (l) => {
      Bi(l);
    };
    this.addManagedElementListeners(t, { dblclick: n }), this.addManagedElementListeners(e, { dblclick: n }), this.addManagedElementListeners(this.getGui(), { dblclick: o }), this.updateIconVisibility();
    const r = i.getProvidedColumnGroup(), a = this.updateIconVisibility.bind(this);
    this.addManagedListeners(r, {
      expandedChanged: a,
      expandableChanged: a
    });
  }
  addTouchAndClickListeners(e, t, i) {
    var s;
    (s = e.touchSvc) == null || s.setupForHeaderGroupElement(this, t, i), this.addManagedElementListeners(t, { click: i });
  }
  updateIconVisibility() {
    const {
      agOpened: e,
      agClosed: t,
      params: { columnGroup: i }
    } = this;
    if (i.isExpandable()) {
      const s = i.isExpanded();
      le(e, s), le(t, !s);
    } else
      le(e, !1), le(t, !1);
  }
  addInIcon(e, t) {
    const i = Ze(e, this.beans, null);
    i && t.appendChild(i);
  }
  addGroupExpandIcon(e) {
    if (!e.columnGroup.isExpandable()) {
      const { agOpened: t, agClosed: i } = this;
      le(t, !1), le(i, !1);
      return;
    }
  }
  setupLabel(e) {
    var o;
    const { displayName: t, columnGroup: i } = e, s = this.innerHeaderGroupComponent || this.isLoadingInnerComponent;
    H(t) && !s && (this.agLabel.textContent = Es(t)), this.toggleCss("ag-sticky-label", !((o = i.getColGroupDef()) != null && o.suppressStickyLabel));
  }
  destroy() {
    super.destroy(), this.innerHeaderGroupComponent && (this.destroyBean(this.innerHeaderGroupComponent), this.innerHeaderGroupComponent = void 0);
  }
}, I0 = {
  moduleName: "ColumnHeaderComp",
  version: B,
  userComponents: {
    agColumnHeader: T0
  },
  icons: {
    // button to launch legacy column menu
    menu: "menu",
    // button to launch new enterprise column menu
    menuAlt: "menu-alt"
  }
}, k0 = {
  moduleName: "ColumnGroupHeaderComp",
  version: B,
  userComponents: {
    agColumnGroupHeader: A0
  },
  icons: {
    // header column group shown when expanded (click to contract)
    columnGroupOpened: "expanded",
    // header column group shown when contracted (click to expand)
    columnGroupClosed: "contracted"
  }
}, L0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "animationFrameSvc", this.p1 = { list: [], sorted: !1 }, this.p2 = { list: [], sorted: !1 }, this.f1 = { list: [], sorted: !1 }, this.destroyTasks = [], this.ticking = !1, this.scrollGoingDown = !0, this.lastScrollTop = 0, this.taskCount = 0;
  }
  setScrollTop(e) {
    this.scrollGoingDown = e >= this.lastScrollTop, e === 0 && (this.scrollGoingDown = !0), this.lastScrollTop = e;
  }
  postConstruct() {
    this.active = !this.gos.get("suppressAnimationFrame"), this.batchFrameworkComps = this.beans.frameworkOverrides.batchFrameworkComps;
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verify() {
    this.active === !1 && I(92);
  }
  createTask(e, t, i, s, o = !1) {
    this.verify();
    let n = i;
    s && this.batchFrameworkComps && (n = "f1");
    const r = { task: e, index: t, createOrder: ++this.taskCount, deferred: o };
    this.addTaskToList(this[n], r), this.schedule();
  }
  addTaskToList(e, t) {
    e.list.push(t), e.sorted = !1;
  }
  sortTaskList(e) {
    if (e.sorted)
      return;
    const t = this.scrollGoingDown ? 1 : -1;
    e.list.sort((i, s) => i.deferred !== s.deferred ? i.deferred ? -1 : 1 : i.index !== s.index ? t * (s.index - i.index) : s.createOrder - i.createOrder), e.sorted = !0;
  }
  addDestroyTask(e) {
    this.verify(), this.destroyTasks.push(e), this.schedule();
  }
  executeFrame(e) {
    const { p1: t, p2: i, f1: s, destroyTasks: o, beans: n } = this, { ctrlsSvc: r, frameworkOverrides: a } = n, l = t.list, d = i.list, c = s.list, u = Date.now();
    let h = 0;
    const g = e <= 0, p = r.getScrollFeature();
    for (; g || h < e; ) {
      if (!p.scrollGridIfNeeded()) {
        let m;
        if (l.length)
          this.sortTaskList(t), m = l.pop().task;
        else if (d.length)
          this.sortTaskList(i), m = d.pop().task;
        else if (c.length)
          a.wrapOutgoing(() => {
            for (; (g || h < e) && !p.scrollGridIfNeeded(); ) {
              if (c.length)
                this.sortTaskList(s), m = c.pop().task, m();
              else
                break;
              h = Date.now() - u;
            }
          }), m = () => {
          };
        else if (o.length)
          m = o.pop();
        else
          break;
        m();
      }
      h = Date.now() - u;
    }
    l.length || d.length || c.length || o.length ? this.requestFrame() : this.ticking = !1;
  }
  flushAllFrames() {
    this.active && this.executeFrame(-1);
  }
  schedule() {
    this.active && (this.ticking || (this.ticking = !0, this.requestFrame()));
  }
  requestFrame() {
    const e = this.executeFrame.bind(this, 60);
    $t(this.beans, e);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
}, O0 = {
  moduleName: "AnimationFrame",
  version: B,
  beans: [L0]
}, _0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "iconSvc";
  }
  createIconNoSpan(e, t) {
    return Ze(e, this.beans, t == null ? void 0 : t.column);
  }
}, H0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "touchSvc";
  }
  mockBodyContextMenu(e, t) {
    this.mockContextMenu(e, e.eBodyViewport, t);
  }
  mockHeaderContextMenu(e, t) {
    this.mockContextMenu(e, e.eGui, t);
  }
  mockRowContextMenu(e) {
    if (!Mi())
      return;
    const t = (i, s, o) => {
      var a;
      const { rowCtrl: n, cellCtrl: r } = e.getControlsForEventTarget((o == null ? void 0 : o.target) ?? null);
      r != null && r.column && r.dispatchCellContextMenuEvent(o ?? null), (a = this.beans.contextMenuSvc) == null || a.handleContextMenuMouseEvent(void 0, o, n, r);
    };
    this.mockContextMenu(e, e.element, t);
  }
  handleCellDoubleClick(e, t) {
    return (() => {
      if (!Mi() || Hh("dblclick"))
        return !1;
      const s = Date.now(), o = s - e.lastIPadMouseClickEvent < 200;
      return e.lastIPadMouseClickEvent = s, o;
    })() ? (e.onCellDoubleClicked(t), t.preventDefault(), !0) : !1;
  }
  setupForHeader(e) {
    const { gos: t, sortSvc: i, menuSvc: s } = this.beans;
    if (t.get("suppressTouch"))
      return;
    const { params: o, eMenu: n, eFilterButton: r } = e, a = new bi(e.getGui(), !0), l = e.shouldSuppressMenuHide(), d = l && H(n) && o.enableMenu, c = d ? new bi(n, !0) : a;
    if (o.enableMenu || s != null && s.isHeaderContextMenuEnabled(o.column)) {
      const u = d ? "tap" : "longTap", h = (g) => o.showColumnMenuAfterMouseClick(g.touchStart);
      e.addManagedListeners(c, { [u]: h });
    }
    if (o.enableSorting) {
      const u = (h) => {
        const g = h.touchStart.target;
        l && (n != null && n.contains(g) || r != null && r.contains(g)) || i == null || i.progressSort(o.column, !1, "uiColumnSorted");
      };
      e.addManagedListeners(a, { tap: u });
    }
    if (o.enableFilterButton && r) {
      const u = new bi(r, !0);
      e.addManagedListeners(u, {
        tap: () => o.showFilter(r)
      }), e.addDestroyFunc(() => u.destroy());
    }
    e.addDestroyFunc(() => a.destroy()), d && e.addDestroyFunc(() => c.destroy());
  }
  setupForHeaderGroup(e) {
    var i;
    const t = e.params;
    if ((i = this.beans.menuSvc) != null && i.isHeaderContextMenuEnabled(
      t.columnGroup.getProvidedColumnGroup()
    )) {
      const s = new bi(t.eGridHeader, !0), o = (n) => t.showColumnMenuAfterMouseClick(n.touchStart);
      e.addManagedListeners(s, { longTap: o }), e.addDestroyFunc(() => s.destroy());
    }
  }
  setupForHeaderGroupElement(e, t, i) {
    const s = new bi(t, !0);
    e.addManagedListeners(s, { tap: i }), e.addDestroyFunc(() => s.destroy());
  }
  mockContextMenu(e, t, i) {
    if (!Mi())
      return;
    const s = new bi(t), o = (n) => {
      Ro(this.beans, n.touchEvent) && i(void 0, n.touchStart, n.touchEvent);
    };
    e.addManagedListeners(s, { longTap: o }), e.addDestroyFunc(() => s.destroy());
  }
}, B0 = {
  moduleName: "Touch",
  version: B,
  beans: [H0]
}, G0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "cellNavigation";
  }
  wireBeans(e) {
    this.rowSpanSvc = e.rowSpanSvc;
  }
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(e, t, i = !1) {
    return i ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t);
  }
  getNextCellToFocusWithCtrlPressed(e, t) {
    const i = e === P.UP, s = e === P.DOWN, o = e === P.LEFT;
    let n, r;
    const { pageBounds: a, gos: l, visibleCols: d, pinnedRowModel: c } = this.beans, { rowPinned: u } = t;
    if (i || s)
      u && c ? i ? r = 0 : r = u === "top" ? c.getPinnedTopRowCount() - 1 : c.getPinnedBottomRowCount() - 1 : r = i ? a.getFirstRow() : a.getLastRow(), n = t.column;
    else {
      const h = l.get("enableRtl");
      r = t.rowIndex, n = (o !== h ? d.allCols : [...d.allCols].reverse()).find(
        (p) => this.isCellGoodToFocusOn({
          rowIndex: r,
          rowPinned: null,
          column: p
        })
      );
    }
    return n ? {
      rowIndex: r,
      rowPinned: u,
      column: n
    } : null;
  }
  getNextCellToFocusWithoutCtrlPressed(e, t) {
    let i = t, s = !1;
    for (; !s; ) {
      switch (e) {
        case P.UP:
          i = this.getCellAbove(i);
          break;
        case P.DOWN:
          i = this.getCellBelow(i);
          break;
        case P.RIGHT:
          i = this.gos.get("enableRtl") ? this.getCellToLeft(i) : this.getCellToRight(i);
          break;
        case P.LEFT:
          i = this.gos.get("enableRtl") ? this.getCellToRight(i) : this.getCellToLeft(i);
          break;
        default:
          i = null, I(8, { key: e });
          break;
      }
      i ? s = this.isCellGoodToFocusOn(i) : s = !0;
    }
    return i;
  }
  isCellGoodToFocusOn(e) {
    const t = e.column;
    let i;
    const { pinnedRowModel: s, rowModel: o } = this.beans;
    switch (e.rowPinned) {
      case "top":
        i = s == null ? void 0 : s.getPinnedTopRow(e.rowIndex);
        break;
      case "bottom":
        i = s == null ? void 0 : s.getPinnedBottomRow(e.rowIndex);
        break;
      default:
        i = o.getRow(e.rowIndex);
        break;
    }
    return i ? !this.isSuppressNavigable(t, i) : !1;
  }
  getCellToLeft(e) {
    if (!e)
      return null;
    const t = this.beans.visibleCols.getColBefore(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellToRight(e) {
    if (!e)
      return null;
    const t = this.beans.visibleCols.getColAfter(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellBelow(e) {
    var s;
    if (!e)
      return null;
    const t = ((s = this.rowSpanSvc) == null ? void 0 : s.getCellEnd(e)) ?? e, i = Dc(this.beans, t, !0);
    return i ? {
      rowIndex: i.rowIndex,
      column: e.column,
      rowPinned: i.rowPinned
    } : null;
  }
  getCellAbove(e) {
    var s;
    if (!e)
      return null;
    const t = ((s = this.rowSpanSvc) == null ? void 0 : s.getCellStart(e)) ?? e, i = ir(
      this.beans,
      {
        rowIndex: t.rowIndex,
        rowPinned: t.rowPinned
      },
      !0
    );
    return i ? {
      rowIndex: i.rowIndex,
      column: e.column,
      rowPinned: i.rowPinned
    } : null;
  }
  getNextTabbedCell(e, t) {
    return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e);
  }
  getNextTabbedCellForwards(e) {
    const { visibleCols: t, pagination: i } = this.beans, s = t.allCols;
    let o = e.rowIndex, n = e.rowPinned, r = t.getColAfter(e.column);
    if (!r) {
      r = s[0];
      const a = Dc(this.beans, e, !0);
      if (de(a) || !a.rowPinned && !((i == null ? void 0 : i.isRowInPage(a.rowIndex)) ?? !0))
        return null;
      o = a ? a.rowIndex : null, n = a ? a.rowPinned : null;
    }
    return { rowIndex: o, column: r, rowPinned: n };
  }
  getNextTabbedCellBackwards(e) {
    const { beans: t } = this, { visibleCols: i, pagination: s } = t, o = i.allCols;
    let n = e.rowIndex, r = e.rowPinned, a = i.getColBefore(e.column);
    if (!a) {
      a = se(o);
      const l = ir(t, { rowIndex: e.rowIndex, rowPinned: e.rowPinned }, !0);
      if (de(l) || !l.rowPinned && !((s == null ? void 0 : s.isRowInPage(l.rowIndex)) ?? !0))
        return null;
      n = l ? l.rowIndex : null, r = l ? l.rowPinned : null;
    }
    return { rowIndex: n, column: a, rowPinned: r };
  }
  isSuppressNavigable(e, t) {
    const { suppressNavigable: i } = e.colDef;
    if (typeof i == "boolean")
      return i;
    if (typeof i == "function") {
      const s = e.createColumnFunctionCallbackParams(t);
      return i(s);
    }
    return !1;
  }
};
function V0(e) {
  return e.focusSvc.getFocusedCell();
}
function N0(e) {
  return e.focusSvc.clearFocusedCell();
}
function W0(e, t, i, s) {
  e.focusSvc.setFocusedCell({ rowIndex: t, column: i, rowPinned: s, forceBrowserFocus: !0 });
}
function z0(e, t) {
  var i;
  return ((i = e.navigation) == null ? void 0 : i.tabToNextCell(!1, t)) ?? !1;
}
function U0(e, t) {
  var i;
  return ((i = e.navigation) == null ? void 0 : i.tabToNextCell(!0, t)) ?? !1;
}
function $0(e, t, i = !1) {
  var o;
  const s = (o = e.headerNavigation) == null ? void 0 : o.getHeaderPositionForColumn(t, i);
  s && e.focusSvc.focusHeaderPosition({ headerPosition: s });
}
var K0 = class extends E {
  constructor() {
    super(...arguments), this.beanName = "editModelSvc", this.edits = /* @__PURE__ */ new Map(), this.cellValidations = new Mp(), this.rowValidations = new Ap(), this.suspendEdits = !1;
  }
  suspend(e) {
    this.suspendEdits = e;
  }
  removeEdits({ rowNode: e, column: t }) {
    if (!this.hasEdits({ rowNode: e }) || !e)
      return;
    const i = this.getEditRow(e);
    t ? i.delete(t) : i.clear(), i.size === 0 && this.edits.delete(e);
  }
  getEditRow(e, t = {}) {
    if (this.suspendEdits || this.edits.size === 0)
      return;
    const i = e && this.edits.get(e);
    if (i)
      return i;
    if (t.checkSiblings) {
      const s = e.pinnedSibling;
      if (s)
        return this.getEditRow(s);
    }
  }
  getEditRowDataValue(e, { checkSiblings: t } = {}) {
    if (!e || this.edits.size === 0)
      return;
    const i = this.getEditRow(e), s = e.pinnedSibling, o = t && s && this.getEditRow(s);
    if (!i && !o)
      return;
    const n = Object.assign({}, e.data), r = (a, l) => a.forEach(({ pendingValue: d }, c) => {
      d !== it && (l[c.getColId()] = d);
    });
    return i && r(i, n), o && r(o, n), n;
  }
  getEdit(e, t) {
    const i = this._getEdit(e);
    return t && i ? { ...i } : i;
  }
  _getEdit(e) {
    var t;
    if (!this.suspendEdits && this.edits.size !== 0)
      return e.rowNode && e.column && ((t = this.getEditRow(e.rowNode)) == null ? void 0 : t.get(e.column));
  }
  getEditMap(e = !0) {
    if (this.suspendEdits || this.edits.size === 0)
      return /* @__PURE__ */ new Map();
    if (!e)
      return this.edits;
    const t = /* @__PURE__ */ new Map();
    return this.edits.forEach((i, s) => {
      const o = /* @__PURE__ */ new Map();
      i.forEach(
        ({ editorState: n, ...r }, a) => (
          // Ensure we copy the cell data to avoid reference issues
          o.set(a, { ...r })
        )
      ), t.set(s, o);
    }), t;
  }
  setEditMap(e) {
    this.edits.clear(), e.forEach((t, i) => {
      const s = /* @__PURE__ */ new Map();
      t.forEach(
        (o, n) => (
          // Ensure we copy the cell data to avoid reference issues
          s.set(n, { ...o })
        )
      ), this.edits.set(i, s);
    });
  }
  setEdit(e, t) {
    (this.edits.size === 0 || !this.edits.has(e.rowNode)) && this.edits.set(e.rowNode, /* @__PURE__ */ new Map());
    const i = this._getEdit(e), s = Object.assign({
      editorState: {
        isCancelAfterEnd: void 0,
        isCancelBeforeStart: void 0
      },
      ...i,
      ...t
    });
    return this.getEditRow(e.rowNode).set(e.column, s), s;
  }
  clearEditValue(e) {
    var s;
    const { rowNode: t, column: i } = e;
    if (t)
      if (i) {
        const o = this._getEdit(e);
        o && (o.editorValue = void 0, o.pendingValue = o.sourceValue, o.state = "changed");
      } else
        (s = this.getEditRow(t)) == null || s.forEach((o) => {
          o.editorValue = void 0, o.pendingValue = o.sourceValue, o.state = "changed";
        });
  }
  getState(e) {
    var t;
    if (!this.suspendEdits)
      return (t = this.getEdit(e)) == null ? void 0 : t.state;
  }
  getEditPositions(e) {
    if (this.suspendEdits || (e ?? this.edits).size === 0)
      return [];
    const t = [];
    return (e ?? this.edits).forEach((i, s) => {
      for (const o of i.keys()) {
        const { editorState: n, ...r } = i.get(o);
        t.push({
          rowNode: s,
          column: o,
          ...r
        });
      }
    }), t;
  }
  hasRowEdits(e, t) {
    return this.suspendEdits || this.edits.size === 0 ? !1 : !!this.getEditRow(e, t);
  }
  hasEdits(e = {}, t = {}) {
    var n;
    if (this.suspendEdits || this.edits.size === 0)
      return !1;
    const { rowNode: i, column: s } = e, { withOpenEditor: o } = t;
    if (i) {
      const r = this.getEditRow(i, t);
      return r ? s ? o ? ((n = this.getEdit(e)) == null ? void 0 : n.state) === "editing" : r.has(s) ?? !1 : r.size !== 0 ? o ? Array.from(r.values()).some(({ state: a }) => a === "editing") : !0 : !1 : !1;
    }
    return o ? this.getEditPositions().some(({ state: r }) => r === "editing") : this.edits.size > 0;
  }
  start(e) {
    const t = this.getEditRow(e.rowNode) ?? /* @__PURE__ */ new Map(), { rowNode: i, column: s } = e;
    s && !t.has(s) && t.set(s, {
      editorValue: void 0,
      pendingValue: it,
      sourceValue: this.beans.valueSvc.getValue(s, i, !1, "api"),
      state: "editing",
      editorState: {
        isCancelAfterEnd: void 0,
        isCancelBeforeStart: void 0
      }
    }), this.edits.set(i, t);
  }
  stop(e) {
    this.hasEdits(e) && (e ? this.removeEdits(e) : this.clear());
  }
  clear() {
    for (const e of this.edits.values())
      e.clear();
    this.edits.clear();
  }
  getCellValidationModel() {
    return this.cellValidations;
  }
  getRowValidationModel() {
    return this.rowValidations;
  }
  setCellValidationModel(e) {
    this.cellValidations = e;
  }
  setRowValidationModel(e) {
    this.rowValidations = e;
  }
  destroy() {
    super.destroy(), this.clear();
  }
}, Mp = class {
  constructor() {
    this.cellValidations = /* @__PURE__ */ new Map();
  }
  getCellValidation(e) {
    var s, o;
    const { rowNode: t, column: i } = e || {};
    return (o = (s = this.cellValidations) == null ? void 0 : s.get(t)) == null ? void 0 : o.get(i);
  }
  hasCellValidation(e) {
    return !e || !e.rowNode || !e.column ? this.cellValidations.size > 0 : !!this.getCellValidation(e);
  }
  setCellValidation(e, t) {
    const { rowNode: i, column: s } = e;
    this.cellValidations.has(i) || this.cellValidations.set(i, /* @__PURE__ */ new Map()), this.cellValidations.get(i).set(s, t);
  }
  clearCellValidation(e) {
    var s;
    const { rowNode: t, column: i } = e;
    (s = this.cellValidations.get(t)) == null || s.delete(i);
  }
  setCellValidationMap(e) {
    this.cellValidations = e;
  }
  getCellValidationMap() {
    return this.cellValidations;
  }
  clearCellValidationMap() {
    this.cellValidations.clear();
  }
}, Ap = class {
  constructor() {
    this.rowValidations = /* @__PURE__ */ new Map();
  }
  getRowValidation(e) {
    const { rowNode: t } = e || {};
    return this.rowValidations.get(t);
  }
  hasRowValidation(e) {
    return !e || !e.rowNode ? this.rowValidations.size > 0 : !!this.getRowValidation(e);
  }
  setRowValidation({ rowNode: e }, t) {
    this.rowValidations.set(e, t);
  }
  clearRowValidation({ rowNode: e }) {
    this.rowValidations.delete(e);
  }
  setRowValidationMap(e) {
    this.rowValidations = e;
  }
  getRowValidationMap() {
    return this.rowValidations;
  }
  clearRowValidationMap() {
    this.rowValidations.clear();
  }
};
function id(e, t = {}) {
  var d;
  const { rowIndex: i, rowId: s, rowCtrl: o, rowPinned: n } = t;
  if (o)
    return o;
  const { rowModel: r, rowRenderer: a } = e;
  let { rowNode: l } = t;
  return l || (s ? l = dR(e, s, n) : i != null && (l = r.getRow(i))), (d = a.getRowCtrls(l ? [l] : [])) == null ? void 0 : d[0];
}
function ue(e, t = {}) {
  var c;
  const { cellCtrl: i, colId: s, columnId: o, column: n } = t;
  if (i)
    return i;
  const r = e.colModel.getCol(s ?? o ?? sl(n)), a = t.rowCtrl ?? id(e, t), l = (a == null ? void 0 : a.getCellCtrl(r)) ?? void 0;
  if (l)
    return l;
  const d = t.rowNode ?? (a == null ? void 0 : a.rowNode);
  if (d)
    return (c = e.rowRenderer.getCellCtrls([d], [r])) == null ? void 0 : c[0];
}
function Wc(e) {
  const { editSvc: t } = e;
  t != null && t.isBatchEditing() ? ps(e) : t == null || t.stopEditing(void 0, { source: "api" });
}
function j0(e, t, i) {
  const { gos: s, popupSvc: o } = t;
  if (!s.get("stopEditingWhenCellsLoseFocus"))
    return;
  const n = (r) => {
    const a = r.relatedTarget;
    if (Va(a) === null) {
      Wc(t);
      return;
    }
    let l = (
      // see if click came from inside the viewports
      i.some((d) => d.contains(a)) && // and also that it's not from a detail grid
      s.isElementInThisInstance(a)
    );
    l || (l = !!o && (o.getActivePopups().some((d) => d.contains(a)) || o.isElementWithinCustomPopup(a))), l || Wc(t);
  };
  i.forEach((r) => e.addManagedElementListeners(r, { focusout: n }));
}
function sl(e) {
  if (e)
    return typeof e == "string" ? e : e.getColId();
}
var it = Symbol("unedited");
function Ip(e, t = {}) {
  var o;
  const i = [], s = e.rowRenderer.getCellCtrls(t.rowNodes, t.columns);
  for (const n of s) {
    const r = (o = n.comp) == null ? void 0 : o.getCellEditor();
    r && i.push({
      ctrl: n,
      editor: Po(r)
    });
  }
  return i;
}
var q0 = (e, t = {}) => Ip(e, t).map((i) => i.editor);
function Y0(e, t, i, s, o, n) {
  var u;
  t.length === 0 && (i != null && i.rowNode) && (i != null && i.column) && Rs(e, i, { key: s, event: o, cellStartedEdit: n });
  const { valueSvc: r, editSvc: a, editModelSvc: l } = e, { rowNode: d, column: c } = i ?? {};
  for (const h of t) {
    const { rowNode: g, column: p } = h, f = ue(e, h);
    if (!f) {
      if (g && p) {
        const C = r.getValue(p, g, void 0, "api"), b = ((i == null ? void 0 : i.rowNode) === g && (i == null ? void 0 : i.column) === p && s || void 0) ?? (a == null ? void 0 : a.getCellDataValue(h, !1)) ?? ((u = r.getValueForDisplay(p, g)) == null ? void 0 : u.value) ?? C ?? it;
        l == null || l.setEdit(h, {
          pendingValue: b,
          sourceValue: C,
          state: "editing"
        });
      }
      continue;
    }
    const m = n && d === f.rowNode && f.column === c;
    Rs(
      e,
      { rowNode: d, column: f.column },
      {
        key: m ? s : null,
        event: m ? o : null,
        cellStartedEdit: m && n
      }
    );
  }
}
function Gt({
  pendingValue: e,
  sourceValue: t
}) {
  return e === it && (e = t), e !== t;
}
function Rs(e, t, i) {
  var C, v, R, b, w, x, F, D, T, k;
  const s = e.gos.get("enableGroupEdit"), { key: o, event: n, cellStartedEdit: r, silent: a } = i ?? {}, l = ue(e, t), d = (C = l == null ? void 0 : l.comp) == null ? void 0 : C.getCellEditor(), c = Lp(e, t, o, r && !a), u = (v = e.editModelSvc) == null ? void 0 : v.getEdit(t);
  let h = c.value;
  if (h === void 0 && (h = u == null ? void 0 : u.sourceValue), (R = e.editModelSvc) == null || R.setEdit(t, {
    editorValue: h,
    state: "editing"
  }), d) {
    (b = d.refresh) == null || b.call(d, c);
    return;
  }
  const g = t.column.getColDef(), p = vg(e.userCompFactory, g, c), f = (p == null ? void 0 : p.popupFromSelector) != null ? p.popupFromSelector : !!g.cellEditorPopup, m = (p == null ? void 0 : p.popupPositionFromSelector) != null ? p.popupPositionFromSelector : g.cellEditorPopupPosition;
  if (Op(p.params, n), l) {
    l.editCompDetails = p, (w = l.comp) == null || w.setEditDetails(p, f, m, e.gos.get("reactiveCustomComponents")), (x = l == null ? void 0 : l.rowCtrl) == null || x.refreshRow({ suppressFlash: !0 });
    const A = (F = e.editModelSvc) == null ? void 0 : F.getEdit(t, !0);
    !a && !((D = A == null ? void 0 : A.editorState) != null && D.cellStartedEditing) && ((T = e.editSvc) == null || T.dispatchCellEvent(
      t,
      n,
      "cellEditingStarted",
      s ? { value: h } : {}
    ), (k = e.editModelSvc) == null || k.setEdit(t, { editorState: { cellStartedEditing: !0 } }));
  }
}
function kp(e, t, i) {
  var n, r;
  const s = { editorValueExists: !1 };
  if (sd(e)) {
    const a = (n = t.getValidationErrors) == null ? void 0 : n.call(t);
    if (((a == null ? void 0 : a.length) ?? 0) > 0)
      return s;
  }
  if (i != null && i.isCancelling)
    return s;
  if (i != null && i.isStopping) {
    const a = (r = t == null ? void 0 : t.isCancelAfterEnd) == null ? void 0 : r.call(t);
    if (a)
      return { ...s, isCancelAfterEnd: a };
  }
  return {
    editorValue: t.getValue(),
    editorValueExists: !0
  };
}
function Lp(e, t, i, s) {
  var C, v, R, b;
  const { valueSvc: o, gos: n, editSvc: r } = e, a = e.gos.get("enableGroupEdit"), l = ue(e, t), d = ((C = t.rowNode) == null ? void 0 : C.rowIndex) ?? void 0, c = r == null ? void 0 : r.isBatchEditing(), u = e.colModel.getCol(t.column.getId()), { rowNode: h, column: g } = t, p = (v = l.comp) == null ? void 0 : v.getCellEditor(), f = (r == null ? void 0 : r.getCellDataValue(t, !1)) ?? (p ? (R = kp(e, p)) == null ? void 0 : R.editorValue : void 0), m = f === it ? (b = o.getValueForDisplay(u, h)) == null ? void 0 : b.value : f;
  return W(n, {
    value: a ? f : m,
    eventKey: i ?? null,
    column: g,
    colDef: g.getColDef(),
    rowIndex: d,
    node: h,
    data: h.data,
    cellStartedEdit: s ?? !1,
    onKeyDown: l == null ? void 0 : l.onKeyDown.bind(l),
    stopEditing: (w) => {
      r.stopEditing(t, { source: c ? "ui" : "api", suppressNavigateAfterEdit: w }), nr(e, t);
    },
    eGridCell: l == null ? void 0 : l.eGui,
    parseValue: (w) => o.parseValue(u, h, w, l == null ? void 0 : l.value),
    formatValue: l == null ? void 0 : l.formatValue.bind(l),
    validate: () => {
      r == null || r.validateEdit();
    }
  });
}
function ol(e, t) {
  const { editModelSvc: i } = e;
  i == null || i.getEditMap().forEach((s, o) => {
    s.forEach((n, r) => {
      !t && (n.state === "editing" || n.pendingValue === it) || !Gt(n) && (n.state !== "editing" || t) && (i == null || i.removeEdits({ rowNode: o, column: r }));
    });
  });
}
function Q0(e, t) {
  var d;
  const i = (d = t.comp) == null ? void 0 : d.getCellEditor();
  if (!(i != null && i.refresh))
    return;
  const { eventKey: s, cellStartedEdit: o } = t.editCompDetails.params, { column: n } = t, r = Lp(e, t, s, o), a = n.getColDef(), l = vg(e.userCompFactory, a, r);
  i.refresh(Op(l.params, s));
}
function Op(e, t) {
  var i;
  return t instanceof KeyboardEvent && e.column.getColDef().cellEditor === "agNumberCellEditor" ? e.suppressPreventDefault = ["-", "+", ".", "e"].includes((t == null ? void 0 : t.key) ?? "") || e.suppressPreventDefault : (i = t == null ? void 0 : t.preventDefault) == null || i.call(t), e;
}
function xi(e, t) {
  var i;
  (i = e.editModelSvc) == null || i.getEditPositions().forEach((s) => {
    var d, c;
    const o = ue(e, s);
    if (!o)
      return;
    const n = (d = o.comp) == null ? void 0 : d.getCellEditor();
    if (!n)
      return;
    const { editorValue: r, editorValueExists: a, isCancelAfterEnd: l } = kp(e, n, t);
    l && ((c = e.editModelSvc) == null || c.setEdit(s, { editorState: { isCancelAfterEnd: l } })), kn(e, s, r, void 0, !a, t);
  });
}
function kn(e, t, i, s, o, n) {
  const { editModelSvc: r, valueSvc: a } = e;
  if (!r)
    return;
  const { rowNode: l, column: d } = t;
  if (!(l && d))
    return;
  let c = r.getEdit(t, !0);
  c != null && c.sourceValue || (c = r.setEdit(t, {
    sourceValue: a.getValue(d, l, void 0, "api"),
    pendingValue: c ? c.editorValue : it
  })), r.setEdit(t, {
    editorValue: o ? c.sourceValue : i
  }), n != null && n.persist && X0(e, t);
}
function X0(e, t) {
  const { editModelSvc: i } = e, s = i == null ? void 0 : i.getEdit(t, !0);
  i == null || i.setEdit(t, {
    pendingValue: s == null ? void 0 : s.editorValue
  });
}
function ps(e, t, i) {
  var s;
  t || (t = (s = e.editModelSvc) == null ? void 0 : s.getEditPositions()), t.forEach((o) => nr(e, o, i));
}
function nr(e, t, i) {
  var d, c;
  const s = e.gos.get("enableGroupEdit"), { editModelSvc: o } = e, n = ue(e, t), r = o == null ? void 0 : o.getEdit(t, !0);
  if (!n) {
    r && (o == null || o.setEdit(t, { state: "changed" }));
    return;
  }
  const { comp: a } = n;
  if (a && !a.getCellEditor()) {
    if (n == null || n.refreshCell(), r) {
      o == null || o.setEdit(t, { state: "changed" });
      const u = s ? zc(i, r) : {
        valueChanged: !1,
        newValue: void 0,
        oldValue: r.sourceValue
      };
      Uc(e, t, u, i);
    }
    return;
  }
  if (sd(e)) {
    const u = (c = (d = a == null ? void 0 : a.getCellEditor()) == null ? void 0 : d.getValidationErrors) == null ? void 0 : c.call(d), h = o == null ? void 0 : o.getCellValidationModel();
    u != null && u.length ? h == null || h.setCellValidation(t, { errorMessages: u }) : h == null || h.clearCellValidation(t);
  }
  o == null || o.setEdit(t, { state: "changed" }), a == null || a.setEditDetails(), a == null || a.refreshEditStyles(!1, !1), n == null || n.refreshCell({ force: !0, suppressFlash: !0 });
  const l = o == null ? void 0 : o.getEdit(t);
  if (l && l.state === "changed") {
    const u = s ? zc(i, l) : {
      valueChanged: Gt(l) && !(i != null && i.cancel),
      newValue: i != null && i.cancel || l.editorState.isCancelAfterEnd ? void 0 : (l == null ? void 0 : l.editorValue) ?? (r == null ? void 0 : r.pendingValue),
      oldValue: l == null ? void 0 : l.sourceValue
    };
    Uc(e, t, u, i);
  }
}
function zc(e, t) {
  return e != null && e.cancel ? {
    valueChanged: !1,
    oldValue: t.sourceValue,
    newValue: void 0,
    value: t.sourceValue
  } : {
    valueChanged: !1,
    oldValue: t.sourceValue,
    newValue: t.pendingValue,
    value: t.sourceValue
  };
}
function Uc(e, t, i, { silent: s, event: o } = {}) {
  const { editSvc: n, editModelSvc: r } = e, a = r == null ? void 0 : r.getEdit(t), { editorState: l } = a || {}, { isCancelBeforeStart: d } = l || {};
  !s && !d && (n == null || n.dispatchCellEvent(t, o, "cellEditingStopped", i), r == null || r.setEdit(t, { editorState: { cellStoppedEditing: !0 } }));
}
function sd(e) {
  var r;
  const { gos: t, colModel: i } = e, s = !!t.get("getFullRowEditValidationErrors"), o = (r = i.getColumnDefs()) == null ? void 0 : r.filter((a) => a.editable).some(({ cellEditorParams: a }) => {
    const { minLength: l, maxLength: d, getValidationErrors: c, min: u, max: h } = a || {};
    return l !== void 0 || d !== void 0 || c !== void 0 || u !== void 0 || h !== void 0;
  }), n = e.gridApi.getCellEditorInstances().some((a) => a.getValidationElement || a.getValidationErrors);
  return o || s || n;
}
function Gi(e, t) {
  var h, g, p, f, m, C, v, R;
  if (!(t || sd(e)))
    return;
  const i = Ip(e), s = new Mp(), { ariaAnnounce: o, localeSvc: n, editModelSvc: r, gos: a } = e, l = a.get("editType") === "fullRow", c = Gh(n)("ariaValidationErrorPrefix", "Cell Editor Validation");
  for (const b of i) {
    const { ctrl: w, editor: x } = b, { rowNode: F, column: D } = w, T = ((h = x.getValidationErrors) == null ? void 0 : h.call(x)) ?? [], k = ((g = x.getValidationElement) == null ? void 0 : g.call(x, !1)) || !((p = x.isPopup) != null && p.call(x)) && w.eGui;
    if (k) {
      const A = T != null && T.length > 0, G = A ? T.join(". ") : "";
      Qm(k, A), A && o.announceValue(`${c} ${T}`, "editorValidation"), k instanceof HTMLInputElement ? k.setCustomValidity(G) : k.classList.toggle("invalid", A);
    }
    (T == null ? void 0 : T.length) > 0 && s.setCellValidation(
      {
        rowNode: F,
        column: D
      },
      {
        errorMessages: T
      }
    );
  }
  xi(e, { persist: !1 }), r == null || r.setCellValidationModel(s);
  const u = /* @__PURE__ */ new Set();
  for (const { ctrl: b } of i)
    u.add(b.rowCtrl);
  if (l) {
    const b = Z0(e);
    r == null || r.setRowValidationModel(b);
  }
  for (const b of u.values()) {
    (f = b.rowEditStyleFeature) == null || f.applyRowStyles();
    for (const w of b.getAllCellCtrls())
      (m = w.tooltipFeature) == null || m.refreshTooltip(!0), (C = w.editorTooltipFeature) == null || C.refreshTooltip(!0), (R = (v = w.editStyleFeature) == null ? void 0 : v.applyCellStyles) == null || R.call(v);
  }
}
var Z0 = (e) => {
  var o;
  const t = new Ap(), i = e.gos.get("getFullRowEditValidationErrors"), s = (o = e.editModelSvc) == null ? void 0 : o.getEditMap();
  if (!s)
    return t;
  for (const n of s.keys()) {
    const r = s.get(n);
    if (!r)
      continue;
    const a = [], { rowIndex: l, rowPinned: d } = n;
    for (const u of r.keys()) {
      const h = r.get(u);
      if (!h)
        continue;
      const { editorValue: g, pendingValue: p, sourceValue: f } = h, m = g ?? (p === it ? void 0 : p) ?? f;
      a.push({
        column: u,
        colId: u.getColId(),
        rowIndex: l,
        rowPinned: d,
        oldValue: f,
        newValue: m
      });
    }
    const c = (i == null ? void 0 : i({ editorsState: a })) ?? [];
    c.length > 0 && t.setRowValidation(
      {
        rowNode: n
      },
      { errorMessages: c }
    );
  }
  return t;
};
function J0(e) {
  var s;
  Gi(e, !0);
  const t = (s = e.editModelSvc) == null ? void 0 : s.getCellValidationModel().getCellValidationMap();
  if (!t)
    return null;
  const i = [];
  return t.forEach((o, n) => {
    o.forEach(({ errorMessages: r }, a) => {
      i.push({
        column: a,
        rowIndex: n.rowIndex,
        rowPinned: n.rowPinned,
        messages: r ?? null
      });
    });
  }), i;
}
function eP(e, t, i, { rowNode: s, column: o }, n) {
  return W(e.gos, {
    type: i,
    node: s,
    data: s.data,
    value: n,
    column: o,
    colDef: o.getColDef(),
    rowPinned: s.rowPinned,
    event: t,
    rowIndex: s.rowIndex
  });
}
function tP(e, t = !1) {
  return e === P.DELETE ? !0 : !t && e === P.BACKSPACE ? yg() : !1;
}
var iP = class extends E {
  constructor(e, t, i, s) {
    super(), this.cellCtrl = e, this.rowNode = i, this.rowCtrl = s, this.beans = t;
  }
  init() {
    this.eGui = this.cellCtrl.eGui;
  }
  onKeyDown(e) {
    const t = e.key;
    switch (t) {
      case P.ENTER:
        this.onEnterKeyDown(e);
        break;
      case P.F2:
        this.onF2KeyDown(e);
        break;
      case P.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case P.TAB:
        this.onTabKeyDown(e);
        break;
      case P.BACKSPACE:
      case P.DELETE:
        this.onBackspaceOrDeleteKeyDown(t, e);
        break;
      case P.DOWN:
      case P.UP:
      case P.RIGHT:
      case P.LEFT:
        this.onNavigationKeyDown(e, t);
        break;
    }
  }
  onNavigationKeyDown(e, t) {
    var o, n;
    const { cellCtrl: i, beans: s } = this;
    if (!((o = s.editSvc) != null && o.isEditing(i, { withOpenEditor: !0 }))) {
      if (e.shiftKey && i.isRangeSelectionEnabled())
        this.onShiftRangeSelect(e);
      else {
        const r = i.getFocusedCellPosition();
        (n = s.navigation) == null || n.navigateToNextCell(e, t, r, !0);
      }
      e.preventDefault();
    }
  }
  onShiftRangeSelect(e) {
    const { rangeSvc: t, navigation: i } = this.beans;
    if (!t)
      return;
    const s = t.extendLatestRangeInDirection(e);
    s && (e.key === P.LEFT || e.key === P.RIGHT ? i == null || i.ensureColumnVisible(s.column) : i == null || i.ensureRowVisible(s.rowIndex));
  }
  onTabKeyDown(e) {
    var t;
    (t = this.beans.navigation) == null || t.onTabKeyDown(this.cellCtrl, e);
  }
  onBackspaceOrDeleteKeyDown(e, t) {
    var d;
    const { cellCtrl: i, beans: s, rowNode: o } = this, { gos: n, rangeSvc: r, eventSvc: a, editSvc: l } = s;
    if (a.dispatchEvent({ type: "keyShortcutChangedCellStart" }), tP(e, n.get("enableCellEditingOnBackspace")) && !(l != null && l.isEditing(i, { withOpenEditor: !0 }))) {
      if (r && zt(n))
        r.clearCellRangeCellValues({ dispatchWrapperEvents: !0, wrapperEventSource: "deleteKey" });
      else if (i.isCellEditable()) {
        const { column: c } = i, u = this.beans.valueSvc.getDeleteValue(c, o);
        o.setDataValue(c, u, "cellClear");
      }
    } else l != null && l.isEditing(i, { withOpenEditor: !0 }) || (d = s.editSvc) == null || d.startEditing(i, { startedEdit: !0, event: t });
    a.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
  }
  onEnterKeyDown(e) {
    var d;
    const { cellCtrl: t, beans: i } = this, { editSvc: s, navigation: o } = i, n = s == null ? void 0 : s.isEditing(t, { withOpenEditor: !0 }), r = t.rowNode, a = s == null ? void 0 : s.isRowEditing(r, { withOpenEditor: !0 }), l = (c) => {
      (s == null ? void 0 : s.startEditing(c, {
        startedEdit: !0,
        event: e,
        source: "edit"
      })) && e.preventDefault();
    };
    if (n || a) {
      if (this.isCtrlEnter(e)) {
        s == null || s.applyBulkEdit(t, ((d = i == null ? void 0 : i.rangeSvc) == null ? void 0 : d.getCellRanges()) || []);
        return;
      }
      if (Gi(i), (s == null ? void 0 : s.checkNavWithValidation(void 0, e)) === "block-stop")
        return;
      s != null && s.isEditing(t, { withOpenEditor: !0 }) ? s == null || s.stopEditing(t, {
        event: e,
        source: "edit"
      }) : a && !t.isCellEditable() ? s == null || s.stopEditing({ rowNode: r }, { event: e, source: "edit" }) : l(t);
    } else if (i.gos.get("enterNavigatesVertically")) {
      const c = e.shiftKey ? P.UP : P.DOWN;
      o == null || o.navigateToNextCell(null, c, t.cellPosition, !1);
    } else {
      if (s != null && s.hasValidationErrors())
        return;
      s != null && s.hasValidationErrors(t) && s.revertSingleCellEdit(t, !0), l(t);
    }
  }
  isCtrlEnter(e) {
    return (e.ctrlKey || e.metaKey) && e.key === P.ENTER;
  }
  onF2KeyDown(e) {
    const {
      cellCtrl: t,
      beans: { editSvc: i }
    } = this;
    i != null && i.isEditing() && (Gi(this.beans), (i == null ? void 0 : i.checkNavWithValidation(void 0, e)) === "block-stop") || i == null || i.startEditing(t, { startedEdit: !0, event: e });
  }
  onEscapeKeyDown(e) {
    const {
      cellCtrl: t,
      beans: { editSvc: i }
    } = this;
    (i == null ? void 0 : i.checkNavWithValidation(t, e)) === "block-stop" && i.revertSingleCellEdit(t), i == null || i.stopEditing(t, {
      event: e,
      cancel: !0
    });
  }
  processCharacter(e) {
    var r;
    const i = e.target !== this.eGui, {
      beans: { editSvc: s },
      cellCtrl: o
    } = this;
    if (i || s != null && s.isEditing(o, { withOpenEditor: !0 }))
      return;
    if (e.key === P.SPACE)
      this.onSpaceKeyDown(e);
    else if (s != null && s.isCellEditable(o, "ui")) {
      if (s != null && s.hasValidationErrors() && !(s != null && s.hasValidationErrors(o)))
        return;
      s == null || s.startEditing(o, { startedEdit: !0, event: e, source: "api" });
      const a = o.editCompDetails;
      !((r = a == null ? void 0 : a.params) != null && r.suppressPreventDefault) && e.preventDefault();
    }
  }
  onSpaceKeyDown(e) {
    var o;
    const { gos: t, editSvc: i } = this.beans, { rowNode: s } = this.cellCtrl;
    !(i != null && i.isEditing(this.cellCtrl, { withOpenEditor: !0 })) && Di(t) && ((o = this.beans.selectionSvc) == null || o.handleSelectionEvent(e, s, "spaceKey")), e.preventDefault();
  }
}, sP = class extends E {
  constructor(e, t, i) {
    super(), this.cellCtrl = e, this.column = i, this.beans = t;
  }
  onMouseEvent(e, t) {
    if (!Wt(t))
      switch (e) {
        case "click":
          this.onCellClicked(t);
          break;
        case "mousedown":
        case "touchstart":
          this.onMouseDown(t);
          break;
        case "dblclick":
          this.onCellDoubleClicked(t);
          break;
        case "mouseout":
          this.onMouseOut(t);
          break;
        case "mouseover":
          this.onMouseOver(t);
          break;
      }
  }
  onCellClicked(e) {
    var f;
    if ((f = this.beans.touchSvc) != null && f.handleCellDoubleClick(this, e))
      return;
    const { eventSvc: t, rangeSvc: i, editSvc: s, editModelSvc: o, frameworkOverrides: n, gos: r } = this.beans, a = e.ctrlKey || e.metaKey, { cellCtrl: l } = this, { column: d, cellPosition: c, rowNode: u } = l, h = Tn(r, d, u, e);
    i && a && !h && i.getCellRangeCount(c) > 1 && i.intersectLastRange(!0);
    const g = l.createEvent(e, "cellClicked");
    g.isEventHandlingSuppressed = h, t.dispatchEvent(g);
    const p = d.getColDef();
    if (p.onCellClicked && window.setTimeout(() => {
      n.wrapOutgoing(() => {
        p.onCellClicked(g);
      });
    }, 0), !h && (o == null ? void 0 : o.getState(l)) !== "editing") {
      const m = s == null ? void 0 : s.isEditing(), C = (o == null ? void 0 : o.getCellValidationModel().getCellValidationMap().size) ?? 0, v = (o == null ? void 0 : o.getRowValidationModel().getRowValidationMap().size) ?? 0;
      if (m && (C > 0 || v > 0))
        return;
      s != null && s.shouldStartEditing(l, e) ? s == null || s.startEditing(l, { event: e }) : s != null && s.shouldStopEditing(l, e) && (this.beans.gos.get("editType") === "fullRow" ? s == null || s.stopEditing(l, {
        event: e,
        source: "edit"
      }) : s == null || s.stopEditing(void 0, {
        event: e,
        source: "edit"
      }));
    }
  }
  onCellDoubleClicked(e) {
    const { column: t, beans: i, cellCtrl: s } = this, { eventSvc: o, frameworkOverrides: n, editSvc: r, editModelSvc: a, gos: l } = i, d = Tn(l, s.column, s.rowNode, e), c = t.getColDef(), u = s.createEvent(
      e,
      "cellDoubleClicked"
    );
    if (u.isEventHandlingSuppressed = d, o.dispatchEvent(u), typeof c.onCellDoubleClicked == "function" && window.setTimeout(() => {
      n.wrapOutgoing(() => {
        c.onCellDoubleClicked(u);
      });
    }, 0), !d && r != null && r.shouldStartEditing(s, e) && (a == null ? void 0 : a.getState(s)) !== "editing") {
      const h = r == null ? void 0 : r.isEditing(), g = (a == null ? void 0 : a.getCellValidationModel().getCellValidationMap().size) ?? 0, p = (a == null ? void 0 : a.getRowValidationModel().getRowValidationMap().size) ?? 0;
      if (h && (g > 0 || p > 0))
        return;
      r == null || r.startEditing(s, { event: e });
    }
  }
  onMouseDown(e) {
    const { ctrlKey: t, metaKey: i, shiftKey: s } = e, o = e.target, { cellCtrl: n, beans: r } = this, { eventSvc: a, rangeSvc: l, rowNumbersSvc: d, focusSvc: c, gos: u, editSvc: h } = r, { column: g, rowNode: p, cellPosition: f } = n, m = Tn(u, g, p, e), C = () => {
      const w = n.createEvent(e, "cellMouseDown");
      w.isEventHandlingSuppressed = m, a.dispatchEvent(w);
    };
    if (m) {
      C();
      return;
    }
    if (this.isRightClickInExistingRange(e))
      return;
    const v = l && !l.isEmpty(), R = this.containsWidget(o), b = ii(g);
    if (d && b && !d.handleMouseDownOnCell(f, e)) {
      l && e.preventDefault(), e.stopImmediatePropagation();
      return;
    }
    if (!s || !v) {
      const w = h == null ? void 0 : h.isEditing(n), F = u.get("enableCellTextSelection") && e.defaultPrevented, D = (hi() || F) && !w && !xl(o) && !R;
      n.focusCell(D, e);
    }
    if (s && v && !c.isCellFocused(f)) {
      e.preventDefault();
      const w = c.getFocusedCell();
      if (w) {
        const { column: x, rowIndex: F, rowPinned: D } = w;
        h != null && h.isEditing(w) && (h == null || h.stopEditing(w)), c.setFocusedCell({
          column: x,
          rowIndex: F,
          rowPinned: D,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0,
          sourceEvent: e
        });
      }
    }
    if (!R) {
      if (l) {
        b && e.preventDefault();
        const w = Yd(r, e) && b;
        if (s)
          l.extendLatestRangeToCell(f);
        else if (!w) {
          const x = t || i;
          l.setRangeToCell(f, x);
        }
      }
      C();
    }
  }
  isRightClickInExistingRange(e) {
    const { rangeSvc: t } = this.beans;
    if (t) {
      const i = t.isCellInAnyRange(this.cellCtrl.cellPosition), s = Yd(this.beans, e);
      if (i && s)
        return !0;
    }
    return !1;
  }
  containsWidget(e) {
    return Ei(e, "ag-selection-checkbox", 3) || Ei(e, "ag-drag-handle", 3);
  }
  onMouseOut(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const { eventSvc: t, colHover: i } = this.beans;
    t.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOut")), i == null || i.clearMouseOver();
  }
  onMouseOver(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const { eventSvc: t, colHover: i } = this.beans;
    t.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOver")), i == null || i.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget)
      return !1;
    const t = this.cellCtrl.eGui, i = t.contains(e.target), s = t.contains(e.relatedTarget);
    return i && s;
  }
}, oP = class extends E {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.column = e.column, this.rowNode = e.rowNode;
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode), this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
  }
  init() {
    this.eSetLeft = this.cellCtrl.getRootElement(), this.eContent = this.cellCtrl.eGui;
    const e = this.cellCtrl.getCellSpan();
    if (e || (this.setupColSpan(), this.setupRowSpan()), this.onLeftChanged(), this.onWidthChanged(), e || this._legacyApplyRowSpan(), e) {
      const t = this.refreshSpanHeight.bind(this, e);
      t(), this.addManagedListeners(this.beans.eventSvc, {
        paginationChanged: t,
        recalculateRowBounds: t,
        pinnedHeightChanged: t
      });
    }
  }
  refreshSpanHeight(e) {
    const t = e.getCellHeight();
    t != null && (this.eContent.style.height = `${t}px`);
  }
  onNewColumnsLoaded() {
    const e = this.column.getRowSpan(this.rowNode);
    this.rowSpan !== e && (this.rowSpan = e, this._legacyApplyRowSpan(!0));
  }
  onDisplayColumnsChanged() {
    const e = this.getColSpanningList();
    ci(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged());
  }
  setupColSpan() {
    this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListeners(this.beans.eventSvc, {
      // because we are col spanning, a reorder of the cols can change what cols we are spanning over
      displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
      // because we are spanning over multiple cols, we check for width any time any cols width changes.
      // this is expensive - really we should be explicitly checking only the cols we are spanning over
      // instead of every col, however it would be tricky code to track the cols we are spanning over, so
      // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
      displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
    }));
  }
  onWidthChanged() {
    if (!this.eContent)
      return;
    const e = this.getCellWidth();
    this.eContent.style.width = `${e}px`;
  }
  getCellWidth() {
    return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth();
  }
  getColSpanningList() {
    const { column: e, rowNode: t } = this, i = e.getColSpan(t), s = [];
    if (i === 1)
      s.push(e);
    else {
      let o = e;
      const n = e.getPinned();
      for (let r = 0; o && r < i && (s.push(o), o = this.beans.visibleCols.getColAfter(o), !(!o || de(o) || n !== o.getPinned())); r++)
        ;
    }
    return s;
  }
  onLeftChanged() {
    if (!this.eSetLeft)
      return;
    const e = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eSetLeft.style.left = e + "px";
  }
  getCellLeft() {
    let e;
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? e = se(this.colsSpanning) : e = this.column, e.getLeft();
  }
  modifyLeftForPrintLayout(e) {
    if (!this.cellCtrl.printLayout || this.column.getPinned() === "left")
      return e;
    const { visibleCols: t } = this.beans, i = t.getColsLeftWidth();
    if (this.column.getPinned() === "right") {
      const s = t.bodyWidth;
      return i + s + (e || 0);
    }
    return i + (e || 0);
  }
  _legacyApplyRowSpan(e) {
    if (this.rowSpan === 1 && !e)
      return;
    const i = Ti(this.beans) * this.rowSpan;
    this.eContent.style.height = `${i}px`, this.eContent.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, nP = "ag-cell", rP = "ag-cell-auto-height", aP = "ag-cell-normal-height", lP = "ag-cell-focus", dP = "ag-cell-first-right-pinned", cP = "ag-cell-last-left-pinned", uP = "ag-cell-not-inline-editing", hP = "ag-cell-wrap-text", gP = 0, fs = class extends E {
  constructor(e, t, i, s) {
    super(), this.column = e, this.rowNode = t, this.rowCtrl = s, this.rangeFeature = void 0, this.rowResizeFeature = void 0, this.positionFeature = void 0, this.customStyleFeature = void 0, this.editStyleFeature = void 0, this.mouseListener = void 0, this.keyboardListener = void 0, this.suppressRefreshCell = !1, this.onCompAttachedFuncs = [], this.onEditorAttachedFuncs = [], this.focusEventWhileNotReady = null, this.hasBeenFocused = !1, this.hasEdit = !1, this.tooltipFeature = void 0, this.editorTooltipFeature = void 0, this.beans = i, this.gos = i.gos, this.editSvc = i.editSvc, this.hasEdit = !!i.editSvc;
    const { colId: o } = e;
    this.instanceId = o + "-" + gP++, this.createCellPosition(), this.updateAndFormatValue(!1);
  }
  addFeatures() {
    var s, o;
    const { beans: e } = this;
    this.positionFeature = new oP(this, e), this.customStyleFeature = (s = e.cellStyles) == null ? void 0 : s.createCellCustomStyleFeature(this, e), this.editStyleFeature = (o = e.editSvc) == null ? void 0 : o.createCellStyleFeature(this, e), this.mouseListener = new sP(this, e, this.column), this.keyboardListener = new iP(this, e, this.rowNode, this.rowCtrl), this.enableTooltipFeature();
    const { rangeSvc: t } = e;
    t && zt(e.gos) && (this.rangeFeature = t.createCellRangeFeature(e, this)), ii(this.column) && (this.rowResizeFeature = this.beans.rowNumbersSvc.createRowNumbersRowResizerFeature(e, this));
  }
  isCellSpanning() {
    return !1;
  }
  getCellSpan() {
  }
  removeFeatures() {
    const e = this.beans.context;
    this.positionFeature = e.destroyBean(this.positionFeature), this.editorTooltipFeature = e.destroyBean(this.editorTooltipFeature), this.customStyleFeature = e.destroyBean(this.customStyleFeature), this.editStyleFeature = e.destroyBean(this.editStyleFeature), this.mouseListener = e.destroyBean(this.mouseListener), this.keyboardListener = e.destroyBean(this.keyboardListener), this.rangeFeature = e.destroyBean(this.rangeFeature), this.rowResizeFeature = e.destroyBean(this.rowResizeFeature), this.disableTooltipFeature();
  }
  enableTooltipFeature(e, t) {
    var i;
    this.tooltipFeature = (i = this.beans.tooltipSvc) == null ? void 0 : i.enableCellTooltipFeature(this, e, t);
  }
  disableTooltipFeature() {
    this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature);
  }
  enableEditorTooltipFeature(e) {
    var t;
    this.editorTooltipFeature && this.disableEditorTooltipFeature(), this.editorTooltipFeature = (t = this.beans.tooltipSvc) == null ? void 0 : t.setupCellEditorTooltip(this, e), Gi(this.beans);
  }
  disableEditorTooltipFeature() {
    this.editorTooltipFeature = this.beans.context.destroyBean(this.editorTooltipFeature);
  }
  setComp(e, t, i, s, o, n, r) {
    var a, l, d, c, u, h, g, p, f;
    this.comp = e, this.eGui = t, this.printLayout = o, r ?? (r = this), this.addDomData(r), this.addFeatures(), r.addDestroyFunc(() => this.removeFeatures()), this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.setupFocus(), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAutoHeight(s, r), this.refreshFirstAndLastStyles(), this.refreshAriaColIndex(), (a = this.positionFeature) == null || a.init(), (l = this.customStyleFeature) == null || l.setComp(e), (d = this.editStyleFeature) == null || d.setComp(e), (c = this.tooltipFeature) == null || c.refreshTooltip(), (u = this.keyboardListener) == null || u.init(), (h = this.rangeFeature) == null || h.setComp(e), (g = this.rowResizeFeature) == null || g.refreshRowResizer(), n && this.isCellEditable() || this.hasEdit && ((p = this.editSvc) != null && p.isEditing(this, { withOpenEditor: !0 })) ? (f = this.editSvc) == null || f.startEditing(this, {
      startedEdit: !1,
      source: "api",
      silent: !0,
      continueEditing: !0
    }) : this.showValue(!1, !0), this.onCompAttachedFuncs.length && (this.onCompAttachedFuncs.forEach((m) => m()), this.onCompAttachedFuncs = []);
  }
  setupAutoHeight(e, t) {
    var i;
    this.isAutoHeight = ((i = this.beans.rowAutoHeight) == null ? void 0 : i.setupCellAutoHeight(this, e, t)) ?? !1;
  }
  getCellAriaRole() {
    return this.column.getColDef().cellAriaRole ?? "gridcell";
  }
  isCellRenderer() {
    const e = this.column.getColDef();
    return e.cellRenderer != null || e.cellRendererSelector != null;
  }
  getValueToDisplay() {
    return this.valueFormatted ?? this.value;
  }
  getDeferLoadingCellRenderer() {
    var l, d;
    const { beans: e, column: t } = this, { userCompFactory: i, ctrlsSvc: s, eventSvc: o } = e, n = t.getColDef(), r = this.createCellRendererParams();
    r.deferRender = !0;
    const a = ic(i, n, r);
    if ((d = (l = s.getGridBodyCtrl()) == null ? void 0 : l.scrollFeature) != null && d.isScrolling()) {
      let c;
      const u = new fe((h) => {
        c = h;
      });
      return this.addManagedListeners(o, {
        bodyScrollEnd: () => c()
      }), { loadingComp: a, onReady: u };
    }
    return { loadingComp: a, onReady: fe.resolve() };
  }
  showValue(e, t) {
    var u, h, g, p;
    const { beans: i, column: s, rowNode: o, rangeFeature: n } = this, { userCompFactory: r } = i;
    let a = this.getValueToDisplay(), l;
    const d = o.stub && ((u = o.groupData) == null ? void 0 : u[s.getId()]) == null, c = s.getColDef();
    if (d || this.isCellRenderer()) {
      const f = this.createCellRendererParams();
      !d || ii(s) ? l = tc(r, c, f) : l = ic(r, c, f);
    }
    if (!l && !d && ((h = i.findSvc) != null && h.isMatch(o, s))) {
      const f = this.createCellRendererParams();
      l = tc(
        r,
        { ...s.getColDef(), cellRenderer: "agFindCellRenderer" },
        f
      );
    }
    if (this.hasEdit && this.editSvc.isBatchEditing() && this.editSvc.isRowEditing(o, { checkSiblings: !0 })) {
      const f = this.editSvc.prepDetailsDuringBatch(this, { compDetails: l, valueToDisplay: a });
      f && (f.compDetails ? l = f.compDetails : f.valueToDisplay && (a = f.valueToDisplay));
    }
    this.comp.setRenderDetails(l, a, e), (g = this.customRowDragComp) == null || g.refreshVisibility(), !t && n && $t(i, () => n == null ? void 0 : n.refreshHandle()), (p = this.rowResizeFeature) == null || p.refreshRowResizer();
  }
  setupControlComps() {
    const e = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(this.isCheckboxSelection(e), !0), this.includeRowDrag = this.isIncludeControl(e.rowDrag), this.includeDndSource = this.isIncludeControl(e.dndSource), this.comp.setIncludeSelection(this.includeSelection), this.comp.setIncludeDndSource(this.includeDndSource), this.comp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
  }
  /**
   * Wrapper providing general conditions under which control elements (e.g. checkboxes and drag handles)
   * are rendered for a particular cell.
   * @param value Whether to render the control in the specific context of the caller
   * @param allowManuallyPinned Whether manually pinned rows are permitted this form of control element
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  isIncludeControl(e, t = !1) {
    return (this.rowNode.rowPinned == null || t && $o(this.rowNode)) && !!e;
  }
  isCheckboxSelection(e) {
    const { rowSelection: t, groupDisplayType: i } = this.beans.gridOptions, s = $n(t), o = ui(this.column);
    return i === "custom" && s !== "selectionColumn" && o ? !1 : e.checkboxSelection || o && typeof t == "object" && ls(t);
  }
  refreshShouldDestroy() {
    const e = this.column.getColDef(), t = this.includeSelection != this.isIncludeControl(this.isCheckboxSelection(e), !0), i = this.includeRowDrag != this.isIncludeControl(e.rowDrag), s = this.includeDndSource != this.isIncludeControl(e.dndSource), o = this.isAutoHeight != this.column.isAutoHeight();
    return t || i || s || o;
  }
  onPopupEditorClosed() {
    const { editSvc: e } = this.beans;
    e != null && e.isEditing(this, { withOpenEditor: !0 }) && (e == null || e.stopEditing(this, { source: e != null && e.isBatchEditing() ? "ui" : "api" }));
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(e = !1) {
    const { editSvc: t } = this.beans;
    return (t == null ? void 0 : t.stopEditing(this, { cancel: e, source: t != null && t.isBatchEditing() ? "ui" : "api" })) ?? !1;
  }
  createCellRendererParams() {
    const {
      value: e,
      valueFormatted: t,
      column: i,
      rowNode: s,
      comp: o,
      eGui: n,
      beans: { valueSvc: r, gos: a, editSvc: l }
    } = this;
    return W(a, {
      value: e,
      valueFormatted: t,
      getValue: () => r.getValueForDisplay(i, s).value,
      setValue: (c) => (l == null ? void 0 : l.setDataValue({ rowNode: s, column: i }, c)) || s.setDataValue(i, c),
      formatValue: this.formatValue.bind(this),
      data: s.data,
      node: s,
      pinned: i.getPinned(),
      colDef: i.getColDef(),
      column: i,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: n,
      eParentOfValue: o.getParentOfValue(),
      registerRowDragger: (c, u, h, g) => this.registerRowDragger(c, u, g),
      setTooltip: (c, u) => {
        var h;
        a.assertModuleRegistered("Tooltip", 3), this.tooltipFeature && this.disableTooltipFeature(), this.enableTooltipFeature(c, u), (h = this.tooltipFeature) == null || h.refreshTooltip();
      }
    });
  }
  onCellChanged(e) {
    e.column === this.column && this.refreshCell({});
  }
  refreshOrDestroyCell(e) {
    var t;
    if (this.refreshShouldDestroy() ? (t = this.rowCtrl) == null || t.recreateCell(this) : this.refreshCell(e), this.hasEdit && this.editCompDetails) {
      const { editSvc: i, comp: s } = this;
      !(s != null && s.getCellEditor()) && i.isEditing(this, { withOpenEditor: !0 }) && i.startEditing(this, { startedEdit: !1, source: "api", silent: !0 });
    }
  }
  // + stop editing {force: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell({ force: e, suppressFlash: t, newData: i } = {}) {
    var d, c, u, h, g, p, f, m;
    if (this.suppressRefreshCell)
      return;
    const s = this.column.getColDef(), o = s.field == null && s.valueGetter == null && s.showRowGroup == null, n = e || o || i, r = !!this.comp, a = this.updateAndFormatValue(r), l = n || a;
    if (r) {
      if (l) {
        this.showValue(!!i, !1);
        const C = (d = this.beans.filterManager) == null ? void 0 : d.isSuppressFlashingCellsBecauseFiltering();
        !t && !C && s.enableCellChangeFlash && ((c = this.beans.cellFlashSvc) == null || c.flashCell(this)), (h = (u = this.editStyleFeature) == null ? void 0 : u.applyCellStyles) == null || h.call(u), (g = this.customStyleFeature) == null || g.applyUserStyles(), (p = this.customStyleFeature) == null || p.applyClassesFromColDef();
      }
      (f = this.tooltipFeature) == null || f.refreshTooltip(), (m = this.customStyleFeature) == null || m.applyCellClassRules();
    }
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  formatValue(e) {
    return this.callValueFormatter(e) ?? e;
  }
  callValueFormatter(e) {
    return this.beans.valueSvc.formatValue(this.column, this.rowNode, e);
  }
  updateAndFormatValue(e) {
    const t = this.value, i = this.valueFormatted, { value: s, valueFormatted: o } = this.beans.valueSvc.getValueForDisplay(this.column, this.rowNode, !0);
    return this.value = s, this.valueFormatted = o, e ? !this.valuesAreEqual(t, this.value) || this.valueFormatted != i : !0;
  }
  valuesAreEqual(e, t) {
    const i = this.column.getColDef();
    return i.equals ? i.equals(e, t) : e === t;
  }
  addDomData(e) {
    const t = this.eGui;
    Oi(this.beans.gos, t, er, this), e.addDestroyFunc(() => Oi(this.beans.gos, t, er, null));
  }
  createEvent(e, t) {
    const { rowNode: i, column: s, value: o, beans: n } = this;
    return eP(n, e, t, { rowNode: i, column: s }, o);
  }
  processCharacter(e) {
    var t;
    (t = this.keyboardListener) == null || t.processCharacter(e);
  }
  onKeyDown(e) {
    var t;
    (t = this.keyboardListener) == null || t.onKeyDown(e);
  }
  onMouseEvent(e, t) {
    var i;
    (i = this.mouseListener) == null || i.onMouseEvent(e, t);
  }
  getColSpanningList() {
    var e;
    return ((e = this.positionFeature) == null ? void 0 : e.getColSpanningList()) ?? [];
  }
  onLeftChanged() {
    var e;
    this.comp && ((e = this.positionFeature) == null || e.onLeftChanged());
  }
  onDisplayedColumnsChanged() {
    this.eGui && (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles());
  }
  refreshFirstAndLastStyles() {
    const { comp: e, column: t, beans: i } = this;
    Jg(e, t, i.visibleCols);
  }
  refreshAriaColIndex() {
    const e = this.beans.visibleCols.getAriaColIndex(this.column);
    Eh(this.eGui, e);
  }
  onWidthChanged() {
    var e;
    return (e = this.positionFeature) == null ? void 0 : e.onWidthChanged();
  }
  getRowPosition() {
    const { rowIndex: e, rowPinned: t } = this.cellPosition;
    return {
      rowIndex: e,
      rowPinned: t
    };
  }
  updateRangeBordersIfRangeCount() {
    var e;
    this.comp && ((e = this.rangeFeature) == null || e.updateRangeBordersIfRangeCount());
  }
  onCellSelectionChanged() {
    var e;
    this.comp && ((e = this.rangeFeature) == null || e.onCellSelectionChanged());
  }
  isRangeSelectionEnabled() {
    return this.rangeFeature != null;
  }
  focusCell(e = !1, t) {
    var s;
    const i = (s = this.editSvc) == null ? void 0 : s.allowedFocusTargetOnValidation(this);
    i && i !== this || this.beans.focusSvc.setFocusedCell({
      ...this.getFocusedCellPosition(),
      forceBrowserFocus: e,
      sourceEvent: t
    });
  }
  /**
   * Restores focus to the cell, if it should have it
   * @param waitForRender if the cell has just setComp, it may not be rendered yet, so we wait for the next render
   */
  restoreFocus(e = !1) {
    const {
      beans: { editSvc: t, focusSvc: i },
      comp: s
    } = this;
    if (!s || t != null && t.isEditing(this) || !this.isCellFocused() || !i.shouldTakeFocus())
      return;
    const o = () => {
      if (!this.isAlive())
        return;
      const n = s.getFocusableElement();
      this.isCellFocused() && n.focus({ preventScroll: !0 });
    };
    if (e) {
      setTimeout(o, 0);
      return;
    }
    o();
  }
  onRowIndexChanged() {
    var e, t;
    this.createCellPosition(), this.onCellFocused(), this.restoreFocus(), (e = this.rangeFeature) == null || e.onCellSelectionChanged(), (t = this.rowResizeFeature) == null || t.refreshRowResizer();
  }
  onSuppressCellFocusChanged(e) {
    const t = this.eGui;
    t && (ii(this.column) && (e = !0), Ue(t, "tabindex", e ? void 0 : -1));
  }
  onFirstRightPinnedChanged() {
    if (!this.comp)
      return;
    const e = this.column.isFirstRightPinned();
    this.comp.toggleCss(dP, e);
  }
  onLastLeftPinnedChanged() {
    if (!this.comp)
      return;
    const e = this.column.isLastLeftPinned();
    this.comp.toggleCss(cP, e);
  }
  /**
   * Returns whether cell is focused by the focusSvc, overridden by spannedCellCtrl
   */
  checkCellFocused() {
    return this.beans.focusSvc.isCellFocused(this.cellPosition);
  }
  isCellFocused() {
    const e = this.checkCellFocused();
    return this.hasBeenFocused || (this.hasBeenFocused = e), e;
  }
  setupFocus() {
    this.restoreFocus(!0), this.onCellFocused(this.focusEventWhileNotReady ?? void 0);
  }
  onCellFocused(e) {
    var o;
    const { beans: t } = this;
    if (Sr(t))
      return;
    if (!this.comp) {
      e && (this.focusEventWhileNotReady = e);
      return;
    }
    const i = this.isCellFocused(), s = ((o = t.editSvc) == null ? void 0 : o.isEditing(this)) ?? !1;
    if (this.comp.toggleCss(lP, i), i && e && e.forceBrowserFocus) {
      let n = this.comp.getFocusableElement();
      if (s) {
        const r = cs(n, null, !0);
        r.length && (n = r[0]);
      }
      n.focus({ preventScroll: !!e.preventScrollOnBrowserFocus });
    }
    i && this.rowCtrl.announceDescription();
  }
  createCellPosition() {
    const { rowIndex: e, rowPinned: t } = this.rowNode;
    this.cellPosition = {
      rowIndex: e,
      rowPinned: Vt(t),
      column: this.column
    };
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    const { comp: e } = this;
    e.toggleCss(nP, !0), e.toggleCss(uP, !0);
    const t = this.column.isAutoHeight() == !0;
    e.toggleCss(rP, t), e.toggleCss(aP, !t);
  }
  onColumnHover() {
    var e;
    (e = this.beans.colHover) == null || e.onCellColumnHover(this.column, this.comp);
  }
  onColDefChanged() {
    var e, t;
    this.comp && (this.column.isTooltipEnabled() ? (this.disableTooltipFeature(), this.enableTooltipFeature()) : this.disableTooltipFeature(), this.setWrapText(), (e = this.editSvc) != null && e.isEditing(this) ? (t = this.editSvc) == null || t.handleColDefChanged(this) : this.refreshOrDestroyCell({ force: !0, suppressFlash: !0 }));
  }
  setWrapText() {
    const e = this.column.getColDef().wrapText == !0;
    this.comp.toggleCss(hP, e);
  }
  dispatchCellContextMenuEvent(e) {
    const t = this.column.getColDef(), i = this.createEvent(e, "cellContextMenu"), { beans: s } = this;
    s.eventSvc.dispatchEvent(i), t.onCellContextMenu && window.setTimeout(() => {
      s.frameworkOverrides.wrapOutgoing(() => {
        t.onCellContextMenu(i);
      });
    }, 0);
  }
  getCellRenderer() {
    var e;
    return ((e = this.comp) == null ? void 0 : e.getCellRenderer()) ?? null;
  }
  destroy() {
    this.onCompAttachedFuncs = [], this.onEditorAttachedFuncs = [], this.isCellFocused() && this.hasBrowserFocus() && this.beans.focusSvc.attemptToRecoverFocus(), super.destroy();
  }
  hasBrowserFocus() {
    var e;
    return ((e = this.eGui) == null ? void 0 : e.contains(he(this.beans))) ?? !1;
  }
  createSelectionCheckbox() {
    var t;
    const e = (t = this.beans.selectionSvc) == null ? void 0 : t.createCheckboxSelectionComponent();
    if (e)
      return this.beans.context.createBean(e), e.init({ rowNode: this.rowNode, column: this.column }), e;
  }
  createDndSource() {
    const e = this.beans.registry.createDynamicBean(
      "dndSourceComp",
      !1,
      this.rowNode,
      this.column,
      this.eGui
    );
    return e && this.beans.context.createBean(e), e;
  }
  registerRowDragger(e, t, i) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(e, t);
      return;
    }
    const s = this.createRowDragComp(e, t, i);
    s && (this.customRowDragComp = s, this.addDestroyFunc(() => {
      this.beans.context.destroyBean(s), this.customRowDragComp = null;
    }), s.refreshVisibility());
  }
  createRowDragComp(e, t, i) {
    var o;
    const s = (o = this.beans.rowDragSvc) == null ? void 0 : o.createRowDragCompForCell(
      this.rowNode,
      this.column,
      () => this.value,
      e,
      t,
      i
    );
    if (s)
      return this.beans.context.createBean(s), s;
  }
  cellEditorAttached() {
    this.onEditorAttachedFuncs.forEach((e) => e()), this.onEditorAttachedFuncs = [];
  }
  setFocusedCellPosition(e) {
  }
  getFocusedCellPosition() {
    return this.cellPosition;
  }
  // used by spannedCellCtrl
  refreshAriaRowIndex() {
  }
  /**
   * Returns the root element of the cell, could be a span container rather than the cell element.
   * @returns The root element of the cell.
   */
  getRootElement() {
    return this.eGui;
  }
};
function od(e, t, i, s, o, n) {
  if (i == null && t == null)
    return;
  const r = {}, a = {}, l = (d, c) => {
    d.split(" ").forEach((u) => {
      u.trim() != "" && c(u);
    });
  };
  if (i) {
    const d = Object.keys(i);
    for (let c = 0; c < d.length; c++) {
      const u = d[c], h = i[u];
      let g;
      typeof h == "string" ? g = e ? e.evaluate(h, s) : !0 : typeof h == "function" && (g = h(s)), l(u, (p) => {
        g ? r[p] = !0 : a[p] = !0;
      });
    }
  }
  t && n && Object.keys(t).forEach(
    (d) => l(d, (c) => {
      r[c] || (a[c] = !0);
    })
  ), n && Object.keys(a).forEach(n), Object.keys(r).forEach(o);
}
function $c(e) {
  if (e.group)
    return e.level;
  const t = e.parent;
  return t ? t.level + 1 : 0;
}
var pP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowStyleSvc";
  }
  processClassesFromGridOptions(e, t) {
    const i = this.gos, s = (r) => {
      typeof r == "string" ? e.push(r) : Array.isArray(r) && r.forEach((a) => e.push(a));
    }, o = i.get("rowClass");
    o && s(o);
    const n = i.getCallback("getRowClass");
    if (n) {
      const r = {
        data: t.data,
        node: t,
        rowIndex: t.rowIndex
      }, a = n(r);
      s(a);
    }
  }
  preProcessRowClassRules(e, t) {
    this.processRowClassRules(
      t,
      (i) => {
        e.push(i);
      },
      () => {
      }
    );
  }
  processRowClassRules(e, t, i) {
    const { gos: s, expressionSvc: o } = this.beans, n = W(s, {
      data: e.data,
      node: e,
      rowIndex: e.rowIndex
    });
    od(
      o,
      void 0,
      s.get("rowClassRules"),
      n,
      t,
      i
    );
  }
  processStylesFromGridOptions(e) {
    const t = this.gos, i = t.get("rowStyle"), s = t.getCallback("getRowStyle");
    let o;
    if (s) {
      const n = {
        data: e.data,
        node: e,
        rowIndex: e.rowIndex
      };
      o = s(n);
    }
    if (o || i)
      return Object.assign({}, i, o);
  }
}, fP = 0, rr = class extends E {
  constructor(e, t, i, s, o) {
    var n, r;
    super(), this.rowNode = e, this.useAnimationFrameForCreate = s, this.printLayout = o, this.allRowGuis = [], this.active = !0, this.centerCellCtrls = { list: [], map: {} }, this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} }, this.slideInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.fadeInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.rowDragComps = [], this.lastMouseDownOnDragger = !1, this.emptyStyle = {}, this.updateColumnListsPending = !1, this.rowId = null, this.businessKey = null, this.beans = t, this.gos = t.gos, this.paginationPage = ((n = t.pagination) == null ? void 0 : n.getCurrentPage()) ?? 0, this.suppressRowTransform = this.gos.get("suppressRowTransform"), this.instanceId = e.id + "-" + fP++, this.rowId = to(e.id), this.initRowBusinessKey(), this.rowFocused = t.focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = $c(this.rowNode), this.setRowType(), this.setAnimateFlags(i), this.rowStyles = this.processStylesFromGridOptions(), this.rowEditStyleFeature = (r = t.editSvc) == null ? void 0 : r.createRowStyleFeature(this, t), this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode"), this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc != "function")
      return;
    const e = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKey = to(e);
  }
  updateGui(e, t) {
    e === "left" ? this.leftGui = t : e === "right" ? this.rightGui = t : e === "fullWidth" ? this.fullWidthGui = t : this.centerGui = t;
  }
  setComp(e, t, i, s) {
    var u, h;
    const { context: o, focusSvc: n } = this.beans;
    s = No(this, o, s);
    const r = { rowComp: e, element: t, containerType: i, compBean: s };
    this.allRowGuis.push(r), this.updateGui(i, r), this.initialiseRowComp(r);
    const a = this.rowNode, l = this.rowType === "FullWidthLoading" || a.stub, d = !a.data && this.beans.rowModel.getType() === "infinite";
    !l && !d && !a.rowPinned && this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
    const c = (u = this.fullWidthGui) == null ? void 0 : u.element;
    c && !((h = this.beans.editSvc) != null && h.isEditing(this)) && n.isRowFocused(a.rowIndex, a.rowPinned) && n.shouldTakeFocus() && setTimeout(() => c.focus({ preventScroll: !0 }), 0);
  }
  unsetComp(e) {
    this.allRowGuis = this.allRowGuis.filter((t) => t.containerType !== e), this.updateGui(e, void 0);
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(e) {
    const t = e ? "none" : "";
    this.allRowGuis.forEach((i) => i.element.style.display = t);
  }
  initialiseRowComp(e) {
    const t = this.gos;
    this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.listenOnDomOrder(e), this.onRowHeightChanged(e), this.updateRowIndexes(e), this.setFocusedClasses(e), this.setStylesFromGridOptions(!1, e), Di(t) && this.rowNode.selectable && this.onRowSelected(e), this.updateColumnLists(!this.useAnimationFrameForCreate);
    const i = e.rowComp;
    this.getInitialRowClasses(e.containerType).forEach((o) => i.toggleCss(o, !0)), this.executeSlideAndFadeAnimations(e), this.rowNode.group && Aa(e.element, this.rowNode.expanded == !0), this.setRowCompRowId(i), this.setRowCompRowBusinessKey(i), Oi(t, e.element, tr, this), e.compBean.addDestroyFunc(() => Oi(t, e.element, tr, null)), this.useAnimationFrameForCreate ? this.beans.animationFrameSvc.createTask(
      this.addHoverFunctionality.bind(this, e),
      this.rowNode.rowIndex,
      "p2",
      !1
    ) : this.addHoverFunctionality(e), this.isFullWidth() && this.setupFullWidth(e), t.get("rowDragEntireRow") && this.addRowDraggerToRow(e), this.useAnimationFrameForCreate && this.beans.animationFrameSvc.addDestroyTask(() => {
      this.isAlive() && e.rowComp.toggleCss("ag-after-created", !0);
    }), this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(e) {
    this.businessKey != null && e.setRowBusinessKey(this.businessKey);
  }
  setRowCompRowId(e) {
    const t = to(this.rowNode.id);
    this.rowId = t, t != null && e.setRowId(t);
  }
  executeSlideAndFadeAnimations(e) {
    const { containerType: t } = e;
    this.slideInAnimation[t] && (Ia(() => {
      this.onTopChanged();
    }), this.slideInAnimation[t] = !1), this.fadeInAnimation[t] && (Ia(() => {
      e.rowComp.toggleCss("ag-opacity-zero", !1);
    }), this.fadeInAnimation[t] = !1);
  }
  addRowDraggerToRow(e) {
    var s;
    const t = (s = this.beans.rowDragSvc) == null ? void 0 : s.createRowDragCompForRow(this.rowNode, e.element);
    if (!t)
      return;
    const i = this.createBean(t, this.beans.context);
    this.rowDragComps.push(i), e.compBean.addDestroyFunc(() => {
      this.rowDragComps = this.rowDragComps.filter((o) => o !== i), this.rowEditStyleFeature = this.destroyBean(this.rowEditStyleFeature, this.beans.context), this.destroyBean(i, this.beans.context);
    });
  }
  setupFullWidth(e) {
    const t = this.getPinnedForContainer(e.containerType), i = this.createFullWidthCompDetails(e.element, t);
    e.rowComp.showFullWidth(i);
  }
  getFullWidthCellRenderers() {
    var e, t;
    return this.gos.get("embedFullWidthRows") ? this.allRowGuis.map((i) => {
      var s;
      return (s = i == null ? void 0 : i.rowComp) == null ? void 0 : s.getFullWidthCellRenderer();
    }) : [(t = (e = this.fullWidthGui) == null ? void 0 : e.rowComp) == null ? void 0 : t.getFullWidthCellRenderer()];
  }
  executeProcessRowPostCreateFunc() {
    const e = this.gos.getCallback("processRowPostCreate");
    if (!e || !this.areAllContainersReady())
      return;
    const t = {
      // areAllContainersReady asserts that centerGui is not null
      eRow: this.centerGui.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    e(t);
  }
  areAllContainersReady() {
    const {
      leftGui: e,
      centerGui: t,
      rightGui: i,
      beans: { visibleCols: s }
    } = this, o = !!e || !s.isPinningLeft(), n = !!t, r = !!i || !s.isPinningRight();
    return o && n && r;
  }
  isNodeFullWidthCell() {
    if (this.rowNode.detail)
      return !0;
    const e = this.beans.gos.getCallback("isFullWidthRow");
    return e ? e({ rowNode: this.rowNode }) : !1;
  }
  setRowType() {
    const e = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow") && !this.gos.get("groupHideOpenParents"), t = this.isNodeFullWidthCell(), i = this.gos.get("masterDetail") && this.rowNode.detail, s = this.beans.colModel.isPivotMode(), o = Xh(this.gos, this.rowNode, s);
    e ? this.rowType = "FullWidthLoading" : i ? this.rowType = "FullWidthDetail" : t ? this.rowType = "FullWidth" : o ? this.rowType = "FullWidthGroup" : this.rowType = "Normal";
  }
  updateColumnLists(e = !1, t = !1) {
    if (this.isFullWidth())
      return;
    const { animationFrameSvc: i } = this.beans;
    if (!(i != null && i.active) || e || this.printLayout) {
      this.updateColumnListsImpl(t);
      return;
    }
    this.updateColumnListsPending || (i.createTask(
      () => {
        this.active && this.updateColumnListsImpl(!0);
      },
      this.rowNode.rowIndex,
      "p1",
      !1
    ), this.updateColumnListsPending = !0);
  }
  /**
   * Overridden by SpannedRowCtrl
   */
  getNewCellCtrl(e) {
    var i;
    if (!((i = this.beans.rowSpanSvc) != null && i.isCellSpanning(e, this.rowNode)))
      return new fs(e, this.rowNode, this.beans, this);
  }
  /**
   * Overridden by SpannedRowCtrl, if span context changes cell needs rebuilt
   */
  isCorrectCtrlForSpan(e) {
    var t;
    return !((t = this.beans.rowSpanSvc) != null && t.isCellSpanning(e.column, this.rowNode));
  }
  createCellCtrls(e, t, i = null) {
    const s = {
      list: [],
      map: {}
    }, o = (d, c, u) => {
      u != null ? s.list.splice(u, 0, c) : s.list.push(c), s.map[d] = c;
    }, n = [];
    for (const d of t) {
      const c = d.getInstanceId();
      let u = e.map[c];
      u && !this.isCorrectCtrlForSpan(u) && (u.destroy(), u = void 0), u || (u = this.getNewCellCtrl(d)), u && o(c, u);
    }
    for (const d of e.list) {
      const c = d.column.getInstanceId();
      if (s.map[c] != null)
        continue;
      !this.isCellEligibleToBeRemoved(d, i) ? n.push([c, d]) : d.destroy();
    }
    if (n.length)
      for (const [d, c] of n) {
        const u = s.list.findIndex((g) => g.column.getLeft() > c.column.getLeft()), h = u === -1 ? void 0 : Math.max(u - 1, 0);
        o(d, c, h);
      }
    const { focusSvc: r, visibleCols: a } = this.beans, l = r.getFocusedCell();
    if (l && l.column.getPinned() == i) {
      const d = l.column.getInstanceId();
      if (!s.map[d] && a.allCols.includes(l.column)) {
        const u = this.createFocusedCellCtrl();
        if (u) {
          const h = s.list.findIndex((p) => p.column.getLeft() > u.column.getLeft()), g = h === -1 ? void 0 : Math.max(h - 1, 0);
          o(d, u, g);
        }
      }
    }
    return s;
  }
  /**
   * Creates a new cell ctrl for the focused cell, if this is the correct row ctrl.
   * @returns a CellCtrl for the focused cell, if required.
   */
  createFocusedCellCtrl() {
    const { focusSvc: e, rowSpanSvc: t } = this.beans, i = e.getFocusedCell();
    if (!i)
      return;
    const s = t == null ? void 0 : t.getCellSpan(i.column, this.rowNode);
    if (s) {
      if (s.firstNode !== this.rowNode || !s.doesSpanContain(i))
        return;
    } else if (!e.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned))
      return;
    return this.getNewCellCtrl(i.column);
  }
  updateColumnListsImpl(e) {
    this.updateColumnListsPending = !1, this.createAllCellCtrls(), this.setCellCtrls(e);
  }
  setCellCtrls(e) {
    this.allRowGuis.forEach((t) => {
      const i = this.getCellCtrlsForContainer(t.containerType);
      t.rowComp.setCellCtrls(i, e);
    });
  }
  getCellCtrlsForContainer(e) {
    switch (e) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
    }
  }
  createAllCellCtrls() {
    const e = this.beans.colViewport, t = this.beans.visibleCols;
    if (this.printLayout)
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, t.allCols), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
    else {
      const i = e.getColsWithinViewport(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, i);
      const s = t.getLeftColsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, s, "left");
      const o = t.getRightColsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, o, "right");
    }
  }
  isCellEligibleToBeRemoved(e, t) {
    const { column: o } = e;
    if (o.getPinned() != t || !this.isCorrectCtrlForSpan(e))
      return !0;
    const { visibleCols: n, editSvc: r } = this.beans, a = r == null ? void 0 : r.isEditing(e), l = e.isCellFocused();
    return a || l ? !(n.allCols.indexOf(o) >= 0) : !0;
  }
  getDomOrder() {
    return this.gos.get("ensureDomOrder") || Me(this.gos, "print");
  }
  listenOnDomOrder(e) {
    const t = () => {
      e.rowComp.setDomOrder(this.getDomOrder());
    };
    e.compBean.addManagedPropertyListeners(["domLayout", "ensureDomOrder"], t);
  }
  setAnimateFlags(e) {
    if (this.rowNode.sticky || !e)
      return;
    const t = H(this.rowNode.oldRowTop), { visibleCols: i } = this.beans, s = i.isPinningLeft(), o = i.isPinningRight();
    if (t) {
      const { slideInAnimation: n } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        n.fullWidth = !0;
        return;
      }
      n.center = !0, n.left = s, n.right = o;
    } else {
      const { fadeInAnimation: n } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        n.fullWidth = !0;
        return;
      }
      n.center = !0, n.left = s, n.right = o;
    }
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const e = (r, a) => r ? r.rowComp.refreshFullWidth(() => this.createFullWidthCompDetails(r.element, a).params) : !0, t = e(this.fullWidthGui, null), i = e(this.centerGui, null), s = e(this.leftGui, "left"), o = e(this.rightGui, "right");
    return t && i && s && o;
  }
  addListeners() {
    const { beans: e, gos: t, rowNode: i } = this, { expansionSvc: s, eventSvc: o, context: n, rowSpanSvc: r } = e;
    this.addManagedListeners(this.rowNode, {
      heightChanged: () => this.onRowHeightChanged(),
      rowSelected: () => this.onRowSelected(),
      rowIndexChanged: this.onRowIndexChanged.bind(this),
      topChanged: this.onTopChanged.bind(this),
      ...(s == null ? void 0 : s.getRowExpandedListeners(this)) ?? {}
    }), i.detail && this.addManagedListeners(i.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) }), this.addManagedListeners(i, {
      dataChanged: this.onRowNodeDataChanged.bind(this),
      cellChanged: this.postProcessCss.bind(this),
      rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
      draggingChanged: this.postProcessRowDragging.bind(this),
      uiLevelChanged: this.onUiLevelChanged.bind(this),
      rowPinned: this.onRowPinned.bind(this)
    }), this.addManagedListeners(o, {
      paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
      heightScaleChanged: this.onTopChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
      cellFocused: this.onCellFocusChanged.bind(this),
      cellFocusCleared: this.onCellFocusChanged.bind(this),
      paginationChanged: this.onPaginationChanged.bind(this),
      modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
      columnMoved: () => this.updateColumnLists()
    }), r && this.addManagedListeners(r, {
      spannedCellsUpdated: ({ pinned: a }) => {
        a && !i.rowPinned || this.updateColumnLists();
      }
    }), this.addDestroyFunc(() => {
      this.rowDragComps = this.destroyBeans(this.rowDragComps, n), this.tooltipFeature = this.destroyBean(this.tooltipFeature, n), this.rowEditStyleFeature = this.destroyBean(this.rowEditStyleFeature, n);
    }), this.addManagedPropertyListeners(
      ["rowStyle", "getRowStyle", "rowClass", "getRowClass", "rowClassRules"],
      this.postProcessCss.bind(this)
    ), this.addManagedPropertyListener("rowDragEntireRow", () => {
      if (t.get("rowDragEntireRow")) {
        this.allRowGuis.forEach((l) => {
          this.addRowDraggerToRow(l);
        });
        return;
      }
      this.rowDragComps = this.destroyBeans(this.rowDragComps, n);
    }), this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListeners(this.rowNode, {
      rowIndexChanged: () => this.getAllCellCtrls().forEach((e) => e.onRowIndexChanged()),
      cellChanged: (e) => this.getAllCellCtrls().forEach((t) => t.onCellChanged(e))
    });
  }
  /** Should only ever be triggered on source rows (i.e. not on pinned siblings) */
  onRowPinned() {
    for (const e of this.allRowGuis)
      e.rowComp.toggleCss("ag-row-pinned-source", !!this.rowNode.pinnedSibling);
  }
  onRowNodeDataChanged(e) {
    this.refreshRow({
      suppressFlash: !e.update,
      newData: !e.update
    });
  }
  refreshRow(e) {
    if (this.isFullWidth() !== !!this.isNodeFullWidthCell()) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      this.refreshFullWidth() || this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach((i) => i.refreshCell(e)), this.allRowGuis.forEach((i) => {
      this.setRowCompRowId(i.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(i.rowComp);
    }), this.onRowSelected(), this.postProcessCss();
  }
  postProcessCss() {
    var e;
    this.setStylesFromGridOptions(!0), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), (e = this.rowEditStyleFeature) == null || e.applyRowStyles(), this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const e = this.beans.rowDropHighlightSvc, t = (e == null ? void 0 : e.row) === this.rowNode ? e.position : "none", i = t === "above", s = t === "inside", o = t === "below", r = this.gos.get("treeData") && (o || i), a = this.rowNode.uiLevel.toString();
    this.allRowGuis.forEach((l) => {
      const d = l.rowComp;
      d.toggleCss("ag-row-highlight-above", i), d.toggleCss("ag-row-highlight-inside", s), d.toggleCss("ag-row-highlight-below", o), d.toggleCss("ag-row-highlight-indent", r), r ? l.element.style.setProperty("--ag-row-highlight-level", a) : l.element.style.removeProperty("--ag-row-highlight-level");
    });
  }
  postProcessRowDragging() {
    const e = this.rowNode.dragging;
    this.allRowGuis.forEach((t) => t.rowComp.toggleCss("ag-row-dragging", e));
  }
  onDisplayedColumnsChanged() {
    var e;
    this.updateColumnLists(!0), (e = this.beans.rowAutoHeight) == null || e.requestCheckAutoHeight();
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(!1, !0);
  }
  getRowPosition() {
    return {
      rowPinned: Vt(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  onKeyboardNavigate(e) {
    const t = this.findFullWidthInfoForEvent(e);
    if (!t)
      return;
    const { rowGui: i, column: s } = t;
    if (!(i.element === e.target))
      return;
    const r = this.rowNode, { focusSvc: a, navigation: l } = this.beans, d = a.getFocusedCell(), c = {
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      column: (d == null ? void 0 : d.column) ?? s
    };
    l == null || l.navigateToNextCell(e, e.key, c, !0), e.preventDefault();
  }
  onTabKeyDown(e) {
    var a;
    if (e.defaultPrevented || Wt(e))
      return;
    const t = this.allRowGuis.find(
      (l) => l.element.contains(e.target)
    ), i = t ? t.element : null, s = i === e.target, o = he(this.beans);
    let n = !1;
    i && o && (n = i.contains(o) && o.classList.contains("ag-cell"));
    let r = null;
    !s && !n && (r = zi(this.beans, i, !1, e.shiftKey)), (this.isFullWidth() && s || !r) && ((a = this.beans.navigation) == null || a.onTabKeyDown(this, e));
  }
  getFullWidthElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : null;
  }
  getRowYPosition() {
    var t;
    const e = (t = this.allRowGuis.find((i) => Mt(i.element))) == null ? void 0 : t.element;
    return e ? e.getBoundingClientRect().top : 0;
  }
  onSuppressCellFocusChanged(e) {
    const t = this.isFullWidth() && e ? void 0 : this.gos.get("tabIndex");
    this.allRowGuis.forEach((i) => {
      Ue(i.element, "tabindex", t);
    });
  }
  onFullWidthRowFocused(e) {
    var o, n, r;
    const t = this.rowNode, i = e ? this.isFullWidth() && e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned : !1;
    let s;
    if (this.fullWidthGui)
      s = this.fullWidthGui.element;
    else {
      const a = this.beans.colModel.getCol(e == null ? void 0 : e.column), l = a == null ? void 0 : a.pinned;
      l ? s = l === "right" ? (o = this.rightGui) == null ? void 0 : o.element : (n = this.leftGui) == null ? void 0 : n.element : s = (r = this.centerGui) == null ? void 0 : r.element;
    }
    s && (s.classList.toggle("ag-full-width-focus", i), i && (e != null && e.forceBrowserFocus) && s.focus({ preventScroll: !0 }));
  }
  recreateCell(e) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, e), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, e), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, e), e.destroy(), this.updateColumnLists();
  }
  removeCellCtrl(e, t) {
    const i = {
      list: [],
      map: {}
    };
    return e.list.forEach((s) => {
      s !== t && (i.list.push(s), i.map[s.column.getInstanceId()] = s);
    }), i;
  }
  onMouseEvent(e, t) {
    switch (e) {
      case "dblclick":
        this.onRowDblClick(t);
        break;
      case "click":
        this.onRowClick(t);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(t);
        break;
    }
  }
  createRowEvent(e, t) {
    const { rowNode: i } = this;
    return W(this.gos, {
      type: e,
      node: i,
      data: i.data,
      rowIndex: i.rowIndex,
      rowPinned: i.rowPinned,
      event: t
    });
  }
  createRowEventWithSource(e, t) {
    const i = this.createRowEvent(e, t);
    return i.source = this, i;
  }
  onRowDblClick(e) {
    if (Wt(e))
      return;
    const t = this.createRowEventWithSource("rowDoubleClicked", e);
    t.isEventHandlingSuppressed = this.isSuppressMouseEvent(e), this.beans.eventSvc.dispatchEvent(t);
  }
  findFullWidthInfoForEvent(e) {
    if (!e)
      return;
    const t = this.findFullWidthRowGui(e.target), i = this.getColumnForFullWidth(t);
    if (!(!t || !i))
      return { rowGui: t, column: i };
  }
  findFullWidthRowGui(e) {
    return this.allRowGuis.find((t) => t.element.contains(e));
  }
  getColumnForFullWidth(e) {
    const { visibleCols: t } = this.beans;
    switch (e == null ? void 0 : e.containerType) {
      case "center":
        return t.centerCols[0];
      case "left":
        return t.leftCols[0];
      case "right":
        return t.rightCols[0];
      default:
        return t.allCols[0];
    }
  }
  onRowMouseDown(e) {
    if (this.lastMouseDownOnDragger = Ei(e.target, "ag-row-drag", 3), !this.isFullWidth() || this.isSuppressMouseEvent(e))
      return;
    const { rangeSvc: t, focusSvc: i } = this.beans;
    t == null || t.removeAllCellRanges();
    const s = this.findFullWidthInfoForEvent(e);
    if (!s)
      return;
    const { rowGui: o, column: n } = s, r = o.element, a = e.target, l = this.rowNode;
    let d = e.defaultPrevented || hi();
    r && r.contains(a) && xl(a) && (d = !1), i.setFocusedCell({
      rowIndex: l.rowIndex,
      column: n,
      rowPinned: l.rowPinned,
      forceBrowserFocus: d
    });
  }
  isSuppressMouseEvent(e) {
    const { gos: t, rowNode: i } = this;
    if (this.isFullWidth()) {
      const o = this.findFullWidthRowGui(e.target);
      return Wb(
        t,
        o == null ? void 0 : o.rowComp.getFullWidthCellRendererParams(),
        i,
        e
      );
    }
    const s = ql(t, e.target);
    return s != null && Tn(t, s.column, i, e);
  }
  onRowClick(e) {
    if (Wt(e) || this.lastMouseDownOnDragger)
      return;
    const i = this.isSuppressMouseEvent(e), { eventSvc: s, selectionSvc: o } = this.beans, n = this.createRowEventWithSource("rowClicked", e);
    n.isEventHandlingSuppressed = i, s.dispatchEvent(n), !i && (o == null || o.handleSelectionEvent(e, this.rowNode, "rowClicked"));
  }
  setupDetailRowAutoHeight(e) {
    var t;
    this.rowType === "FullWidthDetail" && ((t = this.beans.masterDetailSvc) == null || t.setupDetailRowAutoHeight(this, e));
  }
  createFullWidthCompDetails(e, t) {
    const { gos: i, rowNode: s } = this, o = W(i, {
      fullWidth: !0,
      data: s.data,
      node: s,
      value: s.key,
      valueFormatted: s.key,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: e,
      eParentOfValue: e,
      pinned: t,
      addRenderedRowListener: this.addEventListener.bind(this),
      // This is not on the type of ICellRendererParams
      registerRowDragger: (r, a, l, d) => this.addFullWidthRowDragging(r, a, l, d),
      setTooltip: (r, a) => {
        i.assertModuleRegistered("Tooltip", 3), this.setupFullWidthRowTooltip(r, a);
      }
    }), n = this.beans.userCompFactory;
    switch (this.rowType) {
      case "FullWidthDetail":
        return Qv(n, o);
      case "FullWidthGroup": {
        const { value: r, valueFormatted: a } = this.beans.valueSvc.getValueForDisplay(void 0, this.rowNode, !0);
        return o.value = r, o.valueFormatted = a, Yv(n, o);
      }
      case "FullWidthLoading":
        return qv(n, o);
      default:
        return jv(n, o);
    }
  }
  setupFullWidthRowTooltip(e, t) {
    var i;
    this.fullWidthGui && (this.tooltipFeature = (i = this.beans.tooltipSvc) == null ? void 0 : i.setupFullWidthRowTooltip(
      this.tooltipFeature,
      this,
      e,
      t
    ));
  }
  addFullWidthRowDragging(e, t, i = "", s) {
    const { rowDragSvc: o, context: n } = this.beans;
    if (!o || !this.isFullWidth())
      return;
    const r = o.createRowDragComp(
      () => i,
      this.rowNode,
      void 0,
      e,
      t,
      s
    );
    this.createBean(r, n), this.addDestroyFunc(() => {
      this.destroyBean(r, n);
    });
  }
  onUiLevelChanged() {
    const e = $c(this.rowNode);
    if (this.rowLevel != e) {
      const t = "ag-row-level-" + e, i = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((s) => {
        s.rowComp.toggleCss(t, !0), s.rowComp.toggleCss(i, !1);
      });
    }
    this.rowLevel = e;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const e = this.isFirstRowOnPage(), t = this.isLastRowOnPage();
    this.firstRowOnPage !== e && (this.firstRowOnPage = e, this.allRowGuis.forEach((i) => i.rowComp.toggleCss("ag-row-first", e))), this.lastRowOnPage !== t && (this.lastRowOnPage = t, this.allRowGuis.forEach((i) => i.rowComp.toggleCss("ag-row-last", t)));
  }
  getAllCellCtrls() {
    return this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0 ? this.centerCellCtrls.list : [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
  }
  postProcessClassesFromGridOptions() {
    var t;
    const e = [];
    (t = this.beans.rowStyleSvc) == null || t.processClassesFromGridOptions(e, this.rowNode), e.length && e.forEach((i) => {
      this.allRowGuis.forEach((s) => s.rowComp.toggleCss(i, !0));
    });
  }
  postProcessRowClassRules() {
    var e;
    (e = this.beans.rowStyleSvc) == null || e.processRowClassRules(
      this.rowNode,
      (t) => {
        this.allRowGuis.forEach((i) => i.rowComp.toggleCss(t, !0));
      },
      (t) => {
        this.allRowGuis.forEach((i) => i.rowComp.toggleCss(t, !1));
      }
    );
  }
  setStylesFromGridOptions(e, t) {
    e && (this.rowStyles = this.processStylesFromGridOptions()), this.forEachGui(t, (i) => i.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(e) {
    return e === "left" || e === "right" ? e : null;
  }
  getInitialRowClasses(e) {
    var a, l;
    const t = this.getPinnedForContainer(e), i = this.isFullWidth(), { rowNode: s, beans: o } = this, n = [];
    n.push("ag-row"), n.push(this.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), this.fadeInAnimation[e] && n.push("ag-opacity-zero"), n.push(s.rowIndex % 2 === 0 ? "ag-row-even" : "ag-row-odd"), s.isRowPinned() && (n.push("ag-row-pinned"), (a = o.pinnedRowModel) != null && a.isManual() && n.push("ag-row-pinned-manual")), !s.isRowPinned() && s.pinnedSibling && n.push("ag-row-pinned-source"), s.isSelected() && n.push("ag-row-selected"), s.footer && n.push("ag-row-footer"), n.push("ag-row-level-" + this.rowLevel), s.stub && n.push("ag-row-loading"), i && n.push("ag-full-width-row"), (l = o.expansionSvc) == null || l.addExpandedCss(n, s), s.dragging && n.push("ag-row-dragging");
    const { rowStyleSvc: r } = o;
    return r && (r.processClassesFromGridOptions(n, s), r.preProcessRowClassRules(n, s)), n.push(this.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), this.isFirstRowOnPage() && n.push("ag-row-first"), this.isLastRowOnPage() && n.push("ag-row-last"), i && (t === "left" && n.push("ag-cell-last-left-pinned"), t === "right" && n.push("ag-cell-first-right-pinned")), n;
  }
  processStylesFromGridOptions() {
    var e;
    return ((e = this.beans.rowStyleSvc) == null ? void 0 : e.processStylesFromGridOptions(this.rowNode)) ?? this.emptyStyle;
  }
  onRowSelected(e) {
    var t;
    (t = this.beans.selectionSvc) == null || t.onRowCtrlSelected(
      this,
      (i) => {
        (i === this.centerGui || i === this.fullWidthGui) && this.announceDescription();
      },
      e
    );
  }
  announceDescription() {
    var e;
    (e = this.beans.selectionSvc) == null || e.announceAriaRowSelection(this.rowNode);
  }
  addHoverFunctionality(e) {
    if (!this.active)
      return;
    const { element: t, compBean: i } = e, { rowNode: s, beans: o, gos: n } = this;
    i.addManagedListeners(t, {
      // We use pointer events here instead of mouse events, as pointer events
      // are more reliable for hover detection, especially with touch devices
      // or hybrid touch + mouse devices.
      pointerenter: (r) => {
        r.pointerType === "mouse" && s.dispatchRowEvent("mouseEnter");
      },
      pointerleave: (r) => {
        r.pointerType === "mouse" && s.dispatchRowEvent("mouseLeave");
      }
    }), i.addManagedListeners(s, {
      mouseEnter: () => {
        var r;
        !((r = o.dragSvc) != null && r.dragging) && !n.get("suppressRowHoverHighlight") && (t.classList.add("ag-row-hover"), s.setHovered(!0));
      },
      mouseLeave: () => {
        this.resetHoveredStatus(t);
      }
    });
  }
  resetHoveredStatus(e) {
    const t = e ? [e] : this.allRowGuis.map((i) => i.element);
    for (const i of t)
      i.classList.remove("ag-row-hover");
    this.rowNode.setHovered(!1);
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(e) {
    const t = this.beans.ctrlsSvc.getScrollFeature().getApproximateVScollPosition(), i = this.applyPaginationOffset(t.top, !0) - 100, s = this.applyPaginationOffset(t.bottom, !0) + 100;
    return Math.min(Math.max(i, e), s);
  }
  forEachGui(e, t) {
    e ? t(e) : this.allRowGuis.forEach(t);
  }
  isRowRendered() {
    return this.allRowGuis.length > 0;
  }
  onRowHeightChanged(e) {
    if (this.rowNode.rowHeight == null)
      return;
    const t = this.rowNode.rowHeight, i = this.beans.environment.getDefaultRowHeight(), o = Kh(this.gos) ? ri(this.beans, this.rowNode).height : void 0, n = o ? `${Math.min(i, o) - 2}px` : void 0;
    this.forEachGui(e, (r) => {
      r.element.style.height = `${t}px`, n && r.element.style.setProperty("--ag-line-height", n);
    });
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass(e = !1) {
    var s;
    this.active = !1;
    const { rowNode: t } = this;
    if (!e && as(this.gos) && !t.sticky)
      if (t.rowTop != null) {
        const n = this.roundRowTopToBounds(t.rowTop);
        this.setRowTop(n);
      } else
        this.allRowGuis.forEach((n) => n.rowComp.toggleCss("ag-opacity-zero", !0));
    (s = this.fullWidthGui) != null && s.element.contains(he(this.beans)) && this.beans.focusSvc.attemptToRecoverFocus(), t.setHovered(!1);
    const i = this.createRowEvent("virtualRowRemoved");
    this.dispatchLocalEvent(i), this.beans.eventSvc.dispatchEvent(i), super.destroy();
  }
  destroySecondPass() {
    this.allRowGuis.length = 0;
    const e = (t) => (t.list.forEach((i) => i.destroy()), { list: [], map: {} });
    this.centerCellCtrls = e(this.centerCellCtrls), this.leftCellCtrls = e(this.leftCellCtrls), this.rightCellCtrls = e(this.rightCellCtrls);
  }
  setFocusedClasses(e) {
    this.forEachGui(e, (t) => {
      t.rowComp.toggleCss("ag-row-focus", this.rowFocused), t.rowComp.toggleCss("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const { focusSvc: e } = this.beans, t = e.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    t !== this.rowFocused && (this.rowFocused = t, this.setFocusedClasses());
  }
  onPaginationChanged() {
    var t;
    const e = ((t = this.beans.pagination) == null ? void 0 : t.getCurrentPage()) ?? 0;
    this.paginationPage !== e && (this.paginationPage = e, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(e, t = !1) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky)
      return e;
    const i = this.beans.pageBounds.getPixelOffset();
    return e + i * (t ? 1 : -1);
  }
  setRowTop(e) {
    if (!this.printLayout && H(e)) {
      const t = this.applyPaginationOffset(e), o = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? t : this.beans.rowContainerHeight.getRealPixelPosition(t)}px`;
      this.setRowTopStyle(o);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(e) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(e) : void 0;
  }
  getInitialTransform(e) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(e)})`;
  }
  getInitialRowTopShared(e) {
    if (this.printLayout)
      return "";
    const t = this.rowNode;
    let i;
    if (t.sticky)
      i = t.stickyRowTop;
    else {
      const s = this.slideInAnimation[e] ? this.roundRowTopToBounds(t.oldRowTop) : t.rowTop, o = this.applyPaginationOffset(s);
      i = t.isRowPinned() ? o : this.beans.rowContainerHeight.getRealPixelPosition(o);
    }
    return i + "px";
  }
  setRowTopStyle(e) {
    this.allRowGuis.forEach(
      (t) => this.suppressRowTransform ? t.rowComp.setTop(e) : t.rowComp.setTransform(`translateY(${e})`)
    );
  }
  getCellCtrl(e, t = !1) {
    let i = null;
    return this.getAllCellCtrls().forEach((s) => {
      s.column == e && (i = s);
    }), i != null || t || this.getAllCellCtrls().forEach((s) => {
      (s == null ? void 0 : s.getColSpanningList().indexOf(e)) >= 0 && (i = s);
    }), i;
  }
  onRowIndexChanged() {
    this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
  }
  updateRowIndexes(e) {
    var n, r;
    const t = this.rowNode.getRowIndexString();
    if (t === null)
      return;
    const i = (((n = this.beans.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : n.getRowCount()) ?? 0) + (((r = this.beans.filterManager) == null ? void 0 : r.getHeaderRowCount()) ?? 0), s = this.rowNode.rowIndex % 2 === 0, o = i + this.rowNode.rowIndex + 1;
    this.forEachGui(e, (a) => {
      a.rowComp.setRowIndex(t), a.rowComp.toggleCss("ag-row-even", s), a.rowComp.toggleCss("ag-row-odd", !s), Gn(a.element, o);
    });
  }
}, mP = class extends E {
  constructor() {
    super(), this.beanName = "navigation", this.onPageDown = Ud(this.onPageDown, 100), this.onPageUp = Ud(this.onPageUp, 100);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(e, t = !1) {
    const i = e.key, s = e.altKey, o = e.ctrlKey || e.metaKey, n = !!this.beans.rangeSvc && e.shiftKey, r = py(this.gos, e);
    let a = !1;
    switch (i) {
      case P.PAGE_HOME:
      case P.PAGE_END:
        !o && !s && (this.onHomeOrEndKey(i), a = !0);
        break;
      case P.LEFT:
      case P.RIGHT:
      case P.UP:
      case P.DOWN:
        if (!r)
          return !1;
        o && !s && !n && (this.onCtrlUpDownLeftRight(i, r), a = !0);
        break;
      case P.PAGE_DOWN:
      case P.PAGE_UP:
        !o && !s && (a = this.handlePageUpDown(i, r, t));
        break;
    }
    return a && e.preventDefault(), a;
  }
  handlePageUpDown(e, t, i) {
    return i && (t = this.beans.focusSvc.getFocusedCell()), t ? (e === P.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0) : !1;
  }
  navigateTo({
    scrollIndex: e,
    scrollType: t,
    scrollColumn: i,
    focusIndex: s,
    focusColumn: o,
    isAsync: n,
    rowPinned: r
  }) {
    const { scrollFeature: a } = this.gridBodyCon;
    H(i) && !i.isPinned() && a.ensureColumnVisible(i), H(e) && a.ensureIndexVisible(e, t), n || a.ensureIndexVisible(s);
    const { focusSvc: l, rangeSvc: d } = this.beans;
    l.setFocusedCell({
      rowIndex: s,
      column: o,
      rowPinned: r,
      forceBrowserFocus: !0
    }), d == null || d.setRangeToCell({ rowIndex: s, rowPinned: r, column: o });
  }
  // this method is throttled, see the `constructor`
  onPageDown(e) {
    const t = this.beans, i = ha(t), s = this.getViewportHeight(), { pageBounds: o, rowModel: n, rowAutoHeight: r } = t, a = o.getPixelOffset(), l = i.top + s, d = n.getRowIndexAtPixel(l + a);
    r != null && r.active ? this.navigateToNextPageWithAutoHeight(e, d) : this.navigateToNextPage(e, d);
  }
  // this method is throttled, see the `constructor`
  onPageUp(e) {
    const t = this.beans, i = ha(t), { pageBounds: s, rowModel: o, rowAutoHeight: n } = t, r = s.getPixelOffset(), a = i.top, l = o.getRowIndexAtPixel(a + r);
    n != null && n.active ? this.navigateToNextPageWithAutoHeight(e, l, !0) : this.navigateToNextPage(e, l, !0);
  }
  navigateToNextPage(e, t, i = !1) {
    const { pageBounds: s, rowModel: o } = this.beans, n = this.getViewportHeight(), r = s.getFirstRow(), a = s.getLastRow(), l = s.getPixelOffset(), d = o.getRow(e.rowIndex), c = i ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
      (d == null ? void 0 : d.rowHeight) - n - l
    ) : n - l, u = (d == null ? void 0 : d.rowTop) + c;
    let h = o.getRowIndexAtPixel(u + l);
    if (h === e.rowIndex) {
      const p = i ? -1 : 1;
      t = h = e.rowIndex + p;
    }
    let g;
    i ? (g = "bottom", h < r && (h = r), t < r && (t = r)) : (g = "top", h > a && (h = a), t > a && (t = a)), this.isRowTallerThanView(o.getRow(h)) && (t = h, g = "top"), this.navigateTo({
      scrollIndex: t,
      scrollType: g,
      scrollColumn: null,
      focusIndex: h,
      focusColumn: e.column
    });
  }
  navigateToNextPageWithAutoHeight(e, t, i = !1) {
    this.navigateTo({
      scrollIndex: t,
      scrollType: i ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: t,
      focusColumn: e.column
    }), setTimeout(() => {
      const s = this.getNextFocusIndexForAutoHeight(e, i);
      this.navigateTo({
        scrollIndex: t,
        scrollType: i ? "bottom" : "top",
        scrollColumn: null,
        focusIndex: s,
        focusColumn: e.column,
        isAsync: !0
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(e, t = !1) {
    const i = t ? -1 : 1, s = this.getViewportHeight(), { pageBounds: o, rowModel: n } = this.beans, r = o.getLastRow();
    let a = 0, l = e.rowIndex;
    for (; l >= 0 && l <= r; ) {
      const d = n.getRow(l);
      if (d) {
        const c = d.rowHeight ?? 0;
        if (a + c > s)
          break;
        a += c;
      }
      l += i;
    }
    return Math.max(0, Math.min(l, r));
  }
  getViewportHeight() {
    const e = this.beans, t = ha(e), i = this.beans.scrollVisibleSvc.getScrollbarWidth();
    let s = t.bottom - t.top;
    return e.ctrlsSvc.get("center").isHorizontalScrollShowing() && (s -= i), s;
  }
  isRowTallerThanView(e) {
    if (!e)
      return !1;
    const t = e.rowHeight;
    return typeof t != "number" ? !1 : t > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(e, t) {
    const i = this.beans.cellNavigation.getNextCellToFocus(e, t, !0), s = this.getNormalisedPosition(i), { rowIndex: o, rowPinned: n, column: r } = s ?? i, a = r;
    this.navigateTo({
      scrollIndex: o,
      scrollType: null,
      scrollColumn: a,
      focusIndex: o,
      focusColumn: a,
      rowPinned: n
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(e) {
    const t = e === P.PAGE_HOME, { visibleCols: i, pageBounds: s, rowModel: o } = this.beans, n = i.allCols, r = t ? s.getFirstRow() : s.getLastRow(), a = o.getRow(r);
    if (!a)
      return;
    const l = (t ? n : [...n].reverse()).find(
      (d) => !d.isSuppressNavigable(a)
    );
    l && this.navigateTo({
      scrollIndex: r,
      scrollType: null,
      scrollColumn: l,
      focusIndex: r,
      focusColumn: l
    });
  }
  // result of keyboard event
  onTabKeyDown(e, t) {
    const i = t.shiftKey, s = this.tabToNextCellCommon(e, i, t), o = this.beans, { ctrlsSvc: n, pageBounds: r, focusSvc: a, gos: l } = o;
    if (s !== !1) {
      s ? t.preventDefault() : s === null && n.get("gridCtrl").allowFocusForNextCoreContainer(i);
      return;
    }
    if (i) {
      const { rowIndex: d, rowPinned: c } = e.getRowPosition();
      (c ? d === 0 : d === r.getFirstRow()) && (l.get("headerHeight") === 0 || Ai(o) ? Ss(o, !0, !0) : (t.preventDefault(), a.focusPreviousFromFirstCell(t)));
    } else
      e instanceof fs && e.focusCell(!0), (!i && a.focusOverlay(!1) || Ss(o, i)) && t.preventDefault();
  }
  // comes from API
  tabToNextCell(e, t) {
    const i = this.beans, { focusSvc: s, rowRenderer: o } = i, n = s.getFocusedCell();
    if (!n)
      return !1;
    let r = os(i, n);
    return !r && (r = o.getRowByPosition(n), !r || !r.isFullWidth()) ? !1 : !!this.tabToNextCellCommon(r, e, t, "api");
  }
  tabToNextCellCommon(e, t, i, s = "ui") {
    var l;
    const { editSvc: o, focusSvc: n } = this.beans;
    let r;
    const a = e instanceof fs ? e : (l = e.getAllCellCtrls()) == null ? void 0 : l[0];
    return o != null && o.isEditing() ? r = o == null ? void 0 : o.moveToNextCell(a, t, i, s) : r = this.moveToNextCellNotEditing(e, t, i), r === null ? r : r || !!n.focusedHeader;
  }
  // returns null if no navigation should be performed
  moveToNextCellNotEditing(e, t, i) {
    const s = this.beans.visibleCols.allCols;
    let o;
    if (e instanceof rr) {
      if (o = {
        ...e.getRowPosition(),
        column: t ? s[0] : se(s)
      }, this.gos.get("embedFullWidthRows") && i) {
        const r = e.findFullWidthInfoForEvent(i);
        r && (o.column = r.column);
      }
    } else
      o = e.getFocusedCellPosition();
    const n = this.findNextCellToFocusOn(o, { backwards: t, startEditing: !1 });
    if (n === !1)
      return null;
    if (n instanceof fs)
      n.focusCell(!0);
    else if (n)
      return this.tryToFocusFullWidthRow(n, t);
    return H(n);
  }
  /**
   * called by the cell, when tab is pressed while editing.
   * @returns RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */
  findNextCellToFocusOn(e, { backwards: t, startEditing: i, skipToNextEditableCell: s }) {
    let o = e;
    const n = this.beans, { cellNavigation: r, gos: a, focusSvc: l, rowRenderer: d, rangeSvc: c } = n;
    for (; ; ) {
      e !== o && (e = o), t || (o = this.getLastCellOfColSpan(o)), o = r.getNextTabbedCell(o, t);
      const u = a.getCallback("tabToNextCell");
      if (H(u)) {
        const f = u({
          backwards: t,
          editing: i,
          previousCellPosition: e,
          nextCellPosition: o || null
        });
        if (f === !0)
          o = e;
        else {
          if (f === !1)
            return !1;
          o = {
            rowIndex: f.rowIndex,
            column: f.column,
            rowPinned: f.rowPinned
          };
        }
      }
      if (!o)
        return null;
      if (o.rowIndex < 0) {
        const p = xt(n);
        return l.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: p + o.rowIndex,
            column: o.column
          },
          fromCell: !0
        }), null;
      }
      const h = a.get("editType") === "fullRow";
      if (i && (!h || s) && !this.isCellEditable(o))
        continue;
      this.ensureCellVisible(o);
      const g = os(n, o);
      if (!g) {
        const p = d.getRowByPosition(o);
        if (!p || !p.isFullWidth() || i)
          continue;
        return { ...p.getRowPosition(), column: o == null ? void 0 : o.column };
      }
      if (!r.isSuppressNavigable(g.column, g.rowNode))
        return g.setFocusedCellPosition(o), c == null || c.setRangeToCell(o), g;
    }
  }
  isCellEditable(e) {
    const t = this.lookupRowNodeForCell(e);
    return t ? e.column.isCellEditable(t) : !1;
  }
  lookupRowNodeForCell({ rowIndex: e, rowPinned: t }) {
    const { pinnedRowModel: i, rowModel: s } = this.beans;
    return t === "top" ? i == null ? void 0 : i.getPinnedTopRow(e) : t === "bottom" ? i == null ? void 0 : i.getPinnedBottomRow(e) : s.getRow(e);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(e, t, i, s) {
    let o = i, n = !1;
    const r = this.beans, { cellNavigation: a, focusSvc: l, gos: d } = r;
    for (; o && (o === i || !this.isValidNavigateCell(o)); )
      d.get("enableRtl") ? t === P.LEFT && (o = this.getLastCellOfColSpan(o)) : t === P.RIGHT && (o = this.getLastCellOfColSpan(o)), o = a.getNextCellToFocus(t, o), n = de(o);
    if (n && e && e.key === P.UP && (o = {
      rowIndex: -1,
      rowPinned: null,
      column: i.column
    }), s) {
      const u = d.getCallback("navigateToNextCell");
      if (H(u)) {
        const g = u({
          key: t,
          previousCellPosition: i,
          nextCellPosition: o || null,
          event: e
        });
        H(g) ? o = {
          rowPinned: g.rowPinned,
          rowIndex: g.rowIndex,
          column: g.column
        } : o = null;
      }
    }
    if (!o)
      return;
    if (o.rowIndex < 0) {
      const u = xt(r);
      l.focusHeaderPosition({
        headerPosition: { headerRowIndex: u + o.rowIndex, column: i.column },
        event: e || void 0,
        fromCell: !0
      });
      return;
    }
    const c = this.getNormalisedPosition(o);
    c ? this.focusPosition(c) : this.tryToFocusFullWidthRow(o);
  }
  getNormalisedPosition(e) {
    var s;
    if (!!((s = this.beans.spannedRowRenderer) != null && s.getCellByPosition(e)))
      return e;
    this.ensureCellVisible(e);
    const i = os(this.beans, e);
    return i ? (e = i.getFocusedCellPosition(), this.ensureCellVisible(e), e) : null;
  }
  tryToFocusFullWidthRow(e, t) {
    const { visibleCols: i, rowRenderer: s, focusSvc: o, eventSvc: n } = this.beans, r = i.allCols, a = s.getRowByPosition(e);
    if (!a || !a.isFullWidth())
      return !1;
    const l = o.getFocusedCell(), d = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: e.column || (t ? se(r) : r[0])
    };
    this.focusPosition(d);
    const c = t ?? (l != null && nR(d, l));
    return n.dispatchEvent({
      type: "fullWidthRowFocused",
      rowIndex: d.rowIndex,
      rowPinned: d.rowPinned,
      column: d.column,
      isFullWidthCell: !0,
      fromBelow: c
    }), !0;
  }
  focusPosition(e) {
    const { focusSvc: t, rangeSvc: i } = this.beans;
    t.setFocusedCell({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0
    }), i == null || i.setRangeToCell(e);
  }
  isValidNavigateCell(e) {
    return !!Ut(this.beans, e);
  }
  getLastCellOfColSpan(e) {
    const t = os(this.beans, e);
    if (!t)
      return e;
    const i = t.getColSpanningList();
    return i.length === 1 ? e : {
      rowIndex: e.rowIndex,
      column: se(i),
      rowPinned: e.rowPinned
    };
  }
  ensureCellVisible(e) {
    const t = qh(this.gos), i = this.beans.rowModel.getRow(e.rowIndex), s = t && (i == null ? void 0 : i.sticky), { scrollFeature: o } = this.gridBodyCon;
    !s && de(e.rowPinned) && o.ensureIndexVisible(e.rowIndex), e.column.isPinned() || o.ensureColumnVisible(e.column);
  }
  ensureColumnVisible(e) {
    const t = this.gridBodyCon.scrollFeature;
    e.isPinned() || t.ensureColumnVisible(e);
  }
  ensureRowVisible(e) {
    this.gridBodyCon.scrollFeature.ensureIndexVisible(e);
  }
};
function ha(e) {
  return e.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
var CP = {
  moduleName: "KeyboardNavigation",
  version: B,
  beans: [mP, G0, XF],
  apiFunctions: {
    getFocusedCell: V0,
    clearFocusedCell: N0,
    setFocusedCell: W0,
    setFocusedHeader: $0,
    tabToNextCell: z0,
    tabToPreviousCell: U0
  }
}, vP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsListener";
  }
  postConstruct() {
    this.addManagedEventListeners({
      modelUpdated: this.onModelUpdated.bind(this),
      recalculateRowBounds: this.calculatePages.bind(this)
    }), this.onModelUpdated();
  }
  onModelUpdated(e) {
    this.calculatePages(), this.eventSvc.dispatchEvent({
      type: "paginationChanged",
      animate: (e == null ? void 0 : e.animate) ?? !1,
      newData: (e == null ? void 0 : e.newData) ?? !1,
      newPage: (e == null ? void 0 : e.newPage) ?? !1,
      newPageSize: (e == null ? void 0 : e.newPageSize) ?? !1,
      keepRenderedRows: (e == null ? void 0 : e.keepRenderedRows) ?? !1
    });
  }
  calculatePages() {
    const { pageBounds: e, pagination: t, rowModel: i } = this.beans;
    t ? t.calculatePages() : e.calculateBounds(0, i.getRowCount() - 1);
  }
}, wP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "pageBounds", this.pixelOffset = 0;
  }
  getFirstRow() {
    var e;
    return ((e = this.topRowBounds) == null ? void 0 : e.rowIndex) ?? -1;
  }
  getLastRow() {
    var e;
    return ((e = this.bottomRowBounds) == null ? void 0 : e.rowIndex) ?? -1;
  }
  getCurrentPageHeight() {
    const { topRowBounds: e, bottomRowBounds: t } = this;
    return !e || !t ? 0 : Math.max(t.rowTop + t.rowHeight - e.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const { topRowBounds: e, bottomRowBounds: t } = this, i = (e == null ? void 0 : e.rowTop) ?? 0, s = t ? t.rowTop + t.rowHeight : 0;
    return { pageFirstPixel: i, pageLastPixel: s };
  }
  calculateBounds(e, t) {
    const { rowModel: i } = this.beans, s = i.getRowBounds(e);
    s && (s.rowIndex = e), this.topRowBounds = s;
    const o = i.getRowBounds(t);
    o && (o.rowIndex = t), this.bottomRowBounds = o, this.calculatePixelOffset();
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  calculatePixelOffset() {
    var t;
    const e = ((t = this.topRowBounds) == null ? void 0 : t.rowTop) ?? 0;
    this.pixelOffset !== e && (this.pixelOffset = e, this.eventSvc.dispatchEvent({ type: "paginationPixelOffsetChanged" }));
  }
}, bP = (
  /*css*/
  ".ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top{min-width:0;overflow:hidden;position:relative}.ag-pinned-left-sticky-top,.ag-pinned-right-sticky-top{height:100%;overflow:hidden;position:relative}.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{height:100%;overflow:hidden;width:100%}.ag-pinned-left-header,.ag-pinned-right-header{display:inline-block;height:100%;overflow:hidden;position:relative}.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible){.ag-horizontal-left-spacer:not(.ag-scroller-corner){border-right:var(--ag-pinned-column-border)}.ag-horizontal-right-spacer:not(.ag-scroller-corner){border-left:var(--ag-pinned-column-border)}}.ag-pinned-right-header{border-left:var(--ag-pinned-column-border)}.ag-pinned-left-header{border-right:var(--ag-pinned-column-border)}.ag-cell.ag-cell-first-right-pinned:not(.ag-cell-range-left,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-left:var(--ag-pinned-column-border)}.ag-cell.ag-cell-last-left-pinned:not(.ag-cell-range-right,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-right:var(--ag-pinned-column-border)}.ag-pinned-left-header .ag-header-cell-resize:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}.ag-pinned-right-header .ag-header-cell-resize:after{left:50%}.ag-pinned-left-header .ag-header-cell-resize{right:-3px}.ag-pinned-right-header .ag-header-cell-resize{left:-3px}"
), yP = class extends E {
  constructor(e, t) {
    super(), this.isLeft = e, this.elements = t, this.getWidth = e ? () => this.beans.pinnedCols.leftWidth : () => this.beans.pinnedCols.rightWidth;
  }
  postConstruct() {
    this.addManagedEventListeners({
      [`${this.isLeft ? "left" : "right"}PinnedWidthChanged`]: this.onPinnedWidthChanged.bind(this)
    });
  }
  onPinnedWidthChanged() {
    const e = this.getWidth(), t = e > 0;
    for (const i of this.elements)
      i && (le(i, t), Ft(i, e));
  }
}, SP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "pinnedCols";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (t) => {
      this.gridBodyCtrl = t.gridBodyCtrl;
    });
    const e = this.checkContainerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e
    }), this.addManagedPropertyListener("domLayout", e);
  }
  checkContainerWidths() {
    const { gos: e, visibleCols: t, eventSvc: i } = this.beans, s = Me(e, "print"), o = s ? 0 : t.getColsLeftWidth(), n = s ? 0 : t.getDisplayedColumnsRightWidth();
    o != this.leftWidth && (this.leftWidth = o, i.dispatchEvent({ type: "leftPinnedWidthChanged" })), n != this.rightWidth && (this.rightWidth = n, i.dispatchEvent({ type: "rightPinnedWidthChanged" }));
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const e = this.gridBodyCtrl.eBodyViewport, t = So(e);
    if (t <= 50)
      return;
    const i = this.getPinnedColumnsOverflowingViewport(t - 50), s = this.gos.getCallback("processUnpinnedColumns"), { columns: o, hasLockedPinned: n } = i;
    let r = o;
    !r.length && !n || (s && (r = s({
      columns: r,
      viewportWidth: t
    })), !(!r || !r.length) && (r = r.filter((a) => !ii(a)), this.setColsPinned(r, null, "viewportSizeFeature")));
  }
  createPinnedWidthFeature(e, ...t) {
    return new yP(e, t);
  }
  setColsPinned(e, t, i) {
    const { colModel: s, colAnimation: o, visibleCols: n, gos: r } = this.beans;
    if (!s.cols || !(e != null && e.length))
      return;
    if (Me(r, "print")) {
      I(37);
      return;
    }
    o == null || o.start();
    let a;
    t === !0 || t === "left" ? a = "left" : t === "right" ? a = "right" : a = null;
    const l = [];
    e.forEach((d) => {
      if (!d)
        return;
      const c = s.getCol(d);
      c && c.getPinned() !== a && (this.setColPinned(c, a), l.push(c));
    }), l.length && (n.refresh(i), ug(this.eventSvc, l, i)), o == null || o.finish();
  }
  initCol(e) {
    const { pinned: t, initialPinned: i } = e.colDef;
    t !== void 0 ? this.setColPinned(e, t) : this.setColPinned(e, i);
  }
  setColPinned(e, t) {
    t === !0 || t === "left" ? e.pinned = "left" : t === "right" ? e.pinned = "right" : e.pinned = null, e.dispatchStateUpdatedEvent("pinned");
  }
  setupHeaderPinnedWidth(e) {
    const { scrollVisibleSvc: t } = this.beans;
    if (e.pinned == null)
      return;
    const i = e.pinned === "left", s = e.pinned === "right";
    e.hidden = !0;
    const o = () => {
      const n = i ? this.leftWidth : this.rightWidth;
      if (n == null)
        return;
      const r = n == 0, a = e.hidden !== r, l = this.gos.get("enableRtl"), d = t.getScrollbarWidth(), u = t.verticalScrollShowing && (l && i || !l && s) ? n + d : n;
      e.comp.setPinnedContainerWidth(`${u}px`), e.comp.setDisplayed(!r), a && (e.hidden = r, e.refresh());
    };
    e.addManagedEventListeners({
      leftPinnedWidthChanged: o,
      rightPinnedWidthChanged: o,
      scrollVisibilityChanged: o,
      scrollbarWidthChanged: o
    });
  }
  getHeaderResizeDiff(e, t) {
    if (t.getPinned()) {
      const { leftWidth: s, rightWidth: o } = this, n = So(this.beans.ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
      if (s + o + e > n)
        if (n > s + o)
          e = n - s - o;
        else
          return 0;
    }
    return e;
  }
  getPinnedColumnsOverflowingViewport(e) {
    const t = this.rightWidth ?? 0, i = this.leftWidth ?? 0, s = t + i;
    let o = !1;
    if (s < e)
      return { columns: [], hasLockedPinned: o };
    const { visibleCols: n } = this.beans, r = [...n.leftCols], a = [...n.rightCols];
    let l = 0, d = 0;
    const c = 0, u = [];
    let h = s - c - e;
    for (; (d < r.length || l < a.length) && h > 0; ) {
      if (l < a.length) {
        const g = a[l++];
        if (g.colDef.lockPinned) {
          o = !0;
          continue;
        }
        h -= g.getActualWidth(), u.push(g);
      }
      if (d < r.length && h > 0) {
        const g = r[d++];
        if (g.colDef.lockPinned) {
          o = !0;
          continue;
        }
        h -= g.getActualWidth(), u.push(g);
      }
    }
    return { columns: u, hasLockedPinned: o };
  }
}, RP = {
  moduleName: "PinnedColumn",
  version: B,
  beans: [SP],
  css: [bP]
}, xP = class extends E {
  constructor() {
    super(), this.beanName = "ariaAnnounce", this.descriptionContainer = null, this.pendingAnnouncements = /* @__PURE__ */ new Map(), this.lastAnnouncement = "", this.updateAnnouncement = De(this, this.updateAnnouncement.bind(this), 200);
  }
  postConstruct() {
    const e = this.beans, t = Ee(e), i = this.descriptionContainer = t.createElement("div");
    i.classList.add("ag-aria-description-container"), Fh(i, "polite"), Ym(i, "additions text"), qm(i, !0), e.eGridDiv.appendChild(i);
  }
  /**
   * @param key used for debouncing calls
   */
  announceValue(e, t) {
    this.pendingAnnouncements.set(t, e), this.updateAnnouncement();
  }
  updateAnnouncement() {
    if (!this.descriptionContainer)
      return;
    const e = Array.from(this.pendingAnnouncements.values()).join(". ");
    this.pendingAnnouncements.clear(), this.descriptionContainer.textContent = "", setTimeout(() => {
      this.handleAnnouncementUpdate(e);
    }, 50);
  }
  handleAnnouncementUpdate(e) {
    if (!this.isAlive() || !this.descriptionContainer)
      return;
    let t = e;
    if (t == null || t.replace(/[ .]/g, "") == "") {
      this.lastAnnouncement = "";
      return;
    }
    this.lastAnnouncement === t && (t = `${t}`), this.lastAnnouncement = t, this.descriptionContainer.textContent = t;
  }
  destroy() {
    var t;
    super.destroy();
    const { descriptionContainer: e } = this;
    e && (Te(e), (t = e.parentElement) == null || t.removeChild(e)), this.descriptionContainer = null, this.pendingAnnouncements.clear();
  }
}, FP = {
  moduleName: "Aria",
  version: B,
  beans: [xP]
}, PP = (
  /*css*/
  ":where(.ag-delay-render){.ag-cell,.ag-header-cell,.ag-header-group-cell,.ag-row,.ag-spanned-cell-wrapper{visibility:hidden}}"
), Kc = "ag-delay-render", EP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colDelayRenderSvc", this.hideRequested = !1, this.alreadyRevealed = !1, this.timesRetried = 0, this.requesters = /* @__PURE__ */ new Set();
  }
  hideColumns(e) {
    this.alreadyRevealed || this.requesters.has(e) || (this.requesters.add(e), this.hideRequested || (this.beans.ctrlsSvc.whenReady(this, (t) => {
      t.gridBodyCtrl.eGridBody.classList.add(Kc);
    }), this.hideRequested = !0));
  }
  revealColumns(e) {
    if (this.alreadyRevealed || !this.isAlive() || (this.requesters.delete(e), this.requesters.size > 0))
      return;
    const { renderStatus: t, ctrlsSvc: i } = this.beans;
    if (t) {
      if (!t.areHeaderCellsRendered() && this.timesRetried < 5) {
        this.timesRetried++, setTimeout(() => this.revealColumns(e));
        return;
      }
      this.timesRetried = 0;
    }
    i.getGridBodyCtrl().eGridBody.classList.remove(Kc), this.alreadyRevealed = !0;
  }
}, DP = {
  moduleName: "ColumnDelayRender",
  version: B,
  beans: [EP],
  css: [PP]
};
function TP(e) {
  var t;
  (t = e.overlays) == null || t.showLoadingOverlay();
}
function MP(e) {
  var t;
  (t = e.overlays) == null || t.showNoRowsOverlay();
}
function AP(e) {
  var t;
  (t = e.overlays) == null || t.hideOverlay();
}
var IP = (
  /*css*/
  ".ag-overlay{inset:0;pointer-events:none;position:absolute;z-index:2}.ag-overlay-panel,.ag-overlay-wrapper{display:flex;height:100%;width:100%}.ag-overlay-wrapper{align-items:center;flex:none;justify-content:center;text-align:center}.ag-overlay-loading-wrapper{pointer-events:all}.ag-overlay-loading-center{background:var(--ag-background-color);border:solid var(--ag-border-width) var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-popup-shadow);padding:var(--ag-spacing)}"
), kP = {
  tag: "div",
  cls: "ag-overlay",
  role: "presentation",
  children: [
    {
      tag: "div",
      cls: "ag-overlay-panel",
      role: "presentation",
      children: [{ tag: "div", ref: "eOverlayWrapper", cls: "ag-overlay-wrapper", role: "presentation" }]
    }
  ]
}, _p = class extends te {
  constructor() {
    super(kP), this.eOverlayWrapper = _, this.activePromise = null, this.activeOverlay = null, this.updateListenerDestroyFunc = null, this.activeCssClass = null, this.elToFocusAfter = null, this.registerCSS(IP);
  }
  handleKeyDown(e) {
    if (e.key !== P.TAB || e.defaultPrevented || Wt(e))
      return;
    const t = this.beans;
    if (zi(t, this.eOverlayWrapper, !1, e.shiftKey))
      return;
    let s = !1;
    e.shiftKey ? s = t.focusSvc.focusGridView({
      column: se(t.visibleCols.allCols),
      backwards: !0,
      canFocusOverlay: !1
    }) : s = Ss(t, !1), s && e.preventDefault();
  }
  updateLayoutClasses(e, t) {
    const i = this.eOverlayWrapper.classList, { AUTO_HEIGHT: s, NORMAL: o, PRINT: n } = lt;
    i.toggle(s, t.autoHeight), i.toggle(o, t.normal), i.toggle(n, t.print);
  }
  postConstruct() {
    this.createManagedBean(new Kl(this)), this.setDisplayed(!1, { skipAriaHidden: !0 }), this.beans.overlays.setOverlayWrapperComp(this), this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
  }
  setWrapperTypeClass(e) {
    const t = this.eOverlayWrapper.classList;
    this.activeCssClass && t.toggle(this.activeCssClass, !1), this.activeCssClass = e, t.toggle(e, !0);
  }
  showOverlay(e, t, i, s) {
    if (this.setWrapperTypeClass(t), this.destroyActiveOverlay(), this.elToFocusAfter = null, this.activePromise = e, !!e) {
      if (this.setDisplayed(!0, { skipAriaHidden: !0 }), i && this.isGridFocused()) {
        const o = he(this.beans);
        o && !yh(this.beans) && (this.elToFocusAfter = o);
      }
      e.then((o) => {
        if (this.activePromise !== e) {
          this.activeOverlay !== o && (this.destroyBean(o), o = null);
          return;
        }
        if (this.activePromise = null, !!o) {
          if (this.activeOverlay !== o && (this.eOverlayWrapper.appendChild(o.getGui()), this.activeOverlay = o, s)) {
            const n = o;
            this.updateListenerDestroyFunc = this.addManagedPropertyListener(s, ({ currentValue: r }) => {
              var a;
              (a = n.refresh) == null || a.call(n, W(this.gos, { ...r ?? {} }));
            });
          }
          i && this.isGridFocused() && _i(this.eOverlayWrapper);
        }
      });
    }
  }
  updateOverlayWrapperPaddingTop(e) {
    this.eOverlayWrapper.style.setProperty("padding-top", `${e}px`);
  }
  destroyActiveOverlay() {
    var s;
    this.activePromise = null;
    const e = this.activeOverlay;
    if (!e)
      return;
    let t = this.elToFocusAfter;
    this.activeOverlay = null, this.elToFocusAfter = null, t && !this.isGridFocused() && (t = null);
    const i = this.updateListenerDestroyFunc;
    i && (i(), this.updateListenerDestroyFunc = null), this.destroyBean(e), Te(this.eOverlayWrapper), (s = t == null ? void 0 : t.focus) == null || s.call(t, { preventScroll: !0 });
  }
  hideOverlay() {
    this.destroyActiveOverlay(), this.setDisplayed(!1, { skipAriaHidden: !0 });
  }
  isGridFocused() {
    const e = he(this.beans);
    return !!e && this.beans.eGridDiv.contains(e);
  }
  destroy() {
    this.elToFocusAfter = null, this.destroyActiveOverlay(), this.beans.overlays.setOverlayWrapperComp(void 0), super.destroy();
  }
}, LP = {
  selector: "AG-OVERLAY-WRAPPER",
  component: _p
}, OP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "overlays", this.state = 0, this.showInitialOverlay = !0, this.wrapperPadding = 0;
  }
  postConstruct() {
    this.isClientSide = xe(this.gos), this.isServerSide = !this.isClientSide && Ds(this.gos);
    const e = () => this.updateOverlayVisibility();
    this.addManagedEventListeners({
      newColumnsLoaded: e,
      rowDataUpdated: e,
      gridSizeChanged: this.refreshWrapperPadding.bind(this),
      rowCountReady: () => {
        this.showInitialOverlay = !1, this.updateOverlayVisibility();
      }
    }), this.addManagedPropertyListener("loading", e);
  }
  setOverlayWrapperComp(e) {
    this.eWrapper = e, this.updateOverlayVisibility();
  }
  /** Returns true if the overlay is visible. */
  isVisible() {
    return this.state !== 0 && !!this.eWrapper;
  }
  /** Returns true if the overlay is visible and is exclusive (popup over the grid) */
  isExclusive() {
    return this.state === 1 && !!this.eWrapper;
  }
  showLoadingOverlay() {
    this.showInitialOverlay = !1;
    const e = this.gos, t = e.get("loading");
    !t && (t !== void 0 || e.get("suppressLoadingOverlay")) || this.doShowLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.showInitialOverlay = !1;
    const e = this.gos;
    e.get("loading") || e.get("suppressNoRowsOverlay") || this.doShowNoRowsOverlay();
  }
  hideOverlay() {
    if (this.showInitialOverlay = !1, this.gos.get("loading")) {
      I(99);
      return;
    }
    this.doHideOverlay();
  }
  getOverlayWrapperSelector() {
    return LP;
  }
  getOverlayWrapperCompClass() {
    return _p;
  }
  updateOverlayVisibility() {
    if (!this.eWrapper) {
      this.state = 0;
      return;
    }
    const {
      state: e,
      isClientSide: t,
      isServerSide: i,
      beans: { gos: s, colModel: o, rowModel: n }
    } = this;
    let r = this.gos.get("loading");
    r !== void 0 && (this.showInitialOverlay = !1), this.showInitialOverlay && r === void 0 && !s.get("suppressLoadingOverlay") && (r = !s.get("columnDefs") || !o.ready || !s.get("rowData") && t), r ? e !== 1 && this.doShowLoadingOverlay() : (this.showInitialOverlay = !1, t && n.isEmpty() && !s.get("suppressNoRowsOverlay") ? e !== 2 && this.doShowNoRowsOverlay() : (e === 1 || !i && e !== 0) && this.doHideOverlay());
  }
  doShowLoadingOverlay() {
    this.eWrapper && (this.state = 1, this.showOverlay(
      Jv(this.beans.userCompFactory, W(this.gos, {})),
      "ag-overlay-loading-wrapper",
      "loadingOverlayComponentParams"
    ), this.updateExclusive());
  }
  doShowNoRowsOverlay() {
    this.eWrapper && (this.state = 2, this.showOverlay(
      ew(this.beans.userCompFactory, W(this.gos, {})),
      "ag-overlay-no-rows-wrapper",
      "noRowsOverlayComponentParams"
    ), this.updateExclusive());
  }
  doHideOverlay() {
    this.eWrapper && (this.state = 0, this.eWrapper.hideOverlay(), this.updateExclusive());
  }
  showOverlay(e, t, i) {
    var o;
    const s = (e == null ? void 0 : e.newAgStackInstance()) ?? null;
    (o = this.eWrapper) == null || o.showOverlay(s, t, this.isExclusive(), i), this.refreshWrapperPadding();
  }
  updateExclusive() {
    const e = this.exclusive;
    this.exclusive = this.isExclusive(), this.exclusive !== e && this.eventSvc.dispatchEvent({
      type: "overlayExclusiveChanged"
    });
  }
  refreshWrapperPadding() {
    const e = this.eWrapper;
    if (!e)
      return;
    let t = 0;
    if (this.state === 2) {
      const i = this.beans.ctrlsSvc.get("gridHeaderCtrl");
      t = (i == null ? void 0 : i.headerHeight) || 0;
    } else this.wrapperPadding !== 0 && (t = 0);
    this.wrapperPadding !== t && (this.wrapperPadding = t, e.updateOverlayWrapperPaddingTop(t));
  }
}, _P = {
  moduleName: "Overlay",
  version: B,
  userComponents: {
    agLoadingOverlay: Uy,
    agNoRowsOverlay: Ky
  },
  apiFunctions: {
    showLoadingOverlay: TP,
    showNoRowsOverlay: MP,
    hideOverlay: AP
  },
  beans: [OP]
}, HP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowContainerHeight", this.scrollY = 0, this.uiBodyHeight = 0;
  }
  postConstruct() {
    this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) }), this.maxDivHeight = ow(), ni(this.gos, "RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
  }
  updateOffset() {
    if (!this.stretching)
      return;
    const e = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition().top, t = this.getUiBodyHeight();
    (e !== this.scrollY || t !== this.uiBodyHeight) && (this.scrollY = e, this.uiBodyHeight = t, this.calculateOffset());
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const e = this.scrollY / this.maxScrollY, t = e * this.pixelsToShave;
    ni(
      this.gos,
      `RowContainerHeightService - Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`
    ), this.setDivStretchOffset(t);
  }
  setUiContainerHeight(e) {
    e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventSvc.dispatchEvent({ type: "rowContainerHeightChanged" }));
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
  }
  setDivStretchOffset(e) {
    const t = typeof e == "number" ? Math.floor(e) : null;
    this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventSvc.dispatchEvent({ type: "heightScaleChanged" }));
  }
  setModelHeight(e) {
    this.modelHeight = e, this.stretching = e != null && // null happens when in print layout
    this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
  }
  getRealPixelPosition(e) {
    return e - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const e = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
    return e.bottom - e.top;
  }
  getScrollPositionForPixel(e) {
    if (this.pixelsToShave <= 0)
      return e;
    const t = this.modelHeight - this.getUiBodyHeight(), i = e / t;
    return this.maxScrollY * i;
  }
}, BP = 400, GP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowRenderer", this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = !1, this.dataFirstRenderedFired = !1, this.setupRangeSelectionListeners = () => {
      const e = () => {
        this.getAllCellCtrls().forEach((n) => n.onCellSelectionChanged());
      }, t = () => {
        this.getAllCellCtrls().forEach((n) => n.updateRangeBordersIfRangeCount());
      }, i = () => {
        this.eventSvc.addListener("cellSelectionChanged", e), this.eventSvc.addListener("columnMoved", t), this.eventSvc.addListener("columnPinned", t), this.eventSvc.addListener("columnVisible", t);
      }, s = () => {
        this.eventSvc.removeListener("cellSelectionChanged", e), this.eventSvc.removeListener("columnMoved", t), this.eventSvc.removeListener("columnPinned", t), this.eventSvc.removeListener("columnVisible", t);
      };
      this.addDestroyFunc(() => s()), this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
        zt(this.gos) ? i() : s();
      }), zt(this.gos) && i();
    };
  }
  wireBeans(e) {
    this.pageBounds = e.pageBounds, this.colModel = e.colModel, this.pinnedRowModel = e.pinnedRowModel, this.rowModel = e.rowModel, this.focusSvc = e.focusSvc, this.rowContainerHeight = e.rowContainerHeight, this.ctrlsSvc = e.ctrlsSvc, this.editSvc = e.editSvc;
  }
  postConstruct() {
    this.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.initialise();
    });
  }
  initialise() {
    this.addManagedEventListeners({
      paginationChanged: this.onPageLoaded.bind(this),
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
      pinnedRowsChanged: this.onPinnedRowsChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      bodyScroll: this.onBodyScroll.bind(this),
      bodyHeightChanged: this.redraw.bind(this, {})
    }), this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged()), this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw()), this.addManagedPropertyListener("suppressCellFocus", (s) => this.onSuppressCellFocusChanged(s.currentValue)), this.addManagedPropertyListeners(
      [
        "groupSuppressBlankHeader",
        "getBusinessKeyForNode",
        "fullWidthCellRenderer",
        "fullWidthCellRendererParams",
        "suppressStickyTotalRow",
        "groupRowRenderer",
        "groupRowRendererParams",
        // maybe only needs to refresh FW rows...
        "loadingCellRenderer",
        "loadingCellRendererParams",
        "detailCellRenderer",
        "detailCellRendererParams",
        "enableRangeSelection",
        "enableCellTextSelection"
      ],
      () => this.redrawRows()
    ), this.addManagedPropertyListener("cellSelection", ({ currentValue: s, previousValue: o }) => {
      (!o && s || o && !s) && this.redrawRows();
    });
    const { stickyRowSvc: e, gos: t, showRowGroupCols: i } = this.beans;
    if (i && this.addManagedPropertyListener("showOpenedGroup", () => {
      const s = i.getShowRowGroupCols();
      s.length && this.refreshCells({ columns: s, force: !0 });
    }), e)
      this.stickyRowFeature = e.createStickyRowFeature(
        this,
        this.createRowCon.bind(this),
        this.destroyRowCtrls.bind(this)
      );
    else {
      const s = this.gridBodyCtrl;
      s.setStickyTopHeight(0), s.setStickyBottomHeight(0);
    }
    this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = Me(t, "print"), this.embedFullWidthRows = this.printLayout || t.get("embedFullWidthRows"), this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const e = this.getKeepDetailRowsCount(), t = e ?? 3;
      this.cachedRowCtrls = new VP(t);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    var e;
    return ((e = this.stickyRowFeature) == null ? void 0 : e.stickyTopRowCtrls) ?? [];
  }
  getStickyBottomRowCtrls() {
    var e;
    return ((e = this.stickyRowFeature) == null ? void 0 : e.stickyBottomRowCtrls) ?? [];
  }
  updateAllRowCtrls() {
    var s;
    const e = Object.values(this.rowCtrlsByRowIndex), t = Object.values(this.zombieRowCtrls), i = ((s = this.cachedRowCtrls) == null ? void 0 : s.getEntries()) ?? [];
    t.length > 0 || i.length > 0 ? this.allRowCtrls = [...e, ...t, ...i] : this.allRowCtrls = e;
  }
  /**
   * Checks if the cell is rendered or not. Also returns true if row ctrl is present but has not rendered
   * cells yet.
   * @returns true if cellCtrl is present, or if the row is present but has not rendered rows yet
   */
  isCellBeingRendered(e, t) {
    var o;
    const i = this.rowCtrlsByRowIndex[e];
    return !t || !i ? !!i : i.isFullWidth() ? !0 : !!((o = this.beans.spannedRowRenderer) == null ? void 0 : o.getCellByPosition({ rowIndex: e, column: t, rowPinned: null })) || !!i.getCellCtrl(t) || !i.isRowRendered();
  }
  /**
   * Notifies all row and cell controls of any change in focused cell.
   * @param event cell focused event
   */
  updateCellFocus(e) {
    this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e));
  }
  /**
   * Called when a new cell is focused in the grid
   * - if the focused cell isn't rendered; re-draw rows to dry to render it
   * - subsequently updates all cell and row controls with the new focused cell
   * @param event cell focused event
   */
  onCellFocusChanged(e) {
    if (e && e.rowIndex != null && !e.rowPinned) {
      const t = this.beans.colModel.getCol(e.column) ?? void 0;
      this.isCellBeingRendered(e.rowIndex, t) || this.redraw();
    }
    this.updateCellFocus(e);
  }
  onSuppressCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onSuppressCellFocusChanged(e)), this.getFullWidthRowCtrls().forEach((t) => t.onSuppressCellFocusChanged(e));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedEventListeners({
      cellFocused: (e) => this.onCellFocusChanged(e),
      cellFocusCleared: () => this.updateCellFocus(),
      flashCells: (e) => {
        const { cellFlashSvc: t } = this.beans;
        t && this.getAllCellCtrls().forEach((i) => t.onFlashCells(i, e));
      },
      columnHoverChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onColumnHover());
      },
      displayedColumnsChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onDisplayedColumnsChanged());
      },
      displayedColumnsWidthChanged: () => {
        this.printLayout && this.getAllCellCtrls().forEach((e) => e.onLeftChanged());
      }
    }), this.setupRangeSelectionListeners(), this.refreshListenersToColumnsForCellComps(), this.addManagedEventListeners({
      gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this)
    }), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((e) => e()), this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners(), this.colModel.getCols().forEach((t) => {
      const i = (l) => {
        this.getAllCellCtrls().forEach((d) => {
          d.column === t && l(d);
        });
      }, s = () => {
        i((l) => l.onLeftChanged());
      }, o = () => {
        i((l) => l.onWidthChanged());
      }, n = () => {
        i((l) => l.onFirstRightPinnedChanged());
      }, r = () => {
        i((l) => l.onLastLeftPinnedChanged());
      }, a = () => {
        i((l) => l.onColDefChanged());
      };
      t.__addEventListener("leftChanged", s), t.__addEventListener("widthChanged", o), t.__addEventListener("firstRightPinnedChanged", n), t.__addEventListener("lastLeftPinnedChanged", r), t.__addEventListener("colDefChanged", a), this.destroyFuncsForColumnListeners.push(() => {
        t.__removeEventListener("leftChanged", s), t.__removeEventListener("widthChanged", o), t.__removeEventListener("firstRightPinnedChanged", n), t.__removeEventListener("lastLeftPinnedChanged", r), t.__removeEventListener("colDefChanged", a);
      });
    });
  }
  onDomLayoutChanged() {
    const e = Me(this.gos, "print"), t = e || this.gos.get("embedFullWidthRows"), i = t !== this.embedFullWidthRows || this.printLayout !== e;
    this.printLayout = e, this.embedFullWidthRows = t, i && this.redrawAfterModelUpdate({ domLayoutChanged: !0 });
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0, this.lastRenderedRow = -1;
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  onPageLoaded(e) {
    const t = {
      recycleRows: e.keepRenderedRows,
      animate: e.animate,
      newData: e.newData,
      newPage: e.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: !0
    };
    this.redrawAfterModelUpdate(t);
  }
  /**
   * @param column AgColumn
   * @returns An array with HTMLElement for every cell of the column passed as param.
   * If the cell is spanning across multiple columns, it only returns the html element
   * if the column passed is the first column of the span (used for auto width calculation).
   */
  getAllCellsNotSpanningForColumn(e) {
    const t = [];
    return this.getAllRowCtrls().forEach((i) => {
      var o;
      const s = (o = i.getCellCtrl(e, !0)) == null ? void 0 : o.eGui;
      s && t.push(s);
    }), t;
  }
  refreshFloatingRowComps(e = !0) {
    this.refreshFloatingRows(this.topRowCtrls, "top", e), this.refreshFloatingRows(this.bottomRowCtrls, "bottom", e);
  }
  /**
   * Determines which row controllers need to be destroyed and re-created vs which ones can
   * be re-used.
   *
   * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
   *
   * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
   * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
   * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
   *
   * @param rowCtrls The list of existing row controllers
   * @param rowNodes The canonical list of row nodes that should have associated controllers
   */
  refreshFloatingRows(e, t, i) {
    const { pinnedRowModel: s, beans: o, printLayout: n } = this, r = Object.fromEntries(e.map((l) => [l.rowNode.id, l]));
    s == null || s.forEachPinnedRow(t, (l, d) => {
      const c = e[d];
      c && s.getPinnedRowById(c.rowNode.id, t) === void 0 && (c.destroyFirstPass(), c.destroySecondPass()), l.id in r && i ? (e[d] = r[l.id], delete r[l.id]) : e[d] = new rr(l, o, !1, !1, n);
    });
    const a = (t === "top" ? s == null ? void 0 : s.getPinnedTopRowCount() : s == null ? void 0 : s.getPinnedBottomRowCount()) ?? 0;
    e.length = a;
  }
  onPinnedRowDataChanged() {
    const e = {
      recycleRows: !0
    };
    this.redrawAfterModelUpdate(e);
  }
  onPinnedRowsChanged() {
    this.redrawAfterModelUpdate({ recycleRows: !0 });
  }
  redrawRow(e, t = !1) {
    var i, s;
    if (e.sticky)
      (i = this.stickyRowFeature) == null || i.refreshStickyNode(e);
    else if ((s = this.cachedRowCtrls) != null && s.has(e)) {
      this.cachedRowCtrls.removeRow(e);
      return;
    } else {
      const o = (n) => {
        const r = n[e.rowIndex];
        r && r.rowNode === e && (r.destroyFirstPass(), r.destroySecondPass(), n[e.rowIndex] = this.createRowCon(e, !1, !1));
      };
      switch (e.rowPinned) {
        case "top":
          o(this.topRowCtrls);
          break;
        case "bottom":
          o(this.bottomRowCtrls);
          break;
        default:
          o(this.rowCtrlsByRowIndex), this.updateAllRowCtrls();
      }
    }
    t || this.dispatchDisplayedRowsChanged(!1);
  }
  redrawRows(e) {
    const { editSvc: t } = this.beans;
    if (t != null && t.isEditing() && (t.isBatchEditing() ? t.cleanupEditors() : t.stopEditing(void 0, { source: "api" })), e != null) {
      e == null || e.forEach((s) => this.redrawRow(s, !0)), this.dispatchDisplayedRowsChanged(!1);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(e = {}) {
    var a;
    this.getLockOnRefresh();
    const t = (a = this.beans.focusSvc) == null ? void 0 : a.getFocusCellToUseAfterRefresh();
    this.updateContainerHeights(), this.scrollToTopIfNewData(e);
    const i = !e.domLayoutChanged && !!e.recycleRows, s = e.animate && as(this.gos), o = i ? this.getRowsToRecycle() : null;
    i || this.removeAllRowComps(), this.workOutFirstAndLastRowsToRender();
    const { stickyRowFeature: n, gos: r } = this;
    if (n) {
      n.checkStickyRows();
      const l = n.extraTopHeight + n.extraBottomHeight;
      l && this.updateContainerHeights(l);
    }
    this.recycleRows(o, s), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(r.get("enableRowPinning") ? i : void 0), this.dispatchDisplayedRowsChanged(), t != null && this.restoreFocusedCell(t), this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(e) {
    var s;
    const t = e.newData || e.newPage, i = this.gos.get("suppressScrollOnNewData");
    t && !i && (this.gridBodyCtrl.scrollFeature.scrollToTop(), (s = this.stickyRowFeature) == null || s.resetOffsets());
  }
  updateContainerHeights(e = 0) {
    const { rowContainerHeight: t } = this;
    if (this.printLayout) {
      t.setModelHeight(null);
      return;
    }
    let i = this.pageBounds.getCurrentPageHeight();
    i === 0 && (i = 1), t.setModelHeight(i + e);
  }
  getLockOnRefresh() {
    var e, t;
    if (this.refreshInProgress)
      throw new Error(Pt(252));
    this.refreshInProgress = !0, (t = (e = this.beans.frameworkOverrides).getLockOnRefresh) == null || t.call(e);
  }
  releaseLockOnRefresh() {
    var e, t;
    this.refreshInProgress = !1, (t = (e = this.beans.frameworkOverrides).releaseLockOnRefresh) == null || t.call(e);
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(e) {
    if (!e)
      return;
    const t = this.beans.focusSvc, i = this.findPositionToFocus(e);
    if (!i) {
      t.focusHeaderPosition({
        headerPosition: {
          headerRowIndex: xt(this.beans) - 1,
          column: e.column
        }
      });
      return;
    }
    if (e.rowIndex !== i.rowIndex || e.rowPinned != i.rowPinned) {
      t.setFocusedCell({
        ...i,
        preventScrollOnBrowserFocus: !0,
        forceBrowserFocus: !0
      });
      return;
    }
    t.doesRowOrCellHaveBrowserFocus() || this.updateCellFocus(
      W(this.gos, {
        ...i,
        forceBrowserFocus: !0,
        preventScrollOnBrowserFocus: !0,
        type: "cellFocused"
      })
    );
  }
  findPositionToFocus(e) {
    const { pagination: t, pageBounds: i } = this.beans;
    let s = e;
    for (s.rowPinned == null && t && i && !t.isRowInPage(s.rowIndex) && (s = { rowPinned: null, rowIndex: i.getFirstRow() }); s; ) {
      if (s.rowPinned == null && i)
        if (s.rowIndex < i.getFirstRow()) {
          if (s = ir(this.beans, { rowPinned: null, rowIndex: 0 }), !s)
            return null;
        } else s.rowIndex > i.getLastRow() && (s = { rowPinned: null, rowIndex: i.getLastRow() });
      const o = this.getRowByPosition(s);
      if (o != null && o.isAlive())
        return { ...o.getRowPosition(), column: e.column };
      s = ir(this.beans, s);
    }
    return null;
  }
  getAllCellCtrls() {
    const e = [], t = this.getAllRowCtrls(), i = t.length;
    for (let s = 0; s < i; s++) {
      const o = t[s].getAllCellCtrls(), n = o.length;
      for (let r = 0; r < n; r++)
        e.push(o[r]);
    }
    return e;
  }
  getAllRowCtrls() {
    const { spannedRowRenderer: e } = this.beans, t = this.getStickyTopRowCtrls(), i = this.getStickyBottomRowCtrls();
    return [
      ...this.topRowCtrls,
      ...this.bottomRowCtrls,
      ...t,
      ...i,
      ...(e == null ? void 0 : e.getCtrls("top")) ?? [],
      ...(e == null ? void 0 : e.getCtrls("bottom")) ?? [],
      ...(e == null ? void 0 : e.getCtrls("center")) ?? [],
      ...Object.values(this.rowCtrlsByRowIndex)
    ];
  }
  addRenderedRowListener(e, t, i) {
    const s = this.rowCtrlsByRowIndex[t];
    s && s.addEventListener(e, i);
  }
  refreshCells({ rowNodes: e, columns: t, force: i, suppressFlash: s } = {}) {
    const o = {
      force: i,
      newData: !1,
      suppressFlash: s
    };
    for (const n of this.getCellCtrls(e, t))
      n.refreshOrDestroyCell(o);
    this.refreshFullWidth(e);
  }
  refreshRows(e = {}) {
    this.getRowCtrls(e.rowNodes).forEach((t) => t.refreshRow(e)), this.refreshFullWidth(e.rowNodes);
  }
  refreshFullWidth(e) {
    if (!e)
      return;
    let t = !1;
    for (const i of this.getRowCtrls(e)) {
      if (!i.isFullWidth())
        continue;
      i.refreshFullWidth() || (t = !0, this.redrawRow(i.rowNode, !0));
    }
    t && this.dispatchDisplayedRowsChanged(!1);
  }
  /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */
  getRowCtrls(e) {
    const t = nl(e), i = this.getAllRowCtrls();
    return !e || !t ? i : i.filter((s) => {
      const o = s.rowNode;
      return rl(o, t);
    });
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(e, t) {
    let i;
    H(t) && (i = {}, t.forEach((o) => {
      const n = this.colModel.getCol(o);
      H(n) && (i[n.getId()] = !0);
    }));
    const s = [];
    return this.getRowCtrls(e).forEach((o) => {
      o.getAllCellCtrls().forEach((n) => {
        const r = n.column.getId();
        i && !i[r] || s.push(n);
      });
    }), s;
  }
  destroy() {
    this.removeAllRowComps(!0), super.destroy();
  }
  removeAllRowComps(e = !1) {
    var i;
    const t = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(t, e), (i = this.stickyRowFeature) == null || i.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const e = [];
    for (const i of Object.keys(this.rowCtrlsByRowIndex))
      this.rowCtrlsByRowIndex[i].rowNode.id == null && e.push(i);
    this.removeRowCtrls(e);
    const t = {};
    for (const i of Object.values(this.rowCtrlsByRowIndex)) {
      const s = i.rowNode;
      t[s.id] = i;
    }
    return this.rowCtrlsByRowIndex = {}, t;
  }
  // takes array of row indexes
  removeRowCtrls(e, t = !1) {
    e.forEach((i) => {
      const s = this.rowCtrlsByRowIndex[i];
      s && (s.destroyFirstPass(t), s.destroySecondPass()), delete this.rowCtrlsByRowIndex[i];
    });
  }
  onBodyScroll(e) {
    e.direction === "vertical" && this.redraw({ afterScroll: !0 });
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(e = {}) {
    const { focusSvc: t, animationFrameSvc: i } = this.beans, { afterScroll: s } = e;
    let o;
    const n = this.stickyRowFeature;
    n && (o = (t == null ? void 0 : t.getFocusCellToUseAfterRefresh()) || void 0);
    const r = this.firstRenderedRow, a = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let l = !1;
    if (n) {
      l = n.checkStickyRows();
      const c = n.extraTopHeight + n.extraBottomHeight;
      c && this.updateContainerHeights(c);
    }
    const d = this.firstRenderedRow !== r || this.lastRenderedRow !== a;
    if (!(s && !l && !d) && (this.getLockOnRefresh(), this.recycleRows(null, !1, s), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(s && !l), o != null)) {
      const c = t == null ? void 0 : t.getFocusCellToUseAfterRefresh();
      o != null && c == null && (i == null || i.flushAllFrames(), this.restoreFocusedCell(o));
    }
  }
  removeRowCompsNotToDraw(e, t) {
    const i = {};
    e.forEach((n) => i[n] = !0);
    const o = Object.keys(this.rowCtrlsByRowIndex).filter((n) => !i[n]);
    this.removeRowCtrls(o, t);
  }
  calculateIndexesToDraw(e) {
    var r, a;
    const t = [];
    for (let l = this.firstRenderedRow; l <= this.lastRenderedRow; l++)
      t.push(l);
    const i = this.beans.pagination, s = (a = (r = this.beans.focusSvc) == null ? void 0 : r.getFocusedCell()) == null ? void 0 : a.rowIndex;
    s != null && (s < this.firstRenderedRow || s > this.lastRenderedRow) && (!i || i.isRowInPage(s)) && s < this.rowModel.getRowCount() && t.push(s);
    const o = (l) => {
      const d = l.rowNode.rowIndex;
      d == null || d === s || (d < this.firstRenderedRow || d > this.lastRenderedRow) && this.doNotUnVirtualiseRow(l) && t.push(d);
    };
    for (const l of Object.values(this.rowCtrlsByRowIndex))
      o(l);
    if (e)
      for (const l of Object.values(e))
        o(l);
    t.sort((l, d) => l - d);
    const n = [];
    for (let l = 0; l < t.length; l++) {
      const d = t[l], c = this.rowModel.getRow(d);
      c && !c.sticky && n.push(d);
    }
    return n;
  }
  recycleRows(e, t = !1, i = !1) {
    const s = this.calculateIndexesToDraw(e);
    if ((this.printLayout || i) && (t = !1), this.removeRowCompsNotToDraw(s, !t), s.forEach((o) => {
      this.createOrUpdateRowCtrl(o, e, t, i);
    }), e) {
      const { animationFrameSvc: o } = this.beans;
      (o == null ? void 0 : o.active) && i && !this.printLayout ? o.addDestroyTask(() => {
        this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
      }) : this.destroyRowCtrls(e, t);
    }
    this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(e = !1) {
    this.eventSvc.dispatchEvent({
      type: "displayedRowsChanged",
      afterScroll: e
    });
  }
  onDisplayedColumnsChanged() {
    const { visibleCols: e } = this.beans, t = e.isPinningLeft(), i = e.isPinningRight();
    (this.pinningLeft !== t || i !== this.pinningRight) && (this.pinningLeft = t, this.pinningRight = i, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const e = [];
    this.getFullWidthRowCtrls().forEach((t) => {
      const i = t.rowNode.rowIndex;
      e.push(i.toString());
    }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw({ afterScroll: !0 });
  }
  getFullWidthRowCtrls(e) {
    const t = nl(e);
    return this.getAllRowCtrls().filter((i) => {
      if (!i.isFullWidth())
        return !1;
      const s = i.rowNode;
      return !(t != null && !rl(s, t));
    });
  }
  createOrUpdateRowCtrl(e, t, i, s) {
    let o, n = this.rowCtrlsByRowIndex[e];
    if (n || (o = this.rowModel.getRow(e), H(o) && H(t) && t[o.id] && o.alreadyRendered && (n = t[o.id], t[o.id] = null)), !n)
      if (o || (o = this.rowModel.getRow(e)), H(o))
        n = this.createRowCon(o, i, s);
      else
        return;
    return o && (o.alreadyRendered = !0), this.rowCtrlsByRowIndex[e] = n, n;
  }
  destroyRowCtrls(e, t) {
    const i = [];
    if (e) {
      for (const s of Object.values(e))
        if (s) {
          if (this.cachedRowCtrls && s.isCacheable()) {
            this.cachedRowCtrls.addRow(s);
            continue;
          }
          if (s.destroyFirstPass(!t), t) {
            const o = s.instanceId;
            this.zombieRowCtrls[o] = s, i.push(() => {
              s.destroySecondPass(), delete this.zombieRowCtrls[o];
            });
          } else
            s.destroySecondPass();
        }
    }
    t && (i.push(() => {
      this.isAlive() && (this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged());
    }), window.setTimeout(() => i.forEach((s) => s()), BP));
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const e = this.getRowBuffer(), t = Ti(this.beans);
    return e * t;
  }
  workOutFirstAndLastRowsToRender() {
    const { rowContainerHeight: e, pageBounds: t, rowModel: i } = this;
    e.updateOffset();
    let s, o;
    if (!i.isRowsToRender())
      s = 0, o = -1;
    else if (this.printLayout)
      this.beans.environment.refreshRowHeightVariable(), s = t.getFirstRow(), o = t.getLastRow();
    else {
      const c = this.getRowBufferInPixels(), u = this.ctrlsSvc.getScrollFeature(), h = this.gos.get("suppressRowVirtualisation");
      let g = !1, p, f;
      do {
        const b = t.getPixelOffset(), { pageFirstPixel: w, pageLastPixel: x } = t.getCurrentPagePixelRange(), F = e.divStretchOffset, D = u.getVScrollPosition(), T = D.top, k = D.bottom;
        h ? (p = w + F, f = x + F) : (p = Math.max(T + b - c, w) + F, f = Math.min(k + b + c, x) + F), this.firstVisibleVPixel = Math.max(T + b, w) + F, this.lastVisibleVPixel = Math.min(k + b, x) + F, g = this.ensureAllRowsInRangeHaveHeightsCalculated(p, f);
      } while (g);
      let m = i.getRowIndexAtPixel(p), C = i.getRowIndexAtPixel(f);
      const v = t.getFirstRow(), R = t.getLastRow();
      m < v && (m = v), C > R && (C = R), s = m, o = C;
    }
    const n = Me(this.gos, "normal"), r = this.gos.get("suppressMaxRenderedRowRestriction"), a = Math.max(this.getRowBuffer(), 500);
    n && !r && o - s > a && (o = s + a);
    const l = s !== this.firstRenderedRow, d = o !== this.lastRenderedRow;
    (l || d) && (this.firstRenderedRow = s, this.lastRenderedRow = o, this.eventSvc.dispatchEvent({
      type: "viewportChanged",
      firstRow: s,
      lastRow: o
    }));
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    this.dataFirstRenderedFired || (this.dataFirstRenderedFired = !0, $t(this.beans, () => {
      this.beans.eventSvc.dispatchEvent({
        type: "firstDataRendered",
        firstRow: this.firstRenderedRow,
        lastRow: this.lastRenderedRow
      });
    }));
  }
  ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
    var a, l;
    const i = (a = this.pinnedRowModel) == null ? void 0 : a.ensureRowHeightsValid(), s = (l = this.stickyRowFeature) == null ? void 0 : l.ensureRowHeightsValid(), { pageBounds: o, rowModel: n } = this, r = n.ensureRowHeightsValid(
      e,
      t,
      o.getFirstRow(),
      o.getLastRow()
    );
    return (r || s) && this.eventSvc.dispatchEvent({
      type: "recalculateRowBounds"
    }), s || r || i ? (this.updateContainerHeights(), !0) : !1;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(e) {
    var d;
    const s = e.rowNode, o = this.focusSvc.isRowFocused(s.rowIndex, s.rowPinned), n = (d = this.editSvc) == null ? void 0 : d.isEditing(e), r = s.detail;
    return o || n || r ? !!this.isRowPresent(s) : !1;
  }
  isRowPresent(e) {
    var t;
    return this.rowModel.isRowPresent(e) ? ((t = this.beans.pagination) == null ? void 0 : t.isRowInPage(e.rowIndex)) ?? !0 : !1;
  }
  createRowCon(e, t, i) {
    var r, a;
    const s = ((r = this.cachedRowCtrls) == null ? void 0 : r.getRow(e)) ?? null;
    if (s)
      return s;
    const o = i && !this.printLayout && !!((a = this.beans.animationFrameSvc) != null && a.active);
    return new rr(e, this.beans, t, o, this.printLayout);
  }
  getRenderedNodes() {
    const e = Object.values(this.rowCtrlsByRowIndex).map((s) => s.rowNode), t = this.getStickyTopRowCtrls().map((s) => s.rowNode), i = this.getStickyBottomRowCtrls().map((s) => s.rowNode);
    return [...t, ...e, ...i];
  }
  getRowByPosition(e) {
    let t;
    const { rowIndex: i } = e;
    switch (e.rowPinned) {
      case "top":
        t = this.topRowCtrls[i];
        break;
      case "bottom":
        t = this.bottomRowCtrls[i];
        break;
      default:
        t = this.rowCtrlsByRowIndex[i], t || (t = this.getStickyTopRowCtrls().find((s) => s.rowNode.rowIndex === i) || null, t || (t = this.getStickyBottomRowCtrls().find((s) => s.rowNode.rowIndex === i) || null));
        break;
    }
    return t;
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(e, t) {
    if (e == null || t == null)
      return !1;
    const s = e > this.lastRenderedRow;
    return !(t < this.firstRenderedRow) && !s;
  }
}, VP = class {
  constructor(e) {
    this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
  }
  addRow(e) {
    if (this.entriesMap[e.rowNode.id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
      const t = this.entriesList[0];
      t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
    }
  }
  getRow(e) {
    if (e == null || e.id == null)
      return null;
    const t = this.entriesMap[e.id];
    return t ? (this.removeFromCache(t), t.setCached(!1), t.rowNode != e ? null : t) : null;
  }
  has(e) {
    return this.entriesMap[e.id] != null;
  }
  removeRow(e) {
    const t = e.id, i = this.entriesMap[t];
    delete this.entriesMap[t], tt(this.entriesList, i);
  }
  removeFromCache(e) {
    const t = e.rowNode.id;
    delete this.entriesMap[t], tt(this.entriesList, e);
  }
  getEntries() {
    return this.entriesList;
  }
};
function nl(e) {
  if (!e)
    return;
  const t = {
    top: {},
    bottom: {},
    normal: {}
  };
  return e.forEach((i) => {
    const s = i.id;
    switch (i.rowPinned) {
      case "top":
        t.top[s] = i;
        break;
      case "bottom":
        t.bottom[s] = i;
        break;
      default:
        t.normal[s] = i;
        break;
    }
  }), t;
}
function rl(e, t) {
  const i = e.id;
  switch (e.rowPinned) {
    case "top":
      return t.top[i] != null;
    case "bottom":
      return t.bottom[i] != null;
    default:
      return t.normal[i] != null;
  }
}
var NP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowNodeSorter";
  }
  postConstruct() {
    const { gos: e } = this;
    this.isAccentedSort = e.get("accentedSort"), this.primaryColumnsSortGroups = St(e), this.addManagedPropertyListener(
      "accentedSort",
      (t) => this.isAccentedSort = t.currentValue
    ), this.addManagedPropertyListener(
      "autoGroupColumnDef",
      () => this.primaryColumnsSortGroups = St(e)
    );
  }
  doFullSort(e, t) {
    const i = e.map((s, o) => ({
      currentPos: o,
      rowNode: s
    }));
    return i.sort(this.compareRowNodes.bind(this, t)), i.map((s) => s.rowNode);
  }
  compareRowNodes(e, t, i) {
    const s = t.rowNode, o = i.rowNode;
    for (let n = 0, r = e.length; n < r; n++) {
      const a = e[n], l = a.sort === "desc", d = this.getValue(s, a.column), c = this.getValue(o, a.column);
      let u;
      const h = this.getComparator(a, s);
      if (h ? u = h(d, c, s, o, l) : u = Nm(d, c, this.isAccentedSort), !isNaN(u) && u !== 0)
        return a.sort === "asc" ? u : u * -1;
    }
    return t.currentPos - i.currentPos;
  }
  getComparator(e, t) {
    const i = e.column, s = i.getColDef().comparator;
    if (s != null)
      return s;
    if (!i.getColDef().showRowGroup)
      return;
    const o = !t.group && i.getColDef().field;
    if (!o)
      return;
    const n = this.beans.colModel.getColDefCol(o);
    if (n)
      return n.getColDef().comparator;
  }
  getValue(e, t) {
    var a, l;
    const { valueSvc: i, colModel: s, showRowGroupCols: o, gos: n } = this.beans;
    if (!this.primaryColumnsSortGroups)
      return i.getValue(t, e, !1);
    if (e.rowGroupColumn === t) {
      if (Qh(n, s.isPivotActive())) {
        const u = (a = e.allLeafChildren) == null ? void 0 : a[0];
        return u ? i.getValue(t, u, !1) : void 0;
      }
      const c = o == null ? void 0 : o.getShowRowGroupCol(t.getId());
      return c ? (l = e.groupData) == null ? void 0 : l[c.getId()] : void 0;
    }
    if (!(e.group && t.getColDef().showRowGroup))
      return i.getValue(t, e, !1);
  }
};
function WP(e) {
  var t;
  (t = e.sortSvc) == null || t.onSortChanged("api");
}
var Hp = {
  moduleName: "Sort",
  version: B,
  beans: [r0, NP],
  apiFunctions: {
    onSortChanged: WP
  },
  userComponents: {
    agSortIndicator: td
  },
  icons: {
    // show on column header when column is sorted ascending
    sortAscending: "asc",
    // show on column header when column is sorted descending
    sortDescending: "desc",
    // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
    sortUnSort: "none"
  }
}, zP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "syncSvc", this.waitingForColumns = !1;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (e) => this.setColumnDefs(e));
  }
  start() {
    this.beans.ctrlsSvc.whenReady(this, () => {
      const e = this.gos.get("columnDefs");
      e ? this.setColumnsAndData(e) : this.waitingForColumns = !0, this.gridReady();
    });
  }
  setColumnsAndData(e) {
    const { colModel: t, rowModel: i } = this.beans;
    t.setColumnDefs(e ?? [], "gridInitializing"), i.start();
  }
  gridReady() {
    const { eventSvc: e, gos: t } = this;
    e.dispatchEvent({
      type: "gridReady"
    }), ni(t, `initialised successfully, enterprise = ${t.isModuleRegistered("EnterpriseCore")}`);
  }
  setColumnDefs(e) {
    const t = this.gos.get("columnDefs");
    if (t) {
      if (this.waitingForColumns) {
        this.waitingForColumns = !1, this.setColumnsAndData(t);
        return;
      }
      this.beans.colModel.setColumnDefs(t, ds(e.source));
    }
  }
};
function UP(e) {
  var t;
  (t = e.valueCache) == null || t.expire();
}
function $P(e, t) {
  const { colKey: i, rowNode: s, useFormatter: o } = t, n = e.colModel.getColDefCol(i) ?? e.colModel.getCol(i);
  if (de(n))
    return null;
  const r = e.valueSvc.getValueForDisplay(n, s, o);
  return o ? r.valueFormatted ?? Es(r.value) : r.value;
}
var KP = "paste", jP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "changeDetectionSvc", this.clientSideRowModel = null;
  }
  postConstruct() {
    const { gos: e, rowModel: t } = this.beans;
    xe(e) && (this.clientSideRowModel = t), this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
  }
  onCellValueChanged(e) {
    const { gos: t, rowRenderer: i } = this.beans;
    if (e.source === KP || t.get("suppressChangeDetection"))
      return;
    const s = e.node, o = [s], n = this.clientSideRowModel, r = n == null ? void 0 : n.rootNode;
    if (r && !s.isRowPinned()) {
      const a = t.get("aggregateOnlyChangedColumns"), l = new Do(a, r);
      l.addParentNode(s.parent, [e.column]), n.doAggregate(l), l.forEachChangedNodeDepthFirst((d) => {
        o.push(d), d.sibling && o.push(d.sibling);
      });
    }
    i.refreshCells({ rowNodes: o });
  }
}, qP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "expressionSvc", this.cache = {};
  }
  evaluate(e, t) {
    if (typeof e == "string")
      return this.evaluateExpression(e, t);
    Z(15, { expression: e });
  }
  evaluateExpression(e, t) {
    try {
      return this.createExpressionFunction(e)(
        t.value,
        t.context,
        t.oldValue,
        t.newValue,
        t.value,
        t.node,
        t.data,
        t.colDef,
        t.rowIndex,
        t.api,
        t.getValue,
        t.column,
        t.columnGroup
      );
    } catch (i) {
      return Z(16, { expression: e, params: t, e: i }), null;
    }
  }
  createExpressionFunction(e) {
    const t = this.cache;
    if (t[e])
      return t[e];
    const i = this.createFunctionBody(e), s = new Function(
      "x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup",
      i
    );
    return t[e] = s, s;
  }
  createFunctionBody(e) {
    return e.indexOf("return") >= 0 ? e : "return " + e + ";";
  }
}, YP = class extends E {
  constructor() {
    super(...arguments), this.beanName = "valueCache", this.cacheVersion = 0;
  }
  postConstruct() {
    const e = this.gos;
    this.active = e.get("valueCache"), this.neverExpires = e.get("valueCacheNeverExpires");
  }
  onDataChanged() {
    this.neverExpires || this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(e, t, i) {
    if (this.active) {
      const s = this.cacheVersion;
      e.__cacheVersion !== s && (e.__cacheVersion = s, e.__cacheData = {}), e.__cacheData[t] = i;
    }
  }
  getValue(e, t) {
    if (!(!this.active || e.__cacheVersion !== this.cacheVersion))
      return e.__cacheData[t];
  }
}, QP = {
  moduleName: "ValueCache",
  version: B,
  beans: [YP],
  apiFunctions: {
    expireValueCache: UP
  }
}, XP = {
  moduleName: "Expression",
  version: B,
  beans: [qP]
}, ZP = {
  moduleName: "ChangeDetection",
  version: B,
  beans: [jP]
}, JP = {
  moduleName: "CellApi",
  version: B,
  apiFunctions: {
    getCellValue: $P
  }
}, eE = class extends E {
  constructor() {
    super(...arguments), this.beanName = "valueSvc", this.hasEditSvc = !1, this.initialised = !1, this.isSsrm = !1;
  }
  wireBeans(e) {
    this.expressionSvc = e.expressionSvc, this.colModel = e.colModel, this.valueCache = e.valueCache, this.dataTypeSvc = e.dataTypeSvc, this.editSvc = e.editSvc, this.hasEditSvc = !!e.editSvc;
  }
  postConstruct() {
    this.initialised || this.init();
  }
  init() {
    this.executeValueGetter = this.valueCache ? this.executeValueGetterWithValueCache.bind(this) : this.executeValueGetterWithoutValueCache.bind(this), this.isSsrm = Ds(this.gos), this.cellExpressions = this.gos.get("enableCellExpressions"), this.isTreeData = this.gos.get("treeData"), this.initialised = !0;
    const e = (t) => this.callColumnCellValueChangedHandler(t);
    this.eventSvc.addListener("cellValueChanged", e, !0), this.addDestroyFunc(() => this.eventSvc.removeListener("cellValueChanged", e, !0)), this.addManagedPropertyListener("treeData", (t) => this.isTreeData = t.currentValue);
  }
  /**
   * Use this function to get a displayable cell value.
   * The values from this function are not used for sorting, filtering, or aggregation purposes.
   * Handles: groupHideOpenParents, showOpenedGroup and groupSuppressBlankHeader behaviours
   */
  getValueForDisplay(e, t, i = !1, s = !1, o = "ui") {
    const { showRowGroupColValueSvc: n } = this.beans, r = !e && t.group, a = e == null ? void 0 : e.colDef.showRowGroup, l = !this.isTreeData || t.footer;
    if (n && l && (r || a)) {
      const f = n.getGroupValue(t, e);
      if (f == null)
        return {
          value: null,
          valueFormatted: null
        };
      if (!i)
        return {
          value: f.value,
          valueFormatted: null
        };
      const m = n.formatAndPrefixGroupColValue(f, e, s);
      return {
        value: f.value,
        valueFormatted: m
      };
    }
    if (!e)
      return {
        value: t.key,
        valueFormatted: null
      };
    const d = t.leafGroup && this.colModel.isPivotMode(), c = t.group && t.expanded && !t.footer && !d, u = this.gos.get("groupSuppressBlankHeader") || !t.sibling, h = c && !u, g = this.getValue(e, t, h, o), p = i && !(s && e.colDef.useValueFormatterForExport === !1);
    return {
      value: g,
      valueFormatted: p ? this.formatValue(e, t, g) : null
    };
  }
  getValue(e, t, i = !1, s = "ui") {
    var f;
    if (this.initialised || this.init(), !t)
      return;
    const o = e.getColDef(), n = o.field, r = e.getColId(), a = t.data;
    if (this.hasEditSvc && s === "ui") {
      const m = this.editSvc;
      if (m.isEditing()) {
        const C = m.getCellDataValue({ rowNode: t, column: e }, !0);
        if (C !== void 0)
          return C;
      }
    }
    let l;
    const d = o.showRowGroup;
    if (typeof d == "string" && (((f = this.beans.rowGroupColsSvc) == null ? void 0 : f.getColumnIndex(d)) ?? -1) > t.level)
      return null;
    const c = typeof d != "string" || !t.group, u = t.groupData && r in t.groupData, h = !i && t.aggData && t.aggData[r] !== void 0, g = this.isSsrm && i && !!o.aggFunc, p = this.isSsrm && t.footer && t.field && (o.showRowGroup === !0 || o.showRowGroup === t.field);
    if (this.isTreeData && h)
      l = t.aggData[r];
    else if (this.isTreeData && o.valueGetter)
      l = this.executeValueGetter(o.valueGetter, a, e, t);
    else if (this.isTreeData && n && a)
      l = no(a, n, e.isFieldContainsDots());
    else if (u)
      l = t.groupData[r];
    else if (h)
      l = t.aggData[r];
    else if (o.valueGetter && !g) {
      if (!c)
        return l;
      l = this.executeValueGetter(o.valueGetter, a, e, t);
    } else if (p)
      l = no(a, t.field, e.isFieldContainsDots());
    else if (n && a && !g) {
      if (!c)
        return l;
      l = no(a, n, e.isFieldContainsDots());
    }
    if (this.cellExpressions && typeof l == "string" && l.indexOf("=") === 0) {
      const m = l.substring(1);
      l = this.executeValueGetter(m, a, e, t);
    }
    return l;
  }
  parseValue(e, t, i, s) {
    var r;
    const o = e.getColDef(), n = o.valueParser;
    if (H(n)) {
      const a = W(this.gos, {
        node: t,
        data: t == null ? void 0 : t.data,
        oldValue: s,
        newValue: i,
        colDef: o,
        column: e
      });
      return typeof n == "function" ? n(a) : (r = this.expressionSvc) == null ? void 0 : r.evaluate(n, a);
    }
    return i;
  }
  getDeleteValue(e, t) {
    return H(e.getColDef().valueParser) ? this.parseValue(e, t, "", this.getValueForDisplay(e, t).value) ?? null : null;
  }
  formatValue(e, t, i, s, o = !0) {
    const { expressionSvc: n } = this.beans;
    let r = null, a;
    const l = e.getColDef();
    if (s ? a = s : o && (a = l.valueFormatter), a) {
      const d = t ? t.data : null, c = W(this.gos, {
        value: i,
        node: t,
        data: d,
        colDef: l,
        column: e
      });
      typeof a == "function" ? r = a(c) : r = n ? n.evaluate(a, c) : null;
    } else if (l.refData)
      return l.refData[i] || "";
    return r == null && Array.isArray(i) && (r = i.join(", ")), r;
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(e, t, i, s) {
    var c, u;
    const o = this.colModel.getColDefCol(t);
    if (!e || !o)
      return !1;
    de(e.data) && (e.data = {});
    const { field: n, valueSetter: r } = o.getColDef();
    if (de(n) && de(r))
      return I(17), !1;
    if (this.dataTypeSvc && !this.dataTypeSvc.checkType(o, i))
      return I(135), !1;
    const a = W(this.gos, {
      node: e,
      data: e.data,
      oldValue: this.getValue(o, e, void 0, s),
      newValue: i,
      colDef: o.getColDef(),
      column: o
    });
    a.newValue = i;
    let l;
    if (H(r) ? typeof r == "function" ? l = r(a) : l = (c = this.expressionSvc) == null ? void 0 : c.evaluate(r, a) : l = this.setValueUsingField(e.data, n, i, o.isFieldContainsDots()), l === void 0 && (l = !0), !l)
      return !1;
    e.resetQuickFilterAggregateText(), (u = this.valueCache) == null || u.onDataChanged();
    const d = this.getValue(o, e);
    return this.dispatchCellValueChangedEvent(e, a, d, s), e.pinnedSibling && this.dispatchCellValueChangedEvent(e.pinnedSibling, a, d, s), !0;
  }
  dispatchCellValueChangedEvent(e, t, i, s) {
    this.eventSvc.dispatchEvent({
      type: "cellValueChanged",
      event: null,
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: t.column,
      colDef: t.colDef,
      data: e.data,
      node: e,
      oldValue: t.oldValue,
      newValue: i,
      value: i,
      source: s
    });
  }
  callColumnCellValueChangedHandler(e) {
    const t = e.colDef.onCellValueChanged;
    typeof t == "function" && this.beans.frameworkOverrides.wrapOutgoing(() => {
      t({
        node: e.node,
        data: e.data,
        oldValue: e.oldValue,
        newValue: e.newValue,
        colDef: e.colDef,
        column: e.column,
        api: e.api,
        context: e.context
      });
    });
  }
  setValueUsingField(e, t, i, s) {
    if (!t)
      return !1;
    let o = !1;
    if (!s)
      o = e[t] === i, o || (e[t] = i);
    else {
      const n = t.split(".");
      let r = e;
      for (; n.length > 0 && r; ) {
        const a = n.shift();
        n.length === 0 ? (o = r[a] === i, o || (r[a] = i)) : r = r[a];
      }
    }
    return !o;
  }
  executeValueGetterWithValueCache(e, t, i, s) {
    const o = i.getColId(), n = this.valueCache.getValue(s, o);
    if (n !== void 0)
      return n;
    const r = this.executeValueGetterWithoutValueCache(e, t, i, s);
    return this.valueCache.setValue(s, o, r), r;
  }
  executeValueGetterWithoutValueCache(e, t, i, s) {
    var r;
    const o = W(this.gos, {
      data: t,
      node: s,
      column: i,
      colDef: i.getColDef(),
      getValue: this.getValueCallback.bind(this, s)
    });
    let n;
    return typeof e == "function" ? n = e(o) : n = (r = this.expressionSvc) == null ? void 0 : r.evaluate(e, o), n;
  }
  getValueCallback(e, t) {
    const i = this.colModel.getColDefCol(t);
    return i ? this.getValue(i, e) : null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(e, t) {
    const i = this.getValue(e, t), s = e.getColDef().keyCreator;
    let o = i;
    if (s) {
      const n = W(this.gos, {
        value: i,
        colDef: e.getColDef(),
        column: e,
        node: t,
        data: t.data
      });
      o = s(n);
    }
    return typeof o == "string" || o == null || (o = String(o), o === "[object Object]" && I(121)), o;
  }
}, tE = {
  moduleName: "CommunityCore",
  version: B,
  beans: [
    i0,
    GS,
    Jx,
    xv,
    HP,
    ux,
    QF,
    F0,
    bv,
    wP,
    vP,
    GP,
    eE,
    e0,
    YF,
    t0,
    tF,
    zP,
    qx,
    Yx,
    _0
  ],
  icons: {
    // icon on select dropdowns (select cell editor, charts tool panels)
    selectOpen: "small-down",
    /** @deprecated v33 */
    smallDown: "small-down",
    /** @deprecated v33 */
    colorPicker: "color-picker",
    /** @deprecated v33 */
    smallUp: "small-up",
    /** @deprecated v33 */
    checkboxChecked: "small-up",
    /** @deprecated v33 */
    checkboxIndeterminate: "checkbox-indeterminate",
    /** @deprecated v33 */
    checkboxUnchecked: "checkbox-unchecked",
    /** @deprecated v33 */
    radioButtonOn: "radio-button-on",
    /** @deprecated v33 */
    radioButtonOff: "radio-button-off",
    /** @deprecated v33 */
    smallLeft: "small-left",
    /** @deprecated v33 */
    smallRight: "small-right"
  },
  apiFunctions: {
    getGridId: VS,
    destroy: NS,
    isDestroyed: WS,
    getGridOption: zS,
    setGridOption: US,
    updateGridOptions: dp,
    isModuleRegistered: $S
  },
  dependsOn: [
    $x,
    zR,
    QR,
    Hp,
    I0,
    gx,
    k0,
    _P,
    ZP,
    O0,
    CP,
    RP,
    FP,
    B0,
    Zx,
    Kx,
    XP,
    Cx,
    DP
  ]
}, Bp = {
  AdvancedFilter: 1,
  AllEnterprise: 1,
  BatchEdit: 1,
  CellSelection: 1,
  Clipboard: 1,
  ColumnMenu: 1,
  ColumnsToolPanel: 1,
  ContextMenu: 1,
  ExcelExport: 1,
  FiltersToolPanel: 1,
  Find: 1,
  GridCharts: 1,
  IntegratedCharts: 1,
  GroupFilter: 1,
  MasterDetail: 1,
  Menu: 1,
  MultiFilter: 1,
  NewFiltersToolPanel: 1,
  Pivot: 1,
  RangeSelection: 1,
  RichSelect: 1,
  RowNumbers: 1,
  RowGrouping: 1,
  RowGroupingPanel: 1,
  ServerSideRowModelApi: 1,
  ServerSideRowModel: 1,
  SetFilter: 1,
  SideBar: 1,
  Sparklines: 1,
  StatusBar: 1,
  TreeData: 1,
  ViewportRowModel: 1
}, ga = [
  "TextFilter",
  "NumberFilter",
  "DateFilter",
  "SetFilter",
  "MultiFilter",
  "GroupFilter",
  "CustomFilter"
], iE = {
  EditCore: [
    "TextEditor",
    "NumberEditor",
    "DateEditor",
    "CheckboxEditor",
    "LargeTextEditor",
    "SelectEditor",
    "RichSelect",
    "CustomEditor"
  ],
  CheckboxCellRenderer: ["AllCommunity"],
  ClientSideRowModelHierarchy: ["RowGrouping", "Pivot", "TreeData"],
  ColumnFilter: ga,
  ColumnGroupHeaderComp: ["AllCommunity"],
  ColumnGroup: ["AllCommunity"],
  ColumnHeaderComp: ["AllCommunity"],
  ColumnMove: ["AllCommunity"],
  ColumnResize: ["AllCommunity"],
  CommunityCore: ["AllCommunity"],
  CsrmSsrmSharedApi: ["ClientSideRowModelApi", "ServerSideRowModelApi"],
  RowModelSharedApi: ["ClientSideRowModelApi", "ServerSideRowModelApi"],
  EnterpriseCore: ["AllEnterprise"],
  FilterCore: [...ga, "QuickFilter", "ExternalFilter", "AdvancedFilter"],
  GroupCellRenderer: ["RowGrouping", "Pivot", "TreeData", "MasterDetail", "ServerSideRowModel"],
  KeyboardNavigation: ["AllCommunity"],
  LoadingCellRenderer: ["ServerSideRowModel"],
  MenuCore: ["ColumnMenu", "ContextMenu"],
  MenuItem: ["ColumnMenu", "ContextMenu", "MultiFilter", "IntegratedCharts", "ColumnsToolPanel"],
  Overlay: ["AllCommunity"],
  PinnedColumn: ["AllCommunity"],
  SharedAggregation: ["RowGrouping", "Pivot", "TreeData", "ServerSideRowModel"],
  SharedDragAndDrop: ["AllCommunity"],
  SharedMasterDetail: ["MasterDetail", "ServerSideRowModel"],
  SharedMenu: [...ga, "ColumnMenu", "ContextMenu"],
  SharedPivot: ["Pivot", "ServerSideRowModel"],
  SharedRowGrouping: ["RowGrouping", "ServerSideRowModel"],
  SharedRowSelection: ["RowSelection", "ServerSideRowModel"],
  SkeletonCellRenderer: ["ServerSideRowModel"],
  Sort: ["AllCommunity"],
  SsrmInfiniteSharedApi: ["InfiniteRowModel", "ServerSideRowModelApi"],
  SharedTreeData: ["TreeData", "ServerSideRowModel"]
}, sE = {
  InfiniteRowModel: "infinite",
  ClientSideRowModelApi: "clientSide",
  ClientSideRowModel: "clientSide",
  ServerSideRowModelApi: "serverSide",
  ServerSideRowModel: "serverSide",
  ViewportRowModel: "viewport"
};
function oE(e, t) {
  const i = [];
  return (Array.isArray(e) ? e : [e]).forEach((s) => {
    const o = iE[s];
    o ? o.forEach((n) => {
      const r = sE[n];
      (!r || r === t) && i.push(n);
    }) : i.push(s);
  }), i;
}
var Gp = () => `No AG Grid modules are registered! It is recommended to start with all Community features via the AllCommunityModule:
                    
    import { ModuleRegistry, AllCommunityModule } from 'ag-grid-community';
    
    ModuleRegistry.registerModules([ AllCommunityModule ]);
    `, nE = (e) => {
  const t = e.map(
    (s) => `import { ${ao(s)} } from '${Bp[s] ? "ag-grid-enterprise" : "ag-grid-community"}';`
  );
  return e.some((s) => s === "IntegratedCharts" || s === "Sparklines") && t.push("import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';"), `import { ModuleRegistry } from 'ag-grid-community'; 
${t.join(` 
`)} 

ModuleRegistry.registerModules([ ${e.map((s) => ao(s, !0)).join(", ")} ]); 

For more info see: ${rs}/modules/`;
};
function ao(e, t = !1) {
  return t && (e === "IntegratedCharts" || e === "Sparklines") ? `${e}Module.with(AgChartsEnterpriseModule)` : `${e}Module`;
}
function rE(e, t) {
  const i = t.filter((n) => n === "IntegratedCharts" || n === "Sparklines");
  let s = "";
  return !(globalThis == null ? void 0 : globalThis.agCharts) && i.length > 0 ? s = `Unable to use ${e} as either the ag-charts-community or ag-charts-enterprise script needs to be included alongside ag-grid-enterprise.
` : t.some((n) => Bp[n]) && (s = s + `Unable to use ${e} as that requires the ag-grid-enterprise script to be included.
`), s;
}
function Vp({
  moduleName: e,
  rowModelType: t
}) {
  return `To use the ${e}Module you must set the gridOption "rowModelType='${t}'"`;
}
var jc = ({
  reasonOrId: e,
  moduleName: t,
  gridScoped: i,
  gridId: s,
  rowModelType: o,
  additionalText: n,
  isUmd: r
}) => {
  const a = oE(t, o), l = typeof e == "string" ? e : cE[e];
  if (r)
    return rE(l, a);
  const d = a.filter((h) => h === "IntegratedCharts" || h === "Sparklines"), c = d.length > 0 ? `${d.map((h) => ao(h)).join()} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.` : "";
  return `${`Unable to use ${l} as ${a.length > 1 ? "one of " + a.map((h) => ao(h)).join(", ") : ao(a[0])} is not registered${i ? " for gridId: " + s : ""}. ${c} Check if you have registered the module:
`}
${nE(a)}` + (n ? ` 

${n}` : "");
}, qc = (e) => `${e} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.

import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';
import { ModuleRegistry } from 'ag-grid-community';
import { ${e} } from 'ag-grid-enterprise';
    
ModuleRegistry.registerModules([${e}.with(AgChartsEnterpriseModule)]);
    `, aE = (e) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${e}()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.`, lE = {
  1: () => "`rowData` must be an array",
  2: ({ nodeId: e }) => `Duplicate node id '${e}' detected from getRowId callback, this could cause issues in your grid.`,
  3: () => "Calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.",
  4: ({ id: e }) => `Could not find row id=${e}, data item was not found for this id`,
  5: ({ data: e }) => [
    "Could not find data item as object was not found.",
    e,
    " Consider using getRowId to help the Grid find matching row data"
  ],
  6: () => "'groupHideOpenParents' only works when specifying specific columns for 'colDef.showRowGroup'",
  7: () => "Pivoting is not supported with aligned grids as it may produce different columns in each grid.",
  8: ({ key: e }) => `Unknown key for navigation ${e}`,
  9: ({ variable: e }) => `No value for ${e == null ? void 0 : e.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${e == null ? void 0 : e.defaultValue} will be used and updated when styles load.`,
  10: ({ eventType: e }) => `As of v33, the '${e}' event is deprecated. Use the global 'modelUpdated' event to determine when row children have changed.`,
  11: () => "No gridOptions provided to createGrid",
  12: ({ colKey: e }) => ["column ", e, " not found"],
  13: () => "Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid.",
  14: ({ groupPrefix: e }) => `Row IDs cannot start with ${e}, this is a reserved prefix for AG Grid's row grouping feature.`,
  15: ({ expression: e }) => ["value should be either a string or a function", e],
  16: ({ expression: e, params: t, e: i }) => [
    "Processing of the expression failed",
    "Expression = ",
    e,
    "Params = ",
    t,
    "Exception = ",
    i
  ],
  17: () => "you need either field or valueSetter set on colDef for editing to work",
  18: () => "alignedGrids contains an undefined option.",
  19: () => "alignedGrids - No api found on the linked grid.",
  20: () => `You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`,
  21: () => "pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.",
  22: ({ key: e }) => `${e} is an initial property and cannot be updated.`,
  23: () => "The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.",
  24: () => "row height must be a number if not using standard row model",
  25: ({ id: e }) => ["The getRowId callback must return a string. The ID ", e, " is being cast to a string."],
  26: ({ fnName: e, preDestroyLink: t }) => `Grid API function ${e}() cannot be called as the grid has been destroyed.
 Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
 To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${t}`,
  27: ({ fnName: e, module: t }) => `API function '${e}' not registered to module '${t}'`,
  28: () => "setRowCount cannot be used while using row grouping.",
  29: () => "tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?",
  30: ({ toIndex: e }) => [
    "tried to insert columns in invalid location, toIndex = ",
    e,
    "remember that you should not count the moving columns when calculating the new index"
  ],
  31: () => "infinite loop in resizeColumnSets",
  32: () => "applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.",
  33: () => "stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.",
  34: ({ key: e }) => `the column type '${e}' is a default column type and cannot be overridden.`,
  35: () => "Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type.",
  36: ({ t: e }) => "colDef.type '" + e + "' does not correspond to defined gridOptions.columnTypes",
  37: () => "Changing the column pinning status is not allowed with domLayout='print'",
  38: ({ iconName: e }) => `provided icon '${e}' needs to be a string or a function`,
  39: () => "Applying column order broke a group where columns should be married together. Applying new order has been discarded.",
  40: ({ e, method: t }) => `${e}
${aE(t)}`,
  41: () => "Browser did not allow document.execCommand('copy'). Ensure 'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons.",
  42: () => "Browser does not support document.execCommand('copy') for clipboard operations",
  43: ({ iconName: e }) => `As of v33, icon '${e}' is deprecated. Use the icon CSS name instead.`,
  44: () => 'Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.',
  45: ({ parentCellDataType: e }) => `The data type definition ${e} does not exist.`,
  46: () => 'The "baseDataType" property of a data type definition must match that of its parent.',
  47: ({ cellDataType: e }) => `Missing data type definition - "${e}"`,
  48: ({ property: e }) => `Cell data type is "object" but no Value ${e} has been provided. Please either provide an object data type definition with a Value ${e}, or set "colDef.value${e}"`,
  49: ({ methodName: e }) => `Framework component is missing the method ${e}()`,
  50: ({ compName: e }) => `Could not find component ${e}, did you forget to configure this component?`,
  51: () => "Export cancelled. Export is not allowed as per your configuration.",
  52: () => "There is no `window` associated with the current `document`",
  53: () => "unknown value type during csv conversion",
  54: () => "Could not find document body, it is needed for drag and drop and context menu.",
  55: () => "addRowDropZone - A container target needs to be provided",
  56: () => "addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.",
  57: () => "unable to show popup filter, filter instantiation failed",
  58: () => "no values found for select cellEditor",
  59: () => "cannot select pinned rows",
  60: () => "cannot select node until it has finished loading",
  61: () => "since version v32.2.0, rowNode.isFullWidthCell() has been deprecated. Instead check `rowNode.detail` followed by the user provided `isFullWidthRow` grid option.",
  62: ({ colId: e }) => `setFilterModel() - no column found for colId: ${e}`,
  63: ({ colId: e }) => `setFilterModel() - unable to fully apply model, filtering disabled for colId: ${e}`,
  64: ({ colId: e }) => `setFilterModel() - unable to fully apply model, unable to create filter for colId: ${e}`,
  65: () => "filter missing setModel method, which is needed for setFilterModel",
  66: () => "filter API missing getModel method, which is needed for getFilterModel",
  67: () => "Filter is missing isFilterActive() method",
  68: () => "Column Filter API methods have been disabled as Advanced Filters are enabled.",
  69: ({ guiFromFilter: e }) => `getGui method from filter returned ${e}; it should be a DOM element.`,
  70: ({ newFilter: e }) => `Grid option quickFilterText only supports string inputs, received: ${typeof e}`,
  71: () => "debounceMs is ignored when apply button is present",
  72: ({ keys: e }) => ["ignoring FilterOptionDef as it doesn't contain one of ", e],
  73: () => "invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'",
  74: () => "no filter options for filter",
  75: () => "Unknown button type specified",
  76: ({ filterModelType: e }) => [
    'Unexpected type of filter "',
    e,
    '", it looks like the filter was configured with incorrect Filter Options'
  ],
  77: () => "Filter model is missing 'conditions'",
  78: () => 'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.',
  79: () => '"filterParams.maxNumConditions" must be greater than or equal to zero.',
  80: () => '"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.',
  81: () => '"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".',
  82: ({ param: e }) => `DateFilter ${e} is not a number`,
  83: () => "DateFilter minValidYear should be <= maxValidYear",
  84: () => "DateFilter minValidDate should be <= maxValidDate",
  85: () => "DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored.",
  86: () => "DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored.",
  87: () => "DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.",
  88: ({ index: e }) => `Invalid row index for ensureIndexVisible: ${e}`,
  89: () => "A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)",
  90: () => "datasource is missing getRows method",
  91: () => "Filter is missing method doesFilterPass",
  92: () => "AnimationFrameService called but animation frames are off",
  93: () => "cannot add multiple ranges when `cellSelection.suppressMultiRanges = true`",
  94: ({
    paginationPageSizeOption: e,
    pageSizeSet: t,
    pageSizesSet: i,
    pageSizeOptions: s
  }) => `'paginationPageSize=${e}'${t ? "" : " (default value)"}, but ${e} is not included in${i ? "" : " the default"} paginationPageSizeSelector=[${s == null ? void 0 : s.join(", ")}].`,
  95: ({
    paginationPageSizeOption: e,
    paginationPageSizeSelector: t
  }) => `Either set '${t}' to an array that includes ${e} or to 'false' to disable the page size selector.`,
  96: ({ id: e, data: t }) => [
    "Duplicate ID",
    e,
    "found for pinned row with data",
    t,
    "When `getRowId` is defined, it must return unique IDs for all pinned rows. Use the `rowPinned` parameter."
  ],
  97: ({ colId: e }) => `cellEditor for column ${e} is missing getGui() method`,
  98: () => "popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.",
  99: () => "Since v32, `api.hideOverlay()` does not hide the loading overlay when `loading=true`. Set `loading=false` instead.",
  // 100: ({ rowModelType }: { rowModelType: RowModelType }) =>
  //     `selectAll only available when rowModelType='clientSide', ie not ${rowModelType}` as const,
  101: ({
    propertyName: e,
    componentName: t,
    agGridDefaults: i,
    jsComps: s
  }) => {
    const o = [], n = [
      // Don't include the old names / internals in potential suggestions
      ...Object.keys(i ?? []).filter(
        (a) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(a)
      ),
      ...Object.keys(s ?? []).filter((a) => !!s[a])
    ], r = Wa({
      inputValue: t,
      allSuggestions: n,
      hideIrrelevant: !0,
      filterByPercentageOfBestMatch: 0.8
    }).values;
    return o.push(
      `Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.
`
    ), r.length > 0 && o.push(`         Did you mean: [${r.slice(0, 3)}]?
`), o.push("If using a custom component check it has been registered correctly."), o;
  },
  102: () => "selectAll: 'filtered' only works when gridOptions.rowModelType='clientSide'",
  103: () => "Invalid selection state. When using client-side row model, the state must conform to `string[]`.",
  104: ({ value: e, param: t }) => `Numeric value ${e} passed to ${t} param will be interpreted as ${e} seconds. If this is intentional use "${e}s" to silence this warning.`,
  105: ({ e }) => ["chart rendering failed", e],
  106: () => `Theming API and Legacy Themes are both used in the same page. A Theming API theme has been provided to the 'theme' grid option, but the file (ag-grid.css) is also included and will cause styling issues. Remove ag-grid.css from the page. See the migration guide: ${rs}/theming-migration/`,
  107: ({ key: e, value: t }) => `Invalid value for theme param ${e} - ${t}`,
  108: ({ e }) => ["chart update failed", e],
  109: ({ inputValue: e, allSuggestions: t }) => {
    const i = Wa({
      inputValue: e,
      allSuggestions: t,
      hideIrrelevant: !0,
      filterByPercentageOfBestMatch: 0.8
    }).values;
    return [
      `Could not find '${e}' aggregate function. It was configured as "aggFunc: '${e}'" but it wasn't found in the list of registered aggregations.`,
      i.length > 0 ? `         Did you mean: [${i.slice(0, 3)}]?` : "",
      "If using a custom aggregation function check it has been registered correctly."
    ].join(`
`);
  },
  110: () => "groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup",
  111: () => "Invalid selection state. When `groupSelects` is enabled, the state must conform to `IServerSideGroupSelectionState`.",
  113: () => "Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values",
  114: ({ component: e }) => `Could not find component with name of ${e}. Is it in Vue.components?`,
  // 115: () => 'The provided selection state should be an object.' as const,
  116: () => "Invalid selection state. The state must conform to `IServerSideSelectionState`.",
  117: () => "selectAll must be of boolean type.",
  118: () => "Infinite scrolling must be enabled in order to set the row count.",
  119: () => "Unable to instantiate filter",
  120: () => "MultiFloatingFilterComp expects MultiFilter as its parent",
  121: () => "a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (see AG Grid docs) or b) to toString() on the object to return a key",
  122: () => "could not find the document, document is empty",
  123: () => "Advanced Filter is only supported with the Client-Side Row Model or Server-Side Row Model.",
  124: () => "No active charts to update.",
  125: ({ chartId: e }) => `Unable to update chart. No active chart found with ID: ${e}.`,
  126: () => "unable to restore chart as no chart model is provided",
  127: ({ allRange: e }) => `unable to create chart as ${e ? "there are no columns in the grid" : "no range is selected"}.`,
  128: ({ feature: e }) => `${e} is only available if using 'multiRow' selection mode.`,
  129: ({ feature: e, rowModel: t }) => `${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${t}.`,
  130: () => 'cannot multi select unless selection mode is "multiRow"',
  // 131: () => 'cannot range select while selecting multiple rows' as const,
  132: () => "Row selection features are not available unless `rowSelection` is enabled.",
  133: ({ iconName: e }) => `icon '${e}' function should return back a string or a dom object`,
  134: ({ iconName: e }) => `Did not find icon '${e}'`,
  135: () => "Data type of the new value does not match the cell data type of the column",
  136: () => "Unable to update chart as the 'type' is missing. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.",
  137: ({ type: e, currentChartType: t }) => `Unable to update chart as a '${e}' update type is not permitted on a ${t}.`,
  138: ({ chartType: e }) => `invalid chart type supplied: ${e}`,
  139: ({ customThemeName: e }) => `a custom chart theme with the name ${e} has been supplied but not added to the 'chartThemes' list`,
  140: ({ name: e }) => `no stock theme exists with the name '${e}' and no custom chart theme with that name was supplied to 'customChartThemes'`,
  141: () => "cross filtering with row grouping is not supported.",
  142: () => "cross filtering is only supported in the client side row model.",
  143: ({ panel: e }) => `'${e}' is not a valid Chart Tool Panel name`,
  144: ({ type: e }) => `Invalid charts data panel group name supplied: '${e}'`,
  145: ({ group: e }) => `As of v32, only one charts customize panel group can be expanded at a time. '${e}' will not be expanded.`,
  146: ({ comp: e }) => `Unable to instantiate component '${e}' as its module hasn't been loaded. Add 'ValidationModule' to see which module is required.`,
  147: ({ group: e }) => `Invalid charts customize panel group name supplied: '${e}'`,
  148: ({ group: e }) => `invalid chartGroupsDef config '${e}'`,
  149: ({ group: e, chartType: t }) => `invalid chartGroupsDef config '${e}.${t}'`,
  150: () => "'seriesChartTypes' are required when the 'customCombo' chart type is specified.",
  151: ({ chartType: e }) => `invalid chartType '${e}' supplied in 'seriesChartTypes', converting to 'line' instead.`,
  152: ({ colId: e }) => `no 'seriesChartType' found for colId = '${e}', defaulting to 'line'.`,
  153: ({ chartDataType: e }) => `unexpected chartDataType value '${e}' supplied, instead use 'category', 'series' or 'excluded'`,
  154: ({ colId: e }) => `cross filtering requires a 'agSetColumnFilter' or 'agMultiColumnFilter' to be defined on the column with id: ${e}`,
  155: ({ option: e }) => `'${e}' is not a valid Chart Toolbar Option`,
  156: ({ panel: e }) => `Invalid panel in chartToolPanelsDef.panels: '${e}'`,
  157: ({ unrecognisedGroupIds: e }) => ["unable to find group(s) for supplied groupIds:", e],
  158: () => "can not expand a column item that does not represent a column group header",
  159: () => "Invalid params supplied to createExcelFileForExcel() - `ExcelExportParams.data` is empty.",
  160: () => "Export cancelled. Export is not allowed as per your configuration.",
  161: () => "The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'",
  162: ({ id: e, dataType: t }) => `Unrecognized data type for excel export [${e}.dataType=${t}]`,
  163: ({ featureName: e }) => `Excel table export does not work with ${e}. The exported Excel file will not contain any Excel tables.
 Please turn off ${e} to enable Excel table exports.`,
  164: () => "Unable to add data table to Excel sheet: A table already exists.",
  165: () => "Unable to add data table to Excel sheet: Missing required parameters.",
  166: ({ unrecognisedGroupIds: e }) => ["unable to find groups for these supplied groupIds:", e],
  167: ({ unrecognisedColIds: e }) => ["unable to find columns for these supplied colIds:", e],
  168: () => "detailCellRendererParams.template should be function or string",
  169: () => 'Reference to eDetailGrid was missing from the details template. Please add data-ref="eDetailGrid" to the template.',
  170: ({ providedStrategy: e }) => `invalid cellRendererParams.refreshStrategy = ${e} supplied, defaulting to refreshStrategy = 'rows'.`,
  171: () => "could not find detail grid options for master detail, please set gridOptions.detailCellRendererParams.detailGridOptions",
  172: () => "could not find getDetailRowData for master / detail, please set gridOptions.detailCellRendererParams.getDetailRowData",
  173: ({ group: e }) => `invalid chartGroupsDef config '${e}'`,
  174: ({ group: e, chartType: t }) => `invalid chartGroupsDef config '${e}.${t}'`,
  175: ({ menuTabName: e, itemsToConsider: t }) => [
    `Trying to render an invalid menu item '${e}'. Check that your 'menuTabs' contains one of `,
    t
  ],
  176: ({ key: e }) => `unknown menu item type ${e}`,
  177: () => "valid values for cellSelection.handle.direction are 'x', 'y' and 'xy'. Default to 'xy'.",
  178: ({ colId: e }) => `column ${e} is not visible`,
  179: () => "totalValueGetter should be either a function or a string (expression)",
  180: () => "agRichSelectCellEditor requires cellEditorParams.values to be set",
  181: () => "agRichSelectCellEditor cannot have `multiSelect` and `allowTyping` set to `true`. AllowTyping has been turned off.",
  182: () => 'you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data',
  183: () => "Group Column Filter only works on group columns. Please use a different filter.",
  184: ({ parentGroupData: e, childNodeData: t }) => ["duplicate group keys for row data, keys should be unique", [e, t]],
  185: ({ data: e }) => ["getDataPath() should not return an empty path", [e]],
  186: ({
    rowId: e,
    rowData: t,
    duplicateRowsData: i
  }) => [
    "duplicate group keys for row data, keys should be unique",
    e,
    t,
    ...i ?? []
  ],
  187: ({ rowId: e, firstData: t, secondData: i }) => [
    `Duplicate node id ${e}. Row IDs are provided via the getRowId() callback. Please modify the getRowId() callback code to provide unique row id values.`,
    "first instance",
    t,
    "second instance",
    i
  ],
  188: (e) => `getRowId callback must be provided for Server Side Row Model ${(e == null ? void 0 : e.feature) || "selection"} to work correctly.`,
  189: ({ startRow: e }) => `invalid value ${e} for startRow, the value should be >= 0`,
  190: ({ rowGroupId: e, data: t }) => [
    "null and undefined values are not allowed for server side row model keys",
    e ? `column = ${e}` : "",
    "data is ",
    t
  ],
  // 191: () => `cannot multi select unless selection mode is 'multiRow'` as const,
  // 192: () => `cannot use range selection when multi selecting rows` as const,
  // 193: () => "cannot multi select unless selection mode is 'multiRow'" as const,
  194: ({ method: e }) => `calling gridApi.${e}() is only possible when using rowModelType=\`clientSide\`.`,
  195: ({ justCurrentPage: e }) => `selecting just ${e ? "current page" : "filtered"} only works when gridOptions.rowModelType='clientSide'`,
  196: ({ key: e }) => `Provided ids must be of string type. Invalid id provided: ${e}`,
  197: () => "`toggledNodes` must be an array of string ids.",
  // 198: () => `cannot multi select unless selection mode is 'multiRow'` as const,
  199: () => "getSelectedNodes and getSelectedRows functions cannot be used with select all functionality with the server-side row model. Use `api.getServerSideSelectionState()` instead.",
  200: jc,
  201: ({ rowModelType: e }) => `Could not find row model for rowModelType = ${e}`,
  202: () => "`getSelectedNodes` and `getSelectedRows` functions cannot be used with `groupSelectsChildren` and the server-side row model. Use `api.getServerSideSelectionState()` instead.",
  203: () => "Server Side Row Model does not support Dynamic Row Height and Cache Purging. Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.",
  204: () => "Server Side Row Model does not support Auto Row Height and Cache Purging. Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.",
  205: ({ duplicateIdText: e }) => `Unable to display rows as duplicate row ids (${e}) were returned by the getRowId callback. Please modify the getRowId callback to provide unique ids.`,
  206: () => "getRowId callback must be implemented for transactions to work. Transaction was ignored.",
  207: () => 'The Set Filter Parameter "defaultToNothingSelected" value was ignored because it does not work when "excelMode" is used.',
  208: () => "Set Filter Value Formatter must return string values. Please ensure the Set Filter Value Formatter returns string values for complex objects.",
  209: () => `Set Filter Key Creator is returning null for provided values and provided values are primitives. Please provide complex objects. See ${rs}/filter-set-filter-list/#filter-value-types`,
  210: () => "Set Filter has a Key Creator, but provided values are primitives. Did you mean to provide complex objects?",
  211: () => "property treeList=true for Set Filter params, but you did not provide a treeListPathGetter or values of type Date.",
  212: () => "please review all your toolPanel components, it seems like at least one of them doesn't have an id",
  213: () => "Advanced Filter does not work with Filters Tool Panel. Filters Tool Panel has been disabled.",
  214: ({ key: e }) => `unable to lookup Tool Panel as invalid key supplied: ${e}`,
  215: ({ key: e, defaultByKey: t }) => `the key ${e} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(t ?? {}).join(",")}`,
  216: ({ name: e }) => `Missing component for '${e}'`,
  217: ({ invalidColIds: e }) => ["unable to find grid columns for the supplied colDef(s):", e],
  218: ({ property: e, defaultOffset: t }) => `${e} must be a number, the value you provided is not a valid number. Using the default of ${t}px.`,
  219: ({ property: e }) => `Property ${e} does not exist on the target object.`,
  220: ({ lineDash: e }) => `'${e}' is not a valid 'lineDash' option.`,
  221: () => "agAggregationComponent should only be used with the client and server side row model.",
  222: () => "agFilteredRowCountComponent should only be used with the client side row model.",
  223: () => "agSelectedRowCountComponent should only be used with the client and server side row model.",
  224: () => "agTotalAndFilteredRowCountComponent should only be used with the client side row model.",
  225: () => "agTotalRowCountComponent should only be used with the client side row model.",
  226: () => "viewport is missing init method.",
  227: () => "menu item icon must be DOM node or string",
  228: ({ menuItemOrString: e }) => `unrecognised menu item ${e}`,
  229: ({ index: e }) => ["invalid row index for ensureIndexVisible: ", e],
  230: () => "detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://www.ag-grid.com/react-data-grid/master-detail-custom-detail/",
  // @deprecated v32 mark for removal as part of v32 deprecated features
  231: () => "As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.",
  232: () => "Using both rowData and v-model. rowData will be ignored.",
  233: ({ methodName: e }) => `Framework component is missing the method ${e}()`,
  234: () => 'Group Column Filter does not work with the colDef property "field". This property will be ignored.',
  235: () => 'Group Column Filter does not work with the colDef property "filterValueGetter". This property will be ignored.',
  236: () => 'Group Column Filter does not work with the colDef property "filterParams". This property will be ignored.',
  237: () => "Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter.",
  238: () => "setRowCount can only accept a positive row count.",
  239: () => 'Theming API and CSS File Themes are both used in the same page. In v33 we released the Theming API as the new default method of styling the grid. See the migration docs https://www.ag-grid.com/react-data-grid/theming-migration/. Because no value was provided to the `theme` grid option it defaulted to themeQuartz. But the file (ag-grid.css) is also included and will cause styling issues. Either pass the string "legacy" to the theme grid option to use v32 style themes, or remove ag-grid.css from the page to use Theming API.',
  240: ({ theme: e }) => `theme grid option must be a Theming API theme object or the string "legacy", received: ${e}`,
  // 241: () => `cannot select multiple rows when rowSelection.mode is set to 'singleRow'` as const,
  // 242: () => 'cannot select multiple rows when using rangeSelect' as const,
  243: () => "Failed to deserialize state - each provided state object must be an object.",
  244: () => "Failed to deserialize state - `selectAllChildren` must be a boolean value or undefined.",
  245: () => "Failed to deserialize state - `toggledNodes` must be an array.",
  246: () => "Failed to deserialize state - Every `toggledNode` requires an associated string id.",
  247: () => `Row selection state could not be parsed due to invalid data. Ensure all child state has toggledNodes or does not conform with the parent rule. 
Please rebuild the selection state and reapply it.`,
  248: () => "SetFloatingFilter expects SetFilter as its parent",
  249: () => "Must supply a Value Formatter in Set Filter params when using a Key Creator",
  250: () => "Must supply a Key Creator in Set Filter params when `treeList = true` on a group column, and Tree Data or Row Grouping is enabled.",
  251: ({ chartType: e }) => `AG Grid: Unable to create chart as an invalid chartType = '${e}' was supplied.`,
  252: () => `cannot get grid to draw rows when it is in the middle of drawing rows. 
Your code probably called a grid API method while the grid was in the render stage. 
To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). 
To see what part of your code that caused the refresh check this stacktrace.`,
  253: ({ version: e }) => ["Illegal version string: ", e],
  254: () => "Cannot create chart: no chart themes available.",
  255: ({ point: e }) => `Lone surrogate U+${e == null ? void 0 : e.toString(16).toUpperCase()} is not a scalar value`,
  256: () => "Unable to initialise. See validation error, or load ValidationModule if missing.",
  257: () => qc("IntegratedChartsModule"),
  258: () => qc("SparklinesModule"),
  259: ({ part: e }) => `the argument to theme.withPart must be a Theming API part object, received: ${e}`,
  260: ({
    propName: e,
    compName: t,
    gridScoped: i,
    gridId: s,
    rowModelType: o
  }) => jc({
    reasonOrId: `AG Grid '${e}' component: ${t}`,
    moduleName: gs[t],
    gridId: s,
    gridScoped: i,
    rowModelType: o
  }),
  261: () => "As of v33, `column.isHovered()` is deprecated. Use `api.isColumnHovered(column)` instead.",
  262: () => 'As of v33, icon key "smallDown" is deprecated. Use "advancedFilterBuilderSelect" for Advanced Filter Builder dropdown, "selectOpen" for Select cell editor and dropdowns (e.g. Integrated Charts menu), "richSelectOpen" for Rich Select cell editor.',
  263: () => 'As of v33, icon key "smallLeft" is deprecated. Use "panelDelimiterRtl" for Row Group Panel / Pivot Panel, "subMenuOpenRtl" for sub-menus.',
  264: () => 'As of v33, icon key "smallRight" is deprecated. Use "panelDelimiter" for Row Group Panel / Pivot Panel, "subMenuOpen" for sub-menus.',
  265: ({ colId: e }) => `Unable to infer chart data type for column '${e}' if first data entry is null. Please specify "chartDataType", or a "cellDataType" in the column definition. For more information, see ${rs}/integrated-charts-range-chart#coldefchartdatatype .`,
  266: () => 'As of v33.1, using "keyCreator" with the Rich Select Editor has been deprecated. It now requires the "formatValue" callback to convert complex data to strings.',
  267: () => "Detail grids can not use a different theme to the master grid, the `theme` detail grid option will be ignored.",
  268: () => "Transactions aren't supported with tree data when using treeDataChildrenField",
  269: () => "When `masterSelects: 'detail'`, detail grids must be configured with multi-row selection",
  270: ({ id: e, parentId: t }) => `Cycle detected for row with id='${e}' and parent id='${t}'. Resetting the parent for row with id='${e}' and showing it as a root-level node.`,
  271: ({ id: e, parentId: t }) => `Parent row not found for row with id='${e}' and parent id='${t}'. Showing row with id='${e}' as a root-level node.`,
  272: () => Gp(),
  273: ({ providedId: e, usedId: t }) => `Provided column id '${e}' was already in use, ensure all column and group ids are unique. Using '${t}' instead.`,
  274: ({ prop: e }) => {
    let t = `Since v33, ${e} has been deprecated.`;
    switch (e) {
      case "maxComponentCreationTimeMs":
        t += " This property is no longer required and so will be removed in a future version.";
        break;
      case "setGridApi":
        t += " This method is not called by AG Grid. To access the GridApi see: https://ag-grid.com/react-data-grid/grid-interface/#grid-api ";
        break;
      case "children":
        t += " For multiple versions AgGridReact does not support children.";
        break;
    }
    return t;
  },
  275: Vp,
  276: () => "Row Numbers Row Resizer cannot be used when Grid Columns have `autoHeight` enabled.",
  277: ({ colId: e }) => `'enableFilterHandlers' is set to true, but column '${e}' does not have 'filter.doesFilterPass' or 'filter.handler' set.`,
  278: ({ colId: e }) => `Unable to create filter handler for column '${e}'`,
  279: (e) => {
  },
  // `Unable to create dynamic bean '${name}' during module init lifecycle, dynamic beans must be initialised on first use.` as const,
  280: ({ colId: e }) => `'name' must be provided for custom filter components for column '${e}`,
  281: ({ colId: e }) => `Filter for column '${e}' does not have 'filterParams.buttons', but the new Filters Tool Panel has buttons configured. Either configure buttons for the filter, or disable buttons on the Filters Tool Panel.`,
  282: () => "New filter tool panel requires `enableFilterHandlers: true`.",
  283: () => "As of v34, use the same method on the filter handler (`api.getColumnFilterHandler(colKey)`) instead.",
  284: () => "As of v34, filters are active when they have a model. Use `api.getColumnFilterModel()` instead.",
  285: () => "As of v34, use (`api.getColumnFilterModel()`) instead.",
  286: () => "As of v34, use (`api.setColumnFilterModel()`) instead.",
  287: () => "`api.doFilterAction()` requires `enableFilterHandlers = true",
  288: () => "`api.getColumnFilterModel(key, true)` requires `enableFilterHandlers = true",
  289: ({ rowModelType: e }) => `Row Model '${e}' is not supported with Batch Editing`,
  290: ({ rowIndex: e, rowPinned: t }) => `Row with index '${e}' and pinned state '${t}' not found`
};
function dE(e, t) {
  const i = lE[e];
  if (!i)
    return [`Missing error text for error id ${e}!`];
  const s = i(t), n = `
See ${Uh(e, t)}`;
  return Array.isArray(s) ? s.concat(n) : [s, n];
}
var cE = {
  1: "Charting Aggregation",
  2: "pivotResultFields",
  3: "setTooltip"
}, Yc = /* @__PURE__ */ new WeakMap(), Qc = /* @__PURE__ */ new WeakMap();
function uE(e, t, i) {
  if (!t)
    return Z(11), {};
  const s = i;
  let o;
  if (!(s != null && s.setThemeOnGridDiv)) {
    const r = ye({ tag: "div" });
    r.style.height = "100%", e.appendChild(r), e = r, o = () => e.remove();
  }
  return new gE().create(
    e,
    t,
    (r) => {
      const a = new HS(e);
      r.createBean(a);
    },
    void 0,
    i,
    o
  );
}
var hE = 1, gE = class {
  create(e, t, i, s, o, n) {
    const r = MC.applyGlobalGridOptions(t), a = r.gridId ?? String(hE++), l = this.getRegisteredModules(o, a, r.rowModelType), d = this.createBeansList(r.rowModelType, l, a), c = this.createProvidedBeans(e, r, o);
    if (!d)
      return;
    const h = {
      providedBeanInstances: c,
      beanClasses: d,
      id: a,
      beanInitComparator: bS,
      beanDestroyComparator: yS,
      derivedBeans: [vS],
      destroyCallback: () => {
        Qc.delete(p), Yc.delete(e), nF(a), n == null || n();
      }
    }, g = new sb(h);
    this.registerModuleFeatures(g, l), i(g), g.getBean("syncSvc").start(), s == null || s(g);
    const p = g.getBean("gridApi");
    return Yc.set(e, p), Qc.set(p, e), p;
  }
  getRegisteredModules(e, t, i) {
    var s;
    return or(tE, void 0, !0), (s = e == null ? void 0 : e.modules) == null || s.forEach((o) => or(o, t)), rF(t, Xc(i));
  }
  registerModuleFeatures(e, t) {
    const i = e.getBean("registry"), s = e.getBean("apiFunctionSvc");
    t.forEach((o) => {
      i.registerModule(o);
      const n = o.apiFunctions;
      n && Object.keys(n).forEach((a) => {
        s == null || s.addFunction(a, n[a]);
      });
    });
  }
  createProvidedBeans(e, t, i) {
    let s = i ? i.frameworkOverrides : null;
    de(s) && (s = new ap());
    const o = {
      gridOptions: t,
      eGridDiv: e,
      eRootDiv: e,
      globalListener: i ? i.globalListener : null,
      globalSyncListener: i ? i.globalSyncListener : null,
      frameworkOverrides: s
    };
    return i && i.providedBeanInstances && Object.assign(o, i.providedBeanInstances), o;
  }
  createBeansList(e, t, i) {
    const s = {
      clientSide: "ClientSideRowModel",
      infinite: "InfiniteRowModel",
      serverSide: "ServerSideRowModel",
      viewport: "ViewportRowModel"
    }, o = Xc(e), n = s[o];
    if (!n) {
      qs(201, { rowModelType: o }, `Unknown rowModelType ${o}.`);
      return;
    }
    if (!lF()) {
      qs(272, void 0, Gp());
      return;
    }
    if (!e) {
      const a = Object.entries(s).filter(
        ([l, d]) => tl(d, i, l)
      );
      if (a.length == 1) {
        const [l, d] = a[0];
        if (l !== o) {
          const c = {
            moduleName: d,
            rowModelType: l
          };
          qs(275, c, Vp(c));
          return;
        }
      }
    }
    if (!tl(n, i, o)) {
      qs(
        200,
        {
          reasonOrId: `rowModelType = '${o}'`,
          moduleName: n,
          gridScoped: ed(),
          gridId: i,
          rowModelType: o
        },
        `Missing module ${n}Module for rowModelType ${o}.`
      );
      return;
    }
    const r = /* @__PURE__ */ new Set();
    return t.forEach((a) => {
      var l;
      return (l = a.beans) == null ? void 0 : l.forEach((d) => r.add(d));
    }), Array.from(r);
  }
};
function Xc(e) {
  return e ?? "clientSide";
}
var pE = class extends E {
  constructor() {
    super(...arguments), this.beanName = "localeSvc";
  }
  getLocaleTextFunc() {
    const e = this.gos, t = e.getCallback("getLocaleText");
    return t ? SC(t) : RC(e.get("localeText"));
  }
};
function fE(e, t = !1) {
  const i = [], s = [], o = [], n = [], r = [], a = [], l = [], d = [], c = [];
  let u = 0;
  for (let h = 0; h < e.length; h++) {
    const {
      colId: g,
      sort: p,
      sortIndex: f,
      rowGroup: m,
      rowGroupIndex: C,
      aggFunc: v,
      pivot: R,
      pivotIndex: b,
      pinned: w,
      hide: x,
      width: F,
      flex: D
    } = e[h];
    c.push(g), p && (i[f ?? u++] = { colId: g, sort: p }), m && (s[C ?? 0] = g), typeof v == "string" && o.push({ colId: g, aggFunc: v }), R && (n[b ?? 0] = g), w && (w === "right" ? a : r).push(g), x && l.push(g), (D != null || F) && d.push({ colId: g, flex: D ?? void 0, width: F });
  }
  return {
    sort: i.length ? { sortModel: i } : void 0,
    rowGroup: s.length ? { groupColIds: s } : void 0,
    aggregation: o.length ? { aggregationModel: o } : void 0,
    pivot: n.length || t ? { pivotMode: t, pivotColIds: n } : void 0,
    columnPinning: r.length || a.length ? { leftColIds: r, rightColIds: a } : void 0,
    columnVisibility: l.length ? { hiddenColIds: l } : void 0,
    columnSizing: d.length ? { columnSizingModel: d } : void 0,
    columnOrder: c.length ? { orderedColIds: c } : void 0
  };
}
function mE(e) {
  const t = [];
  return e.forEach(({ groupId: i, open: s }) => {
    s && t.push(i);
  }), t.length ? { openColumnGroupIds: t } : void 0;
}
var CE = class {
  wrap(e, t, i, s) {
    const o = this.createWrapper(e, s);
    return t == null || t.forEach((n) => {
      this.createMethod(o, n, !0);
    }), i == null || i.forEach((n) => {
      this.createMethod(o, n, !1);
    }), o;
  }
  createMethod(e, t, i) {
    e.addMethod(t, this.createMethodProxy(e, t, i));
  }
  createMethodProxy(e, t, i) {
    return function() {
      return e.hasMethod(t) ? e.callMethod(t, arguments) : (i && I(49, { methodName: t }), null);
    };
  }
};
function pa(e) {
  return e.get("tooltipShowMode") === "whenTruncated";
}
function vE(e, t) {
  if (typeof e != "number")
    return "";
  const i = t(), s = i("thousandSeparator", ","), o = i("decimalSeparator", ".");
  return e.toString().replace(".", o).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${s}`);
}
var wE = class extends E {
  getFileName(e) {
    const t = this.getDefaultFileExtension();
    return (e == null || !e.length) && (e = this.getDefaultFileName()), e.indexOf(".") === -1 ? `${e}.${t}` : e;
  }
  getData(e) {
    const t = this.createSerializingSession(e);
    return this.beans.gridSerializer.serialize(t, e);
  }
  getDefaultFileName() {
    return `export.${this.getDefaultFileExtension()}`;
  }
}, bE = class {
  constructor(e) {
    const {
      colModel: t,
      rowGroupColsSvc: i,
      colNames: s,
      valueSvc: o,
      gos: n,
      processCellCallback: r,
      processHeaderCallback: a,
      processGroupHeaderCallback: l,
      processRowGroupCallback: d
    } = e;
    this.colModel = t, this.rowGroupColsSvc = i, this.colNames = s, this.valueSvc = o, this.gos = n, this.processCellCallback = r, this.processHeaderCallback = a, this.processGroupHeaderCallback = l, this.processRowGroupCallback = d;
  }
  prepare(e) {
  }
  extractHeaderValue(e) {
    return this.getHeaderName(this.processHeaderCallback, e) ?? "";
  }
  extractRowCellValue(e, t, i, s, o) {
    var h;
    const n = t === 0 && Xh(this.gos, o, this.colModel.isPivotMode());
    if (this.processRowGroupCallback && (this.gos.get("treeData") || o.group) && (e.isRowGroupDisplayed(((h = o.rowGroupColumn) == null ? void 0 : h.getColId()) ?? "") || n))
      return { value: this.processRowGroupCallback(W(this.gos, { column: e, node: o })) ?? "" };
    if (this.processCellCallback)
      return {
        value: this.processCellCallback(
          W(this.gos, {
            accumulatedRowIndex: i,
            column: e,
            node: o,
            value: this.valueSvc.getValueForDisplay(e, o, void 0, void 0).value,
            type: s,
            parseValue: (g) => this.valueSvc.parseValue(
              e,
              o,
              g,
              this.valueSvc.getValue(e, o, void 0)
            ),
            formatValue: (g) => this.valueSvc.formatValue(e, o, g) ?? g
          })
        ) ?? ""
      };
    const r = this.gos.get("treeData"), a = this.valueSvc, l = o.level === -1 && o.footer, d = e.colDef.showRowGroup === !0 && (o.group || r);
    if (!l && (n || d)) {
      let g = "", p = o;
      for (; p && p.level !== -1; ) {
        const { value: f, valueFormatted: m } = a.getValueForDisplay(
          n ? void 0 : e,
          // full width group doesn't have a column
          p,
          !0,
          !0
        );
        g = ` -> ${m ?? f ?? ""}${g}`, p = p.parent;
      }
      return {
        value: g,
        // don't return the unformatted value; as if the grid detects number it'll not use the concatenated string
        valueFormatted: g
      };
    }
    const { value: c, valueFormatted: u } = a.getValueForDisplay(e, o, !0, !0);
    return {
      value: c ?? "",
      valueFormatted: u
    };
  }
  getHeaderName(e, t) {
    return e ? e(W(this.gos, { column: t })) : this.colNames.getDisplayNameForColumn(t, "csv", !0);
  }
};
function yE(e, t) {
  const i = document.defaultView || window;
  if (!i) {
    I(52);
    return;
  }
  const s = document.createElement("a"), o = i.URL.createObjectURL(t);
  s.setAttribute("href", o), s.setAttribute("download", e), s.style.display = "none", document.body.appendChild(s), s.dispatchEvent(
    new MouseEvent("click", {
      bubbles: !1,
      cancelable: !0,
      view: i
    })
  ), document.body.removeChild(s), i.setTimeout(() => {
    i.URL.revokeObjectURL(o);
  }, 0);
}
var SE = {
  enableBrowserTooltips: !0,
  tooltipTrigger: !0,
  tooltipMouseTrack: !0,
  tooltipShowMode: !0,
  tooltipInteraction: !0,
  defaultColGroupDef: !0,
  suppressAutoSize: !0,
  skipHeaderOnAutoSize: !0,
  autoSizeStrategy: !0,
  components: !0,
  stopEditingWhenCellsLoseFocus: !0,
  undoRedoCellEditing: !0,
  undoRedoCellEditingLimit: !0,
  excelStyles: !0,
  cacheQuickFilter: !0,
  customChartThemes: !0,
  chartThemeOverrides: !0,
  chartToolPanelsDef: !0,
  loadingCellRendererSelector: !0,
  localeText: !0,
  keepDetailRows: !0,
  keepDetailRowsCount: !0,
  detailRowHeight: !0,
  detailRowAutoHeight: !0,
  tabIndex: !0,
  valueCache: !0,
  valueCacheNeverExpires: !0,
  enableCellExpressions: !0,
  suppressTouch: !0,
  suppressBrowserResizeObserver: !0,
  suppressPropertyNamesCheck: !0,
  debug: !0,
  dragAndDropImageComponent: !0,
  loadingOverlayComponent: !0,
  suppressLoadingOverlay: !0,
  noRowsOverlayComponent: !0,
  paginationPageSizeSelector: !0,
  paginateChildRows: !0,
  pivotPanelShow: !0,
  pivotSuppressAutoColumn: !0,
  suppressExpandablePivotGroups: !0,
  aggFuncs: !0,
  allowShowChangeAfterFilter: !0,
  ensureDomOrder: !0,
  enableRtl: !0,
  suppressColumnVirtualisation: !0,
  suppressMaxRenderedRowRestriction: !0,
  suppressRowVirtualisation: !0,
  rowDragText: !0,
  groupLockGroupColumns: !0,
  suppressGroupRowsSticky: !0,
  rowModelType: !0,
  cacheOverflowSize: !0,
  infiniteInitialRowCount: !0,
  serverSideInitialRowCount: !0,
  maxBlocksInCache: !0,
  maxConcurrentDatasourceRequests: !0,
  blockLoadDebounceMillis: !0,
  serverSideOnlyRefreshFilteredGroups: !0,
  serverSidePivotResultFieldSeparator: !0,
  viewportRowModelPageSize: !0,
  viewportRowModelBufferSize: !0,
  debounceVerticalScrollbar: !0,
  suppressAnimationFrame: !0,
  suppressPreventDefaultOnMouseWheel: !0,
  scrollbarWidth: !0,
  icons: !0,
  suppressRowTransform: !0,
  gridId: !0,
  enableGroupEdit: !0,
  initialState: !0,
  processUnpinnedColumns: !0,
  createChartContainer: !0,
  getLocaleText: !0,
  getRowId: !0,
  reactiveCustomComponents: !0,
  renderingMode: !0,
  columnMenu: !0,
  suppressSetFilterByDefault: !0,
  getDataPath: !0,
  enableCellSpan: !0,
  enableFilterHandlers: !0,
  filterHandlers: !0
}, Ge = "clientSide", ke = "serverSide", Qi = "infinite", RE = {
  onGroupExpandedOrCollapsed: [Ge],
  refreshClientSideRowModel: [Ge],
  isRowDataEmpty: [Ge],
  forEachLeafNode: [Ge],
  forEachNodeAfterFilter: [Ge],
  forEachNodeAfterFilterAndSort: [Ge],
  resetRowHeights: [Ge, ke],
  applyTransaction: [Ge],
  applyTransactionAsync: [Ge],
  flushAsyncTransactions: [Ge],
  getBestCostNodeSelection: [Ge],
  getServerSideSelectionState: [ke],
  setServerSideSelectionState: [ke],
  applyServerSideTransaction: [ke],
  applyServerSideTransactionAsync: [ke],
  applyServerSideRowData: [ke],
  retryServerSideLoads: [ke],
  flushServerSideAsyncTransactions: [ke],
  refreshServerSide: [ke],
  getServerSideGroupLevelState: [ke],
  refreshInfiniteCache: [Qi],
  purgeInfiniteCache: [Qi],
  getInfiniteRowCount: [Qi],
  isLastRowIndexKnown: [Qi, ke],
  expandAll: [Ge, ke],
  collapseAll: [Ge, ke],
  onRowHeightChanged: [Ge, ke],
  setRowCount: [Qi, ke],
  getCacheBlockState: [Qi, ke]
}, xE = {
  showLoadingOverlay: {
    version: "v32",
    message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).'
  },
  clearRangeSelection: {
    version: "v32.2",
    message: "Use `clearCellSelection` instead."
  },
  getInfiniteRowCount: {
    version: "v32.2",
    old: "getInfiniteRowCount()",
    new: "getDisplayedRowCount()"
  },
  selectAllFiltered: {
    version: "v33",
    old: "selectAllFiltered()",
    new: 'selectAll("filtered")'
  },
  deselectAllFiltered: {
    version: "v33",
    old: "deselectAllFiltered()",
    new: 'deselectAll("filtered")'
  },
  selectAllOnCurrentPage: {
    version: "v33",
    old: "selectAllOnCurrentPage()",
    new: 'selectAll("currentPage")'
  },
  deselectAllOnCurrentPage: {
    version: "v33",
    old: "deselectAllOnCurrentPage()",
    new: 'deselectAll("currentPage")'
  }
};
function FE(e, t, i) {
  const s = xE[e];
  if (s) {
    const { version: n, new: r, old: a, message: l } = s, d = a ?? e;
    return (...c) => {
      const u = r ? `Please use ${r} instead. ` : "";
      return so(`Since ${n} api.${d} is deprecated. ${u}${l ?? ""}`), t.apply(t, c);
    };
  }
  const o = RE[e];
  return o ? (...n) => {
    const r = i.rowModel.getType();
    if (!o.includes(r)) {
      ns(
        `api.${e} can only be called when gridOptions.rowModelType is ${o.join(" or ")}`
      );
      return;
    }
    return t.apply(t, n);
  } : t;
}
var PE = {
  detailCellRendererCtrl: "SharedMasterDetail",
  dndSourceComp: "DragAndDrop",
  fillHandle: "CellSelection",
  groupCellRendererCtrl: "GroupCellRenderer",
  headerFilterCellCtrl: "ColumnFilter",
  headerGroupCellCtrl: "ColumnGroup",
  rangeHandle: "CellSelection",
  tooltipFeature: "Tooltip",
  highlightTooltipFeature: "Tooltip",
  tooltipStateManager: "Tooltip",
  groupStrategy: "RowGrouping",
  treeGroupStrategy: "TreeData",
  rowNumberRowResizer: "RowNumbers",
  singleCell: "EditCore",
  fullRow: "EditCore",
  agSetColumnFilterHandler: "SetFilter",
  agMultiColumnFilterHandler: "MultiFilter",
  agGroupColumnFilterHandler: "GroupFilter",
  agNumberColumnFilterHandler: "NumberFilter",
  agDateColumnFilterHandler: "DateFilter",
  agTextColumnFilterHandler: "TextFilter"
}, EE = {
  expanded: 1,
  contracted: 1,
  "tree-closed": 1,
  "tree-open": 1,
  "tree-indeterminate": 1,
  pin: 1,
  "eye-slash": 1,
  arrows: 1,
  left: 1,
  right: 1,
  group: 1,
  aggregation: 1,
  pivot: 1,
  "not-allowed": 1,
  chart: 1,
  cross: 1,
  cancel: 1,
  tick: 1,
  first: 1,
  previous: 1,
  next: 1,
  last: 1,
  linked: 1,
  unlinked: 1,
  "color-picker": 1,
  loading: 1,
  menu: 1,
  "menu-alt": 1,
  filter: 1,
  "filter-add": 1,
  columns: 1,
  maximize: 1,
  minimize: 1,
  copy: 1,
  cut: 1,
  paste: 1,
  grip: 1,
  save: 1,
  csv: 1,
  excel: 1,
  "small-down": 1,
  "small-left": 1,
  "small-right": 1,
  "small-up": 1,
  asc: 1,
  desc: 1,
  none: 1,
  up: 1,
  down: 1,
  plus: 1,
  minus: 1,
  settings: 1,
  "checkbox-checked": 1,
  "checkbox-indeterminate": 1,
  "checkbox-unchecked": 1,
  "radio-button-on": 1,
  "radio-button-off": 1,
  eye: 1,
  "column-arrow": 1,
  "un-pin": 1,
  "pinned-top": 1,
  "pinned-bottom": 1,
  "chevron-up": 1,
  "chevron-down": 1,
  "chevron-left": 1,
  "chevron-right": 1,
  edit: 1
}, DE = {
  chart: "MenuCore",
  cancel: "EnterpriseCore",
  first: "Pagination",
  previous: "Pagination",
  next: "Pagination",
  last: "Pagination",
  linked: "IntegratedCharts",
  loadingMenuItems: "MenuCore",
  unlinked: "IntegratedCharts",
  menu: "ColumnHeaderComp",
  legacyMenu: "ColumnMenu",
  filter: "ColumnFilter",
  filterActive: "ColumnFilter",
  filterAdd: "NewFiltersToolPanel",
  filterCardCollapse: "NewFiltersToolPanel",
  filterCardExpand: "NewFiltersToolPanel",
  filterCardEditing: "NewFiltersToolPanel",
  filterTab: "ColumnMenu",
  filtersToolPanel: "FiltersToolPanel",
  columns: ["MenuCore"],
  columnsToolPanel: ["ColumnsToolPanel"],
  maximize: "EnterpriseCore",
  minimize: "EnterpriseCore",
  save: "MenuCore",
  columnGroupOpened: "ColumnGroupHeaderComp",
  columnGroupClosed: "ColumnGroupHeaderComp",
  accordionOpen: "EnterpriseCore",
  accordionClosed: "EnterpriseCore",
  accordionIndeterminate: "EnterpriseCore",
  columnSelectClosed: ["ColumnsToolPanel", "ColumnMenu"],
  columnSelectOpen: ["ColumnsToolPanel", "ColumnMenu"],
  columnSelectIndeterminate: ["ColumnsToolPanel", "ColumnMenu"],
  columnMovePin: "SharedDragAndDrop",
  columnMoveHide: "SharedDragAndDrop",
  columnMoveMove: "SharedDragAndDrop",
  columnMoveLeft: "SharedDragAndDrop",
  columnMoveRight: "SharedDragAndDrop",
  columnMoveGroup: "SharedDragAndDrop",
  columnMoveValue: "SharedDragAndDrop",
  columnMovePivot: "SharedDragAndDrop",
  dropNotAllowed: "SharedDragAndDrop",
  ensureColumnVisible: ["ColumnsToolPanel", "ColumnMenu"],
  groupContracted: "GroupCellRenderer",
  groupExpanded: "GroupCellRenderer",
  setFilterGroupClosed: "SetFilter",
  setFilterGroupOpen: "SetFilter",
  setFilterGroupIndeterminate: "SetFilter",
  setFilterLoading: "SetFilter",
  close: "EnterpriseCore",
  check: "MenuItem",
  colorPicker: "CommunityCore",
  groupLoading: "LoadingCellRenderer",
  menuAlt: "ColumnHeaderComp",
  menuPin: "MenuCore",
  menuValue: "MenuCore",
  menuAddRowGroup: ["MenuCore", "ColumnsToolPanel"],
  menuRemoveRowGroup: ["MenuCore", "ColumnsToolPanel"],
  clipboardCopy: "MenuCore",
  clipboardCut: "MenuCore",
  clipboardPaste: "MenuCore",
  pivotPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
  rowGroupPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
  valuePanel: "ColumnsToolPanel",
  columnDrag: "EnterpriseCore",
  rowDrag: ["RowDrag", "DragAndDrop"],
  csvExport: "MenuCore",
  excelExport: "MenuCore",
  smallDown: "CommunityCore",
  selectOpen: "CommunityCore",
  richSelectOpen: "RichSelect",
  richSelectRemove: "RichSelect",
  smallLeft: "CommunityCore",
  smallRight: "CommunityCore",
  subMenuOpen: "MenuItem",
  subMenuOpenRtl: "MenuItem",
  panelDelimiter: "RowGroupingPanel",
  panelDelimiterRtl: "RowGroupingPanel",
  smallUp: "CommunityCore",
  sortAscending: ["MenuCore", "Sort"],
  sortDescending: ["MenuCore", "Sort"],
  sortUnSort: ["MenuCore", "Sort"],
  advancedFilterBuilder: "AdvancedFilter",
  advancedFilterBuilderDrag: "AdvancedFilter",
  advancedFilterBuilderInvalid: "AdvancedFilter",
  advancedFilterBuilderMoveUp: "AdvancedFilter",
  advancedFilterBuilderMoveDown: "AdvancedFilter",
  advancedFilterBuilderAdd: "AdvancedFilter",
  advancedFilterBuilderRemove: "AdvancedFilter",
  advancedFilterBuilderSelectOpen: "AdvancedFilter",
  chartsMenu: "IntegratedCharts",
  chartsMenuEdit: "IntegratedCharts",
  chartsMenuAdvancedSettings: "IntegratedCharts",
  chartsMenuAdd: "IntegratedCharts",
  chartsColorPicker: "IntegratedCharts",
  chartsThemePrevious: "IntegratedCharts",
  chartsThemeNext: "IntegratedCharts",
  chartsDownload: "IntegratedCharts",
  checkboxChecked: "CommunityCore",
  checkboxIndeterminate: "CommunityCore",
  checkboxUnchecked: "CommunityCore",
  radioButtonOn: "CommunityCore",
  radioButtonOff: "CommunityCore",
  rowPin: "PinnedRow",
  rowUnpin: "PinnedRow",
  rowPinBottom: "PinnedRow",
  rowPinTop: "PinnedRow"
}, TE = /* @__PURE__ */ new Set([
  "colorPicker",
  "smallUp",
  "checkboxChecked",
  "checkboxIndeterminate",
  "checkboxUnchecked",
  "radioButtonOn",
  "radioButtonOff",
  "smallDown",
  "smallLeft",
  "smallRight"
]), ME = class extends E {
  constructor() {
    super(...arguments), this.beanName = "validation";
  }
  wireBeans(e) {
    this.gridOptions = e.gridOptions, IC(dE);
  }
  warnOnInitialPropertyUpdate(e, t) {
    e === "api" && SE[t] && I(22, { key: t });
  }
  processGridOptions(e) {
    this.processOptions(e, S0());
  }
  validateApiFunction(e, t) {
    return FE(e, t, this.beans);
  }
  missingUserComponent(e, t, i, s) {
    const o = gs[t];
    o ? this.gos.assertModuleRegistered(
      o,
      `AG Grid '${e}' component: ${t}`
    ) : I(101, {
      propertyName: e,
      componentName: t,
      agGridDefaults: i,
      jsComps: s
    });
  }
  missingDynamicBean(e) {
    const t = PE[e];
    return t ? Pt(200, {
      ...this.gos.getModuleErrorParams(),
      moduleName: t,
      reasonOrId: e
    }) : void 0;
  }
  checkRowEvents(e) {
    IE.has(e) && I(10, { eventType: e });
  }
  validateIcon(e) {
    if (TE.has(e) && I(43, { iconName: e }), EE[e])
      return;
    const t = DE[e];
    if (t) {
      Z(200, {
        reasonOrId: `icon '${e}'`,
        moduleName: t,
        gridScoped: ed(),
        gridId: this.beans.context.getId(),
        rowModelType: this.gos.get("rowModelType"),
        additionalText: "Alternatively, use the CSS icon name directly."
      });
      return;
    }
    I(134, { iconName: e });
  }
  isProvidedUserComp(e) {
    return !!gs[e];
  }
  /** Should only be called via the GridOptionsService */
  validateColDef(e) {
    this.processOptions(e, h0());
  }
  processOptions(e, t) {
    const { validations: i, deprecations: s, allProperties: o, propertyExceptions: n, objectName: r, docsUrl: a } = t;
    o && this.gridOptions.suppressPropertyNamesCheck !== !0 && this.checkProperties(
      e,
      [...n ?? [], ...Object.keys(s)],
      o,
      r,
      a
    );
    const l = /* @__PURE__ */ new Set();
    Object.keys(e).forEach((c) => {
      const u = s[c];
      if (u) {
        const { message: v, version: R } = u;
        l.add(`As of v${R}, ${String(c)} is deprecated. ${v ?? ""}`);
      }
      const h = e[c];
      if (h == null || h === !1)
        return;
      const g = i[c];
      if (!g)
        return;
      const { dependencies: p, validate: f, supportedRowModels: m, expectedType: C } = g;
      if (C) {
        const v = typeof h;
        if (v !== C) {
          l.add(
            `${String(c)} should be of type '${C}' but received '${v}' (${h}).`
          );
          return;
        }
      }
      if (m) {
        const v = this.gridOptions.rowModelType ?? "clientSide";
        if (!m.includes(v)) {
          l.add(
            `${String(c)} is not supported with the '${v}' row model. It is only valid with: ${m.join(", ")}.`
          );
          return;
        }
      }
      if (p) {
        const v = this.checkForRequiredDependencies(c, p, e);
        if (v) {
          l.add(v);
          return;
        }
      }
      if (f) {
        const v = f(e, this.gridOptions, this.beans);
        if (v) {
          l.add(v);
          return;
        }
      }
    }), l.size > 0 && l.forEach((c) => {
      so(c);
    });
  }
  checkForRequiredDependencies(e, t, i) {
    const o = Object.entries(t).filter(([n, r]) => {
      const a = i[n];
      return !r.required.includes(a);
    });
    return o.length === 0 ? null : o.map(
      ([n, r]) => `'${String(e)}' requires '${n}' to be one of [${r.required.map((a) => a === null ? "null" : a === void 0 ? "undefined" : a).join(", ")}]. ${r.reason ?? ""}`
    ).join(`
           `);
  }
  checkProperties(e, t, i, s, o) {
    const n = ["__ob__", "__v_skip", "__metadata__"], r = AE(
      Object.getOwnPropertyNames(e),
      [...n, ...t, ...i],
      i
    ), a = Object.keys(r);
    for (const l of a) {
      const d = r[l];
      let c = `invalid ${s} property '${l}' did you mean any of these: ${d.slice(0, 8).join(", ")}.`;
      i.includes("context") && (c += `
If you are trying to annotate ${s} with application data, use the '${s}.context' property instead.`), so(c);
    }
    if (a.length > 0 && o) {
      const l = this.beans.frameworkOverrides.getDocLink(o);
      so(`to see all the valid ${s} properties please check: ${l}`);
    }
  }
};
function AE(e, t, i) {
  const s = {}, o = e.filter(
    (n) => !t.some((r) => r === n)
  );
  return o.length > 0 && o.forEach(
    (n) => s[n] = Wa({ inputValue: n, allSuggestions: i }).values
  ), s;
}
var IE = /* @__PURE__ */ new Set([
  "firstChildChanged",
  "lastChildChanged",
  "childIndexChanged"
]), kE = {
  moduleName: "Validation",
  version: B,
  beans: [ME]
};
function Np(e) {
  e.sibling && (e.sibling.childrenAfterFilter = e.childrenAfterFilter);
}
var LE = class extends E {
  constructor() {
    super(...arguments), this.beanName = "filterStage", this.refreshProps = /* @__PURE__ */ new Set(["excludeChildrenWhenTreeDataFiltering"]), this.step = "filter";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  execute(e) {
    const { changedPath: t } = e;
    this.filter(t);
  }
  filter(e) {
    var i;
    const t = !!((i = this.filterManager) != null && i.isChildFilterPresent());
    this.filterNodes(t, e);
  }
  filterNodes(e, t) {
    const i = (s, o) => {
      s.hasChildren() && e && !o ? s.childrenAfterFilter = s.childrenAfterGroup.filter((n) => {
        const r = n.childrenAfterFilter && n.childrenAfterFilter.length > 0, a = n.data && this.filterManager.doesRowPassFilter({ rowNode: n });
        return r || a;
      }) : s.childrenAfterFilter = s.childrenAfterGroup, Np(s);
    };
    if (this.doingTreeDataFiltering()) {
      const s = (n, r) => {
        if (n.childrenAfterGroup)
          for (let a = 0; a < n.childrenAfterGroup.length; a++) {
            const l = n.childrenAfterGroup[a], d = r || this.filterManager.doesRowPassFilter({ rowNode: l });
            l.childrenAfterGroup ? s(n.childrenAfterGroup[a], d) : i(l, d);
          }
        i(n, r);
      }, o = (n) => s(n, !1);
      t.executeFromRootNode(o);
    } else {
      const s = (o) => i(o, !1);
      t.forEachChangedNodeDepthFirst(s, !0);
    }
  }
  doingTreeDataFiltering() {
    return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
  }
}, OE = class extends Jl {
  constructor() {
    super(...arguments), this.iconCreated = !1;
  }
  wireComp(e, t, i, s, o) {
    this.comp = e;
    const n = No(this, this.beans.context, o);
    this.eButtonShowMainFilter = i, this.eFloatingFilterBody = s, this.setGui(t, n), this.setupActive(), this.refreshHeaderStyles(), this.setupWidth(n), this.setupLeft(n), this.setupHover(n), this.setupFocus(n), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(n), this.setupUi(), n.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) }), this.setupFilterChangedListener(n);
    const r = () => this.onColDefChanged(n);
    n.addManagedListeners(this.column, { colDefChanged: r }), n.addManagedEventListeners({
      filterSwitched: ({ column: a }) => {
        a === this.column && r();
      }
    }), n.addDestroyFunc(() => {
      this.eButtonShowMainFilter = null, this.eFloatingFilterBody = null, this.userCompDetails = null, this.clearComponent();
    });
  }
  // empty abstract method
  resizeHeader() {
  }
  moveHeader() {
  }
  getHeaderClassParams() {
    const { column: e, beans: t } = this, i = e.colDef;
    return W(t.gos, {
      colDef: i,
      column: e,
      floatingFilter: !0
    });
  }
  setupActive() {
    const e = this.column.getColDef(), t = !!e.filter, i = !!e.floatingFilter;
    this.active = t && i;
  }
  setupUi() {
    if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated)
      return;
    const e = Ze("filter", this.beans, this.column);
    e && (this.iconCreated = !0, this.eButtonShowMainFilter.appendChild(e));
  }
  setupFocus(e) {
    e.createManagedBean(
      new Ts(this.eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    );
  }
  setupAria() {
    const e = this.getLocaleTextFunc();
    vs(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    var r;
    const { beans: t } = this;
    if (he(t) === this.eGui)
      return;
    const o = zi(t, this.eGui, null, e.shiftKey);
    if (o) {
      (r = t.headerNavigation) == null || r.scrollToColumn(this.column), e.preventDefault(), o.focus();
      return;
    }
    const n = this.findNextColumnWithFloatingFilter(e.shiftKey);
    n && t.focusSvc.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.rowCtrl.rowIndex,
        column: n
      },
      event: e
    }) && e.preventDefault();
  }
  findNextColumnWithFloatingFilter(e) {
    const t = this.beans.visibleCols;
    let i = this.column;
    do
      if (i = e ? t.getColBefore(i) : t.getColAfter(i), !i)
        break;
    while (!i.getColDef().filter || !i.getColDef().floatingFilter);
    return i;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case P.UP:
      case P.DOWN:
      case P.LEFT:
      case P.RIGHT:
        if (t)
          return;
        Bi(e);
      case P.ENTER:
        t && _i(this.eGui) && e.preventDefault();
        break;
      case P.ESCAPE:
        t || this.eGui.focus();
    }
  }
  onFocusIn(e) {
    if (this.eGui.contains(e.relatedTarget))
      return;
    const i = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"), s = !!e.relatedTarget && Ei(e.relatedTarget, "ag-floating-filter");
    if (i && s && e.target === this.eGui) {
      const o = this.lastFocusEvent, n = !!(o && o.key === P.TAB);
      if (o && n) {
        const r = o.shiftKey;
        _i(this.eGui, r);
      }
    }
    this.focusThis();
  }
  setupHover(e) {
    var t;
    (t = this.beans.colHover) == null || t.addHeaderFilterColumnHoverListener(e, this.comp, this.column, this.eGui);
  }
  setupLeft(e) {
    const t = new Zl(this.column, this.eGui, this.beans);
    e.createManagedBean(t);
  }
  setupFilterButton() {
    var e;
    this.suppressFilterButton = !((e = this.beans.menuSvc) != null && e.isFloatingFilterButtonEnabled(this.column)), this.highlightFilterButtonWhenActive = !$e(this.gos);
  }
  setupUserComp() {
    var t;
    if (!this.active)
      return;
    const e = (t = this.beans.colFilter) == null ? void 0 : t.getFloatingFilterCompDetails(
      this.column,
      () => this.showParentFilter()
    );
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setCompDetails(e);
  }
  showParentFilter() {
    var t;
    const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    (t = this.beans.menuSvc) == null || t.showFilterMenu({
      column: this.column,
      buttonElement: e,
      containerType: "floatingFilter",
      positionBy: "button"
    });
  }
  setupSyncWithFilter(e) {
    if (!this.active)
      return;
    const {
      beans: { colFilter: t },
      column: i,
      gos: s
    } = this, o = (n) => {
      if ((n == null ? void 0 : n.source) === "filterDestroyed" && (!this.isAlive() || !(t != null && t.isAlive())))
        return;
      const r = this.comp.getFloatingFilterComp();
      r && r.then((a) => {
        if (a) {
          if (s.get("enableFilterHandlers")) {
            const c = n;
            let u = "filter";
            c != null && c.afterFloatingFilter ? u = "ui" : c != null && c.afterDataChange ? u = "dataChanged" : (n == null ? void 0 : n.source) === "api" && (u = "api"), this.updateFloatingFilterParams(this.userCompDetails, u);
            return;
          }
          const l = t == null ? void 0 : t.getCurrentFloatingFilterParentModel(i), d = n ? {
            // event can have additional params like `afterDataChange` which need to be passed through
            ...n,
            columns: n.columns ?? [],
            source: n.source === "api" ? "api" : "columnFilter"
          } : null;
          a.onParentModelChanged(l, d);
        }
      });
    };
    [this.destroySyncListener] = e.addManagedListeners(i, { filterChanged: o }), t != null && t.isFilterActive(i) && o(null);
  }
  setupWidth(e) {
    const t = () => {
      const i = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(i);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupFilterChangedListener(e) {
    this.active && ([this.destroyFilterChangedListener] = e.addManagedListeners(this.column, {
      filterChanged: this.updateFilterButton.bind(this)
    }), this.updateFilterButton());
  }
  updateFilterButton() {
    var e;
    if (!this.suppressFilterButton && this.comp) {
      const t = !!((e = this.beans.filterManager) != null && e.isFilterAllowed(this.column));
      this.comp.setButtonWrapperDisplayed(t), this.highlightFilterButtonWhenActive && t && this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
    }
  }
  onColDefChanged(e) {
    const t = this.active;
    this.setupActive();
    const i = !t && this.active;
    t && !this.active && (this.destroySyncListener(), this.destroyFilterChangedListener());
    const s = this.beans.colFilter, o = this.active ? s == null ? void 0 : s.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null, n = this.comp.getFloatingFilterComp();
    !n || !o ? this.updateCompDetails(e, o, i) : n.then((r) => {
      !r || s != null && s.areFilterCompsDifferent(this.userCompDetails ?? null, o) ? this.updateCompDetails(e, o, i) : this.updateFloatingFilterParams(o, "colDef");
    });
  }
  updateCompDetails(e, t, i) {
    this.isAlive() && (this.setCompDetails(t), this.setupFilterButton(), this.setupUi(), i && (this.setupSyncWithFilter(e), this.setupFilterChangedListener(e)));
  }
  updateFloatingFilterParams(e, t) {
    var s;
    if (!e)
      return;
    let i = e.params;
    (s = this.comp.getFloatingFilterComp()) == null || s.then((o) => {
      var n;
      typeof (o == null ? void 0 : o.refresh) == "function" && (this.gos.get("enableFilterHandlers") && (i = {
        ...i,
        model: Re(((n = this.beans.colFilter) == null ? void 0 : n.model) ?? {}, this.column.getColId()),
        source: t
      }), o.refresh(i));
    });
  }
  addResizeAndMoveKeyboardListeners() {
  }
  destroy() {
    super.destroy(), this.destroySyncListener = null, this.destroyFilterChangedListener = null;
  }
};
function _E(e, t) {
  var s;
  const i = e.colModel.getCol(t);
  if (!i) {
    Z(12, { colKey: t });
    return;
  }
  (s = e.menuSvc) == null || s.showColumnMenu({
    column: i,
    positionBy: "auto"
  });
}
function HE(e) {
  var t;
  (t = e.menuSvc) == null || t.hidePopupMenu();
}
var BE = {
  moduleName: "SharedMenu",
  version: B,
  beans: [Wy],
  apiFunctions: {
    showColumnMenu: _E,
    hidePopupMenu: HE
  }
}, GE = class extends gb {
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridCtrl = e.gridCtrl;
    }), this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
  }
  getDefaultPopupParent() {
    return this.gridCtrl.getGui();
  }
  positionPopupForMenu(e) {
    const { eventSource: t, ePopup: i, event: s } = e, o = t.getBoundingClientRect(), n = this.getParentRect();
    this.setAlignedTo(t, i);
    let r = !1;
    const a = () => {
      const l = this.keepXYWithinBounds(
        i,
        o.top - n.top,
        0
        /* Vertical */
      ), d = i.clientWidth > 0 ? i.clientWidth : 200;
      r || (i.style.minWidth = `${d}px`, r = !0);
      const u = n.right - n.left - d;
      let h;
      return this.gos.get("enableRtl") ? (h = p(), h < 0 && (h = g(), this.setAlignedStyles(i, "left")), h > u && (h = 0, this.setAlignedStyles(i, "right"))) : (h = g(), h > u && (h = p(), this.setAlignedStyles(i, "right")), h < 0 && (h = 0, this.setAlignedStyles(i, "left"))), { x: h, y: l };
      function g() {
        return o.right - n.left - 2;
      }
      function p() {
        return o.left - n.left - d;
      }
    };
    this.positionPopup({
      ePopup: i,
      keepWithinBounds: !0,
      updatePosition: a,
      postProcessCallback: () => this.callPostProcessPopup(
        e,
        "subMenu",
        i,
        t,
        s instanceof MouseEvent ? s : void 0
      )
    });
  }
  callPostProcessPopup(e, t, i, s, o) {
    const n = this.gos.getCallback("postProcessPopup");
    if (n) {
      const { column: r, rowNode: a } = e;
      n({
        column: r,
        rowNode: a,
        ePopup: i,
        type: t,
        eventSource: s,
        mouseEvent: o
      });
    }
  }
  getActivePopups() {
    return this.popupList.map((e) => e.element);
  }
  handleThemeChange(e) {
    if (e.themeChanged) {
      const t = this.beans.environment;
      for (const i of this.popupList)
        t.applyThemeClasses(i.wrapper);
    }
  }
  hasAnchoredPopup() {
    return this.popupList.some((e) => e.isAnchored);
  }
  isStopPropagation(e) {
    return Wt(e);
  }
}, Pr = {
  moduleName: "Popup",
  version: B,
  beans: [GE]
}, VE = (
  /*css*/
  ".ag-set-filter{--ag-indentation-level:0}.ag-set-filter-item{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-set-filter-item{padding-left:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}:where(.ag-rtl) .ag-set-filter-item{padding-right:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}.ag-set-filter-item-checkbox{display:flex;height:100%;width:100%}.ag-set-filter-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr) .ag-set-filter-group-icons{margin-right:var(--ag-widget-container-horizontal-padding)}:where(.ag-rtl) .ag-set-filter-group-icons{margin-left:var(--ag-widget-container-horizontal-padding)}.ag-filter-body-wrapper{display:flex;flex-direction:column}:where(.ag-menu:not(.ag-tabs) .ag-filter) .ag-filter-body-wrapper,:where(.ag-menu:not(.ag-tabs) .ag-filter)>:not(.ag-filter-wrapper){min-width:180px}.ag-filter-filter{flex:1 1 0px}.ag-filter-condition{display:flex;justify-content:center}.ag-floating-filter-body{display:flex;flex:1 1 auto;height:100%;position:relative}.ag-floating-filter-full-body{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;width:100%}:where(.ag-floating-filter-full-body)>div{flex:1 1 auto}.ag-floating-filter-input{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}:where(.ag-input-field-input[type=date]),:where(.ag-input-field-input[type=datetime-local]){width:1px}}.ag-floating-filter-button{display:flex;flex:none}.ag-date-floating-filter-wrapper{display:flex}.ag-set-floating-filter-input :where(input)[disabled]{pointer-events:none}.ag-floating-filter-button-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;height:var(--ag-icon-size);width:var(--ag-icon-size)}.ag-filter-loading{align-items:unset;background-color:var(--ag-chrome-background-color);height:100%;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;width:100%;z-index:1;:where(.ag-menu) &{background-color:var(--ag-menu-background-color)}}.ag-filter-separator{border-top:solid var(--ag-border-width) var(--menu-separator-color)}:where(.ag-filter-select) .ag-picker-field-wrapper{width:0}.ag-filter-condition-operator{height:17px}:where(.ag-ltr) .ag-filter-condition-operator-or{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-condition-operator-or{margin-right:calc(var(--ag-spacing)*2)}.ag-set-filter-select-all{padding-top:var(--ag-widget-container-vertical-padding)}.ag-filter-no-matches,.ag-set-filter-list{height:calc(var(--ag-list-item-height)*6)}.ag-filter-no-matches{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-set-filter-tree-list{height:calc(var(--ag-list-item-height)*10)}.ag-set-filter-filter{margin-left:var(--ag-widget-container-horizontal-padding);margin-right:var(--ag-widget-container-horizontal-padding);margin-top:var(--ag-widget-container-vertical-padding)}.ag-filter-to{margin-top:var(--ag-widget-vertical-spacing)}.ag-mini-filter{margin:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}:where(.ag-ltr) .ag-set-filter-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-rtl) .ag-set-filter-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-filter-menu) .ag-set-filter-list{min-width:200px}.ag-filter-virtual-list-item:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-filter-apply-panel{display:flex;justify-content:flex-end;overflow:hidden;padding:var(--ag-widget-vertical-spacing) var(--ag-widget-container-horizontal-padding) var(--ag-widget-container-vertical-padding)}.ag-filter-apply-panel-button{line-height:1.5}:where(.ag-ltr) .ag-filter-apply-panel-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-apply-panel-button{margin-right:calc(var(--ag-spacing)*2)}.ag-simple-filter-body-wrapper{display:flex;flex-direction:column;min-height:calc(var(--ag-list-item-height) + var(--ag-widget-container-vertical-padding) + var(--ag-widget-vertical-spacing));overflow-y:auto;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);padding-bottom:calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));&>*{margin-bottom:var(--ag-widget-vertical-spacing)}:where(.ag-resizer-wrapper){margin:0}}.ag-multi-filter-menu-item{margin:var(--ag-spacing) 0}.ag-multi-filter-group-title-bar{background-color:transparent;color:var(--ag-header-text-color);font-weight:500;padding:calc(var(--ag-spacing)*1.5) var(--ag-spacing)}.ag-group-filter-field-select-wrapper{display:flex;flex-direction:column;gap:var(--ag-widget-vertical-spacing);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}"
);
function NE(e) {
  const t = e.filterManager;
  return !!(t != null && t.isColumnFilterPresent()) || !!(t != null && t.isAggregateFilterPresent());
}
function WE(e, t) {
  var i;
  return ((i = e.filterManager) == null ? void 0 : i.getColumnFilterInstance(t)) ?? Promise.resolve(void 0);
}
function zE(e, t) {
  var s;
  const i = e.colModel.getColDefCol(t);
  if (i)
    return (s = e.colFilter) == null ? void 0 : s.destroyFilter(i, "api");
}
function UE(e, t) {
  e.frameworkOverrides.wrapIncoming(() => {
    var i;
    return (i = e.filterManager) == null ? void 0 : i.setFilterModel(t);
  });
}
function $E(e) {
  var t;
  return ((t = e.filterManager) == null ? void 0 : t.getFilterModel()) ?? {};
}
function KE(e, t, i) {
  const { gos: s, colModel: o, colFilter: n } = e;
  i && !s.get("enableFilterHandlers") && (I(288), i = !1);
  const r = o.getColDefCol(t);
  return r ? (n == null ? void 0 : n.getModelForColumn(r, i)) ?? null : null;
}
function jE(e, t, i) {
  var s;
  return ((s = e.filterManager) == null ? void 0 : s.setColumnFilterModel(t, i)) ?? Promise.resolve();
}
function qE(e, t) {
  var s;
  const i = e.colModel.getCol(t);
  if (!i) {
    Z(12, { colKey: t });
    return;
  }
  (s = e.menuSvc) == null || s.showFilterMenu({
    column: i,
    containerType: "columnFilter",
    positionBy: "auto"
  });
}
function YE(e) {
  var t;
  (t = e.menuSvc) == null || t.hideFilterMenu();
}
function QE(e, t) {
  var s;
  const i = e.colModel.getCol(t);
  if (!i) {
    Z(12, { colKey: t });
    return;
  }
  return (s = e.colFilter) == null ? void 0 : s.getHandler(i, !0);
}
function XE(e, t) {
  const { colModel: i, colFilter: s, gos: o } = e;
  if (!o.get("enableFilterHandlers")) {
    I(287);
    return;
  }
  const { colId: n, action: r } = t;
  if (n) {
    const a = i.getColById(n);
    a && (s == null || s.updateModel(a, r));
  } else
    s == null || s.updateAllModels(r);
}
var ZE = {
  filterHandler: () => ({
    doesFilterPass: () => !0
  })
}, JE = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colFilter", this.allColumnFilters = /* @__PURE__ */ new Map(), this.allColumnListeners = /* @__PURE__ */ new Map(), this.activeAggregateFilters = [], this.activeColumnFilters = [], this.processingFilterChange = !1, this.modelUpdates = [], this.columnModelUpdates = [], this.state = /* @__PURE__ */ new Map(), this.handlerMap = {
      ...Bg
    }, this.isGlobalButtons = !1, this.activeFilterComps = /* @__PURE__ */ new Set();
  }
  postConstruct() {
    var i, s;
    this.addManagedEventListeners({
      gridColumnsChanged: this.onColumnsChanged.bind(this),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    });
    const e = this.gos, t = {
      ...((s = (i = e.get("initialState")) == null ? void 0 : i.filter) == null ? void 0 : s.filterModel) ?? {}
    };
    this.initialModel = t, this.model = {
      ...t
    }, e.get("enableFilterHandlers") || delete this.handlerMap.agMultiColumnFilter;
  }
  refreshModel() {
    this.onNewRowsLoaded("rowDataUpdated");
  }
  setModel(e, t = "api", i) {
    const { colModel: s, dataTypeSvc: o, filterManager: n } = this.beans;
    if (o != null && o.isPendingInference) {
      this.modelUpdates.push({ model: e, source: t });
      return;
    }
    const r = [], a = this.getModel(!0);
    if (e) {
      const l = new Set(Object.keys(e));
      this.allColumnFilters.forEach((d, c) => {
        const u = e[c];
        r.push(this.setModelOnFilterWrapper(d, u)), l.delete(c);
      }), l.forEach((d) => {
        const c = s.getColDefCol(d) || s.getCol(d);
        if (!c) {
          I(62, { colId: d });
          return;
        }
        if (!c.isFilterAllowed()) {
          I(63, { colId: d });
          return;
        }
        const u = this.getOrCreateFilterWrapper(c, !0);
        if (!u) {
          I(64, { colId: d });
          return;
        }
        r.push(this.setModelOnFilterWrapper(u, e[d], !0));
      });
    } else
      this.model = {}, this.allColumnFilters.forEach((l) => {
        r.push(this.setModelOnFilterWrapper(l, null));
      });
    fe.all(r).then(() => {
      const l = this.getModel(!0), d = [];
      this.allColumnFilters.forEach((c, u) => {
        const h = a ? a[u] : null, g = l ? l[u] : null;
        vo(h, g) || d.push(c.column);
      }), d.length > 0 ? n == null || n.onFilterChanged({ columns: d, source: t }) : i && this.updateActive("filterChanged");
    });
  }
  getModel(e) {
    var n;
    const t = {}, {
      allColumnFilters: i,
      initialModel: s,
      beans: { colModel: o }
    } = this;
    if (i.forEach((r, a) => {
      const l = this.getModelFromFilterWrapper(r);
      H(l) && (t[a] = l);
    }), !e)
      for (const r of Object.keys(s)) {
        const a = s[r];
        H(a) && !i.has(r) && ((n = o.getCol(r)) != null && n.isFilterAllowed()) && (t[r] = a);
      }
    return t;
  }
  setState(e, t, i = "api") {
    if (this.state.clear(), t)
      for (const s of Object.keys(t)) {
        const o = t[s];
        this.state.set(s, {
          model: Re(this.model, s),
          state: o
        });
      }
    this.setModel(e, i, !0);
  }
  getState() {
    const e = this.state;
    if (!e.size)
      return;
    const t = {};
    let i = !1;
    return e.forEach((s, o) => {
      const n = s.state;
      n != null && (i = !0, t[o] = n);
    }), i ? t : void 0;
  }
  getModelFromFilterWrapper(e) {
    const i = e.column.getColId();
    if (e.isHandler)
      return Re(this.model, i);
    const s = e.filter;
    return s ? typeof s.getModel != "function" ? (I(66), null) : s.getModel() : Re(this.initialModel, i);
  }
  isFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  disableFilters() {
    this.initialModel = {};
    const { allColumnFilters: e } = this;
    return e.size ? (e.forEach(
      (t) => this.disposeFilterWrapper(t, "advancedFilterEnabled")
    ), !0) : !1;
  }
  updateActiveFilters() {
    const e = (d) => d ? d.isFilterActive ? d.isFilterActive() : (I(67), !1) : !1, { colModel: t, gos: i } = this.beans, s = !!Oa(i), o = (d) => {
      if (!d.isPrimary())
        return !0;
      const u = !t.isPivotActive();
      return !d.isValueActive() || !u ? !1 : t.isPivotMode() ? !0 : s;
    }, n = [], r = [], a = (d, c, u) => {
      c && (o(d) ? n.push(u) : r.push(u));
    }, l = [];
    return this.allColumnFilters.forEach((d) => {
      const c = d.column, u = c.getColId();
      if (d.isHandler)
        l.push(
          fe.resolve().then(() => {
            a(c, this.isHandlerActive(c), {
              colId: u,
              isHandler: !0,
              handler: d.handler,
              handlerParams: d.handlerParams
            });
          })
        );
      else {
        const h = qt(d);
        h && l.push(
          h.then((g) => {
            a(c, e(g), {
              colId: u,
              isHandler: !1,
              comp: g
            });
          })
        );
      }
    }), fe.all(l).then(() => {
      this.activeAggregateFilters = n, this.activeColumnFilters = r;
    });
  }
  updateFilterFlagInColumns(e, t) {
    var s;
    const i = [];
    return this.allColumnFilters.forEach((o) => {
      const n = o.column;
      if (o.isHandler)
        i.push(
          fe.resolve().then(() => {
            this.setColFilterActive(
              n,
              this.isHandlerActive(n),
              e,
              t
            );
          })
        );
      else {
        const r = qt(o);
        r && i.push(
          r.then((a) => {
            this.setColFilterActive(
              n,
              a.isFilterActive(),
              e,
              t
            );
          })
        );
      }
    }), (s = this.beans.groupFilter) == null || s.updateFilterFlags(e, t), fe.all(i);
  }
  doFiltersPass(e, t, i) {
    const { data: s, aggData: o } = e, n = i ? this.activeAggregateFilters : this.activeColumnFilters, r = i ? o : s, a = this.model;
    for (let l = 0; l < n.length; l++) {
      const d = n[l], { colId: c, isHandler: u } = d;
      if (c !== t)
        if (u) {
          const { handler: h, handlerParams: g } = d;
          if (!h.doesFilterPass({
            node: e,
            data: r,
            model: Re(a, c),
            handlerParams: g
          }))
            return !1;
        } else {
          const h = d.comp;
          if (typeof h.doesFilterPass != "function") {
            Z(91);
            continue;
          }
          if (!h.doesFilterPass({ node: e, data: r }))
            return !1;
        }
    }
    return !0;
  }
  getHandlerParams(e) {
    const t = this.allColumnFilters.get(e.getColId());
    return t != null && t.isHandler ? t.handlerParams : void 0;
  }
  // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
  // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
  // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
  // which results in React State getting applied in the main application, triggering a useEffect() to
  // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
  // getting it's useEffect() triggered in this way.
  callOnFilterChangedOutsideRenderCycle(e) {
    const { rowRenderer: t, filterManager: i } = this.beans, s = () => {
      this.isAlive() && (i == null || i.onFilterChanged(e));
    };
    t.isRefreshInProgress() ? setTimeout(s, 0) : s();
  }
  updateBeforeFilterChanged(e = {}) {
    const { column: t, additionalEventAttributes: i } = e, s = t == null ? void 0 : t.getColId();
    return this.updateActiveFilters().then(
      () => this.updateFilterFlagInColumns("filterChanged", i).then(() => {
        this.allColumnFilters.forEach((o) => {
          var a, l, d;
          const { column: n, isHandler: r } = o;
          s !== n.getColId() && (r && ((l = (a = o.handler).onAnyFilterChanged) == null || l.call(a)), (d = qt(o, r)) == null || d.then((c) => {
            typeof (c == null ? void 0 : c.onAnyFilterChanged) == "function" && c.onAnyFilterChanged();
          }));
        }), this.processingFilterChange = !0;
      })
    );
  }
  updateAfterFilterChanged() {
    this.processingFilterChange = !1;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !(this.gos.get("allowShowChangeAfterFilter") ?? !1) && this.processingFilterChange;
  }
  onNewRowsLoaded(e) {
    const t = [];
    this.allColumnFilters.forEach((i) => {
      var n, r;
      const s = i.isHandler;
      s && ((r = (n = i.handler).onNewRowsLoaded) == null || r.call(n));
      const o = qt(i, s);
      o && t.push(
        o.then((a) => {
          var l;
          (l = a.onNewRowsLoaded) == null || l.call(a);
        })
      );
    }), fe.all(t).then(() => this.updateActive(e, { afterDataChange: !0 }));
  }
  updateActive(e, t) {
    this.updateFilterFlagInColumns(e, t).then(() => this.updateActiveFilters());
  }
  createGetValue(e, t) {
    const { filterValueSvc: i, colModel: s } = this.beans;
    return (o, n) => {
      const r = n ? s.getCol(n) : e;
      return r ? i.getValue(r, o, t) : void 0;
    };
  }
  isFilterActive(e) {
    const t = this.cachedFilter(e);
    if (t != null && t.isHandler)
      return this.isHandlerActive(e);
    const i = t == null ? void 0 : t.filter;
    return i ? i.isFilterActive() : Re(this.initialModel, e.getColId()) != null;
  }
  isHandlerActive(e) {
    const t = H(Re(this.model, e.getColId()));
    if (t)
      return t;
    const i = this.beans.groupFilter;
    return i != null && i.isGroupFilter(e) ? i.isFilterActive(e) : !1;
  }
  getOrCreateFilterUi(e) {
    const t = this.getOrCreateFilterWrapper(e, !0);
    return t ? qt(t) : null;
  }
  getFilterUiForDisplay(e) {
    const t = this.getOrCreateFilterWrapper(e, !0);
    if (!t)
      return null;
    const i = qt(t);
    return i ? i.then((s) => ({
      comp: s,
      params: t.filterUi.filterParams,
      isHandler: t.isHandler
    })) : null;
  }
  getHandler(e, t) {
    const i = this.getOrCreateFilterWrapper(e, t);
    return i != null && i.isHandler ? i.handler : void 0;
  }
  getOrCreateFilterWrapper(e, t) {
    if (!e.isFilterAllowed())
      return;
    let i = this.cachedFilter(e);
    return !i && t && (i = this.createFilterWrapper(e), this.setColumnFilterWrapper(e, i)), i;
  }
  cachedFilter(e) {
    return this.allColumnFilters.get(e.getColId());
  }
  getDefaultFilter(e, t = !1) {
    return this.getDefaultFilterFromDataType(() => {
      var i;
      return (i = this.beans.dataTypeSvc) == null ? void 0 : i.getBaseDataType(e);
    }, t);
  }
  getDefaultFilterFromDataType(e, t = !1) {
    return jC(this.gos) ? t ? "agSetColumnFloatingFilter" : "agSetColumnFilter" : Lb(e(), t);
  }
  getDefaultFloatingFilter(e) {
    return this.getDefaultFilter(e, !0);
  }
  createFilterComp(e, t, i, s, o, n) {
    const r = () => {
      const d = this.createFilterCompParams(e, o, n), c = s(d, o);
      return Xv(this.beans.userCompFactory, t, c, i);
    }, a = r();
    return a ? {
      compDetails: a,
      createFilterUi: (d) => (d ? r() : a).newAgStackInstance()
    } : null;
  }
  createFilterInstance(e, t, i, s) {
    var u, h;
    const o = this.beans.selectableFilter;
    o != null && o.isSelectable(t) && (t = o.getFilterDef(e, t));
    const { handler: n, handlerParams: r, handlerGenerator: a } = this.createHandler(e, t, i) ?? {}, l = this.createFilterComp(
      e,
      t,
      i,
      s,
      !!n,
      "init"
    );
    if (!l)
      return {
        compDetails: null,
        createFilterUi: null,
        handler: n,
        handlerGenerator: a,
        handlerParams: r
      };
    const { compDetails: d, createFilterUi: c } = l;
    return this.isGlobalButtons && ((h = (u = d.params) == null ? void 0 : u.buttons) != null && h.length || I(281, { colId: e.getColId() })), {
      compDetails: d,
      handler: n,
      handlerGenerator: a,
      handlerParams: r,
      createFilterUi: c
    };
  }
  createBaseFilterParams(e, t) {
    const { filterManager: i, rowModel: s } = this.beans;
    return W(this.gos, {
      column: e,
      colDef: e.getColDef(),
      getValue: this.createGetValue(e),
      doesRowPassOtherFilter: t ? () => !0 : (o) => (i == null ? void 0 : i.doesRowPassOtherFilters(e.getColId(), o)) ?? !0,
      // to avoid breaking changes to `filterParams` defined as functions
      // we need to provide the below options even though they are not valid for handlers
      rowModel: s
    });
  }
  createFilterCompParams(e, t, i, s) {
    const o = this.filterChangedCallbackFactory(e), n = this.createBaseFilterParams(e, s);
    if (n.filterChangedCallback = o, n.filterModifiedCallback = s ? () => {
    } : (r) => this.filterModified(e, r), t) {
      const r = n, a = e.getColId(), l = Re(this.model, a);
      r.model = l, r.state = this.state.get(a) ?? {
        model: l
      }, r.onModelChange = (d, c) => {
        this.updateStoredModel(a, d), this.refreshHandlerAndUi(e, d, "ui").then(() => {
          o({ ...c, source: "columnFilter" });
        });
      }, r.onStateChange = (d) => {
        this.updateState(e, d), this.updateOrRefreshFilterUi(e);
      }, r.onAction = (d, c, u) => {
        this.updateModel(e, d, c), this.dispatchLocalEvent({
          type: "filterAction",
          column: e,
          action: d,
          event: u
        });
      }, r.getHandler = () => this.getHandler(e, !0), r.onUiChange = (d) => this.filterUiChanged(e, d), r.source = i;
    }
    return n;
  }
  createFilterUiForHandler(e, t) {
    return t ? {
      created: !1,
      create: t,
      filterParams: e.params,
      compDetails: e
    } : null;
  }
  createFilterUiLegacy(e, t, i) {
    const s = t(), o = {
      created: !0,
      create: t,
      filterParams: e.params,
      compDetails: e,
      promise: s
    };
    return s.then(i), o;
  }
  createFilterWrapper(e) {
    var a;
    const { compDetails: t, handler: i, handlerGenerator: s, handlerParams: o, createFilterUi: n } = this.createFilterInstance(
      e,
      e.getColDef(),
      this.getDefaultFilter(e),
      (l) => l
    ), r = e.getColId();
    if (i)
      return delete this.initialModel[r], (a = i.init) == null || a.call(i, {
        ...o,
        source: "init",
        model: Re(this.model, r)
      }), {
        column: e,
        isHandler: !0,
        handler: i,
        handlerGenerator: s,
        handlerParams: o,
        filterUi: this.createFilterUiForHandler(t, n)
      };
    if (n) {
      const l = {
        column: e,
        filterUi: null,
        isHandler: !1
      };
      return l.filterUi = this.createFilterUiLegacy(t, n, (d) => {
        l.filter = d ?? void 0;
      }), l;
    }
    return {
      column: e,
      filterUi: null,
      isHandler: !1
    };
  }
  createHandlerFunc(e, t, i) {
    var g;
    const { gos: s, frameworkOverrides: o, registry: n } = this.beans;
    let r;
    const a = (p) => {
      const f = p.filter;
      if (mg(f)) {
        const m = f.handler;
        return m || (r = f.doesFilterPass, r ? () => ({
          doesFilterPass: r
        }) : void 0);
      }
      return typeof f == "string" ? f : void 0;
    }, l = s.get("enableFilterHandlers"), d = l ? a(t) : void 0, c = (p) => () => this.createBean(n.createDynamicBean(p, !0));
    let u, h;
    if (typeof d == "string") {
      const p = (g = s.get("filterHandlers")) == null ? void 0 : g[d];
      p != null ? u = p : Sb.has(d) && (u = c(d), h = d);
    } else
      u = d;
    if (!u) {
      let p;
      const { compName: f, jsComp: m, fwComp: C } = wg(o, t);
      f ? p = f : m == null && C == null && t.filter === !0 && (p = i), h = this.handlerMap[p], h && (u = c(h));
    }
    return u ? { filterHandler: u, handlerNameOrCallback: r ?? h } : l ? (xe(s) && I(277, { colId: e.getColId() }), ZE) : void 0;
  }
  createHandler(e, t, i) {
    const s = this.createHandlerFunc(e, t, i);
    if (!s)
      return;
    const o = Wr(
      this.beans.userCompFactory,
      t,
      this.createFilterCompParams(e, !0, "init")
    ), { handlerNameOrCallback: n, filterHandler: r } = s, { handler: a, handlerParams: l } = this.createHandlerFromFunc(e, r, o);
    return {
      handler: a,
      handlerParams: l,
      handlerGenerator: n ?? r
    };
  }
  createHandlerFromFunc(e, t, i) {
    const s = e.getColDef(), o = t(W(this.gos, { column: e, colDef: s })), n = this.createHandlerParams(e, i);
    return { handler: o, handlerParams: n };
  }
  createHandlerParams(e, t) {
    const i = e.getColDef(), s = e.getColId(), o = this.filterChangedCallbackFactory(e);
    return W(this.gos, {
      colDef: i,
      column: e,
      getValue: this.createGetValue(e),
      doesRowPassOtherFilter: (n) => {
        var r;
        return ((r = this.beans.filterManager) == null ? void 0 : r.doesRowPassOtherFilters(s, n)) ?? !0;
      },
      onModelChange: (n, r) => {
        this.updateStoredModel(s, n), this.refreshHandlerAndUi(e, n, "handler").then(() => {
          o({ ...r, source: "columnFilter" });
        });
      },
      filterParams: t
    });
  }
  onColumnsChanged() {
    const e = [], { colModel: t, filterManager: i, groupFilter: s } = this.beans;
    this.allColumnFilters.forEach((n, r) => {
      let a;
      n.column.isPrimary() ? a = t.getColDefCol(r) : a = t.getCol(r), !(a && a === n.column) && (e.push(n.column), this.disposeFilterWrapper(n, "columnChanged"), this.disposeColumnListener(r));
    });
    const o = s && e.every((n) => s.isGroupFilter(n));
    e.length > 0 && !o && (i == null || i.onFilterChanged({ columns: e, source: "api" }));
  }
  isFilterAllowed(e) {
    if (!e.isFilterAllowed())
      return !1;
    const i = this.beans.groupFilter;
    return i != null && i.isGroupFilter(e) ? i.isFilterAllowed(e) : !0;
  }
  getFloatingFilterCompDetails(e, t) {
    const { userCompFactory: i, frameworkOverrides: s, selectableFilter: o } = this.beans, n = (h) => {
      const g = this.getOrCreateFilterUi(e);
      g != null && g.then((p) => {
        h(Po(p));
      });
    }, r = e.getColDef(), a = o != null && o.isSelectable(r) ? o.getFilterDef(e, r) : r, l = Gb(s, a, () => this.getDefaultFloatingFilter(e)) ?? "agReadOnlyFloatingFilter", d = this.gos.get("enableFilterHandlers"), c = Wr(
      i,
      a,
      this.createFilterCompParams(e, d, "init", !0)
    ), u = W(this.gos, {
      column: e,
      filterParams: c,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
      parentFilterInstance: n,
      showParentFilter: t
    });
    if (d) {
      const h = u, g = e.getColId(), p = this.filterChangedCallbackFactory(e);
      h.onUiChange = (f) => this.floatingFilterUiChanged(e, f), h.model = Re(this.model, g), h.onModelChange = (f, m) => {
        this.updateStoredModel(g, f), this.refreshHandlerAndUi(e, f, "floating", !0).then(() => {
          p({ ...m, source: "columnFilter" });
        });
      }, h.getHandler = () => this.getHandler(e, !0), h.source = "init";
    }
    return iw(i, r, u, l);
  }
  getCurrentFloatingFilterParentModel(e) {
    return this.getModelFromFilterWrapper(this.cachedFilter(e) ?? { column: e });
  }
  destroyFilterUi(e, t, i, s) {
    if (e.isHandler) {
      const o = t.getColId();
      delete this.initialModel[o], this.state.delete(o);
      const n = e.filterUi, r = this.createFilterUiForHandler(i, s);
      e.filterUi = r, n != null && n.created && n.promise.then((a) => {
        this.destroyBean(a), this.eventSvc.dispatchEvent({
          type: "filterDestroyed",
          source: "paramsUpdated",
          column: e.column
        });
      });
    } else
      this.destroyFilter(t, "paramsUpdated");
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    const i = e.getColId(), s = this.allColumnFilters.get(i);
    this.disposeColumnListener(i), delete this.initialModel[i], s && this.disposeFilterWrapper(s, t).then((o) => {
      var n;
      o && this.isAlive() && ((n = this.beans.filterManager) == null || n.onFilterChanged({
        columns: [e],
        source: "api"
      }));
    });
  }
  disposeColumnListener(e) {
    const t = this.allColumnListeners.get(e);
    t && (this.allColumnListeners.delete(e), t());
  }
  disposeFilterWrapper(e, t) {
    let i = !1;
    const { column: s, isHandler: o, filterUi: n } = e, r = s.getColId();
    o && (i = this.isHandlerActive(s), this.destroyBean(e.handler), delete this.model[r], this.state.delete(r));
    const a = () => {
      this.setColFilterActive(s, !1, "filterDestroyed"), this.allColumnFilters.delete(r), this.eventSvc.dispatchEvent({
        type: "filterDestroyed",
        source: t,
        column: s
      });
    };
    if (n) {
      if (n.created)
        return n.promise.then((l) => (i = o ? i : !!(l != null && l.isFilterActive()), this.destroyBean(l), a(), i));
      a();
    }
    return fe.resolve(i);
  }
  filterChangedCallbackFactory(e) {
    return (t) => {
      this.callOnFilterChangedOutsideRenderCycle({
        additionalEventAttributes: t,
        columns: [e],
        column: e,
        source: (t == null ? void 0 : t.source) ?? "columnFilter"
      });
    };
  }
  filterParamsChanged(e, t = "api") {
    var m, C, v, R, b, w;
    const i = this.allColumnFilters.get(e);
    if (!i)
      return;
    const s = this.beans, o = i.column, n = o.getColDef(), r = o.isFilterAllowed(), a = this.getDefaultFilter(o), l = s.selectableFilter, d = l != null && l.isSelectable(n) ? l.getFilterDef(o, n) : n, c = r ? this.createHandlerFunc(o, d, this.getDefaultFilter(o)) : void 0, u = !!c, h = i.isHandler;
    if (h != u) {
      this.destroyFilter(o, "paramsUpdated");
      return;
    }
    const { compDetails: g, createFilterUi: p } = (r ? this.createFilterComp(o, d, a, (x) => x, u, "colDef") : null) ?? { compDetails: null, createFilterUi: null }, f = (g == null ? void 0 : g.params) ?? Wr(
      s.userCompFactory,
      d,
      this.createFilterCompParams(o, u, "colDef")
    );
    if (h) {
      const x = (c == null ? void 0 : c.handlerNameOrCallback) ?? (c == null ? void 0 : c.filterHandler), F = Re(this.model, e);
      if (i.handlerGenerator != x) {
        const D = i.handler, { handler: T, handlerParams: k } = this.createHandlerFromFunc(
          o,
          c.filterHandler,
          f
        );
        i.handler = T, i.handlerParams = k, i.handlerGenerator = x, delete this.model[e], (m = T.init) == null || m.call(T, { ...k, source: "init", model: null }), this.destroyBean(D), F != null && ((C = this.beans.filterManager) == null || C.onFilterChanged({
          columns: [o],
          source: t
        }));
      } else {
        const D = this.createHandlerParams(o, g == null ? void 0 : g.params);
        i.handlerParams = D, (R = (v = i.handler).refresh) == null || R.call(v, {
          ...D,
          source: "colDef",
          model: F
        });
      }
    }
    if (this.areFilterCompsDifferent(((b = i.filterUi) == null ? void 0 : b.compDetails) ?? null, g) || !i.filterUi || !g) {
      this.destroyFilterUi(i, o, g, p);
      return;
    }
    i.filterUi.filterParams = f, (w = qt(i, h)) == null || w.then((x) => {
      (x != null && x.refresh ? x.refresh(f) : !0) === !1 ? this.destroyFilterUi(i, o, g, p) : this.dispatchLocalEvent({
        type: "filterParamsChanged",
        column: o,
        params: f
      });
    });
  }
  refreshHandlerAndUi(e, t, i, s) {
    const o = this.cachedFilter(e);
    if (!o)
      return s && this.getOrCreateFilterWrapper(e, !0), fe.resolve();
    if (!o.isHandler)
      return fe.resolve();
    const { filterUi: n, handler: r, handlerParams: a } = o;
    return Rb(
      () => {
        if (n) {
          const { created: l, filterParams: d } = n;
          if (l)
            return n.promise.then((c) => c ? { filter: c, filterParams: d } : void 0);
          n.refreshed = !0;
        }
        return fe.resolve(void 0);
      },
      r,
      a,
      t,
      this.state.get(e.getColId()) ?? { model: t },
      i
    );
  }
  setColumnFilterWrapper(e, t) {
    const i = e.getColId();
    this.allColumnFilters.set(i, t), this.allColumnListeners.set(
      i,
      this.addManagedListeners(e, { colDefChanged: () => this.filterParamsChanged(i) })[0]
    );
  }
  areFilterCompsDifferent(e, t) {
    if (!t || !e)
      return !0;
    const { componentClass: i } = e, { componentClass: s } = t;
    return !(i === s || // react hooks returns new wrappers, so check nested render method
    (i == null ? void 0 : i.render) && (s == null ? void 0 : s.render) && i.render === s.render);
  }
  hasFloatingFilters() {
    return this.beans.colModel.getCols().some((t) => t.getColDef().floatingFilter);
  }
  getFilterInstance(e) {
    const t = this.beans.colModel.getColDefCol(e);
    if (!t)
      return Promise.resolve(void 0);
    const i = this.getOrCreateFilterUi(t);
    return i ? new Promise((s) => {
      i.then((o) => {
        s(Po(o));
      });
    }) : Promise.resolve(null);
  }
  processFilterModelUpdateQueue() {
    this.modelUpdates.forEach(({ model: e, source: t }) => this.setModel(e, t)), this.modelUpdates = [], this.columnModelUpdates.forEach(({ key: e, model: t, resolve: i }) => {
      this.setModelForColumn(e, t).then(() => i());
    }), this.columnModelUpdates = [];
  }
  getModelForColumn(e, t) {
    if (t) {
      const { state: s, model: o } = this, n = e.getColId(), r = s.get(n);
      return r ? r.model ?? null : Re(o, n);
    }
    const i = this.cachedFilter(e);
    return i ? this.getModelFromFilterWrapper(i) : null;
  }
  setModelForColumn(e, t) {
    var i;
    if ((i = this.beans.dataTypeSvc) != null && i.isPendingInference) {
      let s = () => {
      };
      const o = new Promise((n) => {
        s = n;
      });
      return this.columnModelUpdates.push({ key: e, model: t, resolve: s }), o;
    }
    return new Promise((s) => {
      this.setModelForColumnLegacy(e, t).then((o) => s(o));
    });
  }
  getStateForColumn(e) {
    return this.state.get(e) ?? {
      model: Re(this.model, e)
    };
  }
  setModelForColumnLegacy(e, t) {
    const i = this.beans.colModel.getColDefCol(e), s = i ? this.getOrCreateFilterWrapper(i, !0) : null;
    return s ? this.setModelOnFilterWrapper(s, t) : fe.resolve();
  }
  setColDefPropsForDataType(e, t, i) {
    var c;
    const s = e.filter, o = s === !0 ? this.getDefaultFilterFromDataType(() => t.baseDataType) : s;
    if (typeof o != "string")
      return;
    let n, r;
    const a = this.beans, { filterParams: l, filterValueGetter: d } = e;
    o === "agMultiColumnFilter" ? { filterParams: n, filterValueGetter: r } = ((c = a.multiFilter) == null ? void 0 : c.getParamsForDataType(
      l,
      d,
      t,
      i
    )) ?? {} : { filterParams: n, filterValueGetter: r } = Ab(
      o,
      l,
      d,
      t,
      i,
      a,
      this.getLocaleTextFunc()
    ), e.filterParams = n, r && (e.filterValueGetter = r);
  }
  // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
  setColFilterActive(e, t, i, s) {
    e.filterActive !== t && (e.filterActive = t, e.dispatchColEvent("filterActiveChanged", i)), e.dispatchColEvent("filterChanged", i, s);
  }
  setModelOnFilterWrapper(e, t, i) {
    return new fe((s) => {
      if (e.isHandler) {
        const n = e.column, r = n.getColId(), a = this.model[r];
        if (this.updateStoredModel(r, t), i && t === a) {
          s();
          return;
        }
        this.refreshHandlerAndUi(n, t, "api").then(() => s());
        return;
      }
      const o = qt(e);
      if (o) {
        o.then((n) => {
          if (typeof (n == null ? void 0 : n.setModel) != "function") {
            I(65), s();
            return;
          }
          (n.setModel(t) || fe.resolve()).then(() => s());
        });
        return;
      }
      s();
    });
  }
  /** for handlers only */
  updateStoredModel(e, t) {
    H(t) ? this.model[e] = t : delete this.model[e];
    const i = this.state.get(e), s = {
      model: t,
      state: i == null ? void 0 : i.state
    };
    this.state.set(e, s);
  }
  filterModified(e, t) {
    var i;
    (i = this.getOrCreateFilterUi(e)) == null || i.then((s) => {
      this.eventSvc.dispatchEvent({
        type: "filterModified",
        column: e,
        filterInstance: s,
        ...t
      });
    });
  }
  filterUiChanged(e, t) {
    this.gos.get("enableFilterHandlers") && this.eventSvc.dispatchEvent({
      type: "filterUiChanged",
      column: e,
      ...t
    });
  }
  floatingFilterUiChanged(e, t) {
    this.gos.get("enableFilterHandlers") && this.eventSvc.dispatchEvent({
      type: "floatingFilterUiChanged",
      column: e,
      ...t
    });
  }
  updateModel(e, t, i) {
    var r;
    const s = e.getColId(), o = this.cachedFilter(e), n = () => o == null ? void 0 : o.filterUi;
    cc(
      t,
      n,
      () => Re(this.model, s),
      () => this.state.get(s),
      (a) => this.updateState(e, a),
      (a) => {
        var l, d;
        return (d = (l = n()) == null ? void 0 : l.filterParams) == null ? void 0 : d.onModelChange(a, i);
      },
      o != null && o.isHandler ? (r = o.handler.processModelToApply) == null ? void 0 : r.bind(o.handler) : void 0
    );
  }
  updateAllModels(e, t) {
    const i = [];
    this.allColumnFilters.forEach((s, o) => {
      var r;
      const n = this.beans.colModel.getColDefCol(o);
      n && cc(
        e,
        () => s.filterUi,
        () => Re(this.model, o),
        () => this.state.get(o),
        (a) => this.updateState(n, a),
        (a) => {
          this.updateStoredModel(o, a), this.dispatchLocalEvent({
            type: "filterAction",
            column: n,
            action: e
          }), i.push(this.refreshHandlerAndUi(n, a, "ui"));
        },
        s != null && s.isHandler ? (r = s.handler.processModelToApply) == null ? void 0 : r.bind(s.handler) : void 0
      );
    }), i.length && fe.all(i).then(() => {
      this.callOnFilterChangedOutsideRenderCycle({
        source: "columnFilter",
        additionalEventAttributes: t,
        columns: []
      });
    });
  }
  updateOrRefreshFilterUi(e) {
    const t = e.getColId();
    Vg(
      () => {
        var i;
        return (i = this.cachedFilter(e)) == null ? void 0 : i.filterUi;
      },
      () => Re(this.model, t),
      () => this.state.get(t)
    );
  }
  updateState(e, t) {
    this.state.set(e.getColId(), t), this.dispatchLocalEvent({
      type: "filterStateChanged",
      column: e,
      state: t
    });
  }
  // for tool panel only
  canApplyAll() {
    const { state: e, model: t, activeFilterComps: i } = this;
    for (const o of i)
      if (o.source === "COLUMN_MENU")
        return !1;
    let s = !1;
    for (const o of e.keys()) {
      const n = e.get(o);
      if (n.valid === !1)
        return !1;
      (n.model ?? null) !== Re(t, o) && (s = !0);
    }
    return s;
  }
  hasUnappliedModel(e) {
    var s;
    const { model: t, state: i } = this;
    return (((s = i.get(e)) == null ? void 0 : s.model) ?? null) !== Re(t, e);
  }
  setGlobalButtons(e) {
    this.isGlobalButtons = e, this.dispatchLocalEvent({
      type: "filterGlobalButtons",
      isGlobal: e
    });
  }
  shouldKeepStateOnDetach(e, t) {
    if (t === "newFiltersToolPanel")
      return !0;
    const i = this.beans.filterPanelSvc;
    return i != null && i.isActive ? !!i.getState(e.getColId()) : !1;
  }
  destroy() {
    super.destroy(), this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear(), this.state.clear(), this.activeFilterComps.clear();
  }
};
function eD(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isAnyFilterPresent());
}
function tD(e, t = "api") {
  var i;
  (i = e.filterManager) == null || i.onFilterChanged({ source: t });
}
var iD = class extends E {
  constructor() {
    super(...arguments), this.beanName = "filterManager", this.advFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.quickFilter = e.quickFilter, this.advancedFilter = e.advancedFilter, this.colFilter = e.colFilter;
  }
  postConstruct() {
    const e = this.refreshFiltersForAggregations.bind(this), t = this.updateAdvFilterColumns.bind(this);
    this.addManagedEventListeners({
      columnValueChanged: e,
      columnPivotChanged: e,
      columnPivotModeChanged: e,
      newColumnsLoaded: t,
      columnVisible: t,
      advancedFilterEnabledChanged: ({ enabled: s }) => this.onAdvFilterEnabledChanged(s),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
      this.onFilterChanged({ source: "api" });
    }), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => {
      this.updateAggFiltering(), this.onFilterChanged();
    }), this.quickFilter && this.addManagedListeners(this.quickFilter, {
      quickFilterChanged: () => this.onFilterChanged({ source: "quickFilter" })
    });
    const { gos: i } = this;
    this.alwaysPassFilter = i.get("alwaysPassFilter"), this.addManagedPropertyListener("alwaysPassFilter", () => {
      this.alwaysPassFilter = i.get("alwaysPassFilter"), this.onFilterChanged({ source: "api" });
    });
  }
  isExternalFilterPresentCallback() {
    const e = this.gos.getCallback("isExternalFilterPresent");
    return typeof e == "function" && e({});
  }
  doesExternalFilterPass(e) {
    const t = this.gos.get("doesExternalFilterPass");
    return typeof t == "function" && t(e);
  }
  setFilterState(e, t, i = "api") {
    var s;
    this.isAdvFilterEnabled() || (s = this.colFilter) == null || s.setState(e, t, i);
  }
  setFilterModel(e, t = "api", i) {
    var s;
    if (this.isAdvFilterEnabled()) {
      i || this.warnAdvFilters();
      return;
    }
    (s = this.colFilter) == null || s.setModel(e, t);
  }
  getFilterModel() {
    var e;
    return ((e = this.colFilter) == null ? void 0 : e.getModel()) ?? {};
  }
  getFilterState() {
    var e;
    return (e = this.colFilter) == null ? void 0 : e.getState();
  }
  isColumnFilterPresent() {
    var e;
    return !!((e = this.colFilter) != null && e.isFilterPresent());
  }
  isAggregateFilterPresent() {
    var e;
    return !!((e = this.colFilter) != null && e.isAggFilterPresent());
  }
  isChildFilterPresent() {
    return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.externalFilterPresent || this.isAdvFilterPresent();
  }
  isAnyFilterPresent() {
    return this.isChildFilterPresent() || this.isAggregateFilterPresent();
  }
  isAdvFilterPresent() {
    return this.isAdvFilterEnabled() && this.advancedFilter.isFilterPresent();
  }
  onAdvFilterEnabledChanged(e) {
    var t, i;
    e ? (t = this.colFilter) != null && t.disableFilters() && this.onFilterChanged({ source: "advancedFilter" }) : (i = this.advancedFilter) != null && i.isFilterPresent() && (this.advancedFilter.setModel(null), this.onFilterChanged({ source: "advancedFilter" }));
  }
  isAdvFilterEnabled() {
    var e;
    return !!((e = this.advancedFilter) != null && e.isEnabled());
  }
  isAdvFilterHeaderActive() {
    return this.isAdvFilterEnabled() && this.advancedFilter.isHeaderActive();
  }
  refreshFiltersForAggregations() {
    Oa(this.gos) && this.isAnyFilterPresent() && this.onFilterChanged();
  }
  onFilterChanged(e = {}) {
    const { source: t, additionalEventAttributes: i, columns: s = [] } = e;
    this.externalFilterPresent = this.isExternalFilterPresentCallback(), (this.colFilter ? this.colFilter.updateBeforeFilterChanged(e) : fe.resolve()).then(() => {
      var n;
      const o = {
        source: t,
        type: "filterChanged",
        columns: s
      };
      i && Be(o, i), this.eventSvc.dispatchEvent(o), (n = this.colFilter) == null || n.updateAfterFilterChanged();
    });
  }
  isSuppressFlashingCellsBecauseFiltering() {
    var e;
    return !!((e = this.colFilter) != null && e.isSuppressFlashingCellsBecauseFiltering());
  }
  isQuickFilterPresent() {
    var e;
    return !!((e = this.quickFilter) != null && e.isFilterPresent());
  }
  updateAggFiltering() {
    this.aggFiltering = !!Oa(this.gos);
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
  }
  shouldApplyQuickFilterAfterAgg() {
    return (this.aggFiltering || this.beans.colModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
  }
  doesRowPassOtherFilters(e, t) {
    return this.doesRowPassFilter({ rowNode: t, colIdToSkip: e });
  }
  doesRowPassAggregateFilters(e) {
    var i;
    const { rowNode: t } = e;
    return (i = this.alwaysPassFilter) != null && i.call(this, t) ? !0 : !(this.isAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(t) || this.isAggregateFilterPresent() && !this.colFilter.doFiltersPass(t, e.colIdToSkip, !0));
  }
  doesRowPassFilter(e) {
    var i;
    const { rowNode: t } = e;
    return (i = this.alwaysPassFilter) != null && i.call(this, t) ? !0 : !(this.isNonAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(t) || this.externalFilterPresent && !this.doesExternalFilterPass(t) || this.isColumnFilterPresent() && !this.colFilter.doFiltersPass(t, e.colIdToSkip) || this.isAdvFilterPresent() && !this.advancedFilter.doesFilterPass(t));
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    var t;
    return this.isAdvFilterEnabled() ? !1 : !!((t = this.colFilter) != null && t.isFilterAllowed(e));
  }
  getAdvFilterModel() {
    return this.isAdvFilterEnabled() ? this.advancedFilter.getModel() : null;
  }
  setAdvFilterModel(e, t = "api") {
    var i;
    if (this.isAdvFilterEnabled()) {
      if ((i = this.beans.dataTypeSvc) != null && i.isPendingInference) {
        this.advFilterModelUpdateQueue.push(e);
        return;
      }
      this.advancedFilter.setModel(e ?? null), this.onFilterChanged({ source: t });
    }
  }
  toggleAdvFilterBuilder(e, t) {
    this.isAdvFilterEnabled() && this.advancedFilter.getCtrl().toggleFilterBuilder({ source: t, force: e });
  }
  updateAdvFilterColumns() {
    this.isAdvFilterEnabled() && this.advancedFilter.updateValidity() && this.onFilterChanged({ source: "advancedFilter" });
  }
  hasFloatingFilters() {
    var e;
    return this.isAdvFilterEnabled() ? !1 : !!((e = this.colFilter) != null && e.hasFloatingFilters());
  }
  getColumnFilterInstance(e) {
    var t;
    return this.isAdvFilterEnabled() ? (this.warnAdvFilters(), Promise.resolve(void 0)) : ((t = this.colFilter) == null ? void 0 : t.getFilterInstance(e)) ?? Promise.resolve(void 0);
  }
  warnAdvFilters() {
    I(68);
  }
  setupAdvFilterHeaderComp(e) {
    var t;
    (t = this.advancedFilter) == null || t.getCtrl().setupHeaderComp(e);
  }
  getHeaderRowCount() {
    return this.isAdvFilterHeaderActive() ? 1 : 0;
  }
  getHeaderHeight() {
    return this.isAdvFilterHeaderActive() ? this.advancedFilter.getCtrl().getHeaderHeight() : 0;
  }
  processFilterModelUpdateQueue() {
    this.advFilterModelUpdateQueue.forEach((e) => this.setAdvFilterModel(e)), this.advFilterModelUpdateQueue = [];
  }
  setColumnFilterModel(e, t) {
    var i;
    return this.isAdvFilterEnabled() ? (this.warnAdvFilters(), Promise.resolve()) : ((i = this.colFilter) == null ? void 0 : i.setModelForColumn(e, t)) ?? Promise.resolve();
  }
}, sD = class extends E {
  constructor() {
    super(...arguments), this.beanName = "filterMenuFactory";
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc;
  }
  hideActiveMenu() {
    var e;
    (e = this.hidePopup) == null || e.call(this);
  }
  showMenuAfterMouseEvent(e, t, i, s) {
    e && !e.isColumn || this.showPopup(
      e,
      (o) => {
        var n;
        (n = this.popupSvc) == null || n.positionPopupUnderMouseEvent({
          column: e,
          type: i,
          mouseEvent: t,
          ePopup: o
        });
      },
      i,
      t.target,
      $e(this.gos),
      s
    );
  }
  showMenuAfterButtonClick(e, t, i, s) {
    if (e && !e.isColumn)
      return;
    let o = -1, n = "left";
    const r = $e(this.gos);
    !r && this.gos.get("enableRtl") && (o = 1, n = "right");
    const a = r ? void 0 : 4 * o, l = r ? void 0 : 4;
    this.showPopup(
      e,
      (d) => {
        var c;
        (c = this.popupSvc) == null || c.positionPopupByComponent({
          type: i,
          eventSource: t,
          ePopup: d,
          nudgeX: a,
          nudgeY: l,
          alignSide: n,
          keepWithinBounds: !0,
          position: "under",
          column: e
        });
      },
      i,
      t,
      r,
      s
    );
  }
  showPopup(e, t, i, s, o, n) {
    var f;
    const r = e ? this.createBean(new Tb(e, "COLUMN_MENU")) : void 0;
    if (this.activeMenu = r, !(r != null && r.hasFilter()) || !e) {
      Z(57);
      return;
    }
    const a = ye({
      tag: "div",
      cls: `ag-menu${o ? "" : " ag-filter-menu"}`,
      role: "presentation"
    });
    [this.tabListener] = this.addManagedElementListeners(a, {
      keydown: (m) => this.trapFocusWithin(m, a)
    }), a.appendChild(r == null ? void 0 : r.getGui());
    let l;
    const d = () => r == null ? void 0 : r.afterGuiDetached(), c = qC(this.gos) ? s ?? this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody : void 0, u = (m) => {
      vc(e, !1, "contextMenu");
      const C = m instanceof KeyboardEvent;
      if (this.tabListener && (this.tabListener = this.tabListener()), C && s && Mt(s)) {
        const v = Fg(s);
        v == null || v.focus({ preventScroll: !0 });
      }
      d(), this.destroyBean(this.activeMenu), this.dispatchVisibleChangedEvent(!1, i, e), n == null || n();
    }, h = this.getLocaleTextFunc(), g = o && i !== "columnFilter" ? h("ariaLabelColumnMenu", "Column Menu") : h("ariaLabelColumnFilter", "Column Filter"), p = (f = this.popupSvc) == null ? void 0 : f.addPopup({
      modal: !0,
      eChild: a,
      closeOnEsc: !0,
      closedCallback: u,
      positionCallback: () => t(a),
      anchorToElement: c,
      ariaLabel: g
    });
    p && (this.hidePopup = l = p.hideFunc), r.afterInit().then(() => {
      t(a), r.afterGuiAttached({ container: i, hidePopup: l });
    }), vc(e, !0, "contextMenu"), this.dispatchVisibleChangedEvent(!0, i, e);
  }
  trapFocusWithin(e, t) {
    e.key !== P.TAB || e.defaultPrevented || zi(this.beans, t, !1, e.shiftKey) || (e.preventDefault(), _i(t, e.shiftKey));
  }
  dispatchVisibleChangedEvent(e, t, i) {
    this.eventSvc.dispatchEvent({
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: !1,
      key: t,
      column: i ?? null,
      columnGroup: null
    });
  }
  isMenuEnabled(e) {
    return e.isFilterAllowed() && (e.getColDef().menuTabs ?? ["filterMenuTab"]).includes("filterMenuTab");
  }
  showMenuAfterContextMenuEvent() {
  }
  destroy() {
    this.destroyBean(this.activeMenu), super.destroy();
  }
}, oD = class extends E {
  constructor() {
    super(...arguments), this.beanName = "filterValueSvc";
  }
  getValue(e, t, i) {
    if (!t)
      return;
    const s = e.getColDef(), { selectableFilter: o, valueSvc: n } = this.beans, r = i ?? (o == null ? void 0 : o.getFilterValueGetter(e.getColId())) ?? s.filterValueGetter;
    return r ? this.executeFilterValueGetter(r, t.data, e, t, s) : n.getValue(e, t);
  }
  executeFilterValueGetter(e, t, i, s, o) {
    const { expressionSvc: n, valueSvc: r } = this.beans, a = W(this.gos, {
      data: t,
      node: s,
      column: i,
      colDef: o,
      getValue: r.getValueCallback.bind(r, s)
    });
    return typeof e == "function" ? e(a) : n == null ? void 0 : n.evaluate(e, a);
  }
}, nD = {
  tag: "div",
  cls: "ag-floating-filter-input",
  role: "presentation",
  children: [
    {
      tag: "ag-input-text-field",
      ref: "eFloatingFilterText"
    }
  ]
}, rD = class extends te {
  constructor() {
    super(nD, [wr]), this.eFloatingFilterText = _;
  }
  init(e) {
    this.params = e;
    const t = this.beans.colNames.getDisplayNameForColumn(e.column, "header", !0);
    if (this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${t} ${this.getLocaleTextFunc()("ariaFilterInput", "Filter Input")}`), this.gos.get("enableFilterHandlers")) {
      const i = e, s = i.getHandler();
      if (s.getModelAsString) {
        const o = s.getModelAsString(i.model);
        this.eFloatingFilterText.setValue(o);
      }
    }
  }
  onParentModelChanged(e) {
    if (e == null) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((t) => {
      if (t.getModelAsString) {
        const i = t.getModelAsString(e);
        this.eFloatingFilterText.setValue(i);
      }
    });
  }
  refresh(e) {
    this.init(e);
  }
}, nd = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(e, t) {
    this.filterOptions = e.filterOptions ?? t, this.mapCustomOptions(), this.defaultOption = this.getDefaultItem(e.defaultOption);
  }
  refresh(e, t) {
    const i = e.filterOptions ?? t;
    this.filterOptions !== i && (this.filterOptions = i, this.customFilterOptions = {}, this.mapCustomOptions()), this.defaultOption = this.getDefaultItem(e.defaultOption);
  }
  mapCustomOptions() {
    const { filterOptions: e } = this;
    e && e.forEach((t) => {
      if (typeof t == "string")
        return;
      const i = [["displayKey"], ["displayName"], ["predicate", "test"]], s = (o) => o.some((n) => t[n] != null) ? !0 : (I(72, { keys: o }), !1);
      if (!i.every(s)) {
        this.filterOptions = e.filter((o) => o === t) || [];
        return;
      }
      this.customFilterOptions[t.displayKey] = t;
    });
  }
  getDefaultItem(e) {
    const { filterOptions: t } = this;
    if (e)
      return e;
    if (t.length >= 1) {
      const i = t[0];
      if (typeof i == "string")
        return i;
      if (i.displayKey)
        return i.displayKey;
      I(73);
    } else
      I(74);
  }
  getCustomOption(e) {
    return this.customFilterOptions[e];
  }
};
function lo(e, t, i) {
  return i == null ? e.splice(t) : e.splice(t, i);
}
function ar(e) {
  return e == null || typeof e == "string" && e.trim().length === 0;
}
function aD(e) {
  return e === "AND" || e === "OR" ? e : "AND";
}
function lD(e, t, i) {
  if (e == null)
    return;
  const { predicate: s } = e;
  if (s != null && !t.some((o) => o == null))
    return s(t, i);
}
function dD(e, t) {
  let i = e.length;
  return i > t && (e.splice(t), I(78), i = t), i;
}
function Mo(e, t) {
  const i = t.getCustomOption(e);
  if (i) {
    const { numberOfInputs: o } = i;
    return o ?? 1;
  }
  return e && ["empty", "notBlank", "blank"].indexOf(e) >= 0 ? 0 : e === "inRange" ? 2 : 1;
}
var rd = class extends Bb {
  constructor(e, t, i) {
    super(e, "simple-filter"), this.mapValuesFromModel = t, this.defaultOptions = i, this.eTypes = [], this.eJoinPanels = [], this.eJoinAnds = [], this.eJoinOrs = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0;
  }
  setParams(e) {
    super.setParams(e);
    const t = new nd();
    this.optionsFactory = t, t.init(e, this.defaultOptions), this.commonUpdateSimpleParams(e), this.createOption(), this.createMissingConditionsAndOperators();
  }
  updateParams(e, t) {
    this.optionsFactory.refresh(e, this.defaultOptions), super.updateParams(e, t), this.commonUpdateSimpleParams(e);
  }
  commonUpdateSimpleParams(e) {
    this.setNumConditions(e), this.defaultJoinOperator = aD(e.defaultJoinOperator), this.filterPlaceholder = e.filterPlaceholder, this.createFilterListOptions();
    const t = this.getGui();
    this.isReadOnly() ? t.setAttribute("tabindex", "-1") : t.removeAttribute("tabindex");
  }
  // floating filter calls this when user applies filter from floating filter
  onFloatingFilterChanged(e, t) {
    this.setTypeFromFloatingFilter(e), this.setValueFromFloatingFilter(t), this.onUiChanged("immediately", !0);
  }
  setTypeFromFloatingFilter(e) {
    this.eTypes.forEach((t, i) => {
      const s = i === 0 ? e : this.optionsFactory.defaultOption;
      t.setValue(s, !0);
    });
  }
  getModelFromUi() {
    const e = this.getUiCompleteConditions();
    return e.length === 0 ? null : this.maxNumConditions > 1 && e.length > 1 ? {
      filterType: this.filterType,
      operator: this.getJoinOperator(),
      conditions: e
    } : e[0];
  }
  getConditionTypes() {
    return this.eTypes.map((e) => e.getValue());
  }
  getConditionType(e) {
    return this.eTypes[e].getValue();
  }
  getJoinOperator() {
    const { eJoinOrs: e, defaultJoinOperator: t } = this;
    return e.length === 0 ? t : e[0].getValue() === !0 ? "OR" : "AND";
  }
  areNonNullModelsEqual(e, t) {
    const i = !e.operator, s = !t.operator;
    if (!i && s || i && !s)
      return !1;
    let n;
    if (i) {
      const r = e, a = t;
      n = this.areSimpleModelsEqual(r, a);
    } else {
      const r = e, a = t;
      n = r.operator === a.operator && ci(
        r.conditions,
        a.conditions,
        (l, d) => this.areSimpleModelsEqual(l, d)
      );
    }
    return n;
  }
  setModelIntoUi(e, t) {
    if (e == null)
      return this.resetUiToDefaults(t), fe.resolve();
    if (e.operator) {
      const s = e;
      let o = s.conditions;
      o == null && (o = [], I(77));
      const n = dD(o, this.maxNumConditions), r = this.getNumConditions();
      if (n < r)
        this.removeConditionsAndOperators(n);
      else if (n > r)
        for (let l = r; l < n; l++)
          this.createJoinOperatorPanel(), this.createOption();
      const a = s.operator === "OR";
      this.eJoinAnds.forEach((l) => l.setValue(!a, !0)), this.eJoinOrs.forEach((l) => l.setValue(a, !0)), o.forEach((l, d) => {
        this.eTypes[d].setValue(l.type, !0), this.setConditionIntoUi(l, d);
      });
    } else {
      const s = e;
      this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(s.type, !0), this.setConditionIntoUi(s, 0);
    }
    return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.updateUiVisibility(), t || this.params.onUiChange(this.getUiChangeEventParams()), fe.resolve();
  }
  setNumConditions(e) {
    let t = e.maxNumConditions ?? 2;
    t < 1 && (I(79), t = 1), this.maxNumConditions = t;
    let i = e.numAlwaysVisibleConditions ?? 1;
    i < 1 && (I(80), i = 1), i > t && (I(81), i = t), this.numAlwaysVisibleConditions = i;
  }
  createOption() {
    const e = this.getGui(), t = this.createManagedBean(new Vl());
    this.eTypes.push(t), t.addCss("ag-filter-select"), e.appendChild(t.getGui());
    const i = this.createEValue();
    this.eConditionBodies.push(i), e.appendChild(i), this.putOptionsIntoDropdown(t), this.resetType(t);
    const s = this.getNumConditions() - 1;
    this.forEachPositionInput(s, (o) => this.resetInput(o)), this.addChangedListeners(t, s);
  }
  createJoinOperatorPanel() {
    const e = ye({ tag: "div", cls: "ag-filter-condition" });
    this.eJoinPanels.push(e);
    const t = this.createJoinOperator(this.eJoinAnds, e, "and"), i = this.createJoinOperator(this.eJoinOrs, e, "or");
    this.getGui().appendChild(e);
    const s = this.eJoinPanels.length - 1, o = this.joinOperatorId++;
    this.resetJoinOperatorAnd(t, s, o), this.resetJoinOperatorOr(i, s, o), this.isReadOnly() || (t.onValueChange(this.listener), i.onValueChange(this.listener));
  }
  createJoinOperator(e, t, i) {
    const s = this.createManagedBean(new Cw());
    e.push(s);
    const o = "ag-filter-condition-operator";
    return s.addCss(o), s.addCss(`${o}-${i}`), t.appendChild(s.getGui()), s;
  }
  createFilterListOptions() {
    this.filterListOptions = this.optionsFactory.filterOptions.map(
      (e) => typeof e == "string" ? this.createBoilerplateListOption(e) : this.createCustomListOption(e)
    );
  }
  putOptionsIntoDropdown(e) {
    const { filterListOptions: t } = this;
    t.forEach((i) => {
      e.addOption(i);
    }), e.setDisabled(t.length <= 1);
  }
  createBoilerplateListOption(e) {
    return { value: e, text: this.translate(e) };
  }
  createCustomListOption(e) {
    const { displayKey: t } = e, i = this.optionsFactory.getCustomOption(e.displayKey);
    return {
      value: t,
      text: i ? this.getLocaleTextFunc()(i.displayKey, i.displayName) : this.translate(t)
    };
  }
  createBodyTemplate() {
    return null;
  }
  getAgComponents() {
    return [];
  }
  updateUiVisibility() {
    const e = this.getJoinOperator();
    this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e);
  }
  updateNumConditions() {
    let e = -1, t = !0;
    for (let i = 0; i < this.getNumConditions(); i++)
      this.isConditionUiComplete(i) ? e = i : t = !1;
    if (this.shouldAddNewConditionAtEnd(t))
      this.createJoinOperatorPanel(), this.createOption();
    else {
      const i = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
      if (e < i) {
        this.removeConditionsAndOperators(i + 1);
        const s = e + 1, o = i - s;
        o > 0 && this.removeConditionsAndOperators(s, o), this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = e;
  }
  updateConditionStatusesAndValues(e, t) {
    this.eTypes.forEach((s, o) => {
      const n = this.isConditionDisabled(o, e);
      s.setDisabled(n || this.filterListOptions.length <= 1), o === 1 && (yo(this.eJoinPanels[0], n), this.eJoinAnds[0].setDisabled(n), this.eJoinOrs[0].setDisabled(n));
    }), this.eConditionBodies.forEach((s, o) => {
      le(s, this.isConditionBodyVisible(o));
    });
    const i = (t ?? this.getJoinOperator()) === "OR";
    this.eJoinAnds.forEach((s) => {
      s.setValue(!i, !0);
    }), this.eJoinOrs.forEach((s) => {
      s.setValue(i, !0);
    }), this.forEachInput((s, o, n, r) => {
      this.setElementDisplayed(s, o < r), this.setElementDisabled(s, this.isConditionDisabled(n, e));
    }), this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(e) {
    return e && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(e, t) {
    if (e >= this.getNumConditions())
      return;
    const {
      eTypes: i,
      eConditionBodies: s,
      eJoinPanels: o,
      eJoinAnds: n,
      eJoinOrs: r
    } = this;
    this.removeComponents(i, e, t), this.removeElements(s, e, t), this.removeEValues(e, t);
    const a = Math.max(e - 1, 0);
    this.removeElements(o, a, t), this.removeComponents(n, a, t), this.removeComponents(r, a, t);
  }
  removeElements(e, t, i) {
    lo(e, t, i).forEach((o) => dt(o));
  }
  removeComponents(e, t, i) {
    lo(e, t, i).forEach((o) => {
      dt(o.getGui()), this.destroyBean(o);
    });
  }
  afterGuiAttached(e) {
    var t;
    if (super.afterGuiAttached(e), this.resetPlaceholder(), !(e != null && e.suppressFocus)) {
      let i;
      if (!this.isReadOnly()) {
        const s = this.getInputs(0)[0];
        s instanceof Ri && this.isConditionBodyVisible(0) ? i = s.getInputElement() : i = (t = this.eTypes[0]) == null ? void 0 : t.getFocusableElement();
      }
      (i ?? this.getGui()).focus({ preventScroll: !0 });
    }
  }
  afterGuiDetached() {
    var r;
    super.afterGuiDetached();
    const e = this.params;
    if ((r = this.beans.colFilter) != null && r.shouldKeepStateOnDetach(e.column))
      return;
    e.onStateChange({
      model: e.model
    });
    let t = -1, i = -1, s = !1;
    const o = this.getJoinOperator();
    for (let a = this.getNumConditions() - 1; a >= 0; a--)
      if (this.isConditionUiComplete(a))
        t === -1 && (t = a, i = a);
      else {
        const l = a >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(a - 1), d = a < t;
        (l || d) && (this.removeConditionsAndOperators(a, 1), s = !0, d && i--);
      }
    let n = !1;
    this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), n = !0), this.shouldAddNewConditionAtEnd(i === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), n = !0), n && this.updateConditionStatusesAndValues(i, o), s && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = i;
  }
  getModelAsString(e) {
    var t, i;
    return ((i = (t = this.params.getHandler()) == null ? void 0 : t.getModelAsString) == null ? void 0 : i.call(t, e)) ?? "";
  }
  getPlaceholderText(e, t) {
    let i = this.translate(e);
    if (typeof this.filterPlaceholder == "function") {
      const s = this.eTypes[t].getValue(), o = this.translate(s);
      i = this.filterPlaceholder({
        filterOptionKey: s,
        filterOption: o,
        placeholder: i
      });
    } else typeof this.filterPlaceholder == "string" && (i = this.filterPlaceholder);
    return i;
  }
  // allow sub-classes to reset HTML placeholders after UI update.
  resetPlaceholder() {
    const e = this.getLocaleTextFunc();
    this.forEachInput((t, i, s, o) => {
      if (!(t instanceof Ri))
        return;
      const n = i === 0 && o > 1 ? "inRangeStart" : i === 0 ? "filterOoo" : "inRangeEnd", r = i === 0 && o > 1 ? e("ariaFilterFromValue", "Filter from value") : i === 0 ? e("ariaFilterValue", "Filter Value") : e("ariaFilterToValue", "Filter to Value");
      t.setInputPlaceholder(this.getPlaceholderText(n, s)), t.setInputAriaLabel(r);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setElementValue(e, t, i) {
    e instanceof Ri && e.setValue(t != null ? String(t) : null, !0);
  }
  setElementDisplayed(e, t) {
    ec(e) && le(e.getGui(), t);
  }
  setElementDisabled(e, t) {
    ec(e) && yo(e.getGui(), t);
  }
  attachElementOnChange(e, t) {
    e instanceof Ri && e.onValueChange(t);
  }
  forEachInput(e) {
    this.getConditionTypes().forEach((t, i) => {
      this.forEachPositionTypeInput(i, t, e);
    });
  }
  forEachPositionInput(e, t) {
    const i = this.getConditionType(e);
    this.forEachPositionTypeInput(e, i, t);
  }
  forEachPositionTypeInput(e, t, i) {
    const s = Mo(t, this.optionsFactory), o = this.getInputs(e);
    for (let n = 0; n < o.length; n++) {
      const r = o[n];
      r != null && i(r, n, e, s);
    }
  }
  isConditionDisabled(e, t) {
    return this.isReadOnly() ? !0 : e === 0 ? !1 : e > t + 1;
  }
  isConditionBodyVisible(e) {
    const t = this.getConditionType(e);
    return Mo(t, this.optionsFactory) > 0;
  }
  // returns true if the UI represents a working filter, eg all parts are filled out.
  // eg if text filter and textfield blank then returns false.
  isConditionUiComplete(e) {
    return !(e >= this.getNumConditions() || this.getConditionType(e) === "empty" || this.getValues(e).some((i) => i == null));
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const e = [];
    for (let t = 0; t < this.getNumConditions(); t++)
      this.isConditionUiComplete(t) && e.push(this.createCondition(t));
    return e;
  }
  createMissingConditionsAndOperators() {
    if (!this.isReadOnly())
      for (let e = this.getNumConditions(); e < this.numAlwaysVisibleConditions; e++)
        this.createJoinOperatorPanel(), this.createOption();
  }
  resetUiToDefaults(e) {
    this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach((t) => this.resetType(t)), this.eJoinAnds.forEach(
      (t, i) => this.resetJoinOperatorAnd(t, i, this.joinOperatorId + i)
    ), this.eJoinOrs.forEach(
      (t, i) => this.resetJoinOperatorOr(t, i, this.joinOperatorId + i)
    ), this.joinOperatorId++, this.forEachInput((t) => this.resetInput(t)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, this.updateUiVisibility(), e || this.params.onUiChange(this.getUiChangeEventParams());
  }
  resetType(e) {
    const i = this.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
    e.setValue(this.optionsFactory.defaultOption, !0).setAriaLabel(i).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(e, t, i) {
    this.resetJoinOperator(
      e,
      t,
      this.defaultJoinOperator === "AND",
      this.translate("andCondition"),
      i
    );
  }
  resetJoinOperatorOr(e, t, i) {
    this.resetJoinOperator(
      e,
      t,
      this.defaultJoinOperator === "OR",
      this.translate("orCondition"),
      i
    );
  }
  resetJoinOperator(e, t, i, s, o) {
    this.updateJoinOperatorDisabled(
      e.setValue(i, !0).setName(`ag-simple-filter-and-or-${this.getCompId()}-${o}`).setLabel(s),
      t
    );
  }
  updateJoinOperatorsDisabled() {
    const e = (t, i) => this.updateJoinOperatorDisabled(t, i);
    this.eJoinAnds.forEach(e), this.eJoinOrs.forEach(e);
  }
  updateJoinOperatorDisabled(e, t) {
    e.setDisabled(this.isReadOnly() || t > 0);
  }
  resetInput(e) {
    this.setElementValue(e, null), this.setElementDisabled(e, this.isReadOnly());
  }
  // puts model values into the UI
  setConditionIntoUi(e, t) {
    const i = this.mapValuesFromModel(e, this.optionsFactory);
    this.forEachInput((s, o, n) => {
      n === t && this.setElementValue(s, i[o] != null ? i[o] : null);
    });
  }
  // after floating filter changes, this sets the 'value' section. this is implemented by the base class
  // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
  setValueFromFloatingFilter(e) {
    this.forEachInput((t, i, s) => {
      this.setElementValue(t, i === 0 && s === 0 ? e : null, !0);
    });
  }
  addChangedListeners(e, t) {
    this.isReadOnly() || (e.onValueChange(this.listener), this.forEachPositionInput(t, (i) => {
      this.attachElementOnChange(i, this.listener);
    }));
  }
  hasInvalidInputs() {
    return !1;
  }
  isReadOnly() {
    return !!this.params.readOnly;
  }
}, Wp = class {
  constructor(e, t, i, s, o, n) {
    this.alive = !0, this.context = e, this.eParent = o;
    const r = Zv(t, i, s);
    r && r.newAgStackInstance().then((a) => {
      var c, u;
      if (!this.alive) {
        e.destroyBean(a);
        return;
      }
      if (this.dateComp = a, !a)
        return;
      o.appendChild(a.getGui()), (c = a == null ? void 0 : a.afterGuiAttached) == null || c.call(a);
      const { tempValue: l, disabled: d } = this;
      l && a.setDate(l), d != null && ((u = a.setDisabled) == null || u.call(a, d)), n == null || n(this);
    });
  }
  destroy() {
    this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(e) {
    const t = this.dateComp;
    t ? t.setDate(e) : this.tempValue = e;
  }
  setDisabled(e) {
    var i;
    const t = this.dateComp;
    t ? (i = t.setDisabled) == null || i.call(t, e) : this.disabled = e;
  }
  setDisplayed(e) {
    le(this.eParent, e);
  }
  setInputPlaceholder(e) {
    var t, i;
    (i = (t = this.dateComp) == null ? void 0 : t.setInputPlaceholder) == null || i.call(t, e);
  }
  setInputAriaLabel(e) {
    var t, i;
    (i = (t = this.dateComp) == null ? void 0 : t.setInputAriaLabel) == null || i.call(t, e);
  }
  afterGuiAttached(e) {
    var t, i;
    (i = (t = this.dateComp) == null ? void 0 : t.afterGuiAttached) == null || i.call(t, e);
  }
  updateParams(e) {
    var t, i;
    (i = (t = this.dateComp) == null ? void 0 : t.refresh) == null || i.call(t, e);
  }
}, ad = [
  "equals",
  "notEqual",
  "lessThan",
  "greaterThan",
  "inRange",
  "blank",
  "notBlank"
];
function zp(e, t) {
  const { dateFrom: i, dateTo: s, type: o } = e || {};
  return [
    i && ze(i, void 0, !0) || null,
    s && ze(s, void 0, !0) || null
  ].slice(0, Mo(o, t));
}
var Zc = 1e3, Jc = 1 / 0, cD = class extends rd {
  constructor() {
    super("dateFilter", zp, ad), this.eConditionPanelsFrom = [], this.eConditionPanelsTo = [], this.dateConditionFromComps = [], this.dateConditionToComps = [], this.minValidYear = Zc, this.maxValidYear = Jc, this.minValidDate = null, this.maxValidDate = null, this.filterType = "date";
  }
  afterGuiAttached(e) {
    super.afterGuiAttached(e), this.dateConditionFromComps[0].afterGuiAttached(e);
  }
  commonUpdateSimpleParams(e) {
    super.commonUpdateSimpleParams(e);
    const t = (l, d) => {
      const c = e[l];
      if (c != null)
        if (isNaN(c))
          I(82, { param: l });
        else
          return c == null ? d : Number(c);
      return d;
    }, i = t("minValidYear", Zc), s = t("maxValidYear", Jc);
    this.minValidYear = i, this.maxValidYear = s, i > s && I(83);
    const { minValidDate: o, maxValidDate: n } = e, r = o instanceof Date ? o : ze(o);
    this.minValidDate = r;
    const a = n instanceof Date ? n : ze(n);
    this.maxValidDate = a, r && a && r > a && I(84);
  }
  createDateCompWrapper(e) {
    const {
      beans: { userCompFactory: t, context: i, gos: s },
      params: o
    } = this, n = new Wp(
      i,
      t,
      o.colDef,
      W(s, {
        onDateChanged: () => this.onUiChanged(),
        filterParams: o,
        location: "filter"
      }),
      e
    );
    return this.addDestroyFunc(() => n.destroy()), n;
  }
  setElementValue(e, t) {
    e.setDate(t);
  }
  setElementDisplayed(e, t) {
    e.setDisplayed(t);
  }
  setElementDisabled(e, t) {
    e.setDisabled(t);
  }
  createEValue() {
    const e = ye({ tag: "div", cls: "ag-filter-body" });
    return this.createFromToElement(e, this.eConditionPanelsFrom, this.dateConditionFromComps, "from"), this.createFromToElement(e, this.eConditionPanelsTo, this.dateConditionToComps, "to"), e;
  }
  createFromToElement(e, t, i, s) {
    const o = ye({ tag: "div", cls: `ag-filter-${s} ag-filter-date-${s}` });
    t.push(o), e.appendChild(o), i.push(this.createDateCompWrapper(o));
  }
  removeEValues(e, t) {
    this.removeDateComps(this.dateConditionFromComps, e, t), this.removeDateComps(this.dateConditionToComps, e, t), lo(this.eConditionPanelsFrom, e, t), lo(this.eConditionPanelsTo, e, t);
  }
  removeDateComps(e, t, i) {
    lo(e, t, i).forEach((o) => o.destroy());
  }
  isValidDateValue(e) {
    if (e === null)
      return !1;
    const { minValidDate: t, maxValidDate: i, minValidYear: s, maxValidYear: o } = this;
    if (t) {
      if (e < t)
        return !1;
    } else if (e.getUTCFullYear() < s)
      return !1;
    if (i) {
      if (e > i)
        return !1;
    } else if (e.getUTCFullYear() > o)
      return !1;
    return !0;
  }
  isConditionUiComplete(e) {
    if (!super.isConditionUiComplete(e))
      return !1;
    let t = !0;
    return this.forEachInput((i, s, o, n) => {
      o !== e || !t || s >= n || (t = t && this.isValidDateValue(i.getDate()));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.dateFrom === t.dateFrom && e.dateTo === t.dateTo && e.type === t.type;
  }
  createCondition(e) {
    const t = this.getConditionType(e), i = {}, s = this.getValues(e), o = this.params.useIsoSeparator ? "T" : " ";
    return s.length > 0 && (i.dateFrom = Ke(s[0], !0, o)), s.length > 1 && (i.dateTo = Ke(s[1], !0, o)), {
      dateFrom: null,
      dateTo: null,
      filterType: this.filterType,
      type: t,
      ...i
    };
  }
  resetPlaceholder() {
    const e = this.getLocaleTextFunc(), t = this.translate("dateFormatOoo"), i = e("ariaFilterValue", "Filter Value");
    this.forEachInput((s) => {
      s.setInputPlaceholder(t), s.setInputAriaLabel(i);
    });
  }
  getInputs(e) {
    const { dateConditionFromComps: t, dateConditionToComps: i } = this;
    return e >= t.length ? [null, null] : [t[e], i[e]];
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (i, s, o, n) => {
      s < n && t.push(i.getDate());
    }), t;
  }
  translate(e) {
    return e === "lessThan" ? super.translate("before") : e === "greaterThan" ? super.translate("after") : super.translate(e);
  }
}, Up = class extends E {
  constructor(e, t) {
    super(), this.mapValuesFromModel = e, this.defaultOptions = t;
  }
  init(e) {
    const t = e.filterParams, i = new nd();
    this.optionsFactory = i, i.init(t, this.defaultOptions), this.filterModelFormatter = this.createManagedBean(
      new this.FilterModelFormatterClass(i, t)
    ), this.updateParams(e), this.validateModel(e);
  }
  refresh(e) {
    if (e.source === "colDef") {
      const t = e.filterParams, i = this.optionsFactory;
      i.refresh(t, this.defaultOptions), this.filterModelFormatter.updateParams({ optionsFactory: i, filterParams: t }), this.updateParams(e);
    }
    this.validateModel(e);
  }
  updateParams(e) {
    this.params = e;
  }
  doesFilterPass(e) {
    const t = e.model;
    if (t == null)
      return !0;
    const { operator: i } = t, s = [];
    if (i) {
      const r = t;
      s.push(...r.conditions ?? []);
    } else
      s.push(t);
    const o = i && i === "OR" ? "some" : "every", n = this.params.getValue(e.node);
    return s[o]((r) => this.individualConditionPasses(e, r, n));
  }
  getModelAsString(e, t) {
    return this.filterModelFormatter.getModelAsString(e, t) ?? "";
  }
  validateModel(e) {
    const {
      model: t,
      filterParams: { filterOptions: i, maxNumConditions: s }
    } = e;
    if (t == null)
      return;
    let n = zg(t) ? t.conditions : [t];
    const r = (i == null ? void 0 : i.map((c) => typeof c == "string" ? c : c.displayKey)) ?? this.defaultOptions;
    if (!(!n || n.every((c) => r.find((u) => u === c.type) !== void 0))) {
      this.params = {
        ...e,
        model: null
      }, e.onModelChange(null);
      return;
    }
    let l = !1;
    const d = this.filterType;
    if ((n && !n.every((c) => c.filterType === d) || t.filterType !== d) && (n = n.map((c) => ({ ...c, filterType: d })), l = !0), typeof s == "number" && n && n.length > s && (n = n.slice(0, s), l = !0), l) {
      const c = n.length > 1 ? {
        ...t,
        filterType: d,
        conditions: n
      } : {
        ...n[0],
        filterType: d
      };
      this.params = {
        ...e,
        model: c
      }, e.onModelChange(c);
      return;
    }
  }
  /** returns true if the row passes the said condition */
  individualConditionPasses(e, t, i) {
    const s = this.optionsFactory, o = this.mapValuesFromModel(t, s), n = s.getCustomOption(t.type), r = lD(n, o, i);
    return r ?? (i == null ? this.evaluateNullValue(t.type) : this.evaluateNonNullValue(o, i, t, e));
  }
}, $p = class extends Up {
  evaluateNullValue(e) {
    const {
      includeBlanksInEquals: t,
      includeBlanksInNotEqual: i,
      includeBlanksInGreaterThan: s,
      includeBlanksInLessThan: o,
      includeBlanksInRange: n
    } = this.params.filterParams;
    switch (e) {
      case "equals":
        if (t)
          return !0;
        break;
      case "notEqual":
        if (i)
          return !0;
        break;
      case "greaterThan":
      case "greaterThanOrEqual":
        if (s)
          return !0;
        break;
      case "lessThan":
      case "lessThanOrEqual":
        if (o)
          return !0;
        break;
      case "inRange":
        if (n)
          return !0;
        break;
      case "blank":
        return !0;
      case "notBlank":
        return !1;
    }
    return !1;
  }
  evaluateNonNullValue(e, t, i) {
    const s = i.type;
    if (!this.isValid(t))
      return s === "notEqual" || s === "notBlank";
    const o = this.comparator(), n = e[0] != null ? o(e[0], t) : 0;
    switch (s) {
      case "equals":
        return n === 0;
      case "notEqual":
        return n !== 0;
      case "greaterThan":
        return n > 0;
      case "greaterThanOrEqual":
        return n >= 0;
      case "lessThan":
        return n < 0;
      case "lessThanOrEqual":
        return n <= 0;
      case "inRange": {
        const r = o(e[1], t);
        return this.params.filterParams.inRangeInclusive ? n >= 0 && r <= 0 : n > 0 && r < 0;
      }
      case "blank":
        return ar(t);
      case "notBlank":
        return !ar(t);
      default:
        return I(76, { filterModelType: s }), !0;
    }
  }
}, Kp = {
  equals: "Equals",
  notEqual: "NotEqual",
  greaterThan: "GreaterThan",
  greaterThanOrEqual: "GreaterThanOrEqual",
  lessThan: "LessThan",
  lessThanOrEqual: "LessThanOrEqual",
  inRange: "InRange"
}, uD = {
  contains: "Contains",
  notContains: "NotContains",
  equals: "TextEquals",
  notEqual: "TextNotEqual",
  startsWith: "StartsWith",
  endsWith: "EndsWith",
  inRange: "InRange"
}, ld = class extends E {
  constructor(e, t, i) {
    super(), this.optionsFactory = e, this.filterParams = t, this.valueFormatter = i;
  }
  // used by:
  // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
  // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
  getModelAsString(e, t) {
    const i = this.getLocaleTextFunc(), s = t === "filterToolPanel";
    if (!e)
      return s ? ei(this, "filterSummaryInactive") : null;
    if (e.operator != null) {
      const n = e, a = (n.conditions ?? []).map((d) => this.getModelAsString(d, t)), l = n.operator === "AND" ? "andCondition" : "orCondition";
      return a.join(` ${ei(this, l)} `);
    } else {
      if (e.type === "blank" || e.type === "notBlank")
        return s ? ei(this, e.type === "blank" ? "filterSummaryBlank" : "filterSummaryNotBlank") : i(e.type, e.type);
      {
        const n = e, r = this.optionsFactory.getCustomOption(n.type), { displayKey: a, displayName: l, numberOfInputs: d } = r || {};
        return a && l && d === 0 ? i(a, l) : this.conditionToString(
          n,
          s,
          n.type === "inRange" || d === 2,
          a,
          l
        );
      }
    }
  }
  updateParams(e) {
    const { optionsFactory: t, filterParams: i } = e;
    this.optionsFactory = t, this.filterParams = i;
  }
  conditionForToolPanel(e, t, i, s, o, n) {
    let r;
    const a = this.getTypeKey(e);
    return a && (r = ei(this, a)), o && n && (r = this.getLocaleTextFunc()(o, n)), r != null ? t ? `${r} ${ei(this, "filterSummaryInRangeValues", [i(), s()])}` : `${r} ${i()}` : null;
  }
  getTypeKey(e) {
    const t = this.filterTypeKeys[e];
    return t ? `filterSummary${t}` : null;
  }
  formatValue(e) {
    const t = this.valueFormatter;
    return t ? t(e ?? null) ?? "" : String(e);
  }
}, jp = class extends ld {
  constructor(e, t) {
    super(e, t, (i) => {
      const { dataTypeSvc: s, valueSvc: o } = this.beans, n = t.column, r = s == null ? void 0 : s.getDateFormatterFunction(n), a = r == null ? void 0 : r(i ?? void 0);
      return o.formatValue(n, null, a);
    }), this.filterTypeKeys = Kp;
  }
  conditionToString(e, t, i, s, o) {
    const { type: n } = e, r = ze(e.dateFrom), a = ze(e.dateTo), l = this.filterParams.inRangeFloatingFilterDateFormat, d = t ? this.formatValue.bind(this) : (h) => Na(h, l), c = () => r !== null ? d(r) : "null", u = () => a !== null ? d(a) : "null";
    if (t) {
      const h = this.conditionForToolPanel(
        n,
        i,
        c,
        u,
        s,
        o
      );
      if (h != null)
        return h;
    }
    return i ? `${c()}-${u()}` : r != null ? d(r) : `${n}`;
  }
};
function hD(e, t) {
  const i = t;
  return i < e ? -1 : i > e ? 1 : 0;
}
var gD = class extends $p {
  constructor() {
    super(zp, ad), this.filterType = "date", this.FilterModelFormatterClass = jp;
  }
  comparator() {
    return this.params.filterParams.comparator ?? hD;
  }
  isValid(e) {
    const t = this.params.filterParams.isValidDate;
    return !t || t(e);
  }
}, qp = class extends te {
  constructor() {
    super(...arguments), this.defaultDebounceMs = 0;
  }
  setLastTypeFromModel(e) {
    if (!e) {
      this.lastType = this.optionsFactory.defaultOption;
      return;
    }
    const t = e.operator;
    let i;
    t ? i = e.conditions[0] : i = e, this.lastType = i.type;
  }
  canWeEditAfterModelFromParentFilter(e) {
    if (!e)
      return this.isTypeEditable(this.lastType);
    if (e.operator)
      return !1;
    const i = e;
    return this.isTypeEditable(i.type);
  }
  init(e) {
    this.params = e;
    const t = this.gos.get("enableFilterHandlers");
    if (this.reactive = t, this.setParams(e), t) {
      const i = e;
      this.onModelUpdated(i.model);
    }
  }
  setParams(e) {
    const t = new nd();
    this.optionsFactory = t, t.init(e.filterParams, this.defaultOptions), this.filterModelFormatter = this.createManagedBean(
      new this.FilterModelFormatterClass(t, e.filterParams)
    ), this.setSimpleParams(e, !1);
  }
  setSimpleParams(e, t = !0) {
    const i = this.optionsFactory.defaultOption;
    t || (this.lastType = i), this.readOnly = !!e.filterParams.readOnly;
    const s = this.isTypeEditable(i);
    this.setEditable(s);
  }
  refresh(e) {
    this.params = e;
    const t = e, i = this.reactive;
    if ((!i || t.source === "colDef") && this.updateParams(e), i) {
      const { source: s, model: o } = t;
      if (s === "dataChanged" || s === "ui")
        return;
      this.onModelUpdated(o);
    }
  }
  updateParams(e) {
    const t = this.optionsFactory;
    t.refresh(e.filterParams, this.defaultOptions), this.setSimpleParams(e), this.filterModelFormatter.updateParams({
      optionsFactory: t,
      filterParams: e.filterParams
    });
  }
  onParentModelChanged(e, t) {
    t != null && t.afterFloatingFilter || t != null && t.afterDataChange || this.onModelUpdated(e);
  }
  hasSingleInput(e) {
    var i;
    const t = (i = this.optionsFactory.getCustomOption(e)) == null ? void 0 : i.numberOfInputs;
    return t == null || t == 1;
  }
  isTypeEditable(e) {
    const t = ["inRange", "empty", "blank", "notBlank"];
    return !!e && !this.readOnly && this.hasSingleInput(e) && t.indexOf(e) < 0;
  }
  getAriaLabel(e) {
    return `${this.beans.colNames.getDisplayNameForColumn(e.column, "header", !0)} ${this.getLocaleTextFunc()("ariaFilterInput", "Filter Input")}`;
  }
}, pD = {
  tag: "div",
  cls: "ag-floating-filter-input",
  role: "presentation",
  children: [
    {
      tag: "ag-input-text-field",
      ref: "eReadOnlyText"
    },
    { tag: "div", ref: "eDateWrapper", cls: "ag-date-floating-filter-wrapper" }
  ]
}, fD = class extends qp {
  constructor() {
    super(pD, [wr]), this.eReadOnlyText = _, this.eDateWrapper = _, this.FilterModelFormatterClass = jp, this.filterType = "date", this.defaultOptions = ad;
  }
  setParams(e) {
    super.setParams(e), this.createDateComponent();
    const t = this.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(t("ariaDateFilterInput", "Date Filter Input"));
  }
  updateParams(e) {
    super.updateParams(e), this.dateComp.updateParams(this.getDateComponentParams()), this.updateCompOnModelChange(e.currentParentModel());
  }
  updateCompOnModelChange(e) {
    const t = !this.readOnly && this.canWeEditAfterModelFromParentFilter(e);
    if (this.setEditable(t), t) {
      const i = e ? ze(e.dateFrom) : null;
      this.dateComp.setDate(i), this.eReadOnlyText.setValue("");
    } else
      this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(e)), this.dateComp.setDate(null);
  }
  setEditable(e) {
    le(this.eDateWrapper, e), le(this.eReadOnlyText.getGui(), !e);
  }
  onModelUpdated(e) {
    super.setLastTypeFromModel(e), this.updateCompOnModelChange(e);
  }
  onDateChanged() {
    const e = this.dateComp.getDate();
    if (this.reactive) {
      const t = this.params;
      t.onUiChange();
      const i = t.model, s = Ke(e), o = s == null ? null : {
        ...i ?? {
          filterType: this.filterType,
          type: this.lastType ?? this.optionsFactory.defaultOption
        },
        dateFrom: s
      };
      t.onModelChange(o, { afterFloatingFilter: !0 });
    } else
      this.params.parentFilterInstance((t) => {
        t == null || t.onFloatingFilterChanged(this.lastType || null, e);
      });
  }
  getDateComponentParams() {
    const { filterParams: e } = this.params, t = $l(e, this.defaultDebounceMs);
    return W(this.gos, {
      onDateChanged: De(this, this.onDateChanged.bind(this), t),
      filterParams: e,
      location: "floatingFilter"
    });
  }
  createDateComponent() {
    const {
      beans: { context: e, userCompFactory: t },
      eDateWrapper: i,
      params: s
    } = this;
    this.dateComp = new Wp(
      e,
      t,
      s.column.getColDef(),
      this.getDateComponentParams(),
      i,
      (o) => {
        o.setInputAriaLabel(this.getAriaLabel(s));
      }
    ), this.addDestroyFunc(() => this.dateComp.destroy());
  }
}, mD = {
  tag: "div",
  cls: "ag-filter-filter",
  children: [
    {
      tag: "ag-input-text-field",
      ref: "eDateInput",
      cls: "ag-date-filter"
    }
  ]
}, CD = class extends te {
  constructor() {
    super(mD, [wr]), this.eDateInput = _, this.isApply = !1, this.applyOnFocusOut = !1;
  }
  init(e) {
    this.params = e, this.setParams(e);
    const t = this.eDateInput.getInputElement();
    this.addManagedListeners(t, {
      // ensures that the input element is focussed when a clear button is clicked,
      // unless using safari as there is no clear button and focus does not work properly
      mouseDown: () => {
        this.eDateInput.isDisabled() || this.usingSafariDatePicker || t.focus({ preventScroll: !0 });
      },
      input: this.handleInput.bind(this, !1),
      change: this.handleInput.bind(this, !0),
      focusout: this.handleFocusOut.bind(this)
    });
  }
  handleInput(e) {
    if (!this.eDateInput.isDisabled()) {
      if (this.isApply) {
        this.applyOnFocusOut = !e, e && this.params.onDateChanged();
        return;
      }
      e || this.params.onDateChanged();
    }
  }
  handleFocusOut() {
    this.applyOnFocusOut && (this.applyOnFocusOut = !1, this.params.onDateChanged());
  }
  setParams(e) {
    var h;
    const t = this.eDateInput.getInputElement(), i = this.shouldUseBrowserDatePicker(e);
    this.usingSafariDatePicker = i && hi();
    const { minValidYear: s, maxValidYear: o, minValidDate: n, maxValidDate: r, buttons: a, includeTime: l, colDef: d } = e.filterParams || {}, c = this.beans.dataTypeSvc, u = l ?? ((h = c == null ? void 0 : c.getDateIncludesTimeFlag) == null ? void 0 : h.call(c, d.cellDataType)) ?? !1;
    if (i ? u ? (t.type = "datetime-local", t.step = "1") : t.type = "date" : t.type = "text", n && s && I(85), r && o && I(86), n && r) {
      const [g, p] = [n, r].map(
        (f) => f instanceof Date ? f : ze(f)
      );
      g && p && g.getTime() > p.getTime() && I(87);
    }
    n ? n instanceof Date ? t.min = Na(n) : t.min = n : s && (t.min = `${s}-01-01`), r ? r instanceof Date ? t.max = Na(r) : t.max = r : o && (t.max = `${o}-12-31`), this.isApply = e.location === "floatingFilter" && !!(a != null && a.includes("apply"));
  }
  refresh(e) {
    this.params = e, this.setParams(e);
  }
  getDate() {
    return ze(this.eDateInput.getValue());
  }
  setDate(e) {
    var s;
    const t = this.params.filterParams.colDef.cellDataType, i = ((s = this.beans.dataTypeSvc) == null ? void 0 : s.getDateIncludesTimeFlag(t)) ?? !1;
    this.eDateInput.setValue(Ke(e, i));
  }
  setInputPlaceholder(e) {
    this.eDateInput.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.eDateInput.setAriaLabel(e);
  }
  setDisabled(e) {
    this.eDateInput.setDisabled(e);
  }
  afterGuiAttached(e) {
    (!e || !e.suppressFocus) && this.eDateInput.getInputElement().focus({ preventScroll: !0 });
  }
  shouldUseBrowserDatePicker(e) {
    var t;
    return ((t = e == null ? void 0 : e.filterParams) == null ? void 0 : t.browserDatePicker) ?? !0;
  }
}, dd = [
  "equals",
  "notEqual",
  "greaterThan",
  "greaterThanOrEqual",
  "lessThan",
  "lessThanOrEqual",
  "inRange",
  "blank",
  "notBlank"
];
function al(e) {
  const { allowedCharPattern: t } = e ?? {};
  return t ?? null;
}
function ll(e) {
  return e == null || isNaN(e) ? null : e;
}
function Yp(e, t) {
  const { filter: i, filterTo: s, type: o } = e || {};
  return [ll(i), ll(s)].slice(
    0,
    Mo(o, t)
  );
}
var vD = class extends rd {
  constructor() {
    super("numberFilter", Yp, dd), this.eValuesFrom = [], this.eValuesTo = [], this.filterType = "number", this.defaultDebounceMs = 500;
  }
  setElementValue(e, t, i) {
    const { numberFormatter: s } = this.params, o = !i && s ? s(t ?? null) : t;
    super.setElementValue(e, o);
  }
  createEValue() {
    const e = al(this.params), t = ye({ tag: "div", cls: "ag-filter-body", role: "presentation" });
    return this.createFromToElement(t, this.eValuesFrom, "from", e), this.createFromToElement(t, this.eValuesTo, "to", e), t;
  }
  createFromToElement(e, t, i, s) {
    const o = this.createManagedBean(
      s ? new Ui({ allowedCharPattern: s }) : new Gl()
    );
    o.addCss(`ag-filter-${i}`), o.addCss("ag-filter-filter"), t.push(o), e.appendChild(o.getGui());
  }
  removeEValues(e, t) {
    const i = (s) => this.removeComponents(s, e, t);
    i(this.eValuesFrom), i(this.eValuesTo);
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (i, s, o, n) => {
      s < n && t.push(ll(this.stringToFloat(i.getValue())));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  stringToFloat(e) {
    if (typeof e == "number")
      return e;
    let t = Vt(e);
    t != null && t.trim() === "" && (t = null);
    const i = this.params.numberParser;
    return i ? i(t) : t == null || t.trim() === "-" ? null : parseFloat(t);
  }
  createCondition(e) {
    const t = this.getConditionType(e), i = {
      filterType: this.filterType,
      type: t
    }, s = this.getValues(e);
    return s.length > 0 && (i.filter = s[0]), s.length > 1 && (i.filterTo = s[1]), i;
  }
  getInputs(e) {
    const { eValuesFrom: t, eValuesTo: i } = this;
    return e >= t.length ? [null, null] : [t[e], i[e]];
  }
  hasInvalidInputs() {
    let e = !1;
    return this.forEachInput((t) => {
      if (!t.getInputElement().validity.valid) {
        e = !0;
        return;
      }
    }), e;
  }
}, Qp = class extends ld {
  constructor(e, t) {
    super(e, t, t.numberFormatter), this.filterTypeKeys = Kp;
  }
  conditionToString(e, t, i, s, o) {
    const { filter: n, filterTo: r, type: a } = e, l = this.formatValue.bind(this);
    if (t) {
      const d = this.conditionForToolPanel(
        a,
        i,
        () => l(n),
        () => l(r),
        s,
        o
      );
      if (d != null)
        return d;
    }
    return i ? `${l(n)}-${l(r)}` : n != null ? l(n) : `${a}`;
  }
}, wD = class extends $p {
  constructor() {
    super(Yp, dd), this.filterType = "number", this.FilterModelFormatterClass = Qp;
  }
  comparator() {
    return (e, t) => e === t ? 0 : e < t ? 1 : -1;
  }
  isValid(e) {
    return !isNaN(e);
  }
}, Xp = class extends E {
  constructor(e) {
    super(), this.params = e, this.eInput = _, this.onValueChanged = () => {
    };
  }
  setupGui(e) {
    var s;
    this.eInput = this.createManagedBean(new Ui((s = this.params) == null ? void 0 : s.config));
    const t = this.eInput.getGui();
    e.appendChild(t);
    const i = (o) => this.onValueChanged(o);
    this.addManagedListeners(t, {
      input: i,
      keydown: i
    });
  }
  setEditable(e) {
    this.eInput.setDisabled(!e);
  }
  getValue() {
    return this.eInput.getValue();
  }
  setValue(e, t) {
    this.eInput.setValue(e, t);
  }
  setValueChangedListener(e) {
    this.onValueChanged = e;
  }
  setParams({ ariaLabel: e, autoComplete: t }) {
    const { eInput: i } = this;
    i.setInputAriaLabel(e), t !== void 0 && i.setAutoComplete(t);
  }
};
function dl(e) {
  const t = e == null ? void 0 : e.trim();
  return t === "" ? e : t;
}
function Zp(e, t) {
  const { filter: i, filterTo: s, type: o } = e || {};
  return [i || null, s || null].slice(0, Mo(o, t));
}
var bD = {
  tag: "div",
  ref: "eFloatingFilterInputContainer",
  cls: "ag-floating-filter-input",
  role: "presentation"
}, Jp = class extends qp {
  constructor() {
    super(...arguments), this.eFloatingFilterInputContainer = _, this.defaultDebounceMs = 500;
  }
  postConstruct() {
    this.setTemplate(bD);
  }
  onModelUpdated(e) {
    this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.inputSvc.setValue(this.filterModelFormatter.getModelAsString(e));
  }
  setParams(e) {
    this.setupFloatingFilterInputService(e), super.setParams(e), this.setTextInputParams(e);
  }
  setupFloatingFilterInputService(e) {
    this.inputSvc = this.createFloatingFilterInputService(e), this.inputSvc.setupGui(this.eFloatingFilterInputContainer);
  }
  setTextInputParams(e) {
    const t = e.browserAutoComplete ?? !1, { inputSvc: i, defaultDebounceMs: s, readOnly: o } = this;
    if (i.setParams({
      ariaLabel: this.getAriaLabel(e),
      autoComplete: t
    }), this.applyActive = yr(e.filterParams), !o) {
      const n = $l(e.filterParams, s), r = De(
        this,
        this.syncUpWithParentFilter.bind(this),
        n
      );
      i.setValueChangedListener(r);
    }
  }
  updateParams(e) {
    super.updateParams(e), this.setTextInputParams(e);
  }
  recreateFloatingFilterInputService(e) {
    const { inputSvc: t } = this, i = t.getValue();
    Te(this.eFloatingFilterInputContainer), this.destroyBean(t), this.setupFloatingFilterInputService(e), t.setValue(i, !0);
  }
  syncUpWithParentFilter(e) {
    const t = e.key === P.ENTER, i = this.reactive;
    if (i && this.params.onUiChange(), this.applyActive && !t)
      return;
    const { inputSvc: s, params: o, lastType: n } = this;
    let r = s.getValue();
    if (o.filterParams.trimInput && (r = dl(r), s.setValue(r, !0)), i) {
      const a = o, l = a.model, d = this.convertValue(r), c = d == null ? null : {
        ...l ?? {
          filterType: this.filterType,
          type: n ?? this.optionsFactory.defaultOption
        },
        filter: d
      };
      a.onModelChange(c, { afterFloatingFilter: !0 });
    } else
      o.parentFilterInstance((a) => {
        a == null || a.onFloatingFilterChanged(n || null, r || null);
      });
  }
  convertValue(e) {
    return e || null;
  }
  setEditable(e) {
    this.inputSvc.setEditable(e);
  }
}, yD = class extends E {
  constructor() {
    super(...arguments), this.onValueChanged = () => {
    }, this.numberInputActive = !0;
  }
  setupGui(e) {
    this.eNumberInput = this.createManagedBean(new Gl()), this.eTextInput = this.createManagedBean(new Ui()), this.eTextInput.setDisabled(!0);
    const t = this.eNumberInput.getGui(), i = this.eTextInput.getGui();
    e.appendChild(t), e.appendChild(i), this.setupListeners(t, (s) => this.onValueChanged(s)), this.setupListeners(i, (s) => this.onValueChanged(s));
  }
  setEditable(e) {
    this.numberInputActive = e, this.eNumberInput.setDisplayed(this.numberInputActive), this.eTextInput.setDisplayed(!this.numberInputActive);
  }
  setAutoComplete(e) {
    this.eNumberInput.setAutoComplete(e), this.eTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(e, t) {
    this.getActiveInputElement().setValue(e, t);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eNumberInput : this.eTextInput;
  }
  setValueChangedListener(e) {
    this.onValueChanged = e;
  }
  setupListeners(e, t) {
    this.addManagedListeners(e, {
      input: t,
      keydown: t
    });
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eNumberInput.setInputAriaLabel(e), this.eTextInput.setInputAriaLabel(e);
  }
}, SD = class extends Jp {
  constructor() {
    super(...arguments), this.FilterModelFormatterClass = Qp, this.filterType = "number", this.defaultOptions = dd;
  }
  updateParams(e) {
    al(e.filterParams) !== this.allowedCharPattern && this.recreateFloatingFilterInputService(e), super.updateParams(e);
  }
  createFloatingFilterInputService(e) {
    return this.allowedCharPattern = al(e.filterParams), this.allowedCharPattern ? this.createManagedBean(
      new Xp({
        config: { allowedCharPattern: this.allowedCharPattern }
      })
    ) : this.createManagedBean(new yD());
  }
  convertValue(e) {
    return e ? Number(e) : null;
  }
}, cd = [
  "contains",
  "notContains",
  "equals",
  "notEqual",
  "startsWith",
  "endsWith",
  "blank",
  "notBlank"
], RD = class extends rd {
  constructor() {
    super("textFilter", Zp, cd), this.filterType = "text", this.eValuesFrom = [], this.eValuesTo = [], this.defaultDebounceMs = 500;
  }
  createCondition(e) {
    const t = this.getConditionType(e), i = {
      filterType: this.filterType,
      type: t
    }, s = this.getValues(e);
    return s.length > 0 && (i.filter = s[0]), s.length > 1 && (i.filterTo = s[1]), i;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getInputs(e) {
    const { eValuesFrom: t, eValuesTo: i } = this;
    return e >= t.length ? [null, null] : [t[e], i[e]];
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (i, s, o, n) => {
      s < n && t.push(Vt(i.getValue()));
    }), t;
  }
  createEValue() {
    const e = ye({ tag: "div", cls: "ag-filter-body", role: "presentation" }), { eValuesFrom: t, eValuesTo: i } = this;
    return this.createFromToElement(e, t, "from"), this.createFromToElement(e, i, "to"), e;
  }
  createFromToElement(e, t, i) {
    const s = this.createManagedBean(new Ui());
    s.addCss(`ag-filter-${i}`), s.addCss("ag-filter-filter"), t.push(s), e.appendChild(s.getGui());
  }
  removeEValues(e, t) {
    const i = (n) => this.removeComponents(n, e, t), { eValuesFrom: s, eValuesTo: o } = this;
    i(s), i(o);
  }
}, ef = class extends ld {
  constructor() {
    super(...arguments), this.filterTypeKeys = uD;
  }
  conditionToString(e, t, i, s, o) {
    const { filter: n, filterTo: r, type: a } = e;
    if (t) {
      const l = (c) => () => ei(this, "filterSummaryTextQuote", [c]), d = this.conditionForToolPanel(
        a,
        i,
        l(n),
        l(r),
        s,
        o
      );
      if (d != null)
        return d;
    }
    return i ? `${n}-${r}` : n != null ? `${n}` : `${a}`;
  }
}, xD = ({ filterOption: e, value: t, filterText: i }) => {
  if (i == null)
    return !1;
  switch (e) {
    case "contains":
      return t.indexOf(i) >= 0;
    case "notContains":
      return t.indexOf(i) < 0;
    case "equals":
      return t === i;
    case "notEqual":
      return t != i;
    case "startsWith":
      return t.indexOf(i) === 0;
    case "endsWith": {
      const s = t.lastIndexOf(i);
      return s >= 0 && s === t.length - i.length;
    }
    default:
      return !1;
  }
}, FD = (e) => e, PD = (e) => e == null ? null : e.toString().toLowerCase(), ED = class extends Up {
  constructor() {
    super(Zp, cd), this.filterType = "text", this.FilterModelFormatterClass = ef;
  }
  updateParams(e) {
    super.updateParams(e);
    const t = e.filterParams;
    this.matcher = t.textMatcher ?? xD, this.formatter = t.textFormatter ?? (t.caseSensitive ? FD : PD);
  }
  evaluateNullValue(e) {
    return e ? ["notEqual", "notContains", "blank"].indexOf(e) >= 0 : !1;
  }
  evaluateNonNullValue(e, t, i, s) {
    const o = e.map((h) => this.formatter(h)) || [], n = this.formatter(t), {
      api: r,
      colDef: a,
      column: l,
      context: d,
      filterParams: { textFormatter: c }
    } = this.params;
    if (i.type === "blank")
      return ar(t);
    if (i.type === "notBlank")
      return !ar(t);
    const u = {
      api: r,
      colDef: a,
      column: l,
      context: d,
      node: s.node,
      data: s.data,
      filterOption: i.type,
      value: n,
      textFormatter: c
    };
    return o.some((h) => this.matcher({ ...u, filterText: h }));
  }
  processModelToApply(e) {
    if (e && this.params.filterParams.trimInput) {
      const t = (i) => {
        const s = {
          ...i
        }, { filter: o, filterTo: n } = i;
        return o && (s.filter = dl(o) ?? null), n && (s.filterTo = dl(n) ?? null), s;
      };
      return zg(e) ? {
        ...e,
        conditions: e.conditions.map(t)
      } : t(e);
    }
    return e;
  }
}, DD = class extends Jp {
  constructor() {
    super(...arguments), this.FilterModelFormatterClass = ef, this.filterType = "text", this.defaultOptions = cd;
  }
  createFloatingFilterInputService() {
    return this.createManagedBean(new Xp());
  }
};
function TD(e) {
  var t;
  return !!((t = e.quickFilter) != null && t.isFilterPresent());
}
function MD(e) {
  var t;
  return (t = e.quickFilter) == null ? void 0 : t.getText();
}
function AD(e) {
  var t;
  (t = e.quickFilter) == null || t.resetCache();
}
var ID = class extends E {
  constructor() {
    super(...arguments), this.beanName = "quickFilter", this.quickFilter = null, this.quickFilterParts = null;
  }
  postConstruct() {
    const e = this.resetCache.bind(this), t = this.gos;
    this.addManagedEventListeners({
      columnPivotModeChanged: e,
      newColumnsLoaded: e,
      columnRowGroupChanged: e,
      columnVisible: () => {
        t.get("includeHiddenColumnsInQuickFilter") || this.resetCache();
      }
    }), this.addManagedPropertyListener("quickFilterText", (i) => this.setFilter(i.currentValue)), this.addManagedPropertyListeners(
      ["includeHiddenColumnsInQuickFilter", "applyQuickFilterBeforePivotOrAgg"],
      () => this.onColumnConfigChanged()
    ), this.quickFilter = this.parseFilter(t.get("quickFilterText")), this.parser = t.get("quickFilterParser"), this.matcher = t.get("quickFilterMatcher"), this.setFilterParts(), this.addManagedPropertyListeners(["quickFilterMatcher", "quickFilterParser"], () => this.setParserAndMatcher());
  }
  // if we are using autoGroupCols, then they should be included for quick filter. this covers the
  // following scenarios:
  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
  refreshCols() {
    var l;
    const { autoColSvc: e, colModel: t, gos: i, pivotResultCols: s } = this.beans, o = t.isPivotMode(), n = e == null ? void 0 : e.getColumns(), r = t.getColDefCols();
    let a = (o && !i.get("applyQuickFilterBeforePivotOrAgg") ? (l = s == null ? void 0 : s.getPivotResultCols()) == null ? void 0 : l.list : r) ?? [];
    n && (a = a.concat(n)), this.colsToUse = i.get("includeHiddenColumnsInQuickFilter") ? a : a.filter((d) => d.isVisible() || d.isRowGroupActive());
  }
  isFilterPresent() {
    return this.quickFilter !== null;
  }
  doesRowPass(e) {
    const t = this.gos.get("cacheQuickFilter");
    return this.matcher ? this.doesRowPassMatcher(t, e) : this.quickFilterParts.every(
      (i) => t ? this.doesRowPassCache(e, i) : this.doesRowPassNoCache(e, i)
    );
  }
  resetCache() {
    this.beans.rowModel.forEachNode((e) => e.quickFilterAggregateText = null);
  }
  getText() {
    return this.gos.get("quickFilterText");
  }
  setFilterParts() {
    const { quickFilter: e, parser: t } = this;
    e ? this.quickFilterParts = t ? t(e) : e.split(" ") : this.quickFilterParts = null;
  }
  parseFilter(e) {
    return H(e) ? e.toUpperCase() : null;
  }
  setFilter(e) {
    if (e != null && typeof e != "string") {
      I(70, { newFilter: e });
      return;
    }
    const t = this.parseFilter(e);
    this.quickFilter !== t && (this.quickFilter = t, this.setFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  setParserAndMatcher() {
    const e = this.gos.get("quickFilterParser"), t = this.gos.get("quickFilterMatcher"), i = e !== this.parser || t !== this.matcher;
    this.parser = e, this.matcher = t, i && (this.setFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  onColumnConfigChanged() {
    this.refreshCols(), this.resetCache(), this.isFilterPresent() && this.dispatchLocalEvent({ type: "quickFilterChanged" });
  }
  doesRowPassNoCache(e, t) {
    return this.colsToUse.some((i) => {
      const s = this.getTextForColumn(i, e);
      return H(s) && s.indexOf(t) >= 0;
    });
  }
  doesRowPassCache(e, t) {
    return this.checkGenerateAggText(e), e.quickFilterAggregateText.indexOf(t) >= 0;
  }
  doesRowPassMatcher(e, t) {
    let i;
    e ? (this.checkGenerateAggText(t), i = t.quickFilterAggregateText) : i = this.getAggText(t);
    const { quickFilterParts: s, matcher: o } = this;
    return o(s, i);
  }
  checkGenerateAggText(e) {
    e.quickFilterAggregateText || (e.quickFilterAggregateText = this.getAggText(e));
  }
  getTextForColumn(e, t) {
    let i = this.beans.filterValueSvc.getValue(e, t);
    const s = e.getColDef();
    if (s.getQuickFilterText) {
      const o = W(this.gos, {
        value: i,
        node: t,
        data: t.data,
        column: e,
        colDef: s
      });
      i = s.getQuickFilterText(o);
    }
    return H(i) ? i.toString().toUpperCase() : null;
  }
  getAggText(e) {
    const t = [];
    return this.colsToUse.forEach((i) => {
      const s = this.getTextForColumn(i, e);
      H(s) && t.push(s);
    }), t.join(`
`);
  }
}, kD = {
  moduleName: "ClientSideRowModelFilter",
  version: B,
  rowModels: ["clientSide"],
  beans: [LE]
}, ud = {
  moduleName: "FilterCore",
  version: B,
  beans: [iD],
  apiFunctions: {
    isAnyFilterPresent: eD,
    onFilterChanged: tD
  },
  css: [VE],
  dependsOn: [kD]
}, tf = {
  moduleName: "FilterValue",
  version: B,
  beans: [oD]
}, Er = {
  moduleName: "ColumnFilter",
  version: B,
  beans: [JE, sD],
  dynamicBeans: { headerFilterCellCtrl: OE },
  icons: {
    // open filter button - header, floating filter, menu
    filter: "filter",
    // filter is applied - header (legacy column menu), filter tool panel
    filterActive: "filter"
  },
  apiFunctions: {
    isColumnFilterPresent: NE,
    getColumnFilterInstance: WE,
    destroyFilter: zE,
    setFilterModel: UE,
    getFilterModel: $E,
    getColumnFilterModel: KE,
    setColumnFilterModel: jE,
    showColumnFilter: qE,
    hideColumnFilter: YE,
    getColumnFilterHandler: QE,
    doFilterAction: XE
  },
  dependsOn: [ud, Pr, tf, BE]
}, LD = {
  moduleName: "CustomFilter",
  version: B,
  userComponents: { agReadOnlyFloatingFilter: rD },
  dependsOn: [Er]
}, OD = {
  moduleName: "TextFilter",
  version: B,
  dependsOn: [Er],
  userComponents: {
    agTextColumnFilter: {
      classImp: RD,
      params: {
        useForm: !0
      }
    },
    agTextColumnFloatingFilter: DD
  },
  dynamicBeans: {
    agTextColumnFilterHandler: ED
  }
}, _D = {
  moduleName: "NumberFilter",
  version: B,
  dependsOn: [Er],
  userComponents: {
    agNumberColumnFilter: {
      classImp: vD,
      params: {
        useForm: !0
      }
    },
    agNumberColumnFloatingFilter: SD
  },
  dynamicBeans: {
    agNumberColumnFilterHandler: wD
  }
}, HD = {
  moduleName: "DateFilter",
  version: B,
  dependsOn: [Er],
  userComponents: {
    agDateColumnFilter: {
      classImp: cD,
      params: {
        useForm: !0
      }
    },
    agDateInput: CD,
    agDateColumnFloatingFilter: fD
  },
  dynamicBeans: {
    agDateColumnFilterHandler: gD
  }
}, BD = {
  moduleName: "QuickFilterCore",
  version: B,
  rowModels: ["clientSide"],
  beans: [ID],
  dependsOn: [ud, tf]
}, GD = {
  moduleName: "QuickFilter",
  version: B,
  apiFunctions: {
    isQuickFilterPresent: TD,
    getQuickFilter: MD,
    resetQuickFilter: AD
  },
  dependsOn: [BD]
}, VD = {
  moduleName: "ExternalFilter",
  version: B,
  dependsOn: [ud]
}, ND = (
  /*css*/
  ".ag-tooltip{background-color:var(--ag-tooltip-background-color);border:var(--ag-tooltip-border);border-radius:var(--ag-border-radius);color:var(--ag-tooltip-text-color);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;white-space:normal;z-index:99999;&:where(.ag-cell-editor-tooltip){background-color:var(--ag-tooltip-error-background-color);border:var(--ag-tooltip-error-border);color:var(--ag-tooltip-error-text-color);font-weight:500}}.ag-tooltip-custom{position:absolute;z-index:99999}.ag-tooltip-custom:where(:not(.ag-tooltip-interactive)),.ag-tooltip:where(:not(.ag-tooltip-interactive)){pointer-events:none}.ag-tooltip-animate{transition:opacity 1s;&:where(.ag-tooltip-hiding){opacity:0}}"
), fa = (e, t, i) => {
  var a, l, d;
  const { editModelSvc: s } = e, o = (l = (a = s == null ? void 0 : s.getCellValidationModel()) == null ? void 0 : a.getCellValidation(t)) == null ? void 0 : l.errorMessages, n = (d = s == null ? void 0 : s.getRowValidationModel().getRowValidation(t)) == null ? void 0 : d.errorMessages, r = o || n;
  return r && r.length ? r.join(i("tooltipValidationErrorSeparator", ". ")) : void 0;
}, WD = class extends E {
  constructor() {
    super(...arguments), this.beanName = "tooltipSvc";
  }
  setupHeaderTooltip(e, t, i, s) {
    e && t.destroyBean(e);
    const o = pa(this.gos), { column: n, eGui: r } = t, a = n.getColDef();
    !s && o && !a.headerComponent && (s = xn(
      () => r.querySelector(".ag-header-cell-text")
    ));
    const l = {
      getGui: () => r,
      getLocation: () => "header",
      getTooltipValue: () => i ?? n.getColDef().headerTooltip,
      shouldDisplayTooltip: s,
      getAdditionalParams: () => ({
        column: n,
        colDef: n.getColDef()
      })
    };
    let d = this.createTooltipFeature(l);
    return d && (d = t.createBean(d), t.setRefreshFunction("tooltip", () => d.refreshTooltip())), d;
  }
  setupHeaderGroupTooltip(e, t, i, s) {
    e && t.destroyBean(e);
    const o = pa(this.gos), { column: n, eGui: r } = t, a = n.getColGroupDef();
    !s && o && !(a != null && a.headerGroupComponent) && (s = xn(
      () => r.querySelector(".ag-header-group-text")
    ));
    const l = {
      getGui: () => r,
      getLocation: () => "headerGroup",
      getTooltipValue: () => i ?? (a && a.headerTooltip),
      shouldDisplayTooltip: s,
      getAdditionalParams: () => {
        const c = {
          column: n
        };
        return a && (c.colDef = a), c;
      }
    }, d = this.createTooltipFeature(l);
    return d && t.createBean(d);
  }
  enableCellTooltipFeature(e, t, i) {
    const { beans: s } = this, { gos: o, editSvc: n } = s, { column: r, rowNode: a } = e;
    let l = "cell";
    const d = () => {
      const g = !!!(n != null && n.isEditing(e)) && fa(s, e, this.getLocaleTextFunc());
      if (g)
        return l = "cellEditor", g;
      l = "cell";
      const p = r.getColDef(), f = a.data;
      if (p.tooltipField && H(f))
        return no(f, p.tooltipField, r.isTooltipFieldContainsDots());
      const m = p.tooltipValueGetter;
      return m ? m(
        W(o, {
          location: "cell",
          colDef: r.getColDef(),
          column: r,
          rowIndex: e.cellPosition.rowIndex,
          node: a,
          data: a.data,
          value: e.value,
          valueFormatted: e.valueFormatted
        })
      ) : null;
    }, c = pa(o);
    i || (c && !e.isCellRenderer() ? i = () => {
      const h = !!(n != null && n.isEditing(e));
      if (!h && fa(s, e, this.getLocaleTextFunc()))
        return !0;
      if (!r.isTooltipEnabled())
        return !1;
      const f = xn(() => {
        const m = e.eGui;
        return m.children.length === 0 ? m : m.querySelector(".ag-cell-value");
      });
      return !h && f();
    } : i = () => !(n != null && n.isEditing(e)));
    const u = {
      getGui: () => e.eGui,
      getLocation: () => l,
      getTooltipValue: t != null ? () => t : d,
      shouldDisplayTooltip: i,
      getAdditionalParams: () => ({
        column: r,
        colDef: r.getColDef(),
        rowIndex: e.cellPosition.rowIndex,
        node: a,
        data: a.data,
        valueFormatted: e.valueFormatted
      })
    };
    return this.createTooltipFeature(u, s);
  }
  setupFullWidthRowTooltip(e, t, i, s) {
    const o = {
      getGui: () => t.getFullWidthElement(),
      getTooltipValue: () => i,
      getLocation: () => "fullWidthRow",
      shouldDisplayTooltip: s
    }, n = this.beans, r = n.context;
    e && t.destroyBean(e, r);
    const a = this.createTooltipFeature(o, n);
    if (a)
      return t.createBean(a, r);
  }
  setupCellEditorTooltip(e, t) {
    var a, l;
    const { beans: i } = this, { context: s } = i, o = ((a = t.getValidationElement) == null ? void 0 : a.call(t, !0)) || !((l = t.isPopup) != null && l.call(t)) && e.eGui;
    if (!o)
      return;
    const n = {
      getGui: () => o,
      getTooltipValue: () => fa(i, e, this.getLocaleTextFunc()),
      getLocation: () => "cellEditor",
      shouldDisplayTooltip: () => {
        var p, f;
        const { editModelSvc: d } = i, c = (p = d == null ? void 0 : d.getRowValidationModel()) == null ? void 0 : p.getRowValidationMap(), u = (f = d == null ? void 0 : d.getCellValidationModel()) == null ? void 0 : f.getCellValidationMap(), h = !!c && c.size > 0, g = !!u && u.size > 0;
        return h || g;
      }
    }, r = this.createTooltipFeature(n, i);
    if (r)
      return e.createBean(r, s);
  }
  initCol(e) {
    const { colDef: t } = e;
    e.tooltipEnabled = H(t.tooltipField) || H(t.tooltipValueGetter) || H(t.tooltipComponent);
  }
  createTooltipFeature(e, t) {
    return this.beans.registry.createDynamicBean("tooltipFeature", !1, e, t);
  }
}, zD = class extends cb {
  createTooltipComp(e, t) {
    const i = tw(this.beans.userCompFactory, e);
    i == null || i.newAgStackInstance().then(t);
  }
  setEventHandlers(e) {
    [this.onColumnMovedEventCallback] = this.addManagedEventListeners({
      columnMoved: e
    });
  }
  clearEventHandlers() {
    var e;
    (e = this.onColumnMovedEventCallback) == null || e.call(this), this.onColumnMovedEventCallback = void 0;
  }
}, sf = {
  moduleName: "Tooltip",
  version: B,
  beans: [WD],
  dynamicBeans: {
    tooltipFeature: _g,
    highlightTooltipFeature: ub,
    tooltipStateManager: zD
  },
  userComponents: {
    agTooltipComponent: pb
  },
  dependsOn: [Pr],
  css: [ND]
}, ts = class {
  constructor(e) {
    this.cellValueChanges = e;
  }
}, ma = class extends ts {
  constructor(e, t, i, s) {
    super(e), this.initialRange = t, this.finalRange = i, this.ranges = s;
  }
}, UD = 10, eu = class {
  constructor(e) {
    this.actionStack = [], this.maxStackSize = e || UD, this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(e) {
    e.cellValueChanges && e.cellValueChanges.length > 0 && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e));
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
}, $D = class extends E {
  constructor() {
    super(...arguments), this.beanName = "undoRedo", this.cellValueChanges = [], this.activeCellEdit = null, this.activeRowEdit = null, this.isPasting = !1, this.isRangeInAction = !1, this.batchEditing = !1, this.bulkEditing = !1, this.onCellValueChanged = (e) => {
      const t = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned }, i = this.activeCellEdit !== null && cp(this.activeCellEdit, t), s = this.activeRowEdit !== null && rR(this.activeRowEdit, t);
      if (!(i || s || this.isPasting || this.isRangeInAction))
        return;
      const { rowPinned: n, rowIndex: r, column: a, oldValue: l, value: d } = e, c = {
        rowPinned: n,
        rowIndex: r,
        columnId: a.getColId(),
        newValue: d,
        oldValue: l
      };
      this.cellValueChanges.push(c);
    }, this.clearStacks = () => {
      this.undoStack.clear(), this.redoStack.clear();
    };
  }
  postConstruct() {
    const { gos: e, ctrlsSvc: t } = this.beans;
    if (!e.get("undoRedoCellEditing"))
      return;
    const i = e.get("undoRedoCellEditingLimit");
    if (i <= 0)
      return;
    this.undoStack = new eu(i), this.redoStack = new eu(i), this.addListeners();
    const s = this.clearStacks.bind(this);
    this.addManagedEventListeners({
      cellValueChanged: this.onCellValueChanged.bind(this),
      // undo / redo is restricted to actual editing so we clear the stacks when other operations are
      // performed that change the order of the row / cols.
      modelUpdated: (o) => {
        o.keepUndoRedoStack || this.clearStacks();
      },
      columnPivotModeChanged: s,
      newColumnsLoaded: s,
      columnGroupOpened: s,
      columnRowGroupChanged: s,
      columnMoved: s,
      columnPinned: s,
      columnVisible: s,
      rowDragEnd: s
    }), t.whenReady(this, (o) => {
      this.gridBodyCtrl = o.gridBodyCtrl;
    });
  }
  getCurrentUndoStackSize() {
    var e;
    return ((e = this.undoStack) == null ? void 0 : e.getCurrentStackSize()) ?? 0;
  }
  getCurrentRedoStackSize() {
    var e;
    return ((e = this.redoStack) == null ? void 0 : e.getCurrentStackSize()) ?? 0;
  }
  undo(e) {
    const { eventSvc: t, undoStack: i, redoStack: s } = this;
    t.dispatchEvent({
      type: "undoStarted",
      source: e
    });
    const o = this.undoRedo(i, s, "initialRange", "oldValue", "undo");
    t.dispatchEvent({
      type: "undoEnded",
      source: e,
      operationPerformed: o
    });
  }
  redo(e) {
    const { eventSvc: t, undoStack: i, redoStack: s } = this;
    t.dispatchEvent({
      type: "redoStarted",
      source: e
    });
    const o = this.undoRedo(s, i, "finalRange", "newValue", "redo");
    t.dispatchEvent({
      type: "redoEnded",
      source: e,
      operationPerformed: o
    });
  }
  undoRedo(e, t, i, s, o) {
    if (!e)
      return !1;
    const n = e.pop();
    return !n || !n.cellValueChanges ? !1 : (this.processAction(
      n,
      (r) => r[s],
      o
    ), n instanceof ma ? this.processRange(n.ranges || [n[i]]) : this.processCell(n.cellValueChanges), t.push(n), !0);
  }
  processAction(e, t, i) {
    e.cellValueChanges.forEach((s) => {
      const { rowIndex: o, rowPinned: n, columnId: r } = s, a = { rowIndex: o, rowPinned: n }, l = Ut(this.beans, a);
      l.displayed && l.setDataValue(r, t(s), i);
    });
  }
  processRange(e) {
    let t;
    const i = this.beans.rangeSvc;
    i.removeAllCellRanges(!0), e.forEach((s, o) => {
      if (!s)
        return;
      const n = s.startRow, r = s.endRow;
      o === e.length - 1 && (t = {
        rowPinned: n.rowPinned,
        rowIndex: n.rowIndex,
        columnId: s.startColumn.getColId()
      }, this.setLastFocusedCell(t));
      const a = {
        rowStartIndex: n.rowIndex,
        rowStartPinned: n.rowPinned,
        rowEndIndex: r.rowIndex,
        rowEndPinned: r.rowPinned,
        columnStart: s.startColumn,
        columns: s.columns
      };
      i.addCellRange(a);
    });
  }
  processCell(e) {
    const t = e[0], { rowIndex: i, rowPinned: s } = t, o = { rowIndex: i, rowPinned: s }, n = Ut(this.beans, o), r = {
      rowPinned: t.rowPinned,
      rowIndex: n.rowIndex,
      columnId: t.columnId
    };
    this.setLastFocusedCell(r);
  }
  setLastFocusedCell(e) {
    const { rowIndex: t, columnId: i, rowPinned: s } = e, { colModel: o, focusSvc: n, rangeSvc: r } = this.beans, a = o.getCol(i);
    if (!a)
      return;
    const { scrollFeature: l } = this.gridBodyCtrl;
    l.ensureIndexVisible(t), l.ensureColumnVisible(a);
    const d = { rowIndex: t, column: a, rowPinned: s };
    n.setFocusedCell({ ...d, forceBrowserFocus: !0 }), r == null || r.setRangeToCell(d);
  }
  addListeners() {
    this.addManagedEventListeners({
      rowEditingStarted: (e) => {
        this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      rowEditingStopped: () => {
        const e = new ts(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.activeRowEdit = null;
      },
      cellEditingStarted: (e) => {
        this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      cellEditingStopped: (e) => {
        if (this.activeCellEdit = null, e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
          const i = new ts(this.cellValueChanges);
          this.pushActionsToUndoStack(i);
        }
      },
      pasteStart: () => {
        this.isPasting = !0;
      },
      pasteEnd: () => {
        const e = new ts(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.isPasting = !1;
      },
      fillStart: () => {
        this.isRangeInAction = !0;
      },
      fillEnd: (e) => {
        const t = new ma(this.cellValueChanges, e.initialRange, e.finalRange);
        this.pushActionsToUndoStack(t), this.isRangeInAction = !1;
      },
      keyShortcutChangedCellStart: () => {
        this.isRangeInAction = !0;
      },
      keyShortcutChangedCellEnd: () => {
        let e;
        const { rangeSvc: t, gos: i } = this.beans;
        t && zt(i) ? e = new ma(this.cellValueChanges, void 0, void 0, [
          ...t.getCellRanges()
        ]) : e = new ts(this.cellValueChanges), this.pushActionsToUndoStack(e), this.isRangeInAction = !1;
      },
      batchEditingStarted: () => this.startBigChange("batchEditing"),
      batchEditingStopped: ({ changes: e }) => this.stopBigChange("batchEditing", e),
      bulkEditingStarted: () => this.startBigChange("bulkEditing"),
      bulkEditingStopped: ({ changes: e }) => this.stopBigChange("bulkEditing", e)
    });
  }
  startBigChange(e) {
    this[e] = !0;
  }
  stopBigChange(e, t) {
    if (!this[e] || (this[e] = !1, (t == null ? void 0 : t.length) === 0))
      return;
    const i = new ts(t ?? []);
    this.pushActionsToUndoStack(i), this.cellValueChanges = [];
  }
  pushActionsToUndoStack(e) {
    this.undoStack.push(e), this.cellValueChanges = [], this.redoStack.clear();
  }
}, KD = (
  /*css*/
  ".ag-cell-inline-editing{border:var(--ag-cell-editing-border)!important;border-radius:var(--ag-border-radius);box-shadow:var(--ag-cell-editing-shadow);padding:0;z-index:1;.ag-cell-edit-wrapper,.ag-cell-editor,.ag-cell-wrapper,:where(.ag-cell-editor) .ag-input-field-input,:where(.ag-cell-editor) .ag-wrapper{height:100%;line-height:normal;min-height:100%;width:100%}&.ag-cell-editing-error{border-color:var(--ag-invalid-color)!important}}:where(.ag-popup-editor) .ag-large-text{background-color:var(--ag-background-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);padding:0}.ag-large-text-input{display:block;height:auto;padding:var(--ag-cell-horizontal-padding)}:where(.ag-rtl .ag-large-text-input) textarea{resize:none}:where(.ag-ltr) .ag-checkbox-edit{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-checkbox-edit{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-row.ag-row-editing-invalid .ag-cell-inline-editing){opacity:.8}.ag-popup-editor{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}"
), jD = {
  tag: "div",
  cls: "ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit",
  children: [
    {
      tag: "ag-checkbox",
      ref: "eEditor",
      role: "presentation"
    }
  ]
}, qD = class extends Rr {
  constructor() {
    super(jD, [Bl]), this.eEditor = _;
  }
  initialiseEditor(e) {
    const t = e.value ?? void 0, i = this.eEditor;
    i.setValue(t), i.getInputElement().setAttribute("tabindex", "-1"), this.setAriaLabel(t), this.addManagedListeners(i, {
      fieldValueChanged: (o) => this.setAriaLabel(o.selected)
    });
  }
  getValue() {
    return this.eEditor.getValue();
  }
  focusIn() {
    this.eEditor.getFocusableElement().focus();
  }
  afterGuiAttached() {
    this.params.cellStartedEdit && this.focusIn();
  }
  isPopup() {
    return !1;
  }
  setAriaLabel(e) {
    const t = this.getLocaleTextFunc(), i = Cr(t, e), s = t("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eEditor.setInputAriaLabel(`${s} (${i})`);
  }
  getValidationElement(e) {
    return e ? this.params.eGridCell : this.eEditor.getInputElement();
  }
  getValidationErrors() {
    const { params: e } = this, { getValidationErrors: t } = e, i = this.getValue();
    return t ? t({
      value: i,
      internalErrors: null,
      cellEditorParams: e
    }) : null;
  }
}, Dr = class extends Rr {
  constructor(e) {
    super(), this.cellEditorInput = e, this.eEditor = _;
  }
  initialiseEditor(e) {
    const { cellEditorInput: t } = this;
    this.setTemplate(
      { tag: "div", cls: "ag-cell-edit-wrapper", children: [t.getTemplate()] },
      t.getAgComponents()
    );
    const { eEditor: i } = this, { cellStartedEdit: s, eventKey: o, suppressPreventDefault: n } = e;
    i.getInputElement().setAttribute("title", ""), t.init(i, e);
    let r, a = !0;
    s ? (this.focusAfterAttached = !0, o === P.BACKSPACE || o === P.DELETE ? r = "" : o && o.length === 1 ? n ? a = !1 : r = o : (r = t.getStartValue(), o !== P.F2 && (this.highlightAllOnFocus = !0))) : (this.focusAfterAttached = !1, r = t.getStartValue()), a && r != null && i.setStartValue(r), this.addGuiEventListener("keydown", (l) => {
      const { key: d } = l;
      (d === P.PAGE_UP || d === P.PAGE_DOWN) && l.preventDefault();
    });
  }
  afterGuiAttached() {
    var s, o;
    const e = this.getLocaleTextFunc(), t = this.eEditor;
    if (t.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), !this.focusAfterAttached)
      return;
    hi() || t.getFocusableElement().focus();
    const i = t.getInputElement();
    this.highlightAllOnFocus ? i.select() : (o = (s = this.cellEditorInput).setCaret) == null || o.call(s);
  }
  // gets called when tabbing through cells and in full row edit mode
  focusIn() {
    const { eEditor: e } = this, t = e.getFocusableElement(), i = e.getInputElement();
    t.focus(), i.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return !1;
  }
  getValidationElement() {
    return this.eEditor.getInputElement();
  }
  getValidationErrors() {
    return this.cellEditorInput.getValidationErrors();
  }
}, YD = {
  tag: "ag-input-date-field",
  ref: "eEditor",
  cls: "ag-cell-editor"
}, QD = class {
  constructor(e, t) {
    this.getDataTypeService = e, this.getLocaleTextFunc = t;
  }
  getTemplate() {
    return YD;
  }
  getAgComponents() {
    return [Eg];
  }
  init(e, t) {
    var r, a;
    this.eEditor = e, this.params = t;
    const { min: i, max: s, step: o, colDef: n } = t;
    i != null && e.setMin(i), s != null && e.setMax(s), o != null && e.setStep(o), this.includeTime = t.includeTime ?? ((a = (r = this.getDataTypeService()) == null ? void 0 : r.getDateIncludesTimeFlag) == null ? void 0 : a.call(r, n.cellDataType)), this.includeTime != null && e.setIncludeTime(this.includeTime);
  }
  getValidationErrors() {
    const t = this.eEditor.getInputElement().valueAsDate, { params: i } = this, { min: s, max: o, getValidationErrors: n } = i;
    let r = [];
    const a = this.getLocaleTextFunc();
    if (t instanceof Date && !isNaN(t.getTime())) {
      if (s) {
        const l = s instanceof Date ? s : new Date(s);
        if (t < l) {
          const d = l.toLocaleDateString();
          r.push(
            a("minDateValidation", `Date must be after ${d}`, [d])
          );
        }
      }
      if (o) {
        const l = o instanceof Date ? o : new Date(o);
        if (t > l) {
          const d = l.toLocaleDateString();
          r.push(
            a("maxDateValidation", `Date must be before ${d}`, [d])
          );
        }
      }
    }
    return r.length || (r = null), n ? n({ value: t, cellEditorParams: i, internalErrors: r }) : r;
  }
  getValue() {
    const { eEditor: e, params: t } = this, i = e.getDate();
    return !H(i) && !H(t.value) ? t.value : i ?? null;
  }
  getStartValue() {
    const { value: e } = this.params;
    if (e instanceof Date)
      return Ke(e, this.includeTime ?? !1);
  }
}, XD = class extends Dr {
  constructor() {
    super(
      new QD(
        () => this.beans.dataTypeSvc,
        () => this.getLocaleTextFunc()
      )
    );
  }
}, ZD = {
  tag: "ag-input-date-field",
  ref: "eEditor",
  cls: "ag-cell-editor"
}, JD = class {
  constructor(e, t) {
    this.getDataTypeService = e, this.getLocaleTextFunc = t;
  }
  getTemplate() {
    return ZD;
  }
  getAgComponents() {
    return [Eg];
  }
  init(e, t) {
    var r, a;
    this.eEditor = e, this.params = t;
    const { min: i, max: s, step: o, colDef: n } = t;
    i != null && e.setMin(i), s != null && e.setMax(s), o != null && e.setStep(o), this.includeTime = t.includeTime ?? ((a = (r = this.getDataTypeService()) == null ? void 0 : r.getDateIncludesTimeFlag) == null ? void 0 : a.call(r, n.cellDataType)), this.includeTime != null && e.setIncludeTime(this.includeTime);
  }
  getValidationErrors() {
    const { eEditor: e, params: t } = this, i = e.getInputElement().value, s = this.formatDate(this.parseDate(i ?? void 0)), { min: o, max: n, getValidationErrors: r } = t;
    let a = [];
    if (s) {
      const l = new Date(s), d = this.getLocaleTextFunc();
      if (o) {
        const c = new Date(o);
        if (l < c) {
          const u = c.toLocaleDateString();
          a.push(
            d("minDateValidation", `Date must be after ${u}`, [u])
          );
        }
      }
      if (n) {
        const c = new Date(n);
        if (l > c) {
          const u = c.toLocaleDateString();
          a.push(
            d("maxDateValidation", `Date must be before ${u}`, [u])
          );
        }
      }
    }
    return a.length || (a = null), r ? r({
      value: this.getValue(),
      cellEditorParams: t,
      internalErrors: a
    }) : a;
  }
  getValue() {
    const { params: e, eEditor: t } = this, i = this.formatDate(t.getDate());
    return !H(i) && !H(e.value) ? e.value : e.parseValue(i ?? "");
  }
  getStartValue() {
    return Ke(this.parseDate(this.params.value ?? void 0) ?? null, this.includeTime ?? !1);
  }
  parseDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateParserFunction(this.params.column)(e) : ze(e) ?? void 0;
  }
  formatDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateFormatterFunction(this.params.column)(e) : Ke(e ?? null, this.includeTime ?? !1) ?? void 0;
  }
}, eT = class extends Dr {
  constructor() {
    super(
      new JD(
        () => this.beans.dataTypeSvc,
        () => this.getLocaleTextFunc()
      )
    );
  }
}, tT = {
  tag: "div",
  cls: "ag-large-text",
  children: [
    {
      tag: "ag-input-text-area",
      ref: "eEditor",
      cls: "ag-large-text-input"
    }
  ]
}, iT = class extends Rr {
  constructor() {
    super(tT, [ww]), this.eEditor = _;
  }
  initialiseEditor(e) {
    const { eEditor: t } = this, { cellStartedEdit: i, eventKey: s, maxLength: o, cols: n, rows: r } = e;
    this.focusAfterAttached = i, t.getInputElement().setAttribute("title", ""), t.setMaxLength(o || 200).setCols(n || 60).setRows(r || 10);
    let a;
    i ? (this.focusAfterAttached = !0, s === P.BACKSPACE || s === P.DELETE ? a = "" : s && s.length === 1 ? a = s : (a = this.getStartValue(e), s !== P.F2 && (this.highlightAllOnFocus = !0))) : (this.focusAfterAttached = !1, a = this.getStartValue(e)), a != null && t.setValue(a, !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.activateTabIndex();
  }
  getStartValue(e) {
    const { value: t } = e;
    return (t == null ? void 0 : t.toString()) ?? t;
  }
  onKeyDown(e) {
    const t = e.key;
    (t === P.LEFT || t === P.UP || t === P.RIGHT || t === P.DOWN || e.shiftKey && t === P.ENTER) && e.stopPropagation();
  }
  afterGuiAttached() {
    const { eEditor: e, focusAfterAttached: t, highlightAllOnFocus: i } = this, s = this.getLocaleTextFunc();
    e.setInputAriaLabel(s("ariaInputEditor", "Input Editor")), t && (e.getFocusableElement().focus(), i && e.getInputElement().select());
  }
  getValue() {
    const { eEditor: e, params: t } = this, { value: i } = t, s = e.getValue();
    return !H(s) && !H(i) ? i : t.parseValue(s);
  }
  getValidationElement() {
    return this.eEditor.getInputElement();
  }
  getValidationErrors() {
    const { params: e } = this, { maxLength: t, getValidationErrors: i } = e, s = this.getLocaleTextFunc(), o = this.getValue();
    let n = [];
    return typeof o == "string" && t != null && o.length > t && n.push(
      s("maxLengthValidation", `Must be ${t} characters or fewer.`, [String(t)])
    ), n.length || (n = null), i ? i({
      value: o,
      internalErrors: n,
      cellEditorParams: e
    }) : n;
  }
}, sT = {
  tag: "ag-input-number-field",
  ref: "eEditor",
  cls: "ag-cell-editor"
}, oT = class {
  constructor(e) {
    this.getLocaleTextFunc = e;
  }
  getTemplate() {
    return sT;
  }
  getAgComponents() {
    return [bw];
  }
  init(e, t) {
    this.eEditor = e, this.params = t;
    const { max: i, min: s, precision: o, step: n } = t;
    i != null && e.setMax(i), s != null && e.setMin(s), o != null && e.setPrecision(o), n != null && e.setStep(n);
    const r = e.getInputElement();
    t.preventStepping ? e.addManagedElementListeners(r, { keydown: this.preventStepping }) : t.showStepperButtons && r.classList.add("ag-number-field-input-stepper");
  }
  getValidationErrors() {
    const { params: e } = this, { min: t, max: i, getValidationErrors: s } = e, n = this.eEditor.getInputElement().valueAsNumber, r = this.getLocaleTextFunc();
    let a = [];
    return typeof n == "number" && (t != null && n < t && a.push(
      r("minValueValidation", `Must be greater than or equal to ${t}.`, [String(t)])
    ), i != null && n > i && a.push(
      r("maxValueValidation", `Must be less than or equal to ${i}.`, [String(i)])
    )), a.length || (a = null), s ? s({
      value: n,
      cellEditorParams: e,
      internalErrors: a
    }) : a;
  }
  preventStepping(e) {
    (e.key === P.UP || e.key === P.DOWN) && e.preventDefault();
  }
  getValue() {
    const { eEditor: e, params: t } = this, i = e.getValue();
    if (!H(i) && !H(t.value))
      return t.value;
    let s = t.parseValue(i);
    if (s == null)
      return s;
    if (typeof s == "string") {
      if (s === "")
        return null;
      s = Number(s);
    }
    return isNaN(s) ? null : s;
  }
  getStartValue() {
    return this.params.value;
  }
  setCaret() {
    hi() && this.eEditor.getInputElement().focus({ preventScroll: !0 });
  }
}, nT = class extends Dr {
  constructor() {
    super(new oT(() => this.getLocaleTextFunc()));
  }
}, rT = {
  tag: "div",
  cls: "ag-cell-edit-wrapper",
  children: [
    {
      tag: "ag-select",
      ref: "eEditor",
      cls: "ag-cell-editor"
    }
  ]
}, aT = class extends Rr {
  constructor() {
    super(rT, [Aw]), this.eEditor = _, this.startedByEnter = !1;
  }
  wireBeans(e) {
    this.valueSvc = e.valueSvc;
  }
  initialiseEditor(e) {
    this.focusAfterAttached = e.cellStartedEdit;
    const { eEditor: t, valueSvc: i, gos: s } = this, { values: o, value: n, eventKey: r } = e;
    if (de(o)) {
      I(58);
      return;
    }
    this.startedByEnter = r != null ? r === P.ENTER : !1;
    let a = !1;
    o.forEach((u) => {
      const h = { value: u }, g = i.formatValue(e.column, null, u), p = g != null;
      h.text = p ? g : u, t.addOption(h), a = a || n === u;
    }), a ? t.setValue(e.value, !0) : e.values.length && t.setValue(e.values[0], !0);
    const { valueListGap: l, valueListMaxWidth: d, valueListMaxHeight: c } = e;
    l != null && t.setPickerGap(l), c != null && t.setPickerMaxHeight(c), d != null && t.setPickerMaxWidth(d), s.get("editType") !== "fullRow" && this.addManagedListeners(this.eEditor, { selectedItem: () => e.stopEditing() });
  }
  afterGuiAttached() {
    this.focusAfterAttached && this.eEditor.getFocusableElement().focus(), this.startedByEnter && setTimeout(() => {
      this.isAlive() && this.eEditor.showPicker();
    });
  }
  focusIn() {
    this.eEditor.getFocusableElement().focus();
  }
  getValue() {
    return this.eEditor.getValue();
  }
  isPopup() {
    return !1;
  }
  getValidationElement() {
    return this.eEditor.getAriaElement();
  }
  getValidationErrors() {
    const { params: e } = this, { values: t, getValidationErrors: i } = e, s = this.getValue();
    let o = [];
    if (t && !t.includes(s)) {
      const n = this.getLocaleTextFunc();
      o.push(n("invalidSelectionValidation", "Invalid selection."));
    } else
      o = null;
    return i ? i({
      value: s,
      internalErrors: o,
      cellEditorParams: e
    }) : o;
  }
}, lT = {
  tag: "ag-input-text-field",
  ref: "eEditor",
  cls: "ag-cell-editor"
}, dT = class {
  constructor(e) {
    this.getLocaleTextFunc = e;
  }
  getTemplate() {
    return lT;
  }
  getAgComponents() {
    return [wr];
  }
  init(e, t) {
    this.eEditor = e, this.params = t;
    const i = t.maxLength;
    i != null && e.setMaxLength(i);
  }
  getValidationErrors() {
    const { params: e } = this, { maxLength: t, getValidationErrors: i } = e, s = this.getValue(), o = this.getLocaleTextFunc();
    let n = [];
    return t != null && typeof s == "string" && s.length > t && n.push(
      o("maxLengthValidation", `Must be ${t} characters or fewer.`, [String(t)])
    ), n.length || (n = null), i ? i({ value: s, cellEditorParams: e, internalErrors: n }) : n;
  }
  getValue() {
    const { eEditor: e, params: t } = this, i = e.getValue();
    return !H(i) && !H(t.value) ? t.value : t.parseValue(i);
  }
  getStartValue() {
    const e = this.params;
    return e.useFormatter || e.column.getColDef().refData ? e.formatValue(e.value) : e.value;
  }
  setCaret() {
    hi() && this.eEditor.getInputElement().focus({ preventScroll: !0 });
    const e = this.eEditor, t = e.getValue(), i = H(t) && t.length || 0;
    i && e.getInputElement().setSelectionRange(i, i);
  }
}, tu = class extends Dr {
  constructor() {
    super(new dT(() => this.getLocaleTextFunc()));
  }
};
function cT(e) {
  return e.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
function uT(e) {
  return e.ctrlsSvc.getScrollFeature().getHScrollPosition();
}
function of(e, t, i = "auto") {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsSvc.getScrollFeature().ensureColumnVisible(t, i),
    "ensureVisible"
  );
}
function nf(e, t, i) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsSvc.getScrollFeature().ensureIndexVisible(t, i),
    "ensureVisible"
  );
}
function hT(e, t, i = null) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsSvc.getScrollFeature().ensureNodeVisible(t, i),
    "ensureVisible"
  );
}
function gT(e) {
  var t;
  (t = e.undoRedo) == null || t.undo("api");
}
function pT(e) {
  var t;
  (t = e.undoRedo) == null || t.redo("api");
}
function fT(e, t) {
  var i;
  return (i = e.editModelSvc) == null ? void 0 : i.getEditRowDataValue(t, { checkSiblings: !0 });
}
function mT(e) {
  var s;
  const t = (s = e.editModelSvc) == null ? void 0 : s.getEditMap(), i = [];
  return t == null || t.forEach((o, n) => {
    const { rowIndex: r, rowPinned: a } = n;
    o.forEach((l, d) => {
      const { editorValue: c, pendingValue: u, sourceValue: h, state: g } = l, p = Gt(l);
      let f = c ?? u;
      f === it && (f = void 0);
      const m = {
        newValue: f,
        oldValue: h,
        state: g,
        column: d,
        colId: d.getColId(),
        colKey: d.getColId(),
        rowIndex: r,
        rowPinned: a
      };
      (g === "editing" || g === "changed" && p) && i.push(m);
    });
  }), i;
}
function CT(e, t = !1) {
  var s;
  const { editSvc: i } = e;
  i != null && i.isBatchEditing() ? (t ? (s = e.editModelSvc) == null || s.getEditPositions().forEach((o) => {
    o.state === "editing" && i.revertSingleCellEdit(o);
  }) : xi(e, { persist: !0 }), ps(e, void 0, { cancel: t })) : i == null || i.stopEditing(void 0, { cancel: t, source: "edit", forceStop: !t, forceCancel: t });
}
function vT(e, t) {
  var s;
  const i = ue(e, t);
  return ((s = e.editSvc) == null ? void 0 : s.isEditing(i)) ?? !1;
}
function wT(e, t) {
  const { key: i, colKey: s, rowIndex: o, rowPinned: n } = t, { editSvc: r, colModel: a } = e, l = a.getCol(s);
  if (!l) {
    I(12, { colKey: s });
    return;
  }
  const c = Ut(e, {
    rowIndex: o,
    rowPinned: n || null
  });
  if (!c) {
    I(290, { rowIndex: o, rowPinned: n });
    return;
  }
  if (!l.isCellEditable(c))
    return;
  n == null && nf(e, o), of(e, s), r == null || r.startEditing(
    {
      rowNode: c,
      column: l
    },
    {
      event: i ? new KeyboardEvent("keydown", { key: i }) : void 0,
      source: "api"
    }
  );
}
function bT(e) {
  var t;
  return ((t = e.editSvc) == null ? void 0 : t.validateEdit()) || null;
}
function yT(e) {
  var t;
  return ((t = e.undoRedo) == null ? void 0 : t.getCurrentUndoStackSize()) ?? 0;
}
function ST(e) {
  var t;
  return ((t = e.undoRedo) == null ? void 0 : t.getCurrentRedoStackSize()) ?? 0;
}
var RT = { tag: "div", cls: "ag-popup-editor", attrs: { tabindex: "-1" } }, xT = class extends Ol {
  constructor(e) {
    super(RT), this.params = e;
  }
  postConstruct() {
    Oi(this.gos, this.getGui(), "popupEditorWrapper", !0), this.addKeyDownListener();
  }
  addKeyDownListener() {
    const e = this.getGui(), t = this.params, i = (s) => {
      qa(this.gos, s, t.node, t.column, !0) || t.onKeyDown(s);
    };
    this.addManagedElementListeners(e, { keydown: i });
  }
};
function FT(e, { column: t }, i, s, o = "ui") {
  var d;
  if (i instanceof KeyboardEvent && (i.key === P.TAB || i.key === P.ENTER || i.key === P.F2 || i.key === P.BACKSPACE && s))
    return !0;
  if ((i == null ? void 0 : i.shiftKey) && ((d = e.rangeSvc) == null ? void 0 : d.getCellRanges().length) != 0)
    return !1;
  const r = t == null ? void 0 : t.getColDef(), a = PT(e.gos, r), l = i == null ? void 0 : i.type;
  return l === "click" && (i == null ? void 0 : i.detail) === 1 && a === 1 || l === "dblclick" && (i == null ? void 0 : i.detail) === 2 && a === 2 ? !0 : o === "api" ? s ?? !1 : !1;
}
function PT(e, t) {
  return e.get("suppressClickEdit") === !0 ? 0 : e.get("singleClickEdit") === !0 || t != null && t.singleClickEdit ? 1 : 2;
}
function cl(e, { rowNode: t, column: i }, s = "ui") {
  const o = i.getColDef().editable, n = e.editModelSvc;
  return i.isColumnFunc(t, o) || !!n && n.hasEdits({ rowNode: t, column: i }, { withOpenEditor: !0 });
}
function ET(e, t, i = "ui") {
  const s = cl(e, t, i);
  return s === !0 || i === "ui" ? s : e.colModel.getCols().some((n) => cl(e, { rowNode: t.rowNode, column: n }, i));
}
var lr = (e, t = !1) => {
  if (e !== void 0)
    return Gt(e) || t && e.state === "editing";
};
function rf(e, t, i = !1) {
  var s;
  return lr((s = e.editModelSvc) == null ? void 0 : s.getEdit(t), i);
}
function af(e, t) {
  const { editModelSvc: i } = e, { column: s, rowNode: o } = t;
  if (e.gos.get("groupTotalRow") && !(o != null && o.footer))
    return !1;
  for (const n of (o == null ? void 0 : o.allLeafChildren) ?? [])
    if (lr(i == null ? void 0 : i.getEdit({ rowNode: n, column: s })) || lr(i == null ? void 0 : i.getEdit({ rowNode: n.pinnedSibling, column: s })))
      return !0;
}
function lf(e, { rowNode: t, column: i }) {
  var s;
  if (t = t.pinnedSibling, !!t)
    return lr(
      (s = e.editModelSvc) == null ? void 0 : s.getEdit({
        rowNode: t,
        column: i
      })
    );
}
var DT = class extends E {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.editSvc = t.editSvc, this.editModelSvc = t.editModelSvc;
  }
  setComp(e) {
    this.cellComp = e, this.applyCellStyles();
  }
  applyCellStyles() {
    var o;
    const { cellCtrl: e, editSvc: t, beans: i } = this;
    if (t != null && t.isBatchEditing() && t.isEditing()) {
      const n = rf(i, e) || af(i, e) || lf(i, e);
      this.applyBatchingStyle(n);
    } else
      this.applyBatchingStyle(!1);
    const s = !!((o = this.editModelSvc) != null && o.getCellValidationModel().hasCellValidation(this.cellCtrl));
    this.cellComp.toggleCss("ag-cell-editing-error", s);
  }
  applyBatchingStyle(e) {
    var t;
    this.cellComp.toggleCss("ag-cell-editing", e ?? !1), this.cellComp.toggleCss("ag-cell-batch-edit", (e && ((t = this.editSvc) == null ? void 0 : t.isBatchEditing())) ?? !1);
  }
}, TT = class extends E {
  constructor(e, t) {
    super(), this.rowCtrl = e, this.beans = t, this.gos = t.gos, this.editSvc = t.editSvc, this.editModelSvc = t.editModelSvc;
  }
  applyRowStyles() {
    var r;
    const { rowCtrl: e, editModelSvc: t, beans: i } = this;
    let s = e.rowNode, o = t == null ? void 0 : t.getEditRow(s);
    const n = (r = this.editModelSvc) == null ? void 0 : r.getRowValidationModel().hasRowValidation({ rowNode: s });
    if (!o && s.pinnedSibling && (s = s.pinnedSibling, o = t == null ? void 0 : t.getEditRow(s)), o) {
      const a = Array.from(o.keys()).some((l) => {
        const d = { rowNode: s, column: l };
        return rf(i, d, !0) || af(i, d) || lf(i, d);
      });
      this.applyStyle(n, a);
      return;
    }
    this.applyStyle(n);
  }
  applyStyle(e = !1, t = !1) {
    var o, n;
    const i = ((o = this.editSvc) == null ? void 0 : o.isBatchEditing()) ?? !1, s = this.gos.get("editType") === "fullRow";
    (n = this.rowCtrl) == null || n.forEachGui(void 0, ({ rowComp: r }) => {
      r.toggleCss("ag-row-editing", s && t), r.toggleCss("ag-row-batch-edit", s && t && i), r.toggleCss("ag-row-inline-editing", t), r.toggleCss("ag-row-not-inline-editing", !t), r.toggleCss("ag-row-editing-invalid", s && t && e);
    });
  }
}, MT = ({ rowModel: e, pinnedRowModel: t, editModelSvc: i }, s) => {
  const o = /* @__PURE__ */ new Set();
  return e.forEachNode((n) => s.has(n) && o.add(n)), t == null || t.forEachPinnedRow("top", (n) => s.has(n) && o.add(n)), t == null || t.forEachPinnedRow("bottom", (n) => s.has(n) && o.add(n)), s.forEach((n) => {
    o.has(n) || i.removeEdits({ rowNode: n });
  }), o;
}, AT = ({ editModelSvc: e }, t, i) => {
  t.forEach(
    (s) => {
      var o;
      return (o = e == null ? void 0 : e.getEditRow(s)) == null ? void 0 : o.forEach((n, r) => !i.has(r) && e.removeEdits({ rowNode: s, column: r }));
    }
  );
}, IT = (e) => () => {
  const t = new Set(e.colModel.getCols()), i = e.editModelSvc.getEditMap(!0), s = new Set(i.keys());
  AT(e, MT(e, s), t);
}, kT = /* @__PURE__ */ new Set(["undo", "redo", "paste", "bulk", "rangeSvc"]), LT = /* @__PURE__ */ new Set(["ui", "api"]), df = {
  paste: "api",
  rangeSvc: "api",
  fillHandle: "api",
  cellClear: "api",
  bulk: "api"
}, OT = new Set(Object.keys(df)), _T = /* @__PURE__ */ new Set([
  "paste",
  "rangeSvc",
  "renderer",
  "cellClear",
  "redo",
  "undo"
]), ln = { cancel: !0, source: "api" }, HT = { cancel: !1, source: "api" }, Xi = { checkSiblings: !0 }, Vs = { force: !0, suppressFlash: !0 }, BT = class extends E {
  constructor() {
    super(...arguments), this.beanName = "editSvc", this.batch = !1, this.stopping = !1, this.committing = !1;
  }
  postConstruct() {
    const { beans: e } = this;
    this.model = e.editModelSvc, this.valueSvc = e.valueSvc, this.rangeSvc = e.rangeSvc, this.addManagedPropertyListener("editType", ({ currentValue: s }) => {
      this.stopEditing(void 0, ln), this.createStrategy(s);
    });
    const t = IT(e), i = () => {
      const s = this.model.getCellValidationModel().getCellValidationMap().size > 0, o = this.model.getRowValidationModel().getRowValidationMap().size > 0;
      return s || o ? this.stopEditing(void 0, ln) : this.isEditing() && (this.isBatchEditing() ? ps(e, this.model.getEditPositions()) : this.stopEditing(void 0, HT)), !1;
    };
    this.addManagedEventListeners({
      columnPinned: t,
      columnVisible: t,
      columnRowGroupChanged: t,
      rowExpansionStateChanged: t,
      pinnedRowsChanged: t,
      displayedRowsChanged: t,
      sortChanged: i,
      filterChanged: i,
      cellFocused: this.onCellFocused.bind(this)
    });
  }
  isBatchEditing() {
    return this.batch;
  }
  setBatchEditing(e) {
    e ? (this.batch = !0, this.stopEditing(void 0, ln)) : (this.stopEditing(void 0, ln), this.batch = !1);
  }
  createStrategy(e) {
    const { beans: t, gos: i, strategy: s } = this, o = iu(i, e);
    if (s) {
      if (s.beanName === o)
        return s;
      this.destroyStrategy();
    }
    return this.strategy = this.createOptionalManagedBean(
      t.registry.createDynamicBean(o, !0)
    );
  }
  destroyStrategy() {
    this.strategy && (this.strategy.destroy(), this.strategy = this.destroyBean(this.strategy));
  }
  shouldStartEditing(e, t, i, s = "ui") {
    const o = FT(this.beans, e, t, i, s);
    return o && (this.strategy ?? (this.strategy = this.createStrategy())), o;
  }
  shouldStopEditing(e, t, i = "ui") {
    var s;
    return ((s = this.strategy) == null ? void 0 : s.shouldStop(e, t, i)) ?? null;
  }
  shouldCancelEditing(e, t, i = "ui") {
    var s;
    return ((s = this.strategy) == null ? void 0 : s.shouldCancel(e, t, i)) ?? null;
  }
  validateEdit() {
    return J0(this.beans);
  }
  isEditing(e, t) {
    return this.model.hasEdits(e, t ?? Xi);
  }
  isRowEditing(e, t) {
    return (e && this.model.hasRowEdits(e, t)) ?? !1;
  }
  /** @returns whether to prevent default on event */
  startEditing(e, t) {
    const { startedEdit: i = !0, event: s = null, source: o = "ui", ignoreEventKey: n = !1, silent: r } = t;
    if (this.strategy ?? (this.strategy = this.createStrategy()), !this.isCellEditable(e, "api"))
      return;
    const a = ue(this.beans, e);
    if (a && !a.comp) {
      a.onCompAttachedFuncs.push(() => this.startEditing(e, t));
      return;
    }
    const l = this.shouldStartEditing(e, s, i, o);
    if (l === !1 && o !== "api") {
      this.isEditing(e) && this.stopEditing();
      return;
    }
    !this.batch && this.shouldStopEditing(e, void 0, o) && !t.continueEditing && this.stopEditing(void 0, { source: o }), l && this.isBatchEditing() && this.dispatchBatchEvent("batchEditingStarted", /* @__PURE__ */ new Map()), this.strategy.start({
      position: e,
      event: s,
      source: o,
      ignoreEventKey: n,
      startedEdit: i,
      silent: r
    });
  }
  stopEditing(e, t) {
    var C, v, R;
    const { event: i, cancel: s, source: o = "ui", suppressNavigateAfterEdit: n, forceCancel: r, forceStop: a } = t || {}, { beans: l, model: d } = this;
    if (OT.has(o) && this.isBatchEditing())
      return this.bulkRefresh(e), !1;
    const c = this.committing ? df[o] : o;
    if (!(this.committing || this.isEditing(e) || this.isBatchEditing() && d.hasEdits(e, Xi)) || !this.strategy || this.stopping)
      return !1;
    this.stopping = !0;
    const h = ue(l, e);
    h && (h.onEditorAttachedFuncs = []);
    let g = d.getEditMap(!0), p = !1;
    const f = !s && (!!this.shouldStopEditing(e, i, c) || this.committing && !this.batch) || (a ?? !1), m = s && !!this.shouldCancelEditing(e, i, c) || (r ?? !1);
    if (f || m) {
      xi(l, { persist: !0, isCancelling: m || s, isStopping: f });
      const b = d.getEditMap(), w = this.processEdits(b, s, o);
      (C = this.strategy) == null || C.stop(s, i), w.forEach((x) => {
        d.clearEditValue(x);
      }), this.bulkRefresh(void 0, g), d.getEditPositions(b).forEach((x) => {
        const F = ue(l, x), D = Gt(x);
        F == null || F.refreshCell({ force: !0, suppressFlash: !D });
      }), g = b, p || (p = f);
    } else if (i instanceof KeyboardEvent && this.batch && ((v = this.strategy) != null && v.midBatchInputsAllowed(e)) && this.isEditing(e, { withOpenEditor: !0 })) {
      const b = i.key, w = b === P.ENTER, x = b === P.ESCAPE, F = b === P.TAB;
      (w || F || x) && (w || F ? xi(l, { persist: !0 }) : x && this.revertSingleCellEdit(h), this.isBatchEditing() ? (R = this.strategy) == null || R.cleanupEditors() : ps(l, d.getEditPositions(), { event: i, cancel: x }), i.preventDefault(), this.bulkRefresh(e, g, { suppressFlash: !0 }), g = d.getEditMap());
    } else
      xi(l, { persist: !0 }), g = d.getEditMap();
    return p && e && this.model.removeEdits(e), !n && h && this.navigateAfterEdit(i instanceof KeyboardEvent && i.shiftKey, h.cellPosition), ol(l), this.model.hasEdits() || (this.model.getCellValidationModel().clearCellValidationMap(), this.model.getRowValidationModel().clearRowValidationMap()), this.bulkRefresh(), m && this.beans.rowRenderer.refreshRows({ rowNodes: Array.from(g.keys()) }), this.isBatchEditing() && (this.beans.rowRenderer.refreshRows({ suppressFlash: !0, force: !0 }), p && f && this.dispatchBatchEvent("batchEditingStopped", g)), this.stopping = !1, p;
  }
  navigateAfterEdit(e, t) {
    var s;
    if (this.gos.get("enterNavigatesVerticallyAfterEdit")) {
      const o = e ? P.UP : P.DOWN;
      (s = this.beans.navigation) == null || s.navigateToNextCell(null, o, t, !1);
    }
  }
  processEdits(e, t = !1, i) {
    const s = Array.from(e.keys()), o = this.model.getCellValidationModel().getCellValidationMap().size > 0 || this.model.getRowValidationModel().getRowValidationMap().size > 0, n = [];
    for (const r of s) {
      const a = e.get(r);
      for (const l of a.keys()) {
        const d = a.get(l), c = { rowNode: r, column: l }, u = Gt(d);
        !t && u && !o && (this.setNodeDataValue(r, l, d.pendingValue, void 0, i) || n.push(c));
      }
    }
    return n;
  }
  setNodeDataValue(e, t, i, s, o = "edit") {
    const { beans: n } = this, r = ue(n, { rowNode: e, column: t }), a = LT.has(o) ? "edit" : o;
    r && (r.suppressRefreshCell = !0), this.commitNextEdit();
    const l = e.setDataValue(t, i, a);
    return r && (r.suppressRefreshCell = !1), s && (r == null || r.refreshCell(Vs)), l;
  }
  setEditMap(e, t) {
    var s;
    this.strategy ?? (this.strategy = this.createStrategy()), (s = this.strategy) == null || s.setEditMap(e, t), this.bulkRefresh();
    let i = Vs;
    t != null && t.forceRefreshOfEditCellsOnly && (i = {
      ...GT(e),
      ...Vs
    }), this.beans.rowRenderer.refreshCells(i);
  }
  dispatchEditValuesChanged({ rowNode: e, column: t }, i = {}) {
    if (!e || !t || !i)
      return;
    const { pendingValue: s, sourceValue: o } = i, { rowIndex: n, rowPinned: r, data: a } = e;
    this.beans.eventSvc.dispatchEvent({
      type: "cellEditValuesChanged",
      node: e,
      rowIndex: n,
      rowPinned: r,
      column: t,
      source: "api",
      data: a,
      newValue: s,
      oldValue: o,
      value: s,
      colDef: t.getColDef()
    });
  }
  bulkRefresh(e = {}, t, i = {}) {
    var a;
    const { beans: s, gos: o } = this, { editModelSvc: n, rowModel: r } = s;
    xe(o) && (e.rowNode && e.column ? this.refCell(e, this.model.getEdit(e), i) : t && ((a = n == null ? void 0 : n.getEditMap(!1)) == null || a.forEach((l, d) => {
      for (const c of l.keys())
        this.refCell({ rowNode: d, column: c }, l.get(c), i);
    })));
  }
  refCell({ rowNode: e, column: t }, i, s = {}) {
    var u;
    const { beans: o, gos: n } = this, r = /* @__PURE__ */ new Set([e]), a = /* @__PURE__ */ new Set(), l = e.pinnedSibling;
    l && r.add(l);
    const d = e.sibling;
    d && a.add(d);
    let c = e.parent;
    for (; c; )
      (u = c.sibling) != null && u.footer && n.get("groupTotalRow") || !c.parent && c.sibling && n.get("grandTotalRow") ? a.add(c.sibling) : a.add(c), c = c.parent;
    r.forEach((h) => this.dispatchEditValuesChanged({ rowNode: h, column: t }, i)), r.forEach((h) => {
      var g;
      return (g = ue(o, { rowNode: h, column: t })) == null ? void 0 : g.refreshCell(s);
    }), a.forEach((h) => {
      var g;
      return (g = ue(o, { rowNode: h, column: t })) == null ? void 0 : g.refreshCell(s);
    });
  }
  stopAllEditing(e = !1, t = "ui") {
    this.isEditing() && this.stopEditing(void 0, { cancel: e, source: t });
  }
  isCellEditable(e, t = "ui") {
    const { rowNode: i } = e, { gos: s, beans: o } = this;
    if (i.group) {
      if (s.get("treeData")) {
        if (!i.data && !s.get("enableGroupEdit"))
          return !1;
      } else if (!s.get("enableGroupEdit"))
        return !1;
    }
    const n = iu(s) === "fullRow" ? ET(o, e, t) : cl(o, e, t);
    return n && (this.strategy ?? (this.strategy = this.createStrategy())), n;
  }
  cellEditingInvalidCommitBlocks() {
    return this.gos.get("invalidEditValueMode") === "block";
  }
  checkNavWithValidation(e, t, i = !0) {
    var s, o, n, r;
    if (this.hasValidationErrors(e)) {
      const a = ue(this.beans, e);
      return this.cellEditingInvalidCommitBlocks() ? ((s = t == null ? void 0 : t.preventDefault) == null || s.call(t), i && (!(a != null && a.hasBrowserFocus()) && (a == null || a.focusCell()), (r = (n = (o = a == null ? void 0 : a.comp) == null ? void 0 : o.getCellEditor()) == null ? void 0 : n.focusIn) == null || r.call(n)), "block-stop") : (a && this.revertSingleCellEdit(a), "revert-continue");
    }
    return "continue";
  }
  revertSingleCellEdit(e, t = !1) {
    var s, o, n, r, a;
    const i = ue(this.beans, e);
    (s = i == null ? void 0 : i.comp) != null && s.getCellEditor() && (ps(this.beans, [e], { silent: !0 }), this.model.clearEditValue(e), Rs(this.beans, e, { silent: !0 }), Gi(this.beans), i == null || i.refreshCell(Vs), (o = i.rowCtrl.rowEditStyleFeature) == null || o.applyRowStyles(), t && (i == null || i.focusCell(), (a = (r = (n = i == null ? void 0 : i.comp) == null ? void 0 : n.getCellEditor()) == null ? void 0 : r.focusIn) == null || a.call(r)));
  }
  hasValidationErrors(e) {
    var s;
    Gi(this.beans);
    const t = ue(this.beans, e);
    t && (t.refreshCell(Vs), (s = t.rowCtrl.rowEditStyleFeature) == null || s.applyRowStyles());
    let i = !1;
    return e != null && e.rowNode ? (i || (i = this.model.getRowValidationModel().hasRowValidation({ rowNode: e.rowNode })), e.column && (i || (i = this.model.getCellValidationModel().hasCellValidation({ rowNode: e.rowNode, column: e.column })))) : (i || (i = this.model.getCellValidationModel().getCellValidationMap().size > 0), i || (i = this.model.getRowValidationModel().getRowValidationMap().size > 0)), i;
  }
  moveToNextCell(e, t, i, s = "ui") {
    var a;
    let o;
    const n = this.isEditing(), r = n && this.checkNavWithValidation(void 0, i) === "block-stop";
    return e instanceof fs && n && (o = (a = this.strategy) == null ? void 0 : a.moveToNextEditingCell(e, t, i, s, r)), o === null || (o = o || !!this.beans.focusSvc.focusedHeader, o === !1 && !r && this.stopEditing()), o;
  }
  getCellDataValue({ rowNode: e, column: t }, i = !0) {
    if (!e || !t)
      return;
    let s = this.model.getEdit({ rowNode: e, column: t });
    const o = e.pinnedSibling;
    if (o) {
      const r = this.model.getEdit({ rowNode: o, column: t });
      r && (s = r);
    }
    const n = i ? (s == null ? void 0 : s.editorValue) ?? (s == null ? void 0 : s.pendingValue) : s == null ? void 0 : s.pendingValue;
    return n === it || !s ? (s == null ? void 0 : s.sourceValue) ?? this.valueSvc.getValue(t, e, !1, "api") : n;
  }
  addStopEditingWhenGridLosesFocus(e) {
    j0(this, this.beans, e);
  }
  createPopupEditorWrapper(e) {
    return new xT(e);
  }
  commitNextEdit() {
    this.committing = !0;
  }
  setDataValue(e, t, i) {
    var s;
    try {
      if ((!this.isEditing() || this.committing) && !_T.has(i))
        return;
      const { beans: o } = this;
      this.strategy ?? (this.strategy = this.createStrategy());
      const n = this.isBatchEditing() ? "ui" : this.committing ? i ?? "api" : "api";
      if (!i || kT.has(i))
        return kn(o, e, t, i, void 0, { persist: !0 }), this.setNodeDataValue(e.rowNode, e.column, t, !0, i);
      const r = this.model.getEdit(e);
      if (r) {
        if (r.pendingValue === t)
          return !1;
        if (r.sourceValue !== t)
          return kn(o, e, t, i, void 0, { persist: !0 }), this.stopEditing(e, { source: n, suppressNavigateAfterEdit: !0 }), !0;
        if (r.sourceValue === t)
          return (s = o.editModelSvc) == null || s.removeEdits(e), this.dispatchEditValuesChanged(e, {
            ...r,
            pendingValue: t
          }), !0;
      }
      return kn(o, e, t, i, void 0, { persist: !0 }), this.stopEditing(e, { source: n, suppressNavigateAfterEdit: !0 }), !0;
    } finally {
      this.committing = !1;
    }
  }
  handleColDefChanged(e) {
    Q0(this.beans, e);
  }
  destroy() {
    this.model.clear(), this.destroyStrategy(), super.destroy();
  }
  prepDetailsDuringBatch(e, t) {
    if (!this.batch || !this.model.hasRowEdits(e.rowNode, Xi))
      return;
    const { rowNode: s, column: o } = e, { compDetails: n, valueToDisplay: r } = t;
    if (n) {
      const { params: l } = n;
      return l.data = this.model.getEditRowDataValue(s, Xi), { compDetails: n };
    }
    const a = this.model.getEditRow(e.rowNode, Xi);
    if (r !== void 0 && (a != null && a.has(o)))
      return { valueToDisplay: this.valueSvc.getValue(o, s) };
  }
  cleanupEditors() {
    var e;
    (e = this.strategy) == null || e.cleanupEditors();
  }
  dispatchCellEvent(e, t, i, s) {
    var o;
    (o = this.strategy) == null || o.dispatchCellEvent(e, t, i, s);
  }
  dispatchBatchEvent(e, t) {
    this.eventSvc.dispatchEvent(this.createBatchEditEvent(e, t));
  }
  createBatchEditEvent(e, t) {
    return W(this.gos, {
      type: e,
      ...e === "batchEditingStopped" ? {
        changes: this.toEventChangeList(t)
      } : {}
    });
  }
  toEventChangeList(e) {
    return this.model.getEditPositions(e).map((t) => ({
      rowIndex: t.rowNode.rowIndex,
      rowPinned: t.rowNode.rowPinned,
      columnId: t.column.getColId(),
      newValue: t.pendingValue,
      oldValue: t.sourceValue
    }));
  }
  applyBulkEdit({ rowNode: e, column: t }, i) {
    var d, c;
    if (!i || i.length === 0)
      return;
    const { beans: s, rangeSvc: o, valueSvc: n } = this;
    xi(s, { persist: !0 });
    const r = this.model.getEditMap(!0), a = (c = (d = r.get(e)) == null ? void 0 : d.get(t)) == null ? void 0 : c.pendingValue;
    this.batch || this.eventSvc.dispatchEvent({ type: "bulkEditingStarted" }), i.forEach((u) => {
      if (o == null || o.forEachRowInRange(u, (h) => {
        const g = Ut(s, h);
        if (g === void 0)
          return;
        const p = r.get(g) ?? /* @__PURE__ */ new Map();
        for (const f of u.columns)
          if (f && this.isCellEditable({ rowNode: g, column: f }, "api")) {
            const m = n.getValue(f, g, !0, "api");
            let C = n.parseValue(
              f,
              g ?? null,
              a,
              m
            );
            Number.isNaN(C) && (C = null), p.set(f, {
              editorValue: void 0,
              pendingValue: C,
              sourceValue: m,
              state: "changed",
              editorState: {
                isCancelAfterEnd: void 0,
                isCancelBeforeStart: void 0
              }
            });
          }
        p.size > 0 && r.set(g, p);
      }), this.setEditMap(r), this.batch) {
        this.cleanupEditors(), ol(s), this.bulkRefresh();
        return;
      }
      this.commitNextEdit(), this.stopEditing(void 0, { source: "bulk" }), this.eventSvc.dispatchEvent({ type: "bulkEditingStopped", changes: this.toEventChangeList(r) });
    }), this.bulkRefresh();
    const l = ue(s, { rowNode: e, column: t });
    l && l.focusCell(!0);
  }
  createCellStyleFeature(e, t) {
    return new DT(e, t);
  }
  createRowStyleFeature(e, t) {
    return new TT(e, t);
  }
  setEditingCells(e, t) {
    const { beans: i } = this, { colModel: s, valueSvc: o } = i, n = /* @__PURE__ */ new Map();
    e.forEach(({ colId: r, column: a, colKey: l, rowIndex: d, rowPinned: c, newValue: u, state: h }) => {
      const g = r ? s.getCol(r) : l ? s.getCol(l) : a;
      if (!g)
        return;
      const p = Ut(i, { rowIndex: d, rowPinned: c });
      if (!p)
        return;
      const f = o.getValue(g, p, !0, "api");
      if (!(t != null && t.forceRefreshOfEditCellsOnly) && !Gt({ pendingValue: u, sourceValue: f }) && h !== "editing")
        return;
      let m = n.get(p);
      m || (m = /* @__PURE__ */ new Map(), n.set(p, m)), u === void 0 && (u = it), m.set(g, {
        editorValue: void 0,
        pendingValue: u,
        sourceValue: f,
        state: h ?? "changed",
        editorState: {
          isCancelAfterEnd: void 0,
          isCancelBeforeStart: void 0
        }
      });
    }), this.setEditMap(n, t);
  }
  onCellFocused(e) {
    var n;
    const t = ue(this.beans, e);
    if (!t || !this.isEditing(t, Xi))
      return;
    const i = this.model.getEdit(t);
    if (!i || !Gt(i))
      return;
    const o = this.getLocaleTextFunc()("ariaPendingChange", "Pending Change");
    (n = this.beans.ariaAnnounce) == null || n.announceValue(o, "pendingChange");
  }
  allowedFocusTargetOnValidation(e) {
    return ue(this.beans, e);
  }
};
function GT(e) {
  return {
    rowNodes: e ? Array.from(e.keys()) : void 0,
    columns: e ? [...new Set(Array.from(e.values()).flatMap((t) => Array.from(t.keys())))] : void 0
  };
}
function iu(e, t) {
  return t ?? e.get("editType") ?? "singleCell";
}
var cf = class extends E {
  postConstruct() {
    var e, t;
    this.model = this.beans.editModelSvc, this.editSvc = this.beans.editSvc, this.addManagedEventListeners({
      cellFocused: (e = this.onCellFocusChanged) == null ? void 0 : e.bind(this),
      cellFocusCleared: (t = this.onCellFocusChanged) == null ? void 0 : t.bind(this)
    });
  }
  clearEdits(e) {
    this.model.clearEditValue(e);
  }
  onCellFocusChanged(e) {
    let t;
    const i = e.previousParams, { editSvc: s, beans: o } = this, n = e.type === "cellFocused" ? e.sourceEvent : null;
    i && (t = ue(o, i));
    const { gos: r, editModelSvc: a } = o, l = e.type === "cellFocusCleared";
    if (s.isEditing(void 0, { withOpenEditor: !0 })) {
      const { column: d, rowIndex: c, rowPinned: u } = e, h = {
        column: d,
        rowNode: Ut(o, { rowIndex: c, rowPinned: u })
      }, g = r.get("invalidEditValueMode") === "block";
      if (g)
        return;
      const p = !g, f = !!(a != null && a.getCellValidationModel().hasCellValidation(h)), m = p && f;
      (i || l ? s.stopEditing(void 0, {
        cancel: m,
        source: l && p ? "api" : void 0,
        event: n
      }) : !0) || (s.isBatchEditing() ? s.cleanupEditors() : s.stopEditing(void 0, { source: "api" }));
    }
    t == null || t.refreshCell({ suppressFlash: !0, force: !0 });
  }
  stop(e, t) {
    const i = this.model.getEditPositions(), s = { all: [], pass: [], fail: [] };
    if (i.forEach((n) => {
      var a;
      s.all.push(n);
      const r = this.model.getCellValidationModel().getCellValidation(n);
      if ((((a = r == null ? void 0 : r.errorMessages) == null ? void 0 : a.length) ?? 0) > 0) {
        s.fail.push(n);
        return;
      }
      s.pass.push(n);
    }), e)
      return i.forEach((n) => {
        nr(this.beans, n, { cancel: e }), this.model.stop(n);
      }), !0;
    const o = this.processValidationResults(s);
    return o.destroy.length > 0 && o.destroy.forEach((n) => {
      nr(this.beans, n, { event: t, cancel: e }), this.model.stop(n);
    }), o.keep.length > 0 && o.keep.forEach((n) => {
      var a;
      const r = ue(this.beans, n);
      (a = this.editSvc) != null && a.cellEditingInvalidCommitBlocks() || r && this.editSvc.revertSingleCellEdit(r);
    }), !0;
  }
  cleanupEditors({ rowNode: e } = {}, t) {
    xi(this.beans, { persist: !1 });
    const i = this.model.getEditPositions(), s = [];
    e ? i.forEach((o) => {
      !e || o.rowNode === e || s.push(o);
    }) : i.forEach((o) => {
      s.push(o);
    }), ps(this.beans, s), ol(this.beans, t);
  }
  setFocusOutOnEditor(e) {
    var t, i, s;
    (s = (i = (t = e.comp) == null ? void 0 : t.getCellEditor()) == null ? void 0 : i.focusOut) == null || s.call(i);
  }
  setFocusInOnEditor(e) {
    const t = e.comp, i = t == null ? void 0 : t.getCellEditor();
    if (i != null && i.focusIn)
      i.focusIn();
    else {
      const s = this.beans.gos.get("editType") === "fullRow";
      e.focusCell(s), e.onEditorAttachedFuncs.push(() => {
        var o, n;
        return (n = (o = t == null ? void 0 : t.getCellEditor()) == null ? void 0 : o.focusIn) == null ? void 0 : n.call(o);
      });
    }
  }
  setupEditors(e) {
    const { event: t, ignoreEventKey: i = !1, startedEdit: s, position: o, cells: n = this.model.getEditPositions() } = e, r = t instanceof KeyboardEvent && !i && t.key || void 0;
    Y0(this.beans, n, o, r, t, s);
  }
  dispatchCellEvent(e, t, i, s) {
    const o = ue(this.beans, e);
    o && this.eventSvc.dispatchEvent({ ...o.createEvent(t ?? null, i), ...s });
  }
  dispatchRowEvent(e, t, i) {
    if (i)
      return;
    const s = id(this.beans, e);
    s && this.eventSvc.dispatchEvent(s.createRowEvent(t));
  }
  shouldStop(e, t, i = "ui") {
    const s = this.editSvc.isBatchEditing();
    return s && i === "api" ? !0 : s && (i === "ui" || i === "edit") ? !1 : i === "api" ? !0 : t instanceof KeyboardEvent && !s ? t.key === P.ENTER : null;
  }
  shouldCancel(e, t, i = "ui") {
    const s = this.editSvc.isBatchEditing();
    return !!(t instanceof KeyboardEvent && !s && t.key === P.ESCAPE || s && i === "api" || i === "api");
  }
  setEditMap(e, t) {
    var s;
    t != null && t.update || this.editSvc.stopEditing(void 0, { cancel: !0, source: "api" });
    const i = [];
    if (e.forEach((o, n) => {
      o.forEach((r, a) => {
        r.state === "editing" && i.push({ ...r, rowNode: n, column: a });
      });
    }), t != null && t.update && (e = new Map([...this.model.getEditMap(), ...e])), (s = this.model) == null || s.setEditMap(e), i.length > 0) {
      const o = i.at(-1), n = o.pendingValue === it ? void 0 : o.pendingValue;
      this.start({ position: o, event: new KeyboardEvent("keydown", { key: n }), source: "api" });
      const r = ue(this.beans, o);
      r && this.setFocusInOnEditor(r);
    }
  }
  destroy() {
    this.cleanupEditors(), super.destroy();
  }
}, VT = class extends cf {
  constructor() {
    super(...arguments), this.beanName = "fullRow", this.startedRows = [];
  }
  shouldStop(e, t, i = "ui") {
    const { rowNode: s } = e || {};
    if (!id(this.beans, {
      rowNode: this.rowNode
    }))
      return !0;
    const n = super.shouldStop({ rowNode: this.rowNode }, t, i);
    return n !== null ? n : this.rowNode ? s !== this.rowNode : !1;
  }
  midBatchInputsAllowed({ rowNode: e }) {
    return e ? this.model.hasEdits({ rowNode: e }) : !1;
  }
  clearEdits(e) {
    this.model.clearEditValue(e);
  }
  start(e) {
    const { position: t, silent: i, startedEdit: s, event: o, ignoreEventKey: n } = e, { rowNode: r } = t;
    this.rowNode !== r && super.cleanupEditors(t), this.dispatchRowEvent({ rowNode: r }, "rowEditingStarted", i), this.startedRows.push(r);
    const a = this.beans.visibleCols.allCols, l = [];
    a.forEach((d) => {
      if (!d.isCellEditable(r))
        return;
      const c = {
        rowNode: r,
        column: d
      };
      l.push(c), this.model.hasEdits(c) || this.model.start(c);
    }), this.rowNode = r, this.setupEditors({ cells: l, position: t, startedEdit: s, event: o, ignoreEventKey: n });
  }
  processValidationResults(e) {
    return e.fail.length > 0 && this.editSvc.cellEditingInvalidCommitBlocks() ? {
      destroy: [],
      keep: e.all
    } : {
      destroy: e.all,
      keep: []
    };
  }
  stop(e, t) {
    var o;
    const { rowNode: i } = this;
    if (i && !this.model.hasRowEdits(i))
      return !1;
    const s = [];
    return e || this.model.getEditMap().forEach((n, r) => {
      if (!(!n || n.size === 0)) {
        for (const a of n.values())
          if (Gt(a)) {
            s.push(r);
            break;
          }
      }
    }), Gi(this.beans), !e && ((o = this.editSvc) == null ? void 0 : o.checkNavWithValidation({ rowNode: i })) === "block-stop" ? !1 : (super.stop(e, t), s.forEach((n) => this.dispatchRowEvent({ rowNode: n }, "rowValueChanged")), this.cleanupEditors({ rowNode: i }, !0), this.rowNode = void 0, !0);
  }
  onCellFocusChanged(e) {
    const { rowIndex: t } = e, i = e.previousParams;
    if ((i == null ? void 0 : i.rowIndex) === t || e.sourceEvent instanceof KeyboardEvent)
      return;
    const s = ue(this.beans, i);
    this.gos.get("invalidEditValueMode") === "block" && s && (this.model.getCellValidationModel().getCellValidation(s) || this.model.getRowValidationModel().getRowValidation(s)) || super.onCellFocusChanged(e);
  }
  cleanupEditors(e = {}, t) {
    super.cleanupEditors(e, t), this.startedRows.forEach((i) => this.dispatchRowEvent({ rowNode: i }, "rowEditingStopped")), this.startedRows.length = 0;
  }
  // returns null if no navigation should be performed
  moveToNextEditingCell(e, t, i, s = "ui", o = !1) {
    var h, g, p, f;
    const n = e.cellPosition;
    let r;
    this.model.suspend(!0);
    try {
      r = (h = this.beans.navigation) == null ? void 0 : h.findNextCellToFocusOn(n, {
        backwards: t,
        startEditing: !0,
        // Default behaviour for fullRow is skip to the next cell,
        // editable or not. FullRow editing might have some editable
        // and some not editable cells in the row.
        // More complex logic needed to skip to the
        // next FullRow editable cell,
        skipToNextEditableCell: !1
      });
    } finally {
      this.model.suspend(!1);
    }
    if (r === !1)
      return null;
    if (r == null)
      return !1;
    const a = r.cellPosition, l = e.isCellEditable(), d = r.isCellEditable(), c = a && n.rowIndex === a.rowIndex && n.rowPinned === a.rowPinned;
    l && this.setFocusOutOnEditor(e), this.restoreEditors();
    const u = this.gos.get("suppressStartEditOnTab");
    return d && !o ? u ? r.focusCell(!0, i) : ((g = r.comp) != null && g.getCellEditor() || Rs(this.beans, r, { event: i, cellStartedEdit: !0 }), this.setFocusInOnEditor(r), r.focusCell(!1, i)) : (d && o && this.setFocusInOnEditor(r), r.focusCell(!0, i)), !c && !o && ((p = this.editSvc) == null || p.stopEditing({ rowNode: e.rowNode }, { event: i }), this.cleanupEditors(r, !0), u ? r.focusCell(!0, i) : this.editSvc.startEditing(r, { startedEdit: !0, event: i, source: s, ignoreEventKey: !0 })), (f = e.rowCtrl) == null || f.refreshRow({ suppressFlash: !0, force: !0 }), !0;
  }
  restoreEditors() {
    this.model.getEditMap().forEach(
      (e, t) => e.forEach(({ state: i }, s) => {
        var n;
        if (i !== "editing")
          return;
        const o = ue(this.beans, {
          rowNode: t,
          column: s
        });
        o && !((n = o.comp) != null && n.getCellEditor()) && Rs(this.beans, o, { silent: !0 });
      })
    );
  }
  destroy() {
    super.destroy(), this.rowNode = void 0, this.startedRows.length = 0;
  }
}, NT = class extends cf {
  constructor() {
    super(...arguments), this.beanName = "singleCell";
  }
  shouldStop(e, t, i = "ui") {
    const s = super.shouldStop(e, t, i);
    if (s !== null)
      return s;
    const { rowNode: o, column: n } = e || {};
    return (!this.rowNode || !this.column) && o && n ? null : this.rowNode !== o || this.column !== n;
  }
  midBatchInputsAllowed(e) {
    return this.model.hasEdits(e);
  }
  start(e) {
    const { position: t, startedEdit: i, event: s, ignoreEventKey: o } = e;
    (this.rowNode !== t.rowNode || this.column !== t.column) && super.cleanupEditors(), this.rowNode = t.rowNode, this.column = t.column, this.model.start(t), this.setupEditors({ cells: [t], position: t, startedEdit: i, event: s, ignoreEventKey: o });
  }
  dispatchRowEvent(e, t, i) {
  }
  processValidationResults(e) {
    return e.fail.length > 0 && this.editSvc.cellEditingInvalidCommitBlocks() ? {
      destroy: [],
      keep: e.all
    } : {
      destroy: e.all,
      keep: []
    };
  }
  stop(e, t) {
    return super.stop(e, t), this.rowNode = void 0, this.column = void 0, !0;
  }
  onCellFocusChanged(e) {
    const { colModel: t, editSvc: i } = this.beans, { rowIndex: s, column: o, rowPinned: n } = e, r = Ut(this.beans, { rowIndex: s, rowPinned: n }), a = sl(o), l = t.getCol(a), d = e.previousParams;
    if (d) {
      const c = sl(d.column);
      if ((d == null ? void 0 : d.rowIndex) === s && c === a && (d == null ? void 0 : d.rowPinned) === n)
        return;
    }
    i != null && i.isEditing({ rowNode: r, column: l }, { withOpenEditor: !0 }) && e.type === "cellFocused" || super.onCellFocusChanged(e);
  }
  // returns null if no navigation should be performed
  moveToNextEditingCell(e, t, i, s = "ui", o = !1) {
    var p, f, m, C, v, R;
    const n = this.beans.focusSvc.getFocusedCell();
    n && (e = os(this.beans, n) ?? e);
    const r = e.cellPosition;
    let a;
    const l = this.beans.gos.get("editType") === "fullRow";
    l && this.model.suspend(!0), o || (e.eGui.focus(), (f = this.editSvc) == null || f.stopEditing(e, { source: (p = this.editSvc) != null && p.isBatchEditing() ? "ui" : "api", event: i }));
    try {
      a = (m = this.beans.navigation) == null ? void 0 : m.findNextCellToFocusOn(r, {
        backwards: t,
        startEditing: !0
        // Default behaviour for fullRow is skip to the next cell,
        // editable or not. FullRow editing might have some editable
        // and some not editable cells in the row.
        // More complex logic needed to skip to the
        // next FullRow editable cell,
        // skipToNextEditableCell: false,
      });
    } finally {
      l && this.model.suspend(!1);
    }
    if (a === !1)
      return null;
    if (a == null)
      return !1;
    const d = a.cellPosition, c = e.isCellEditable(), u = a.isCellEditable(), h = d && r.rowIndex === d.rowIndex && r.rowPinned === d.rowPinned;
    c && !o && this.setFocusOutOnEditor(e);
    const g = this.gos.get("suppressStartEditOnTab");
    if (!h && !o && (super.cleanupEditors(a, !0), g ? a.focusCell(!0, i) : this.editSvc.startEditing(a, { startedEdit: !0, event: i, source: s, ignoreEventKey: !0 })), u && !o) {
      if (a.focusCell(!1, i), g)
        a.focusCell(!0, i);
      else if (!((C = a.comp) != null && C.getCellEditor())) {
        const b = (v = this.editSvc) == null ? void 0 : v.isEditing(a, { withOpenEditor: !0 });
        Rs(this.beans, a, { event: i, cellStartedEdit: !0, silent: b }), this.setFocusInOnEditor(a), this.cleanupEditors(a);
      }
    } else
      u && o && this.setFocusInOnEditor(a), a.focusCell(!0, i);
    return (R = e.rowCtrl) == null || R.refreshRow({ suppressFlash: !0, force: !0 }), !0;
  }
  destroy() {
    super.destroy(), this.rowNode = void 0, this.column = void 0;
  }
}, gi = {
  moduleName: "EditCore",
  version: B,
  beans: [K0, BT],
  apiFunctions: {
    getEditingCells: mT,
    getEditRowValues: fT,
    getCellEditorInstances: q0,
    startEditingCell: wT,
    stopEditing: CT,
    isEditing: vT,
    validateEdit: bT
  },
  dynamicBeans: {
    singleCell: NT,
    fullRow: VT
  },
  dependsOn: [Pr, sf],
  css: [KD]
}, WT = {
  moduleName: "UndoRedoEdit",
  version: B,
  beans: [$D],
  apiFunctions: {
    undoCellEditing: gT,
    redoCellEditing: pT,
    getCurrentUndoSize: yT,
    getCurrentRedoSize: ST
  },
  dependsOn: [gi]
}, zT = {
  moduleName: "TextEditor",
  version: B,
  userComponents: { agCellEditor: tu, agTextCellEditor: tu },
  dependsOn: [gi]
}, UT = {
  moduleName: "NumberEditor",
  version: B,
  userComponents: {
    agNumberCellEditor: {
      classImp: nT
    }
  },
  dependsOn: [gi]
}, $T = {
  moduleName: "DateEditor",
  version: B,
  userComponents: {
    agDateCellEditor: XD,
    agDateStringCellEditor: eT
  },
  dependsOn: [gi]
}, KT = {
  moduleName: "CheckboxEditor",
  version: B,
  userComponents: {
    agCheckboxCellEditor: qD
  },
  dependsOn: [gi]
}, jT = {
  moduleName: "SelectEditor",
  version: B,
  userComponents: { agSelectCellEditor: aT },
  dependsOn: [gi]
}, qT = {
  moduleName: "LargeTextEditor",
  version: B,
  userComponents: { agLargeTextCellEditor: iT },
  dependsOn: [gi]
}, YT = {
  moduleName: "CustomEditor",
  version: B,
  dependsOn: [gi]
}, QT = class extends E {
  constructor() {
    super(...arguments), this.beanName = "selectionColSvc";
  }
  postConstruct() {
    this.addManagedPropertyListener("rowSelection", (e) => {
      this.onSelectionOptionsChanged(
        e.currentValue,
        e.previousValue,
        ds(e.source)
      );
    }), this.addManagedPropertyListener("selectionColumnDef", this.updateColumns.bind(this));
  }
  addColumns(e) {
    const t = this.columns;
    t != null && (e.list = t.list.concat(e.list), e.tree = t.tree.concat(e.tree), ov(e));
  }
  createColumns(e, t) {
    var h, g;
    const i = () => {
      var p;
      qn(this.beans, (p = this.columns) == null ? void 0 : p.tree), this.columns = null;
    }, s = e.treeDepth, n = (((h = this.columns) == null ? void 0 : h.treeDepth) ?? -1) == s, r = this.generateSelectionCols();
    if (sv(r, ((g = this.columns) == null ? void 0 : g.list) ?? []) && n)
      return;
    i();
    const { colGroupSvc: l } = this.beans, d = (l == null ? void 0 : l.findDepth(e.tree)) ?? 0, c = (l == null ? void 0 : l.balanceTreeForAutoCols(r, d)) ?? [];
    this.columns = {
      list: r,
      tree: c,
      treeDepth: d,
      map: {}
    }, t((p) => {
      if (!p)
        return null;
      const f = p.filter((m) => !ui(m));
      return [...r, ...f];
    });
  }
  updateColumns(e) {
    var i;
    const t = ds(e.source);
    (i = this.columns) == null || i.list.forEach((s) => {
      const o = this.createSelectionColDef(e.currentValue);
      s.setColDef(o, null, t), ut(this.beans, { state: [{ ...o, colId: s.getColId() }] }, t);
    });
  }
  getColumn(e) {
    var t;
    return ((t = this.columns) == null ? void 0 : t.list.find((i) => ng(i, e))) ?? null;
  }
  getColumns() {
    var e;
    return ((e = this.columns) == null ? void 0 : e.list) ?? null;
  }
  isSelectionColumnEnabled() {
    var r, a;
    const { gos: e, beans: t } = this, i = e.get("rowSelection");
    if (typeof i != "object" || !Di(e))
      return !1;
    const s = (((a = (r = t.autoColSvc) == null ? void 0 : r.getColumns()) == null ? void 0 : a.length) ?? 0) > 0;
    if (i.checkboxLocation === "autoGroupColumn" && s)
      return !1;
    const o = !!ls(i), n = Pn(i);
    return o || n;
  }
  createSelectionColDef(e) {
    const { gos: t } = this, i = e ?? t.get("selectionColumnDef"), s = t.get("enableRtl"), { rowSpan: o, spanRows: n, ...r } = i ?? {};
    return {
      // overridable properties
      width: 50,
      resizable: !1,
      suppressHeaderMenuButton: !0,
      sortable: !1,
      suppressMovable: !0,
      lockPosition: s ? "right" : "left",
      comparator(a, l, d, c) {
        const u = d.isSelected(), h = c.isSelected();
        return u === h ? 0 : u ? 1 : -1;
      },
      editable: !1,
      suppressFillHandle: !0,
      pinned: null,
      // overrides
      ...r,
      // non-overridable properties
      colId: ig,
      chartDataType: "excluded"
    };
  }
  generateSelectionCols() {
    if (!this.isSelectionColumnEnabled())
      return [];
    const e = this.createSelectionColDef(), t = e.colId;
    this.gos.validateColDef(e, t, !0);
    const i = new Wi(e, null, t, !1);
    return this.createBean(i), [i];
  }
  onSelectionOptionsChanged(e, t, i) {
    const s = t && typeof t != "string" ? ls(t) : void 0, o = e && typeof e != "string" ? ls(e) : void 0, n = s !== o, r = t && typeof t != "string" ? Pn(t) : void 0, a = e && typeof e != "string" ? Pn(e) : void 0, l = r !== a, d = $n(e), c = $n(t);
    (n || l || d !== c) && this.beans.colModel.refreshAll(i);
  }
  destroy() {
    var e;
    qn(this.beans, (e = this.columns) == null ? void 0 : e.tree), super.destroy();
  }
  /**
   * Refreshes visibility of the selection column based on which columns are currently visible.
   * Called by the VisibleColsService with the columns that are currently visible in left/center/right
   * containers. This method *MUTATES* those arrays directly.
   *
   * The selection column should be visible if all of the following are true
   * - The selection column is not disabled
   * - The number of visible columns excluding the selection column and row numbers column is greater than 0
   * @param leftCols Visible columns in the left-pinned container
   * @param centerCols Visible columns in the center viewport
   * @param rightCols Visible columns in the right-pinned container
   */
  refreshVisibility(e, t, i) {
    var l, d;
    if (!((l = this.columns) != null && l.list.length))
      return;
    const s = e.length + t.length + i.length;
    if (s === 0)
      return;
    const o = this.columns.list[0];
    if (!o.isVisible())
      return;
    const n = () => {
      let c;
      switch (o.pinned) {
        case "left":
        case !0:
          c = e;
          break;
        case "right":
          c = i;
          break;
        default:
          c = t;
      }
      c && tt(c, o);
    };
    (((d = this.beans.rowNumbersSvc) == null ? void 0 : d.getColumn(sg)) ? 2 : 1) === s && n();
  }
};
function XT(e, t) {
  var r;
  if (!t.nodes.every((a) => a.rowPinned && !$o(a) ? (I(59), !1) : a.id === void 0 ? (I(60), !1) : !0))
    return;
  const { nodes: s, source: o, newValue: n } = t;
  (r = e.selectionSvc) == null || r.setNodesSelected({ nodes: s, source: o ?? "api", newValue: n });
}
function ZT(e, t, i = "apiSelectAll") {
  var s;
  (s = e.selectionSvc) == null || s.selectAllRowNodes({ source: i, selectAll: t });
}
function JT(e, t, i = "apiSelectAll") {
  var s;
  (s = e.selectionSvc) == null || s.deselectAllRowNodes({ source: i, selectAll: t });
}
function eM(e, t = "apiSelectAllFiltered") {
  var i;
  (i = e.selectionSvc) == null || i.selectAllRowNodes({ source: t, selectAll: "filtered" });
}
function tM(e, t = "apiSelectAllFiltered") {
  var i;
  (i = e.selectionSvc) == null || i.deselectAllRowNodes({ source: t, selectAll: "filtered" });
}
function iM(e, t = "apiSelectAllCurrentPage") {
  var i;
  (i = e.selectionSvc) == null || i.selectAllRowNodes({ source: t, selectAll: "currentPage" });
}
function sM(e, t = "apiSelectAllCurrentPage") {
  var i;
  (i = e.selectionSvc) == null || i.deselectAllRowNodes({ source: t, selectAll: "currentPage" });
}
function oM(e) {
  var t;
  return ((t = e.selectionSvc) == null ? void 0 : t.getSelectedNodes()) ?? [];
}
function nM(e) {
  var t;
  return ((t = e.selectionSvc) == null ? void 0 : t.getSelectedRows()) ?? [];
}
var rM = class extends pS {
  constructor() {
    super(...arguments), this.beanName = "selectionSvc", this.selectedNodes = /* @__PURE__ */ new Map(), this.detailSelection = /* @__PURE__ */ new Map(), this.masterSelectsDetail = !1;
  }
  postConstruct() {
    super.postConstruct();
    const { gos: e } = this;
    this.mode = Kn(e), this.groupSelectsDescendants = Fo(e), this.groupSelectsFiltered = jn(e) === "filteredDescendants", this.masterSelectsDetail = qd(e) === "detail", this.addManagedPropertyListeners(["groupSelectsChildren", "groupSelectsFiltered", "rowSelection"], () => {
      const t = Fo(e), i = Kn(e), s = jn(e) === "filteredDescendants";
      this.masterSelectsDetail = qd(e) === "detail", (t !== this.groupSelectsDescendants || s !== this.groupSelectsFiltered || i !== this.mode) && (this.deselectAllRowNodes({ source: "api" }), this.groupSelectsDescendants = t, this.groupSelectsFiltered = s, this.mode = i);
    }), this.addManagedEventListeners({ rowSelected: this.onRowSelected.bind(this) });
  }
  destroy() {
    super.destroy(), this.resetNodes();
  }
  handleSelectionEvent(e, t, i) {
    if (this.isRowSelectionBlocked(t))
      return 0;
    const s = this.inferNodeSelections(t, e.shiftKey, e.metaKey || e.ctrlKey, i);
    if (s == null)
      return 0;
    if (this.selectionCtx.selectAll = !1, "select" in s)
      return s.reset ? this.resetNodes() : this.selectRange(s.deselect, !1, i), this.selectRange(s.select, !0, i);
    {
      const o = s.checkFilteredNodes ? hf(s.node) : s.newValue;
      return this.setNodesSelected({
        nodes: [s.node],
        newValue: o,
        clearSelection: s.clearSelection,
        keepDescendants: s.keepDescendants,
        event: e,
        source: i
      });
    }
  }
  setNodesSelected({
    newValue: e,
    clearSelection: t,
    suppressFinishActions: i,
    nodes: s,
    event: o,
    source: n,
    keepDescendants: r = !1
  }) {
    var d;
    const { gos: a } = this;
    if (!Di(a) && e)
      return I(132), 0;
    if (s.length === 0)
      return 0;
    if (s.length > 1 && !this.isMultiSelect())
      return I(130), 0;
    let l = 0;
    for (let c = 0; c < s.length; c++) {
      const u = s[c], h = Zi(u);
      if (h.rowPinned && !$o(h)) {
        I(59);
        continue;
      }
      if (h.id === void 0) {
        I(60);
        continue;
      }
      this.groupSelectsFiltered && h.group && !a.get("treeData") || this.selectRowNode(h, e, o, n) && (this.detailSelection.delete(h.id), l++), this.groupSelectsDescendants && ((d = h.childrenAfterGroup) != null && d.length) && (l += this.selectChildren(h, e, n));
    }
    return i || (s.length === 1 && n === "api" && this.selectionCtx.setRoot(Zi(s[0])), e && (t || !this.isMultiSelect()) && (l += this.clearOtherNodes(Zi(s[0]), r, n)), l > 0 && (this.updateGroupsFromChildrenSelections(n), this.dispatchSelectionChanged(n))), l;
  }
  // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
  // holding down 'shift'.
  selectRange(e, t, i) {
    let s = 0;
    return e.forEach((o) => {
      const n = Zi(o);
      if (n.group && this.groupSelectsDescendants)
        return;
      this.selectRowNode(n, t, void 0, i) && s++;
    }), s > 0 && (this.updateGroupsFromChildrenSelections(i), this.dispatchSelectionChanged(i)), s;
  }
  selectChildren(e, t, i) {
    const s = this.groupSelectsFiltered ? e.childrenAfterAggFilter : e.childrenAfterGroup;
    return s ? this.setNodesSelected({
      newValue: t,
      clearSelection: !1,
      suppressFinishActions: !0,
      source: i,
      nodes: s
    }) : 0;
  }
  getSelectedNodes() {
    return Array.from(this.selectedNodes.values());
  }
  getSelectedRows() {
    const e = [];
    return this.selectedNodes.forEach((t) => t.data && e.push(t.data)), e;
  }
  getSelectionCount() {
    return this.selectedNodes.size;
  }
  /**
   * This method is used by the CSRM to remove groups which are being disposed of,
   * events do not need fired in this case
   */
  filterFromSelection(e) {
    const t = /* @__PURE__ */ new Map();
    this.selectedNodes.forEach((i, s) => {
      e(i) && t.set(s, i);
    }), this.selectedNodes = t;
  }
  updateGroupsFromChildrenSelections(e, t) {
    if (!this.groupSelectsDescendants)
      return !1;
    const { gos: i, rowModel: s } = this.beans;
    if (!xe(i))
      return !1;
    const o = s.rootNode;
    if (!o)
      return !1;
    t || (t = new Do(!0, o), t.active = !1);
    let n = !1;
    return t.forEachChangedNodeDepthFirst((r) => {
      if (r !== o) {
        const a = this.calculateSelectedFromChildren(r);
        n = this.selectRowNode(r, a === null ? !1 : a, void 0, e) || n;
      }
    }), n;
  }
  clearOtherNodes(e, t, i) {
    const s = /* @__PURE__ */ new Map();
    let o = 0;
    return this.selectedNodes.forEach((n) => {
      const r = n.id == e.id;
      if ((t ? !lM(e, n) : !0) && !r) {
        const l = this.selectedNodes.get(n.id);
        o += this.setNodesSelected({
          nodes: [l],
          newValue: !1,
          clearSelection: !1,
          suppressFinishActions: !0,
          source: i
        }), this.groupSelectsDescendants && n.parent && s.set(n.parent.id, n.parent);
      }
    }), s.forEach((n) => {
      const r = this.calculateSelectedFromChildren(n);
      this.selectRowNode(n, r === null ? !1 : r, void 0, i);
    }), o;
  }
  onRowSelected(e) {
    const t = e.node;
    this.groupSelectsDescendants && t.group || (t.isSelected() ? this.selectedNodes.set(t.id, t) : this.selectedNodes.delete(t.id));
  }
  syncInRowNode(e, t) {
    this.syncInOldRowNode(e, t), this.syncInNewRowNode(e);
  }
  createDaemonNode(e) {
    if (!e.id)
      return;
    const t = new Hi(this.beans);
    return t.id = e.id, t.data = e.data, t.__daemon = !0, t.__selected = e.__selected, t.level = e.level, t;
  }
  // if the id has changed for the node, then this means the rowNode
  // is getting used for a different data item, which breaks
  // our selectedNodes, as the node now is mapped by the old id
  // which is inconsistent. so to keep the old node as selected,
  // we swap in the clone (with the old id and old data). this means
  // the oldNode is effectively a daemon we keep a reference to,
  // so if client calls api.getSelectedNodes(), it gets the daemon
  // in the result. when the client un-selects, the reference to the
  // daemon is removed. the daemon, because it's an oldNode, is not
  // used by the grid for rendering, it's a copy of what the node used
  // to be like before the id was changed.
  syncInOldRowNode(e, t) {
    t && e.id !== t.id && this.selectedNodes.get(t.id) == e && this.selectedNodes.set(t.id, t);
  }
  syncInNewRowNode(e) {
    this.selectedNodes.has(e.id) ? (e.__selected = !0, this.selectedNodes.set(e.id, e)) : e.__selected = !1;
  }
  reset(e) {
    const t = this.getSelectionCount();
    this.resetNodes(), t && this.dispatchSelectionChanged(e);
  }
  resetNodes() {
    this.selectedNodes.forEach((e) => {
      this.selectRowNode(e, !1);
    }), this.selectedNodes.clear();
  }
  // returns a list of all nodes at 'best cost' - a feature to be used
  // with groups / trees. if a group has all it's children selected,
  // then the group appears in the result, but not the children.
  // Designed for use with 'children' as the group selection type,
  // where groups don't actually appear in the selection normally.
  getBestCostNodeSelection() {
    const { gos: e, rowModel: t } = this.beans;
    if (!xe(e))
      return;
    const i = t.getTopLevelNodes();
    if (i === null)
      return;
    const s = [];
    function o(n) {
      for (let r = 0, a = n.length; r < a; r++) {
        const l = n[r];
        l.isSelected() ? s.push(l) : l.group && l.childrenAfterGroup && o(l.childrenAfterGroup);
      }
    }
    return o(i), s;
  }
  isEmpty() {
    return this.getSelectionCount() === 0;
  }
  deselectAllRowNodes({ source: e, selectAll: t }) {
    const i = xe(this.gos);
    let s = !1;
    const o = (n) => {
      const r = this.selectRowNode(Zi(n), !1, void 0, e);
      s || (s = r);
    };
    if (t === "currentPage" || t === "filtered") {
      if (!i) {
        Z(102);
        return;
      }
      this.getNodesToSelect(t).forEach(o);
    } else
      this.selectedNodes.forEach(o), this.reset(e);
    if (this.selectionCtx.selectAll = !1, i && this.groupSelectsDescendants) {
      const n = this.updateGroupsFromChildrenSelections(e);
      s || (s = n);
    }
    s && this.dispatchSelectionChanged(e);
  }
  getSelectedCounts(e) {
    let t = 0, i = 0;
    return this.getNodesToSelect(e).forEach((s) => {
      this.groupSelectsDescendants && s.group || (s.isSelected() ? t++ : s.selectable && i++);
    }), { selectedCount: t, notSelectedCount: i };
  }
  getSelectAllState(e) {
    const { selectedCount: t, notSelectedCount: i } = this.getSelectedCounts(e);
    return uf(t, i) ?? null;
  }
  hasNodesToSelect(e) {
    return this.getNodesToSelect(e).filter((t) => t.selectable).length > 0;
  }
  /**
   * @param selectAll See `MultiRowSelectionOptions.selectAll`
   * @returns all nodes including unselectable nodes which are the target of this selection attempt
   */
  getNodesToSelect(e) {
    if (!this.canSelectAll())
      return [];
    const t = [], i = (o) => t.push(o);
    if (e === "currentPage")
      return this.forEachNodeOnPage((o) => {
        if (!o.group) {
          i(o);
          return;
        }
        if (!o.expanded && !o.footer) {
          const n = (r) => {
            var a;
            i(r), (a = r.childrenAfterFilter) == null || a.forEach(n);
          };
          n(o);
          return;
        }
        this.groupSelectsDescendants || i(o);
      }), t;
    const s = this.beans.rowModel;
    return e === "filtered" ? (s.forEachNodeAfterFilter(i), t) : (s.forEachNode(i), t);
  }
  forEachNodeOnPage(e) {
    const { pageBounds: t, rowModel: i } = this.beans, s = t.getFirstRow(), o = t.getLastRow();
    for (let n = s; n <= o; n++) {
      const r = i.getRow(n);
      r && e(r);
    }
  }
  selectAllRowNodes(e) {
    const { gos: t, selectionCtx: i } = this;
    if (!Di(t)) {
      I(132);
      return;
    }
    if (zC(t) && !xo(t)) {
      I(130);
      return;
    }
    if (!this.canSelectAll())
      return;
    const { source: s, selectAll: o } = e;
    let n = !1;
    if (this.getNodesToSelect(o).forEach((r) => {
      const a = this.selectRowNode(Zi(r), !0, void 0, s);
      n || (n = a);
    }), i.selectAll = !0, xe(t) && this.groupSelectsDescendants) {
      const r = this.updateGroupsFromChildrenSelections(s);
      n || (n = r);
    }
    n && this.dispatchSelectionChanged(s);
  }
  getSelectionState() {
    return this.isEmpty() ? null : Array.from(this.selectedNodes.keys());
  }
  setSelectionState(e, t, i) {
    if (e || (e = []), !Array.isArray(e)) {
      Z(103);
      return;
    }
    const s = new Set(e), o = [];
    this.beans.rowModel.forEachNode((n) => {
      s.has(n.id) && o.push(n);
    }), i && this.resetNodes(), this.setNodesSelected({
      newValue: !0,
      nodes: o,
      source: t
    });
  }
  canSelectAll() {
    const { gos: e } = this.beans;
    return !!xe(e);
  }
  /**
   * Updates the selectable state for a node by invoking isRowSelectable callback.
   * If the node is not selectable, it will be deselected.
   *
   * Callers:
   *  - property isRowSelectable changed
   *  - after grouping / treeData via `updateSelectableAfterGrouping`
   */
  updateSelectable(e) {
    var l;
    const { gos: t, rowModel: i } = this.beans;
    if (!Di(t))
      return;
    const s = "selectableChanged", o = e !== void 0, n = xe(t) && this.groupSelectsDescendants, r = [], a = (d) => {
      var u;
      if (o && !d.group)
        return;
      if (n && d.group) {
        const h = ((u = d.childrenAfterGroup) == null ? void 0 : u.some((g) => g.selectable)) ?? !1;
        this.setRowSelectable(d, h, !0);
        return;
      }
      !this.updateRowSelectable(d, !0) && d.isSelected() && r.push(d);
    };
    if (n) {
      if (e === void 0) {
        const d = i.rootNode;
        e = d ? new Do(!1, d) : void 0;
      }
      e == null || e.forEachChangedNodeDepthFirst(a, !o, !o);
    } else
      i.forEachNode(a);
    r.length && this.setNodesSelected({
      nodes: r,
      newValue: !1,
      source: s
    }), !o && n && ((l = this.updateGroupsFromChildrenSelections) == null || l.call(this, s));
  }
  // only called by CSRM
  updateSelectableAfterGrouping(e) {
    var t;
    this.updateSelectable(e), this.groupSelectsDescendants && ((t = this.updateGroupsFromChildrenSelections) != null && t.call(this, "rowGroupChanged", e)) && this.dispatchSelectionChanged("rowGroupChanged");
  }
  refreshMasterNodeState(e, t) {
    var n, r;
    if (!this.masterSelectsDetail)
      return;
    const i = (r = (n = e.detailNode) == null ? void 0 : n.detailGridInfo) == null ? void 0 : r.api;
    if (!i)
      return;
    const s = aM(i);
    if (e.isSelected() !== s && this.selectRowNode(e, s, t, "masterDetail") && this.dispatchSelectionChanged("masterDetail"), !s) {
      const a = this.detailSelection.get(e.id) ?? /* @__PURE__ */ new Set();
      for (const l of i.getSelectedNodes())
        a.add(l.id);
      this.detailSelection.set(e.id, a);
    }
  }
  setDetailSelectionState(e, t, i) {
    if (this.masterSelectsDetail) {
      if (!xo(t)) {
        I(269);
        return;
      }
      switch (e.isSelected()) {
        case !0: {
          i.selectAll();
          break;
        }
        case !1: {
          i.deselectAll();
          break;
        }
        case void 0: {
          const s = this.detailSelection.get(e.id);
          if (s) {
            const o = [];
            for (const n of s) {
              const r = i.getRowNode(n);
              r && o.push(r);
            }
            i.setNodesSelected({ nodes: o, newValue: !0, source: "masterDetail" });
          }
          break;
        }
      }
    }
  }
  dispatchSelectionChanged(e) {
    this.eventSvc.dispatchEvent({
      type: "selectionChanged",
      source: e,
      selectedNodes: this.getSelectedNodes(),
      serverSideState: null
    });
  }
};
function Zi(e) {
  return $o(e) ? e.pinnedSibling : e.footer ? e.sibling : e;
}
function aM(e) {
  let t = 0, i = 0;
  return e.forEachNode((s) => {
    s.isSelected() ? t++ : s.selectable && i++;
  }), uf(t, i);
}
function uf(e, t) {
  if (e === 0 && t === 0)
    return !1;
  if (!(e > 0 && t > 0))
    return e > 0;
}
function lM(e, t) {
  let i = t.parent;
  for (; i; ) {
    if (i === e)
      return !0;
    i = i.parent;
  }
  return !1;
}
function hf(e) {
  var s;
  const t = e.isSelected() === !1, i = ((s = e.childrenAfterFilter) == null ? void 0 : s.some(hf)) ?? !1;
  return t || i;
}
var dM = {
  moduleName: "SharedRowSelection",
  version: B,
  beans: [QT],
  apiFunctions: {
    setNodesSelected: XT,
    selectAll: ZT,
    deselectAll: JT,
    selectAllFiltered: eM,
    deselectAllFiltered: tM,
    selectAllOnCurrentPage: iM,
    deselectAllOnCurrentPage: sM,
    getSelectedNodes: oM,
    getSelectedRows: nM
  }
}, cM = {
  moduleName: "RowSelection",
  version: B,
  rowModels: ["clientSide", "infinite", "viewport"],
  beans: [rM],
  dependsOn: [dM]
};
function uM(e) {
  var t;
  (t = e.expansionSvc) == null || t.expandAll(!0);
}
function hM(e) {
  var t;
  (t = e.expansionSvc) == null || t.expandAll(!1);
}
function gf(e) {
  var t;
  (t = e.rowModel) == null || t.onRowHeightChanged();
}
function pf(e) {
  var t, i;
  if ((t = e.rowAutoHeight) != null && t.active) {
    I(3);
    return;
  }
  (i = e.rowModel) == null || i.resetRowHeights();
}
function gM(e, t, i) {
  var n;
  const s = sR(e);
  if (s) {
    if (((n = e.rowGroupColsSvc) == null ? void 0 : n.columns.length) === 0) {
      if (t < 0) {
        Z(238);
        return;
      }
      s.setRowCount(t, i);
      return;
    }
    Z(28);
    return;
  }
  const o = xr(e);
  if (o) {
    o.setRowCount(t, i);
    return;
  }
}
function pM(e) {
  var t;
  return Ds(e.gos) ? e.rowModel.getBlockStates() : ((t = e.rowNodeBlockLoader) == null ? void 0 : t.getBlockState()) ?? {};
}
function fM(e) {
  return e.rowModel.isLastRowIndexKnown();
}
var mM = {
  moduleName: "CsrmSsrmSharedApi",
  version: B,
  apiFunctions: { expandAll: uM, collapseAll: hM }
}, CM = {
  moduleName: "RowModelSharedApi",
  version: B,
  apiFunctions: { onRowHeightChanged: gf, resetRowHeights: pf }
}, vM = {
  moduleName: "SsrmInfiniteSharedApi",
  version: B,
  apiFunctions: {
    setRowCount: gM,
    getCacheBlockState: pM,
    isLastRowIndexKnown: fM
  }
}, wM = class extends E {
  constructor() {
    super(...arguments), this.beanName = "alignedGridsSvc", this.consuming = !1;
  }
  getAlignedGridApis() {
    let e = this.gos.get("alignedGrids") ?? [];
    const t = typeof e == "function";
    return typeof e == "function" && (e = e()), e.map((s) => {
      var n;
      if (!s) {
        Z(18), t || Z(20);
        return;
      }
      if (this.isGridApi(s))
        return s;
      const o = s;
      return "current" in o ? (n = o.current) == null ? void 0 : n.api : (o.api || Z(19), o.api);
    }).filter((s) => !!s && !s.isDestroyed());
  }
  isGridApi(e) {
    return !!e && !!e.dispatchEvent;
  }
  postConstruct() {
    const e = this.fireColumnEvent.bind(this);
    this.addManagedEventListeners({
      columnMoved: e,
      columnVisible: e,
      columnPinned: e,
      columnGroupOpened: e,
      columnResized: e,
      bodyScroll: this.fireScrollEvent.bind(this),
      alignedGridColumn: ({ event: t }) => this.onColumnEvent(t),
      alignedGridScroll: ({ event: t }) => this.onScrollEvent(t)
    });
  }
  // common logic across all the fire methods
  fireEvent(e) {
    this.consuming || this.getAlignedGridApis().forEach((t) => {
      t.isDestroyed() || t.dispatchEvent(e);
    });
  }
  // common logic across all consume methods. very little common logic, however extracting
  // guarantees consistency across the methods.
  onEvent(e) {
    this.consuming = !0, e(), this.consuming = !1;
  }
  fireColumnEvent(e) {
    this.fireEvent({
      type: "alignedGridColumn",
      event: e
    });
  }
  fireScrollEvent(e) {
    e.direction === "horizontal" && this.fireEvent({
      type: "alignedGridScroll",
      event: e
    });
  }
  onScrollEvent(e) {
    this.onEvent(() => {
      this.beans.ctrlsSvc.getScrollFeature().setHorizontalScrollPosition(e.left, !0);
    });
  }
  extractDataFromEvent(e, t) {
    const i = [];
    return e.columns ? e.columns.forEach((s) => {
      i.push(t(s));
    }) : e.column && i.push(t(e.column)), i;
  }
  getMasterColumns(e) {
    return this.extractDataFromEvent(e, (t) => t);
  }
  getColumnIds(e) {
    return this.extractDataFromEvent(e, (t) => t.getColId());
  }
  onColumnEvent(e) {
    this.onEvent(() => {
      switch (e.type) {
        case "columnMoved":
        case "columnVisible":
        case "columnPinned":
        case "columnResized": {
          this.processColumnEvent(e);
          break;
        }
        case "columnGroupOpened": {
          this.processGroupOpenedEvent(e);
          break;
        }
        case "columnPivotChanged":
          I(21);
          break;
      }
    });
  }
  processGroupOpenedEvent(e) {
    const { colGroupSvc: t } = this.beans;
    t && e.columnGroups.forEach((i) => {
      let s = null;
      i && (s = t.getProvidedColGroup(i.getGroupId())), !(i && !s) && t.setColumnGroupOpened(s, i.isExpanded(), "alignedGridChanged");
    });
  }
  processColumnEvent(e) {
    var c;
    const t = e.column;
    let i = null;
    const s = this.beans, { colResize: o, ctrlsSvc: n, colModel: r } = s;
    if (t && (i = r.getColDefCol(t.getColId())), t && !i)
      return;
    const a = this.getMasterColumns(e);
    switch (e.type) {
      case "columnMoved":
        {
          const h = e.api.getColumnState().map((g) => ({ colId: g.colId }));
          ut(s, { state: h, applyOrder: !0 }, "alignedGridChanged");
        }
        break;
      case "columnVisible":
        {
          const h = e.api.getColumnState().map((g) => ({ colId: g.colId, hide: g.hide }));
          ut(s, { state: h }, "alignedGridChanged");
        }
        break;
      case "columnPinned":
        {
          const h = e.api.getColumnState().map((g) => ({ colId: g.colId, pinned: g.pinned }));
          ut(s, { state: h }, "alignedGridChanged");
        }
        break;
      case "columnResized": {
        const u = e, h = {};
        a.forEach((g) => {
          h[g.getId()] = { key: g.getColId(), newWidth: g.getActualWidth() };
        }), (c = u.flexColumns) == null || c.forEach((g) => {
          h[g.getId()] && delete h[g.getId()];
        }), o == null || o.setColumnWidths(
          Object.values(h),
          !1,
          u.finished,
          "alignedGridChanged"
        );
        break;
      }
    }
    const d = n.getGridBodyCtrl().isVerticalScrollShowing();
    this.getAlignedGridApis().forEach((u) => {
      u.setGridOption("alwaysShowVerticalScroll", d);
    });
  }
}, bM = {
  moduleName: "AlignedGrids",
  version: B,
  beans: [wM],
  dependsOn: [Cp]
}, yM = class extends dS {
  constructor() {
    super(...arguments), this.beanName = "csrmNodeSvc";
  }
}, Ca = class {
  constructor() {
    this.removals = /* @__PURE__ */ new Set(), this.updates = /* @__PURE__ */ new Set(), this.adds = /* @__PURE__ */ new Set();
  }
  /** Marks a row as removed. Order of operations is: remove, update, add */
  remove(e) {
    this.adds.delete(e) || (this.updates.delete(e), this.removals.add(e));
  }
  /** Marks a row as updated. Order of operations is: remove, update, add */
  update(e) {
    this.adds.has(e) || this.updates.add(e);
  }
  /** Marks a row as added. Order of operation is: remove, update, add */
  add(e) {
    this.adds.add(e);
  }
}, ff = (e) => {
  const t = e.childrenAfterSort, i = e.sibling;
  if (i && (i.childrenAfterSort = t), !!t)
    for (let s = 0, o = t.length - 1; s <= o; s++) {
      const n = t[s], r = s === 0, a = s === o;
      n.firstChild !== r && (n.firstChild = r, n.dispatchRowEvent("firstChildChanged")), n.lastChild !== a && (n.lastChild = a, n.dispatchRowEvent("lastChildChanged")), n.childIndex !== s && (n.childIndex = s, n.dispatchRowEvent("childIndexChanged"));
    }
}, SM = class extends E {
  constructor() {
    super(...arguments), this.beanName = "sortStage", this.refreshProps = /* @__PURE__ */ new Set(["postSortRows", "groupDisplayType", "accentedSort"]), this.step = "sort";
  }
  execute(e) {
    const t = this.beans.sortSvc.getSortOptions(), i = t.length > 0 && !!e.changedRowNodes && // in time we can remove this check, so that delta sort is always
    // on if transactions are present. it's off for now so that we can
    // selectively turn it on and test it with some select users before
    // rolling out to everyone.
    this.gos.get("deltaSort");
    this.sort(t, i, e.changedRowNodes, e.changedPath);
  }
  sort(e, t, i, s) {
    const { gos: o, colModel: n, rowGroupColsSvc: r, rowNodeSorter: a, rowRenderer: l, showRowGroupCols: d } = this.beans, c = o.get("groupMaintainOrder"), u = n.getCols().some((v) => v.isRowGroupActive()), h = r == null ? void 0 : r.columns, g = n.isPivotMode(), p = o.getCallback("postSortRows");
    let f = !1, m;
    const C = (v) => {
      var x, F;
      const R = g && v.leafGroup;
      let b = c && u && !v.leafGroup;
      b && (m ?? (m = this.shouldSortContainsGroupCols(e)), b && (b = !m));
      let w = null;
      if (b) {
        let D = !1;
        if (h) {
          const T = v.level + 1;
          T < h.length && (D = h[T].getSort() === null);
        }
        D || (w = FM(v));
      } else !e.length || R ? w = null : t && i ? w = RM(a, v, i, s, e) : w = a.doFullSort(v.childrenAfterAggFilter, e);
      if (w || (w = ((x = v.childrenAfterAggFilter) == null ? void 0 : x.slice(0)) ?? []), f || (f = ((F = v.childrenAfterSort) == null ? void 0 : F[0]) !== w[0]), v.childrenAfterSort = w, ff(v), p) {
        const D = { nodes: v.childrenAfterSort };
        p(D);
      }
    };
    if (s == null || s.forEachChangedNodeDepthFirst(C), f && o.get("groupHideOpenParents")) {
      const v = d == null ? void 0 : d.getShowRowGroupCols();
      v != null && v.length && l.refreshCells({ columns: v, force: !0 });
    }
  }
  shouldSortContainsGroupCols(e) {
    const t = e.length;
    if (!t)
      return !1;
    if (St(this.gos)) {
      for (let i = 0; i < t; ++i) {
        const s = e[i].column;
        if (s.isPrimary() && s.isRowGroupActive())
          return !0;
      }
      return !1;
    }
    for (let i = 0; i < t; ++i)
      if (e[i].column.getColDef().showRowGroup)
        return !0;
    return !1;
  }
}, RM = (e, t, i, s, o) => {
  const n = t.childrenAfterAggFilter, r = t.childrenAfterSort;
  if (!r)
    return e.doFullSort(n, o);
  const a = /* @__PURE__ */ new Set(), l = [], { updates: d, adds: c } = i;
  for (let h = 0, g = n.length; h < g; ++h) {
    const p = n[h];
    d.has(p) || c.has(p) || s && !s.canSkip(p) ? l.push({
      currentPos: l.length,
      rowNode: p
    }) : a.add(p);
  }
  const u = r.filter((h) => a.has(h)).map((h, g) => ({ currentPos: g, rowNode: h }));
  return l.sort((h, g) => e.compareRowNodes(o, h, g)), xM(e, o, l, u);
}, xM = (e, t, i, s) => {
  let o = 0, n = 0;
  const r = i.length, a = s.length, l = new Array(r + a);
  let d = 0;
  for (; o < r && n < a; ) {
    const c = i[o], u = s[n];
    e.compareRowNodes(t, c, u) < 0 ? (l[d++] = c.rowNode, ++o) : (l[d++] = u.rowNode, ++n);
  }
  for (; o < r; )
    l[d++] = i[o++].rowNode;
  for (; n < a; )
    l[d++] = s[n++].rowNode;
  return l;
}, FM = (e) => {
  const t = e.childrenAfterSort, i = e.childrenAfterAggFilter, s = t == null ? void 0 : t.length, o = i == null ? void 0 : i.length;
  if (!s || !o)
    return null;
  const n = new Array(o), r = /* @__PURE__ */ new Set();
  for (let l = 0; l < o; ++l)
    r.add(i[l]);
  let a = 0;
  for (let l = 0; l < s; ++l) {
    const d = t[l];
    r.delete(d) && (n[a++] = d);
  }
  if (r.size === 0 && a === s)
    return t;
  for (const l of r)
    n[a++] = l;
  return n.length = a, n;
}, PM = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.rootNode = null, this.rowsToDisplay = [], this.rowDataUpdatedPending = !1, this.started = !1, this.isRefreshingModel = !1, this.rowNodesCountReady = !1, this.rowCountReady = !1, this.onRowHeightChanged_debounced = De(this, this.onRowHeightChanged.bind(this), 100);
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.valueCache = e.valueCache, this.filterStage = e.filterStage, this.sortStage = e.sortStage, this.flattenStage = e.flattenStage, this.groupStage = e.groupStage, this.aggStage = e.aggStage, this.pivotStage = e.pivotStage, this.filterAggStage = e.filterAggStage;
  }
  postConstruct() {
    this.orderedStages = [
      this.groupStage,
      this.filterStage,
      this.pivotStage,
      this.aggStage,
      this.sortStage,
      this.filterAggStage,
      this.flattenStage
    ].filter((s) => !!s);
    const e = this.refreshModel.bind(this, { step: "group" }), t = this.refreshModel.bind(this, {
      step: "group",
      // after cols change, row grouping (the first stage) could of changed
      afterColumnsChanged: !0,
      keepRenderedRows: !0,
      // we want animations cos sorting or filtering could be applied
      animate: !this.gos.get("suppressAnimationFrame")
    });
    this.addManagedEventListeners({
      newColumnsLoaded: t,
      columnRowGroupChanged: e,
      columnValueChanged: this.onValueChanged.bind(this),
      columnPivotChanged: this.refreshModel.bind(this, { step: "pivot" }),
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      columnPivotModeChanged: e,
      gridStylesChanged: this.onGridStylesChanges.bind(this),
      gridReady: this.onGridReady.bind(this),
      rowExpansionStateChanged: this.onRowGroupOpened.bind(this)
    }), this.addPropertyListeners(), this.rootNode = new Hi(this.beans);
    const i = this.getNewNodeManager();
    this.nodeManager = i, i.activate(this.rootNode);
  }
  getNewNodeManager() {
    const { gos: e, beans: t } = this;
    return eg(e) === "treeNested" && t.csrmChildrenTreeNodeSvc || t.csrmNodeSvc;
  }
  addPropertyListeners() {
    const e = [
      "treeData",
      "treeDataChildrenField",
      ...this.orderedStages.flatMap(({ refreshProps: t }) => [...t])
    ];
    this.addManagedPropertyListeners(e, (t) => {
      var s;
      const i = (s = t.changeSet) == null ? void 0 : s.properties;
      i && this.onPropChange(i);
    }), this.addManagedPropertyListener("rowData", () => this.onPropChange(["rowData"])), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
  }
  start() {
    this.started = !0, this.rowNodesCountReady ? this.refreshModel({ step: "group", rowDataUpdated: !0, newData: !0 }) : this.setInitialData();
  }
  setInitialData() {
    this.gos.get("rowData") && this.onPropChange(["rowData"]);
  }
  ensureRowHeightsValid(e, t, i, s) {
    let o, n = !1;
    do {
      o = !1;
      const r = this.getRowIndexAtPixel(e), a = this.getRowIndexAtPixel(t), l = Math.max(r, i), d = Math.min(a, s);
      for (let c = l; c <= d; c++) {
        const u = this.getRow(c);
        if (u.rowHeightEstimated) {
          const h = ri(this.beans, u);
          u.setRowHeight(h.height), o = !0, n = !0;
        }
      }
      o && this.setRowTopAndRowIndex();
    } while (o);
    return n;
  }
  onPropChange(e) {
    if (!this.rootNode)
      return;
    const t = this.gos, i = new Set(e), s = {
      step: "nothing",
      changedProps: i
    }, o = i.has("rowData"), n = this.nodeManager, r = this.getNewNodeManager(), a = n !== r || o && i.has("treeData") && t.get("treeData") || i.has("treeDataChildrenField") && t.get("treeData");
    let l;
    if ((a || o) && (l = t.get("rowData"), l != null && !Array.isArray(l) && (l = null, I(1))), a && (o || (l = (n == null ? void 0 : n.extractRowData()) ?? l), n !== r && (n == null || n.deactivate(), this.nodeManager = r), r.activate(this.rootNode)), l)
      if (!a && !this.isEmpty() && l.length > 0 && t.exists("getRowId") && // this property is a backwards compatibility property, for those who want
      // the old behaviour of Row IDs but NOT Immutable Data.
      !t.get("resetRowDataOnUpdate"))
        s.keepRenderedRows = !0, s.animate = !this.gos.get("suppressAnimationFrame"), s.changedRowNodes = new Ca(), r.setImmutableRowData(s, l);
      else {
        s.rowDataUpdated = !0, s.newData = !0;
        const { selectionSvc: c, pinnedRowModel: u } = this.beans;
        c == null || c.reset("rowDataChanged"), u != null && u.isManual() && u.reset(), this.rowNodesCountReady = !0, r.setNewRowData(l);
      }
    if (s.rowDataUpdated)
      s.step = "group";
    else if (s.step === "nothing") {
      for (const { refreshProps: d, step: c } of this.orderedStages)
        if (e.some((u) => d.has(u))) {
          s.step = c;
          break;
        }
    }
    s.step !== "nothing" && this.refreshModel(s);
  }
  setRowTopAndRowIndex() {
    const { beans: e, rowsToDisplay: t } = this, i = e.environment.getDefaultRowHeight();
    let s = 0;
    const o = /* @__PURE__ */ new Set(), n = Me(this.gos, "normal");
    for (let r = 0, a = t.length; r < a; ++r) {
      const l = t[r];
      if (l.id != null && o.add(l.id), l.rowHeight == null) {
        const d = ri(e, l, n, i);
        l.setRowHeight(d.height, d.estimated);
      }
      l.setRowTop(s), l.setRowIndex(r), s += l.rowHeight;
    }
    return o;
  }
  clearRowTopAndRowIndex(e, t) {
    const i = e.active, s = (n) => {
      n && n.id != null && !t.has(n.id) && n.clearRowTopAndRowIndex();
    }, o = (n) => {
      if (n !== null && (s(n), s(n.detailNode), s(n.sibling), n.hasChildren() && n.childrenAfterGroup)) {
        const r = n.level == -1;
        i && !r && !n.expanded || n.childrenAfterGroup.forEach(o);
      }
    };
    o(this.rootNode);
  }
  isLastRowIndexKnown() {
    return !0;
  }
  getRowCount() {
    return this.rowsToDisplay ? this.rowsToDisplay.length : 0;
  }
  /**
   * Returns the number of rows with level === 1
   */
  getTopLevelRowCount() {
    const e = this.rootNode;
    if (!e || this.rowsToDisplay.length === 0)
      return 0;
    if (this.rowsToDisplay && this.rowsToDisplay[0] === e)
      return 1;
    const i = e.childrenAfterSort, s = e.sibling && e.sibling.displayed ? 1 : 0;
    return (i ? i.length : 0) + s;
  }
  /**
   * Get the row display index by the top level index
   * top level index is the index of rows with level === 1
   */
  getTopLevelRowDisplayedIndex(e) {
    const { rootNode: t, rowsToDisplay: i } = this;
    if (!t || !i.length || i[0] === t)
      return e;
    const { childrenAfterSort: o } = t, n = (a) => {
      let l = o[a];
      if (this.gos.get("groupHideOpenParents"))
        for (; l.expanded && l.childrenAfterSort && l.childrenAfterSort.length > 0; )
          l = l.childrenAfterSort[0];
      return l.rowIndex;
    }, { footerSvc: r } = this.beans;
    return r ? r.getTopDisplayIndex(i, e, o, n) : n(e);
  }
  /**
   * The opposite of `getTopLevelRowDisplayedIndex`
   */
  getTopLevelIndexFromDisplayedIndex(e) {
    var r;
    const { rootNode: t, rowsToDisplay: i } = this;
    if (!t || !i.length || i[0] === t)
      return e;
    let o = this.getRow(e);
    for (o.footer && (o = o.sibling); o.parent && o.parent !== t; )
      o = o.parent;
    const n = (r = t.childrenAfterSort) == null ? void 0 : r.findIndex((a) => a === o);
    return n === -1 ? e : n ?? e;
  }
  getRowBounds(e) {
    const t = this.rowsToDisplay[e];
    return t ? {
      rowTop: t.rowTop,
      rowHeight: t.rowHeight
    } : null;
  }
  onRowGroupOpened() {
    const e = as(this.gos);
    this.refreshModel({ step: "map", keepRenderedRows: !0, animate: e });
  }
  onFilterChanged(e) {
    if (e.afterDataChange)
      return;
    const t = as(this.gos), s = e.columns.length === 0 || e.columns.some((o) => o.isPrimary()) ? "filter" : "filter_aggregates";
    this.refreshModel({ step: s, keepRenderedRows: !0, animate: t });
  }
  onSortChanged() {
    const e = as(this.gos);
    this.refreshModel({
      step: "sort",
      keepRenderedRows: !0,
      animate: e
    });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.refreshModel({ step: this.colModel.isPivotActive() ? "pivot" : "aggregate" });
  }
  createChangePath(e) {
    const t = new Do(!1, this.rootNode);
    return e || (t.active = !1), t;
  }
  isSuppressModelUpdateAfterUpdateTransaction(e) {
    if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction"))
      return !1;
    const { changedRowNodes: t, newData: i, rowDataUpdated: s } = e;
    return !(!t || i || !s || t.removals.size || t.adds.size);
  }
  refreshModel(e) {
    var n, r, a;
    if (!this.rootNode)
      return;
    const t = this.beans;
    let i = !!e.rowDataUpdated;
    const s = e.changedPath ?? (e.changedPath = this.createChangePath(!e.newData && i));
    if (this.started && i && this.eventSvc.dispatchEvent({ type: "rowDataUpdated" }), !this.started || this.isRefreshingModel || this.colModel.changeEventsDispatching || this.isSuppressModelUpdateAfterUpdateTransaction(e)) {
      this.rowDataUpdatedPending || (this.rowDataUpdatedPending = i);
      return;
    }
    switch (this.rowDataUpdatedPending && (this.rowDataUpdatedPending = !1, e.rowDataUpdated = i = !0, e.step = "group"), this.isRefreshingModel = !0, (n = t.masterDetailSvc) == null || n.refreshModel(e), i && e.step !== "group" && ((r = t.colFilter) == null || r.refreshModel()), e.step) {
      case "group":
        (this.doRowGrouping(e) || i) && ((a = t.colFilter) == null || a.refreshModel()), !this.rowCountReady && this.rowNodesCountReady && (this.rowCountReady = !0, this.eventSvc.dispatchEventOnce({ type: "rowCountReady" }));
      case "filter":
        this.doFilter(s);
      case "pivot":
        this.doPivot(s);
      case "aggregate":
        this.doAggregate(s);
      case "filter_aggregates":
        this.doFilterAggregates(s);
      case "sort":
        this.doSort(e.changedRowNodes, s);
      case "map":
        this.doRowsToDisplay();
    }
    const o = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(s, o), this.isRefreshingModel = !1, this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      animate: e.animate,
      keepRenderedRows: e.keepRenderedRows,
      newData: e.newData,
      newPage: !1,
      keepUndoRedoStack: e.keepUndoRedoStack
    });
  }
  isEmpty() {
    var e, t, i;
    return !((t = (e = this.rootNode) == null ? void 0 : e.allLeafChildren) != null && t.length) || !((i = this.colModel) != null && i.ready);
  }
  isRowsToRender() {
    return this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(e, t) {
    let i = !1, s = !1;
    const o = [], n = Fo(this.gos);
    return this.forEachNodeAfterFilterAndSort((r) => {
      if (s)
        return;
      if (i && (r === t || r === e) && (s = !0, r.group && n)) {
        o.push(...r.allLeafChildren);
        return;
      }
      if (!i) {
        if (r !== t && r !== e)
          return;
        i = !0, t === e && (s = !0);
      }
      if (!r.group || !n) {
        o.push(r);
        return;
      }
    }), o;
  }
  getTopLevelNodes() {
    var e;
    return ((e = this.rootNode) == null ? void 0 : e.childrenAfterGroup) ?? null;
  }
  getRow(e) {
    return this.rowsToDisplay[e];
  }
  isRowPresent(e) {
    return this.rowsToDisplay.indexOf(e) >= 0;
  }
  getRowIndexAtPixel(e) {
    const t = this.rowsToDisplay;
    if (this.isEmpty() || t.length === 0)
      return -1;
    let i = 0, s = t.length - 1;
    if (e <= 0)
      return 0;
    if (se(t).rowTop <= e)
      return t.length - 1;
    let n = -1, r = -1;
    for (; ; ) {
      const a = Math.floor((i + s) / 2), l = t[a];
      if (this.isRowInPixel(l, e) || (l.rowTop < e ? i = a + 1 : l.rowTop > e && (s = a - 1), n === i && r === s))
        return a;
      n = i, r = s;
    }
  }
  isRowInPixel(e, t) {
    const i = e.rowTop, s = e.rowTop + e.rowHeight;
    return i <= t && s > t;
  }
  forEachLeafNode(e) {
    var t, i;
    (i = (t = this.rootNode) == null ? void 0 : t.allLeafChildren) == null || i.forEach((s, o) => e(s, o));
  }
  forEachNode(e, t = !1) {
    this.depthFirstSearchRowNodes(e, t);
  }
  forEachDisplayedNode(e) {
    this.rowsToDisplay.forEach(e);
  }
  forEachNodeAfterFilter(e, t = !1) {
    this.depthFirstSearchRowNodes(e, t, (i) => i.childrenAfterAggFilter);
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    this.depthFirstSearchRowNodes(e, t, (i) => i.childrenAfterSort);
  }
  forEachPivotNode(e, t = !1, i = !1) {
    const { colModel: s, rowGroupColsSvc: o } = this.beans;
    if (!s.isPivotMode())
      return;
    if (!(o != null && o.columns.length)) {
      e(this.rootNode, 0);
      return;
    }
    const n = i ? "childrenAfterSort" : "childrenAfterGroup";
    this.depthFirstSearchRowNodes(
      e,
      t,
      (r) => r.leafGroup ? null : r[n]
    );
  }
  /**
   * Iterate through each node and all of its children
   * @param callback the function to execute for each node
   * @param includeFooterNodes whether to also iterate over footer nodes
   * @param nodes the nodes to start iterating over
   * @param getChildren a function to determine the recursion strategy
   * @param startIndex the index to start from
   * @returns the index ended at
   */
  depthFirstSearchRowNodes(e, t = !1, i = (n) => n.childrenAfterGroup, s = this.rootNode, o = 0) {
    let n = o;
    if (!s)
      return n;
    const r = s === this.rootNode;
    r || e(s, n++);
    const { footerSvc: a } = this.beans;
    if (s.hasChildren() && !s.footer) {
      const l = i(s);
      if (l) {
        n = (a == null ? void 0 : a.addTotalRows(n, s, e, t, r, "top")) ?? n;
        for (const d of l)
          n = this.depthFirstSearchRowNodes(e, t, i, d, n);
        return (a == null ? void 0 : a.addTotalRows(n, s, e, t, r, "bottom")) ?? n;
      }
    }
    return n;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  doAggregate(e) {
    var i;
    const t = this.rootNode;
    t && ((i = this.aggStage) == null || i.execute({ rowNode: t, changedPath: e }));
  }
  doFilterAggregates(e) {
    const t = this.rootNode;
    this.filterAggStage ? this.filterAggStage.execute({ rowNode: t, changedPath: e }) : t.childrenAfterAggFilter = t.childrenAfterFilter;
  }
  doSort(e, t) {
    this.sortStage ? this.sortStage.execute({
      rowNode: this.rootNode,
      changedRowNodes: e,
      changedPath: t
    }) : t.forEachChangedNodeDepthFirst((i) => {
      i.childrenAfterSort = i.childrenAfterAggFilter.slice(0), ff(i);
    });
  }
  doRowGrouping(e) {
    var o;
    const t = this.rootNode, i = (o = this.groupStage) == null ? void 0 : o.execute({
      rowNode: t,
      changedRowNodes: e.changedRowNodes,
      changedPath: e.changedPath,
      rowNodesOrderChanged: !!e.rowNodesOrderChanged,
      afterColumnsChanged: !!e.afterColumnsChanged
    });
    if (i !== void 0)
      return i;
    const s = t.sibling;
    return t.childrenAfterGroup = t.allLeafChildren, s && (s.childrenAfterGroup = t.childrenAfterGroup), t.updateHasChildren(), !1;
  }
  doFilter(e) {
    this.filterStage ? this.filterStage.execute({ rowNode: this.rootNode, changedPath: e }) : e.forEachChangedNodeDepthFirst((t) => {
      t.childrenAfterFilter = t.childrenAfterGroup, Np(t);
    }, !0);
  }
  doPivot(e) {
    var t;
    (t = this.pivotStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  getRowNode(e) {
    var s;
    const t = this.nodeManager.getRowNode(e);
    return typeof t == "object" ? t : typeof e == "string" && e.indexOf($a) === 0 ? (s = this.groupStage) == null ? void 0 : s.getNode(e) : void 0;
  }
  batchUpdateRowData(e, t) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const i = this.gos.get("asyncTransactionWaitMillis");
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.isAlive() && this.executeBatchUpdateRowData();
      }, i);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t });
  }
  flushAsyncTransactions() {
    this.applyAsyncTransactionsTimeout != null && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData());
  }
  executeBatchUpdateRowData() {
    var o, n;
    (o = this.valueCache) == null || o.onDataChanged();
    const e = [], t = [], i = new Ca();
    let s = !1;
    (n = this.rowDataTransactionBatch) == null || n.forEach((r) => {
      this.rowNodesCountReady = !0;
      const { rowNodeTransaction: a, rowsInserted: l } = this.nodeManager.updateRowData(
        r.rowDataTransaction,
        i
      );
      l && (s = !0), t.push(a), r.callback && e.push(r.callback.bind(null, a));
    }), this.commitTransactions(s, i), e.length > 0 && window.setTimeout(() => {
      e.forEach((r) => r());
    }, 0), t.length > 0 && this.eventSvc.dispatchEvent({
      type: "asyncTransactionsFlushed",
      results: t
    }), this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0;
  }
  /**
   * Used to apply transaction changes.
   * Called by gridApi & rowDragFeature
   */
  updateRowData(e) {
    var o;
    (o = this.valueCache) == null || o.onDataChanged(), this.rowNodesCountReady = !0;
    const t = new Ca(), { rowNodeTransaction: i, rowsInserted: s } = this.nodeManager.updateRowData(e, t);
    return this.commitTransactions(s, t), i;
  }
  /**
   * Common to:
   * - executeBatchUpdateRowData (batch transactions)
   * - updateRowData (single transaction)
   * - setImmutableRowData (generated transaction)
   *
   * @param rowNodeTrans - the transactions to apply
   * @param orderChanged - whether the order of the rows has changed, either via generated transaction or user provided addIndex
   */
  commitTransactions(e, t) {
    this.refreshModel({
      step: "group",
      rowDataUpdated: !0,
      rowNodesOrderChanged: e,
      keepRenderedRows: !0,
      animate: !this.gos.get("suppressAnimationFrame"),
      changedRowNodes: t,
      changedPath: this.createChangePath(!0)
    });
  }
  doRowsToDisplay() {
    const { flattenStage: e, rootNode: t } = this;
    let i;
    if (e)
      i = e.execute({ rowNode: t });
    else {
      i = (t == null ? void 0 : t.childrenAfterSort) ?? [];
      for (const s of i)
        s.setUiLevel(0);
    }
    this.rowsToDisplay = i;
  }
  onRowHeightChanged() {
    this.refreshModel({
      step: "map",
      keepRenderedRows: !0,
      keepUndoRedoStack: !0
    });
  }
  resetRowHeights() {
    const e = this.rootNode;
    if (!e)
      return;
    const t = this.resetRowHeightsForAllRowNodes();
    e.setRowHeight(e.rowHeight, !0), e.sibling && e.sibling.setRowHeight(e.sibling.rowHeight, !0), t && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      t.setRowHeight(t.rowHeight, !0);
      const i = t.detailNode;
      i && i.setRowHeight(i.rowHeight, !0), t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, !0), e = !0;
    }), e;
  }
  onGridStylesChanges(e) {
    var t;
    if (e.rowHeightChanged) {
      if ((t = this.beans.rowAutoHeight) != null && t.active)
        return;
      this.resetRowHeights();
    }
  }
  onGridReady() {
    this.started || this.setInitialData();
  }
  isRowDataLoaded() {
    return this.rowCountReady;
  }
  destroy() {
    super.destroy(), this.started = !1, this.rootNode = null, this.nodeManager = null, this.rowDataTransactionBatch = null, this.orderedStages = Xd, this.rowsToDisplay = Xd;
  }
  /**
   * @deprecated v33.1
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
};
function EM(e) {
  var t;
  (t = e.expansionSvc) == null || t.onGroupExpandedOrCollapsed();
}
function DM(e, t) {
  const i = Kt(e);
  i && ((!t || t === "everything") && (t = "group"), i.refreshModel({
    step: t,
    keepRenderedRows: !0,
    animate: !e.gos.get("suppressAnimationFrame")
  }));
}
function TM(e) {
  var t;
  return ((t = Kt(e)) == null ? void 0 : t.isEmpty()) ?? !0;
}
function MM(e, t) {
  var i;
  (i = Kt(e)) == null || i.forEachLeafNode(t);
}
function AM(e, t) {
  var i;
  (i = Kt(e)) == null || i.forEachNodeAfterFilter(t);
}
function IM(e, t) {
  var i;
  (i = Kt(e)) == null || i.forEachNodeAfterFilterAndSort(t);
}
function kM(e, t) {
  return e.frameworkOverrides.wrapIncoming(
    () => {
      var i;
      return (i = Kt(e)) == null ? void 0 : i.updateRowData(t);
    }
  );
}
function LM(e, t, i) {
  e.frameworkOverrides.wrapIncoming(
    () => {
      var s;
      return (s = Kt(e)) == null ? void 0 : s.batchUpdateRowData(t, i);
    }
  );
}
function OM(e) {
  e.frameworkOverrides.wrapIncoming(() => {
    var t;
    return (t = Kt(e)) == null ? void 0 : t.flushAsyncTransactions();
  });
}
function _M(e) {
  var t;
  return (t = e.selectionSvc) == null ? void 0 : t.getBestCostNodeSelection();
}
var HM = {
  moduleName: "ClientSideRowModel",
  version: B,
  rowModels: ["clientSide"],
  beans: [yM, PM, SM],
  dependsOn: [Hp]
}, BM = {
  moduleName: "ClientSideRowModelApi",
  version: B,
  apiFunctions: {
    onGroupExpandedOrCollapsed: EM,
    refreshClientSideRowModel: DM,
    isRowDataEmpty: TM,
    forEachLeafNode: MM,
    forEachNodeAfterFilter: AM,
    forEachNodeAfterFilterAndSort: IM,
    applyTransaction: kM,
    applyTransactionAsync: LM,
    flushAsyncTransactions: OM,
    getBestCostNodeSelection: _M,
    resetRowHeights: pf,
    onRowHeightChanged: gf
  },
  dependsOn: [mM, CM]
}, GM = class extends E {
  constructor() {
    super(...arguments), this.beanName = "gridSerializer";
  }
  wireBeans(e) {
    this.visibleCols = e.visibleCols, this.colModel = e.colModel, this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel;
  }
  serialize(e, t = {}) {
    const { allColumns: i, columnKeys: s, skipRowGroups: o, exportRowNumbers: n } = t, r = this.getColumnsToExport({
      allColumns: i,
      skipRowGroups: o,
      columnKeys: s,
      exportRowNumbers: n
    });
    return [
      // first pass, put in the header names of the cols
      this.prepareSession(r),
      this.prependContent(t),
      this.exportColumnGroups(t, r),
      this.exportHeaders(t, r),
      this.processPinnedTopRows(t, r),
      this.processRows(t, r),
      this.processPinnedBottomRows(t, r),
      this.appendContent(t)
    ].reduce((a, l) => l(a), e).parse();
  }
  processRow(e, t, i, s) {
    var p;
    const o = t.shouldRowBeSkipped || (() => !1), r = t.rowPositions != null || !!t.onlySelected, a = this.gos.get("groupHideOpenParents") && !r, l = this.colModel.isPivotMode() ? s.leafGroup : !s.group, d = !!s.footer, c = s.allChildrenCount === 1 && ((p = s.childrenAfterGroup) == null ? void 0 : p.length) === 1 && NC(this.gos, s);
    if (!l && !d && (t.skipRowGroups || c || a) || t.onlySelected && !s.isSelected() || t.skipPinnedTop && s.rowPinned === "top" || t.skipPinnedBottom && s.rowPinned === "bottom" || s.stub || s.level === -1 && !l && !d || o(W(this.gos, { node: s })))
      return;
    const g = e.onNewBodyRow(s);
    if (i.forEach((f, m) => {
      g.onColumn(f, m, s);
    }), t.getCustomContentBelowRow) {
      const f = t.getCustomContentBelowRow(W(this.gos, { node: s }));
      f && e.addCustomContent(f);
    }
  }
  appendContent(e) {
    return (t) => {
      const i = e.appendContent;
      return i && t.addCustomContent(i), t;
    };
  }
  prependContent(e) {
    return (t) => {
      const i = e.prependContent;
      return i && t.addCustomContent(i), t;
    };
  }
  prepareSession(e) {
    return (t) => (t.prepare(e), t);
  }
  exportColumnGroups(e, t) {
    return (i) => {
      if (!e.skipColumnGroupHeaders) {
        const s = new pg(), { colGroupSvc: o } = this.beans, n = o ? o.createColumnGroups({
          columns: t,
          idCreator: s,
          pinned: null,
          isStandaloneStructure: !0
        }) : t;
        this.recursivelyAddHeaderGroups(
          n,
          i,
          e.processGroupHeaderCallback
        );
      }
      return i;
    };
  }
  exportHeaders(e, t) {
    return (i) => {
      if (!e.skipColumnHeaders) {
        const s = i.onNewHeaderRow();
        t.forEach((o, n) => {
          s.onColumn(o, n, void 0);
        });
      }
      return i;
    };
  }
  processPinnedTopRows(e, t) {
    return (i) => {
      var o, n;
      const s = this.processRow.bind(this, i, e, t);
      return e.rowPositions ? e.rowPositions.filter((r) => r.rowPinned === "top").sort((r, a) => r.rowIndex - a.rowIndex).map((r) => {
        var a;
        return (a = this.pinnedRowModel) == null ? void 0 : a.getPinnedTopRow(r.rowIndex);
      }).forEach(s) : (o = this.pinnedRowModel) != null && o.isManual() || (n = this.pinnedRowModel) == null || n.forEachPinnedRow("top", s), i;
    };
  }
  processRows(e, t) {
    return (i) => {
      var d;
      const s = this.rowModel, o = xe(this.gos), n = Ds(this.gos), r = !o && e.onlySelected, a = this.processRow.bind(this, i, e, t), { exportedRows: l = "filteredAndSorted" } = e;
      if (e.rowPositions)
        return e.rowPositions.filter((c) => c.rowPinned == null).sort((c, u) => c.rowIndex - u.rowIndex).map((c) => s.getRow(c.rowIndex)).forEach(a), i;
      if (this.colModel.isPivotMode())
        return o ? s.forEachPivotNode(a, !0, l === "filteredAndSorted") : n ? s.forEachNodeAfterFilterAndSort(a, !0) : s.forEachNode(a), i;
      if (e.onlySelectedAllPages || r) {
        const c = ((d = this.beans.selectionSvc) == null ? void 0 : d.getSelectedNodes()) ?? [];
        this.replicateSortedOrder(c), c.forEach(a);
      } else
        l === "all" ? s.forEachNode(a) : o || n ? s.forEachNodeAfterFilterAndSort(a, !0) : s.forEachNode(a);
      return i;
    };
  }
  replicateSortedOrder(e) {
    const { sortSvc: t, rowNodeSorter: i } = this.beans;
    if (!t || !i)
      return;
    const s = t.getSortOptions(), o = (n, r) => {
      var a, l;
      return n.rowIndex != null && r.rowIndex != null ? n.rowIndex - r.rowIndex : n.level === r.level ? ((a = n.parent) == null ? void 0 : a.id) === ((l = r.parent) == null ? void 0 : l.id) ? i.compareRowNodes(
        s,
        {
          rowNode: n,
          currentPos: n.rowIndex ?? -1
        },
        {
          rowNode: r,
          currentPos: r.rowIndex ?? -1
        }
      ) : o(n.parent, r.parent) : n.level > r.level ? o(n.parent, r) : o(n, r.parent);
    };
    e.sort(o);
  }
  processPinnedBottomRows(e, t) {
    return (i) => {
      var o, n;
      const s = this.processRow.bind(this, i, e, t);
      return e.rowPositions ? e.rowPositions.filter((r) => r.rowPinned === "bottom").sort((r, a) => r.rowIndex - a.rowIndex).map((r) => {
        var a;
        return (a = this.pinnedRowModel) == null ? void 0 : a.getPinnedBottomRow(r.rowIndex);
      }).forEach(s) : (o = this.pinnedRowModel) != null && o.isManual() || (n = this.pinnedRowModel) == null || n.forEachPinnedRow("bottom", s), i;
    };
  }
  getColumnsToExport(e) {
    const { allColumns: t = !1, skipRowGroups: i = !1, exportRowNumbers: s = !1, columnKeys: o } = e, { colModel: n, gos: r, visibleCols: a } = this, l = n.isPivotMode(), d = (h) => ui(h) ? !1 : !ii(h) || s;
    if (o && o.length)
      return n.getColsForKeys(o).filter(d);
    const c = r.get("treeData");
    let u = [];
    return t && !l ? u = n.getCols() : u = a.allCols, u = u.filter(
      (h) => d(h) && (i && !c ? !kl(h) : !0)
    ), u;
  }
  recursivelyAddHeaderGroups(e, t, i) {
    const s = [];
    e.forEach((o) => {
      const n = o;
      n.getChildren && n.getChildren().forEach((r) => s.push(r));
    }), e.length > 0 && be(e[0]) && this.doAddHeaderHeader(t, e, i), s && s.length > 0 && this.recursivelyAddHeaderGroups(
      s,
      t,
      i
    );
  }
  doAddHeaderHeader(e, t, i) {
    const s = e.onNewHeaderGroupingRow();
    let o = 0;
    t.forEach((n) => {
      const r = n;
      let a;
      i ? a = i(
        W(this.gos, {
          columnGroup: r
        })
      ) : a = this.beans.colNames.getDisplayNameForColumnGroup(r, "header");
      const d = (r.isExpandable() ? r.getLeafColumns() : []).reduce(
        (c, u, h, g) => {
          let p = se(c);
          return u.getColumnGroupShow() === "open" ? (!p || p[1] != null) && (p = [h], c.push(p)) : p && p[1] == null && (p[1] = h - 1), h === g.length - 1 && p && p[1] == null && (p[1] = h), c;
        },
        []
      );
      s.onColumn(
        r,
        a || "",
        o++,
        r.getLeafColumns().length - 1,
        d
      );
    });
  }
}, VM = {
  moduleName: "SharedExport",
  version: B,
  beans: [GM]
}, su = `\r
`, NM = class extends bE {
  constructor(e) {
    super(e), this.config = e, this.isFirstLine = !0, this.result = "";
    const { suppressQuotes: t, columnSeparator: i } = e;
    this.suppressQuotes = t, this.columnSeparator = i;
  }
  addCustomContent(e) {
    e && (typeof e == "string" ? (/^\s*\n/.test(e) || this.beginNewLine(), e = e.replace(/\r?\n/g, su), this.result += e) : e.forEach((t) => {
      this.beginNewLine(), t.forEach((i, s) => {
        s !== 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(i.data.value || ""), i.mergeAcross && this.appendEmptyCells(i.mergeAcross);
      });
    }));
  }
  onNewHeaderGroupingRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
    };
  }
  onNewHeaderGroupingRowColumn(e, t, i, s) {
    i != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(t), this.appendEmptyCells(s);
  }
  appendEmptyCells(e) {
    for (let t = 1; t <= e; t++)
      this.result += this.columnSeparator + this.putInQuotes("");
  }
  onNewHeaderRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderRowColumn.bind(this)
    };
  }
  onNewHeaderRowColumn(e, t) {
    t != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(this.extractHeaderValue(e));
  }
  onNewBodyRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewBodyRowColumn.bind(this)
    };
  }
  onNewBodyRowColumn(e, t, i) {
    t != 0 && (this.result += this.columnSeparator);
    const s = this.extractRowCellValue(e, t, t, "csv", i);
    this.result += this.putInQuotes(s.valueFormatted ?? s.value);
  }
  putInQuotes(e) {
    if (this.suppressQuotes)
      return e;
    if (e == null)
      return '""';
    let t;
    return typeof e == "string" ? t = e : typeof e.toString == "function" ? t = e.toString() : (I(53), t = ""), '"' + t.replace(/"/g, '""') + '"';
  }
  parse() {
    return this.result;
  }
  beginNewLine() {
    this.isFirstLine || (this.result += su), this.isFirstLine = !1;
  }
}, WM = class extends wE {
  constructor() {
    super(...arguments), this.beanName = "csvCreator";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.colNames = e.colNames, this.rowGroupColsSvc = e.rowGroupColsSvc, this.valueSvc = e.valueSvc;
  }
  getMergedParams(e) {
    const t = this.gos.get("defaultCsvExportParams");
    return Object.assign({}, t, e);
  }
  export(e) {
    if (this.isExportSuppressed()) {
      I(51);
      return;
    }
    const t = this.getMergedParams(e), i = this.getData(t), s = new Blob(["\uFEFF", i], { type: "text/plain" }), o = typeof t.fileName == "function" ? t.fileName(W(this.gos, {})) : t.fileName;
    yE(this.getFileName(o), s);
  }
  exportDataAsCsv(e) {
    this.export(e);
  }
  getDataAsCsv(e, t = !1) {
    const i = t ? Object.assign({}, e) : this.getMergedParams(e);
    return this.getData(i);
  }
  getDefaultFileExtension() {
    return "csv";
  }
  createSerializingSession(e) {
    const { colModel: t, colNames: i, rowGroupColsSvc: s, valueSvc: o, gos: n } = this, {
      processCellCallback: r,
      processHeaderCallback: a,
      processGroupHeaderCallback: l,
      processRowGroupCallback: d,
      suppressQuotes: c,
      columnSeparator: u
    } = e;
    return new NM({
      colModel: t,
      colNames: i,
      valueSvc: o,
      gos: n,
      processCellCallback: r || void 0,
      processHeaderCallback: a || void 0,
      processGroupHeaderCallback: l || void 0,
      processRowGroupCallback: d || void 0,
      suppressQuotes: c || !1,
      columnSeparator: u || ",",
      rowGroupColsSvc: s
    });
  }
  isExportSuppressed() {
    return this.gos.get("suppressCsvExport");
  }
};
function zM(e, t) {
  var i;
  return (i = e.csvCreator) == null ? void 0 : i.getDataAsCsv(t);
}
function UM(e, t) {
  var i;
  (i = e.csvCreator) == null || i.exportDataAsCsv(t);
}
var $M = {
  moduleName: "CsvExport",
  version: B,
  beans: [WM],
  apiFunctions: {
    getDataAsCsv: zM,
    exportDataAsCsv: UM
  },
  dependsOn: [VM]
}, KM = class extends E {
  constructor(e, t, i) {
    super(), this.id = e, this.parentCache = t, this.params = i, this.state = "needsLoading", this.version = 0, this.startRow = e * i.blockSize, this.endRow = this.startRow + i.blockSize;
  }
  load() {
    this.state = "loading", this.loadFromDatasource();
  }
  setStateWaitingToLoad() {
    this.version++, this.state = "needsLoading";
  }
  pageLoadFailed(e) {
    this.isRequestMostRecentAndLive(e) && (this.state = "failed"), this.dispatchLocalEvent({ type: "loadComplete" });
  }
  pageLoaded(e, t, i) {
    this.successCommon(e, { rowData: t, rowCount: i });
  }
  isRequestMostRecentAndLive(e) {
    const t = e === this.version, i = this.isAlive();
    return t && i;
  }
  successCommon(e, t) {
    this.dispatchLocalEvent({ type: "loadComplete" }), this.isRequestMostRecentAndLive(e) && (this.state = "loaded", this.processServerResult(t));
  }
  postConstruct() {
    this.rowNodes = [];
    const {
      params: { blockSize: e, rowHeight: t },
      startRow: i,
      beans: s,
      rowNodes: o
    } = this;
    for (let n = 0; n < e; n++) {
      const r = i + n, a = new Hi(s);
      a.setRowHeight(t), a.uiLevel = 0, a.setRowIndex(r), a.setRowTop(t * r), o.push(a);
    }
  }
  getBlockStateJson() {
    const { id: e, startRow: t, endRow: i, state: s } = this;
    return {
      id: "" + e,
      state: {
        blockNumber: e,
        startRow: t,
        endRow: i,
        pageStatus: s
      }
    };
  }
  setDataAndId(e, t, i) {
    H(t) ? e.setDataAndId(t, i.toString()) : e.setDataAndId(void 0, void 0);
  }
  loadFromDatasource() {
    const e = this.createLoadParams();
    if (de(this.params.datasource.getRows)) {
      I(90);
      return;
    }
    window.setTimeout(() => {
      this.params.datasource.getRows(e);
    }, 0);
  }
  createLoadParams() {
    const {
      startRow: e,
      endRow: t,
      version: i,
      params: { sortModel: s, filterModel: o },
      gos: n
    } = this;
    return {
      startRow: e,
      endRow: t,
      successCallback: this.pageLoaded.bind(this, i),
      failCallback: this.pageLoadFailed.bind(this, i),
      sortModel: s,
      filterModel: o,
      context: W(n, {}).context
    };
  }
  forEachNode(e, t, i) {
    this.rowNodes.forEach((s, o) => {
      this.startRow + o < i && e(s, t.value++);
    });
  }
  getRow(e, t = !1) {
    t || (this.lastAccessed = this.params.lastAccessedSequence.value++);
    const i = e - this.startRow;
    return this.rowNodes[i];
  }
  processServerResult(e) {
    const { rowNodes: t, beans: i } = this;
    t.forEach((o, n) => {
      const r = e.rowData ? e.rowData[n] : void 0;
      !o.id && o.alreadyRendered && r && (t[n] = new Hi(i), t[n].setRowIndex(o.rowIndex), t[n].setRowTop(o.rowTop), t[n].setRowHeight(o.rowHeight), o.clearRowTopAndRowIndex()), this.setDataAndId(t[n], r, this.startRow + n);
    });
    const s = e.rowCount != null && e.rowCount >= 0 ? e.rowCount : void 0;
    this.parentCache.pageLoaded(this, s);
  }
  destroy() {
    this.rowNodes.forEach((e) => {
      e.clearRowTopAndRowIndex();
    }), super.destroy();
  }
}, jM = 2, qM = class extends E {
  constructor(e) {
    super(), this.params = e, this.lastRowIndexKnown = !1, this.blocks = {}, this.blockCount = 0, this.rowCount = e.initialRowCount;
  }
  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
  // it will want new pages in the cache as it asks for rows. only when we are inserting /
  // removing rows via the api is dontCreatePage set, where we move rows between the pages.
  getRow(e, t = !1) {
    const i = Math.floor(e / this.params.blockSize);
    let s = this.blocks[i];
    if (!s) {
      if (t)
        return;
      s = this.createBlock(i);
    }
    return s.getRow(e);
  }
  createBlock(e) {
    const t = this.params, i = this.createBean(new KM(e, this, t));
    return this.blocks[i.id] = i, this.blockCount++, this.purgeBlocksIfNeeded(i), t.rowNodeBlockLoader.addBlock(i), i;
  }
  // we have this on infinite row model only, not server side row model,
  // because for server side, it would leave the children in inconsistent
  // state - eg if a node had children, but after the refresh it had data
  // for a different row, then the children would be with the wrong row node.
  refreshCache() {
    if (this.blockCount == 0) {
      this.purgeCache();
      return;
    }
    this.getBlocksInOrder().forEach((t) => t.setStateWaitingToLoad()), this.params.rowNodeBlockLoader.checkBlockToLoad();
  }
  destroy() {
    this.getBlocksInOrder().forEach((e) => this.destroyBlock(e)), super.destroy();
  }
  getRowCount() {
    return this.rowCount;
  }
  isLastRowIndexKnown() {
    return this.lastRowIndexKnown;
  }
  // block calls this, when page loaded
  pageLoaded(e, t) {
    this.isAlive() && (ni(this.gos, `InfiniteCache - onPageLoaded: page = ${e.id}, lastRow = ${t}`), this.checkRowCount(e, t), this.onCacheUpdated());
  }
  purgeBlocksIfNeeded(e) {
    const t = this.getBlocksInOrder().filter((r) => r != e), i = (r, a) => a.lastAccessed - r.lastAccessed;
    t.sort(i);
    const s = this.params.maxBlocksInCache > 0, o = s ? this.params.maxBlocksInCache - 1 : null, n = jM - 1;
    t.forEach((r, a) => {
      const l = r.state === "needsLoading" && a >= n, d = s ? a >= o : !1;
      if (l || d) {
        if (this.isBlockCurrentlyDisplayed(r) || this.isBlockFocused(r))
          return;
        this.removeBlockFromCache(r);
      }
    });
  }
  isBlockFocused(e) {
    const t = this.beans.focusSvc.getFocusCellToUseAfterRefresh();
    if (!t || t.rowPinned != null)
      return !1;
    const { startRow: i, endRow: s } = e;
    return t.rowIndex >= i && t.rowIndex < s;
  }
  isBlockCurrentlyDisplayed(e) {
    const { startRow: t, endRow: i } = e;
    return this.beans.rowRenderer.isRangeInRenderedViewport(t, i - 1);
  }
  removeBlockFromCache(e) {
    e && this.destroyBlock(e);
  }
  checkRowCount(e, t) {
    if (typeof t == "number" && t >= 0)
      this.rowCount = t, this.lastRowIndexKnown = !0;
    else if (!this.lastRowIndexKnown) {
      const { blockSize: i, overflowSize: s } = this.params, n = (e.id + 1) * i + s;
      this.rowCount < n && (this.rowCount = n);
    }
  }
  setRowCount(e, t) {
    this.rowCount = e, H(t) && (this.lastRowIndexKnown = t), this.lastRowIndexKnown || this.rowCount % this.params.blockSize === 0 && this.rowCount++, this.onCacheUpdated();
  }
  forEachNodeDeep(e) {
    const t = { value: 0 };
    this.getBlocksInOrder().forEach((i) => i.forEachNode(e, t, this.rowCount));
  }
  getBlocksInOrder() {
    const e = (i, s) => i.id - s.id;
    return Object.values(this.blocks).sort(e);
  }
  destroyBlock(e) {
    delete this.blocks[e.id], this.destroyBean(e), this.blockCount--, this.params.rowNodeBlockLoader.removeBlock(e);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  onCacheUpdated() {
    this.isAlive() && (this.destroyAllBlocksPastVirtualRowCount(), this.eventSvc.dispatchEvent({
      type: "storeUpdated"
    }));
  }
  destroyAllBlocksPastVirtualRowCount() {
    const e = [];
    this.getBlocksInOrder().forEach((t) => {
      t.id * this.params.blockSize >= this.rowCount && e.push(t);
    }), e.length > 0 && e.forEach((t) => this.destroyBlock(t));
  }
  purgeCache() {
    this.getBlocksInOrder().forEach((e) => this.removeBlockFromCache(e)), this.lastRowIndexKnown = !1, this.rowCount === 0 && (this.rowCount = this.params.initialRowCount), this.onCacheUpdated();
  }
  getRowNodesInRange(e, t) {
    const i = [];
    let s = -1, o = !1;
    const n = { value: 0 };
    let r = !1;
    return this.getBlocksInOrder().forEach((l) => {
      if (!r) {
        if (o && s + 1 !== l.id) {
          r = !0;
          return;
        }
        s = l.id, l.forEachNode(
          (d) => {
            const c = d === e || d === t;
            (o || c) && i.push(d), c && (o = !o);
          },
          n,
          this.rowCount
        );
      }
    }), r || o ? [] : i;
  }
}, YM = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowModel";
  }
  getRowBounds(e) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * e
    };
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid() {
    return !1;
  }
  postConstruct() {
    this.gos.get("rowModelType") === "infinite" && (this.rowHeight = Ti(this.beans), this.addEventListeners(), this.addDestroyFunc(() => this.destroyCache()));
  }
  start() {
    this.setDatasource(this.gos.get("datasource"));
  }
  destroy() {
    this.destroyDatasource(), super.destroy();
  }
  destroyDatasource() {
    this.datasource && (this.destroyBean(this.datasource), this.beans.rowRenderer.datasourceChanged(), this.datasource = null);
  }
  addEventListeners() {
    this.addManagedEventListeners({
      filterChanged: this.reset.bind(this),
      sortChanged: this.reset.bind(this),
      newColumnsLoaded: this.onColumnEverything.bind(this),
      storeUpdated: this.dispatchModelUpdatedEvent.bind(this)
    }), this.addManagedPropertyListener("datasource", () => this.setDatasource(this.gos.get("datasource"))), this.addManagedPropertyListener("cacheBlockSize", () => this.resetCache()), this.addManagedPropertyListener("rowHeight", () => {
      this.rowHeight = Ti(this.beans), this.cacheParams.rowHeight = this.rowHeight, this.updateRowHeights();
    });
  }
  onColumnEverything() {
    var t;
    let e;
    this.cacheParams ? e = !vo(this.cacheParams.sortModel, ((t = this.beans.sortSvc) == null ? void 0 : t.getSortModel()) ?? []) : e = !0, e && this.reset();
  }
  getType() {
    return "infinite";
  }
  setDatasource(e) {
    this.destroyDatasource(), this.datasource = e, e && this.reset();
  }
  isEmpty() {
    return !this.infiniteCache;
  }
  isRowsToRender() {
    return !!this.infiniteCache;
  }
  getNodesInRangeForSelection(e, t) {
    var i;
    return ((i = this.infiniteCache) == null ? void 0 : i.getRowNodesInRange(e, t)) ?? [];
  }
  reset() {
    var i;
    if (!this.datasource)
      return;
    ws(this.gos) != null || (i = this.beans.selectionSvc) == null || i.reset("rowDataChanged"), this.resetCache();
  }
  dispatchModelUpdatedEvent() {
    this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      // not sure if these should all be false - noticed if after implementing,
      // maybe they should be true?
      newPage: !1,
      newPageSize: !1,
      newData: !1,
      keepRenderedRows: !0,
      animate: !1
    });
  }
  resetCache() {
    this.destroyCache();
    const e = this.beans, { filterManager: t, sortSvc: i, rowNodeBlockLoader: s, eventSvc: o, gos: n } = e;
    this.cacheParams = {
      // the user provided datasource
      datasource: this.datasource,
      // sort and filter model
      filterModel: (t == null ? void 0 : t.getFilterModel()) ?? {},
      sortModel: (i == null ? void 0 : i.getSortModel()) ?? [],
      rowNodeBlockLoader: s,
      // properties - this way we take a snapshot of them, so if user changes any, they will be
      // used next time we create a new cache, which is generally after a filter or sort change,
      // or a new datasource is set
      initialRowCount: n.get("infiniteInitialRowCount"),
      maxBlocksInCache: n.get("maxBlocksInCache"),
      rowHeight: Ti(e),
      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
      // the current page and request first row of next page
      overflowSize: n.get("cacheOverflowSize"),
      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
      // server for one page at a time. so the default if not specified is 100.
      blockSize: n.get("cacheBlockSize"),
      // the cache could create this, however it is also used by the pages, so handy to create it
      // here as the settings are also passed to the pages
      lastAccessedSequence: { value: 0 }
    }, this.infiniteCache = this.createBean(new qM(this.cacheParams)), o.dispatchEventOnce({
      type: "rowCountReady"
    }), this.dispatchModelUpdatedEvent();
  }
  updateRowHeights() {
    this.forEachNode((e) => {
      e.setRowHeight(this.rowHeight), e.setRowTop(this.rowHeight * e.rowIndex);
    }), this.dispatchModelUpdatedEvent();
  }
  destroyCache() {
    this.infiniteCache = this.destroyBean(this.infiniteCache);
  }
  getRow(e) {
    const t = this.infiniteCache;
    if (t && !(e >= t.getRowCount()))
      return t.getRow(e);
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((i) => {
      i.id === e && (t = i);
    }), t;
  }
  forEachNode(e) {
    var t;
    (t = this.infiniteCache) == null || t.forEachNodeDeep(e);
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(e) {
    return e;
  }
  getRowIndexAtPixel(e) {
    if (this.rowHeight !== 0) {
      const t = Math.floor(e / this.rowHeight), i = this.getRowCount() - 1;
      return t > i ? i : t;
    }
    return 0;
  }
  getRowCount() {
    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  refreshCache() {
    var e;
    (e = this.infiniteCache) == null || e.refreshCache();
  }
  purgeCache() {
    var e;
    (e = this.infiniteCache) == null || e.purgeCache();
  }
  // for iRowModel
  isLastRowIndexKnown() {
    var e;
    return ((e = this.infiniteCache) == null ? void 0 : e.isLastRowIndexKnown()) ?? !1;
  }
  setRowCount(e, t) {
    var i;
    (i = this.infiniteCache) == null || i.setRowCount(e, t);
  }
  resetRowHeights() {
  }
  onRowHeightChanged() {
  }
};
function QM(e) {
  var t;
  (t = xr(e)) == null || t.refreshCache();
}
function XM(e) {
  var t;
  (t = xr(e)) == null || t.purgeCache();
}
function ZM(e) {
  var t;
  return (t = xr(e)) == null ? void 0 : t.getRowCount();
}
var JM = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowNodeBlockLoader", this.activeBlockLoadsCount = 0, this.blocks = [], this.active = !0;
  }
  postConstruct() {
    this.maxConcurrentRequests = WC(this.gos);
    const e = this.gos.get("blockLoadDebounceMillis");
    e && e > 0 && (this.checkBlockToLoadDebounce = De(
      this,
      this.performCheckBlocksToLoad.bind(this),
      e
    ));
  }
  addBlock(e) {
    this.blocks.push(e), e.addEventListener("loadComplete", this.loadComplete.bind(this)), this.checkBlockToLoad();
  }
  removeBlock(e) {
    tt(this.blocks, e);
  }
  destroy() {
    super.destroy(), this.active = !1;
  }
  loadComplete() {
    this.activeBlockLoadsCount--, this.checkBlockToLoad();
  }
  checkBlockToLoad() {
    this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad();
  }
  performCheckBlocksToLoad() {
    if (!this.active)
      return;
    if (this.printCacheStatus(), this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
      ni(this.gos, "RowNodeBlockLoader - checkBlockToLoad: max loads exceeded");
      return;
    }
    const e = this.maxConcurrentRequests != null ? this.maxConcurrentRequests - this.activeBlockLoadsCount : 1, t = this.blocks.filter((i) => i.state === "needsLoading").slice(0, e);
    this.activeBlockLoadsCount += t.length, t.forEach((i) => i.load()), this.printCacheStatus();
  }
  getBlockState() {
    const e = {};
    return this.blocks.forEach((t) => {
      const { id: i, state: s } = t.getBlockStateJson();
      e[i] = s;
    }), e;
  }
  printCacheStatus() {
    ni(
      this.gos,
      `RowNodeBlockLoader - printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`
    );
  }
}, eA = {
  moduleName: "InfiniteRowModelCore",
  version: B,
  rowModels: ["infinite"],
  beans: [YM, JM]
}, tA = {
  moduleName: "InfiniteRowModel",
  version: B,
  apiFunctions: {
    refreshInfiniteCache: QM,
    purgeInfiniteCache: XM,
    getInfiniteRowCount: ZM
  },
  dependsOn: [eA, vM]
}, iA = "", sA = "", oA = {
  tag: "span",
  children: [
    { tag: "span", ref: "eDelta", cls: "ag-value-change-delta" },
    { tag: "span", ref: "eValue", cls: "ag-value-change-value" }
  ]
}, nA = class extends te {
  constructor() {
    super(oA), this.eValue = _, this.eDelta = _, this.refreshCount = 0;
  }
  init(e) {
    this.refresh(e, !0);
  }
  showDelta(e, t) {
    const i = Math.abs(t), s = e.formatValue(i), o = H(s) ? s : i, n = t >= 0, r = this.eDelta;
    n ? r.textContent = iA + o : r.textContent = sA + o, r.classList.toggle("ag-value-change-delta-up", n), r.classList.toggle("ag-value-change-delta-down", !n);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.hideDeltaValue();
      }, 2e3);
    });
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight"), Te(this.eDelta);
  }
  refresh(e, t = !1) {
    var d;
    const { value: i, valueFormatted: s } = e, { eValue: o, lastValue: n, beans: r } = this;
    if (i === n || (H(s) ? o.textContent = s : H(i) ? o.textContent = i : Te(o), (d = r.filterManager) != null && d.isSuppressFlashingCellsBecauseFiltering()))
      return !1;
    const a = i && typeof i == "object" && "toNumber" in i ? i.toNumber() : i, l = n && typeof n == "object" && "toNumber" in n ? n.toNumber() : n;
    if (a === l)
      return !1;
    if (typeof a == "number" && typeof l == "number") {
      const c = a - l;
      this.showDelta(e, c);
    }
    return n && o.classList.add("ag-value-change-value-highlight"), t || this.setTimerToRemoveDelta(), this.lastValue = i, !0;
  }
}, rA = (
  /*css*/
  ".ag-value-slide-out{opacity:1}:where(.ag-ltr) .ag-value-slide-out{margin-right:5px;transition:opacity 3s,margin-right 3s}:where(.ag-rtl) .ag-value-slide-out{margin-left:5px;transition:opacity 3s,margin-left 3s}:where(.ag-ltr,.ag-rtl) .ag-value-slide-out{transition-timing-function:linear}.ag-value-slide-out-end{opacity:0}:where(.ag-ltr) .ag-value-slide-out-end{margin-right:10px}:where(.ag-rtl) .ag-value-slide-out-end{margin-left:10px}"
), aA = {
  tag: "span",
  children: [{ tag: "span", ref: "eCurrent", cls: "ag-value-slide-current" }]
}, lA = class extends te {
  constructor() {
    super(aA), this.eCurrent = _, this.refreshCount = 0, this.registerCSS(rA);
  }
  init(e) {
    this.refresh(e, !0);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.ePrevious && this.getGui().removeChild(this.ePrevious);
    const { beans: t, eCurrent: i } = this, s = ye({ tag: "span", cls: "ag-value-slide-previous ag-value-slide-out" });
    this.ePrevious = s, s.textContent = i.textContent, this.getGui().insertBefore(s, i), t.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50), window.setTimeout(() => {
        e === this.refreshCount && (this.getGui().removeChild(this.ePrevious), this.ePrevious = null);
      }, 3e3);
    });
  }
  refresh(e, t = !1) {
    var o;
    let i = e.value;
    if (de(i) && (i = ""), i === this.lastValue || (o = this.beans.filterManager) != null && o.isSuppressFlashingCellsBecauseFiltering())
      return !1;
    t || this.addSlideAnimation(), this.lastValue = i;
    const s = this.eCurrent;
    return H(e.valueFormatted) ? s.textContent = e.valueFormatted : H(e.value) ? s.textContent = i : Te(s), !0;
  }
}, dA = class extends E {
  constructor() {
    super(...arguments), this.beanName = "cellFlashSvc", this.nextAnimationTime = null, this.nextAnimationCycle = null, this.animations = {
      highlight: /* @__PURE__ */ new Map(),
      "data-changed": /* @__PURE__ */ new Map()
    };
  }
  animateCell(e, t, i = this.beans.gos.get("cellFlashDuration"), s = this.beans.gos.get("cellFadeDuration")) {
    const o = this.animations[t];
    o.delete(e);
    const n = Date.now(), r = n + i, a = n + i + s, l = {
      phase: "flash",
      flashEndTime: r,
      fadeEndTime: a
    };
    o.set(e, l);
    const d = `ag-cell-${t}`, c = `${d}-animation`, {
      comp: u,
      eGui: { style: h }
    } = e;
    u.toggleCss(d, !0), u.toggleCss(c, !1), h.removeProperty("transition"), h.removeProperty("transition-delay"), this.nextAnimationTime && r + 15 < this.nextAnimationTime && (clearTimeout(this.nextAnimationCycle), this.nextAnimationCycle = null, this.nextAnimationTime = null), this.nextAnimationCycle || (this.beans.frameworkOverrides.wrapIncoming(() => {
      this.nextAnimationCycle = setTimeout(this.advanceAnimations.bind(this), i);
    }), this.nextAnimationTime = r);
  }
  advanceAnimations() {
    const e = Date.now();
    let t = null;
    for (const i of Object.keys(this.animations)) {
      const s = this.animations[i], o = `ag-cell-${i}`, n = `${o}-animation`;
      for (const [r, a] of s) {
        if (!r.isAlive() || !r.comp) {
          s.delete(r);
          continue;
        }
        const { phase: l, flashEndTime: d, fadeEndTime: c } = a, u = l === "flash" ? d : c;
        if (!(e + 15 >= u)) {
          t = Math.min(u, t ?? 1 / 0);
          continue;
        }
        const {
          comp: g,
          eGui: { style: p }
        } = r;
        switch (l) {
          case "flash":
            g.toggleCss(o, !1), g.toggleCss(n, !0), p.transition = `background-color ${c - d}ms`, p.transitionDelay = `${d - e}ms`, t = Math.min(c, t ?? 1 / 0), a.phase = "fade";
            break;
          case "fade":
            g.toggleCss(o, !1), g.toggleCss(n, !1), p.removeProperty("transition"), p.removeProperty("transition-delay"), s.delete(r);
            break;
        }
      }
    }
    t == null ? (this.nextAnimationTime = null, this.nextAnimationCycle = null) : t && (this.nextAnimationCycle = setTimeout(this.advanceAnimations.bind(this), t - e), this.nextAnimationTime = t);
  }
  onFlashCells(e, t) {
    if (!e.comp)
      return;
    const i = oR(e.cellPosition);
    t.cells[i] && this.animateCell(e, "highlight");
  }
  flashCell(e, t) {
    this.animateCell(e, "data-changed", t == null ? void 0 : t.flashDuration, t == null ? void 0 : t.fadeDuration);
  }
  destroy() {
    for (const e of Object.keys(this.animations))
      this.animations[e].clear();
  }
};
function cA(e, t = {}) {
  const { cellFlashSvc: i } = e;
  i && e.frameworkOverrides.wrapIncoming(() => {
    e.rowRenderer.getCellCtrls(t.rowNodes, t.columns).forEach((s) => i.flashCell(s, t));
  });
}
var uA = {
  moduleName: "HighlightChanges",
  version: B,
  beans: [dA],
  userComponents: {
    agAnimateShowChangeCellRenderer: nA,
    agAnimateSlideCellRenderer: lA
  },
  apiFunctions: {
    flashCells: cA
  }
};
function hA(e) {
  var t;
  return ((t = e.stateSvc) == null ? void 0 : t.getState()) ?? {};
}
function gA(e, t, i) {
  var s;
  return (s = e.stateSvc) == null ? void 0 : s.setState(t, i);
}
function ou(e) {
  switch (e = { ...e }, e.version || (e.version = "32.1.0"), e.version) {
    case "32.1.0":
      e = pA(e);
  }
  return e.version = B, e;
}
function pA(e) {
  return e.cellSelection = fA(e, "rangeSelection"), e;
}
function fA(e, t) {
  if (e && typeof e == "object")
    return e[t];
}
var mA = class extends E {
  constructor() {
    super(...arguments), this.beanName = "stateSvc", this.updateRowGroupExpansionStateTimer = 0, this.suppressEvents = !0, this.queuedUpdateSources = /* @__PURE__ */ new Set(), this.dispatchStateUpdateEventDebounced = De(this, () => this.dispatchQueuedStateUpdateEvents(), 0), this.onRowGroupOpenedDebounced = De(
      this,
      () => {
        this.beans.gos.get("ssrmExpandAllAffectsAllRows") ? (this.updateCachedState("ssrmRowGroupExpansion", this.getRowGroupExpansionState()), this.updateCachedState("rowGroupExpansion", void 0)) : (this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), this.updateCachedState("ssrmRowGroupExpansion", void 0));
      },
      0
    ), this.onRowSelectedDebounced = De(
      this,
      () => {
        this.staleStateKeys.delete("rowSelection"), this.updateCachedState("rowSelection", this.getRowSelectionState());
      },
      0
    ), this.staleStateKeys = /* @__PURE__ */ new Set();
  }
  postConstruct() {
    const { gos: e, ctrlsSvc: t, colDelayRenderSvc: i } = this.beans;
    this.isClientSideRowModel = xe(e);
    const s = ou(e.get("initialState") ?? {}), o = s.partialColumnState;
    delete s.partialColumnState, this.cachedState = s;
    const n = this.suppressEventsAndDispatchInitEvent.bind(this);
    t.whenReady(
      this,
      () => n(() => this.setupStateOnGridReady(s))
    ), (s.columnOrder || s.columnVisibility || s.columnSizing || s.columnPinning || s.columnGroup) && (i == null || i.hideColumns("columnState"));
    const [r, a, l] = this.addManagedEventListeners({
      newColumnsLoaded: ({ source: d }) => {
        d === "gridInitializing" && (r(), n(() => {
          this.setupStateOnColumnsInitialised(s, !!o), i == null || i.revealColumns("columnState");
        }));
      },
      rowCountReady: () => {
        a == null || a(), n(() => this.setupStateOnRowCountReady(s));
      },
      firstDataRendered: () => {
        l == null || l(), n(() => this.setupStateOnFirstDataRendered(s));
      }
    });
  }
  destroy() {
    super.destroy(), clearTimeout(this.updateRowGroupExpansionStateTimer), this.queuedUpdateSources.clear();
  }
  getState() {
    return this.staleStateKeys.size && this.refreshStaleState(), this.cachedState;
  }
  setState(e, t) {
    const i = ou(e);
    delete i.partialColumnState, this.cachedState = i, this.startSuppressEvents();
    const s = "api", o = t ? new Set(t) : void 0;
    this.setGridReadyState(i, s, o), this.setColumnsInitialisedState(i, s, !1, o), this.setRowCountState(i, s, o), setTimeout(() => {
      this.isAlive() && this.setFirstDataRenderedState(i, s, o), this.stopSuppressEvents(s);
    });
  }
  setGridReadyState(e, t, i) {
    var s, o;
    t === "api" && !(i != null && i.has("sideBar")) && ((o = (s = this.beans.sideBar) == null ? void 0 : s.comp) == null || o.setState(e.sideBar)), this.updateCachedState("sideBar", this.getSideBarState());
  }
  setupStateOnGridReady(e) {
    this.setGridReadyState(e, "gridInitializing");
    const t = () => this.updateCachedState("sideBar", this.getSideBarState());
    this.addManagedEventListeners({
      toolPanelVisibleChanged: t,
      sideBarUpdated: t
    });
  }
  updateColumnAndGroupState() {
    this.updateColumnState([
      "aggregation",
      "columnOrder",
      "columnPinning",
      "columnSizing",
      "columnVisibility",
      "pivot",
      "rowGroup",
      "sort"
    ]), this.updateCachedState("columnGroup", this.getColumnGroupState());
  }
  setColumnsInitialisedState(e, t, i, s) {
    this.setColumnState(e, t, i, s), this.setColumnGroupState(e, t, s), this.updateColumnAndGroupState();
  }
  setupStateOnColumnsInitialised(e, t) {
    this.setColumnsInitialisedState(e, "gridInitializing", t);
    const i = (s) => () => this.updateColumnState([s]);
    this.addManagedEventListeners({
      columnValueChanged: i("aggregation"),
      columnMoved: i("columnOrder"),
      columnPinned: i("columnPinning"),
      columnResized: i("columnSizing"),
      columnVisible: i("columnVisibility"),
      columnPivotChanged: i("pivot"),
      columnPivotModeChanged: i("pivot"),
      columnRowGroupChanged: i("rowGroup"),
      sortChanged: i("sort"),
      newColumnsLoaded: this.updateColumnAndGroupState.bind(this),
      columnGroupOpened: () => this.updateCachedState("columnGroup", this.getColumnGroupState())
    });
  }
  setRowCountState(e, t, i) {
    const {
      filter: s,
      rowGroupExpansion: o,
      ssrmRowGroupExpansion: n,
      rowSelection: r,
      pagination: a
    } = e, l = (c, u) => !(i != null && i.has(c)) && (u || t === "api");
    l("filter", s) && this.setFilterState(s), l("rowGroupExpansion", o) && this.setRowGroupExpansionState(n, o, t), l("rowSelection", r) && this.setRowSelectionState(r, t), l("pagination", a) && this.setPaginationState(a, t);
    const d = this.updateCachedState.bind(this);
    d("filter", this.getFilterState()), this.beans.gos.get("ssrmExpandAllAffectsAllRows") ? (d("ssrmRowGroupExpansion", this.getRowGroupExpansionState()), d("rowGroupExpansion", void 0)) : (d("rowGroupExpansion", this.getRowGroupExpansionState()), d("ssrmRowGroupExpansion", void 0)), d("rowSelection", this.getRowSelectionState()), d("pagination", this.getPaginationState());
  }
  setupStateOnRowCountReady(e) {
    this.setRowCountState(e, "gridInitializing");
    const t = this.updateCachedState.bind(this), i = () => {
      this.updateRowGroupExpansionStateTimer = 0, this.beans.gos.get("ssrmExpandAllAffectsAllRows") ? (t("ssrmRowGroupExpansion", this.getRowGroupExpansionState()), t("rowGroupExpansion", void 0)) : (t("rowGroupExpansion", this.getRowGroupExpansionState()), t("ssrmRowGroupExpansion", void 0));
    }, s = () => t("filter", this.getFilterState()), { gos: o, colFilter: n } = this.beans;
    this.addManagedEventListeners({
      filterChanged: s,
      rowExpansionStateChanged: this.onRowGroupOpenedDebounced,
      expandOrCollapseAll: i,
      // `groupDefaultExpanded`/`isGroupOpenByDefault` updates expansion state without an expansion event
      columnRowGroupChanged: i,
      rowDataUpdated: () => {
        (o.get("groupDefaultExpanded") !== 0 || o.get("isGroupOpenByDefault")) && (this.updateRowGroupExpansionStateTimer || (this.updateRowGroupExpansionStateTimer = setTimeout(i)));
      },
      selectionChanged: () => {
        this.staleStateKeys.add("rowSelection"), this.onRowSelectedDebounced();
      },
      paginationChanged: (r) => {
        (r.newPage || r.newPageSize) && t("pagination", this.getPaginationState());
      }
    }), n && this.addManagedListeners(n, {
      filterStateChanged: s
    });
  }
  setFirstDataRenderedState(e, t, i) {
    const {
      scroll: s,
      cellSelection: o,
      focusedCell: n,
      columnOrder: r,
      rowPinning: a
    } = e, l = (u, h) => !(i != null && i.has(u)) && (h || t === "api");
    l("focusedCell", n) && this.setFocusedCellState(n), l("cellSelection", o) && this.setCellSelectionState(o), l("scroll", s) && this.setScrollState(s), l("rowPinning", a) && this.setRowPinningState(a), this.setColumnPivotState(!!(r != null && r.orderedColIds), t);
    const d = this.updateCachedState.bind(this);
    d("sideBar", this.getSideBarState()), d("focusedCell", this.getFocusedCellState());
    const c = this.getRangeSelectionState();
    d("rangeSelection", c), d("cellSelection", c), d("scroll", this.getScrollState());
  }
  setupStateOnFirstDataRendered(e) {
    this.setFirstDataRenderedState(e, "gridInitializing");
    const t = this.updateCachedState.bind(this), i = () => t("focusedCell", this.getFocusedCellState());
    this.addManagedEventListeners({
      cellFocused: i,
      cellFocusCleared: i,
      cellSelectionChanged: (s) => {
        if (s.finished) {
          const o = this.getRangeSelectionState();
          t("rangeSelection", o), t("cellSelection", o);
        }
      },
      bodyScrollEnd: () => t("scroll", this.getScrollState()),
      pinnedRowsChanged: () => t("rowPinning", this.getRowPinningState())
    });
  }
  getColumnState() {
    const e = this.beans;
    return fE(Qn(e), e.colModel.isPivotMode());
  }
  setColumnState(e, t, i, s) {
    const {
      sort: o,
      rowGroup: n,
      aggregation: r,
      pivot: a,
      columnPinning: l,
      columnVisibility: d,
      columnSizing: c,
      columnOrder: u
    } = e;
    let h = !1;
    const g = (A, G) => {
      const $ = !(s != null && s.has(A)) && !!(G || t === "api");
      return h || (h = $), $;
    }, p = {}, f = (A) => {
      let G = p[A];
      return G || (G = { colId: A }, p[A] = G, G);
    }, m = {}, C = g("sort", o);
    C && (o == null || o.sortModel.forEach(({ colId: A, sort: G }, $) => {
      const q = f(A);
      q.sort = G, q.sortIndex = $;
    })), (C || !i) && (m.sort = null, m.sortIndex = null);
    const v = g("rowGroup", n);
    v && (n == null || n.groupColIds.forEach((A, G) => {
      const $ = f(A);
      $.rowGroup = !0, $.rowGroupIndex = G;
    })), (v || !i) && (m.rowGroup = null, m.rowGroupIndex = null);
    const R = g("aggregation", r);
    R && (r == null || r.aggregationModel.forEach(({ colId: A, aggFunc: G }) => {
      f(A).aggFunc = G;
    })), (R || !i) && (m.aggFunc = null);
    const b = g("pivot", a);
    b && (a == null || a.pivotColIds.forEach((A, G) => {
      const $ = f(A);
      $.pivot = !0, $.pivotIndex = G;
    }), this.gos.updateGridOptions({
      options: { pivotMode: !!(a != null && a.pivotMode) },
      source: t
    })), (b || !i) && (m.pivot = null, m.pivotIndex = null);
    const w = g("columnPinning", l);
    w && (l == null || l.leftColIds.forEach((A) => {
      f(A).pinned = "left";
    }), l == null || l.rightColIds.forEach((A) => {
      f(A).pinned = "right";
    })), (w || !i) && (m.pinned = null);
    const x = g("columnVisibility", d);
    x && (d == null || d.hiddenColIds.forEach((A) => {
      f(A).hide = !0;
    })), (x || !i) && (m.hide = null);
    const F = g("columnSizing", c);
    F && (c == null || c.columnSizingModel.forEach(({ colId: A, flex: G, width: $ }) => {
      const q = f(A);
      q.flex = G ?? null, q.width = $;
    })), (F || !i) && (m.flex = null);
    const D = u == null ? void 0 : u.orderedColIds, T = !!(D != null && D.length) && !(s != null && s.has("columnOrder")), k = T ? D.map((A) => f(A)) : Object.values(p);
    (k.length || h) && (this.columnStates = k, ut(
      this.beans,
      {
        state: k,
        applyOrder: T,
        defaultState: m
      },
      t
    ));
  }
  setColumnPivotState(e, t) {
    const i = this.columnStates;
    this.columnStates = void 0;
    const s = this.columnGroupStates;
    this.columnGroupStates = void 0;
    const o = this.beans, { pivotResultCols: n, colGroupSvc: r } = o;
    if (n != null && n.isPivotResultColsPresent()) {
      if (i) {
        const a = [];
        for (const l of i)
          n.getPivotResultCol(l.colId) && a.push(l);
        ut(
          o,
          {
            state: a,
            applyOrder: e
          },
          t
        );
      }
      s && (r == null || r.setColumnGroupState(s, t));
    }
  }
  getColumnGroupState() {
    const e = this.beans.colGroupSvc;
    if (!e)
      return;
    const t = e.getColumnGroupState();
    return mE(t);
  }
  setColumnGroupState(e, t, i) {
    var a;
    const s = this.beans.colGroupSvc;
    if (!s || i != null && i.has("columnGroup") || t !== "api" && !Object.prototype.hasOwnProperty.call(e, "columnGroup"))
      return;
    const o = new Set((a = e.columnGroup) == null ? void 0 : a.openColumnGroupIds), r = s.getColumnGroupState().map(({ groupId: l }) => {
      const d = o.has(l);
      return d && o.delete(l), {
        groupId: l,
        open: d
      };
    });
    o.forEach((l) => {
      r.push({
        groupId: l,
        open: !0
      });
    }), r.length && (this.columnGroupStates = r), s.setColumnGroupState(r, t);
  }
  getFilterState() {
    const e = this.beans.filterManager;
    let t = e == null ? void 0 : e.getFilterModel();
    t && Object.keys(t).length === 0 && (t = void 0);
    const i = e == null ? void 0 : e.getFilterState(), s = (e == null ? void 0 : e.getAdvFilterModel()) ?? void 0;
    return t || s || i ? { filterModel: t, columnFilterState: i, advancedFilterModel: s } : void 0;
  }
  setFilterState(e) {
    const t = this.beans.filterManager, { filterModel: i, columnFilterState: s, advancedFilterModel: o } = e ?? {
      filterModel: null,
      columnFilterState: null,
      advancedFilterModel: null
    };
    (i !== void 0 || s !== void 0) && (t == null || t.setFilterState(i ?? null, s ?? null, "columnFilter")), o !== void 0 && (t == null || t.setAdvFilterModel(o ?? null, "advancedFilter"));
  }
  getRangeSelectionState() {
    var t;
    const e = (t = this.beans.rangeSvc) == null ? void 0 : t.getCellRanges().map((i) => {
      const { id: s, type: o, startRow: n, endRow: r, columns: a, startColumn: l } = i;
      return {
        id: s,
        type: o,
        startRow: n,
        endRow: r,
        colIds: a.map((d) => d.getColId()),
        startColId: l.getColId()
      };
    });
    return e != null && e.length ? { cellRanges: e } : void 0;
  }
  setCellSelectionState(e) {
    const { gos: t, rangeSvc: i, colModel: s, visibleCols: o } = this.beans;
    if (!zt(t) || !i)
      return;
    const n = [];
    e == null || e.cellRanges.forEach((r) => {
      const a = [];
      if (r.colIds.forEach((d) => {
        const c = s.getCol(d);
        c && a.push(c);
      }), !a.length)
        return;
      let l = s.getCol(r.startColId);
      if (!l) {
        const d = o.allCols, c = new Set(a);
        l = d.find((u) => c.has(u));
      }
      n.push({
        ...r,
        columns: a,
        startColumn: l
      });
    }), i.setCellRanges(n);
  }
  getScrollState() {
    if (!this.isClientSideRowModel)
      return;
    const e = this.beans.ctrlsSvc.getScrollFeature(), { left: t } = (e == null ? void 0 : e.getHScrollPosition()) ?? { left: 0 }, { top: i } = (e == null ? void 0 : e.getVScrollPosition()) ?? { top: 0 };
    return i || t ? {
      top: i,
      left: t
    } : void 0;
  }
  setScrollState(e) {
    if (!this.isClientSideRowModel)
      return;
    const { top: t, left: i } = e ?? { top: 0, left: 0 }, { frameworkOverrides: s, rowRenderer: o, animationFrameSvc: n, ctrlsSvc: r } = this.beans;
    s.wrapIncoming(() => {
      var a;
      r.get("center").setCenterViewportScrollLeft(i), (a = r.getScrollFeature()) == null || a.setVerticalScrollPosition(t), o.redraw({ afterScroll: !0 }), n == null || n.flushAllFrames();
    });
  }
  getSideBarState() {
    var e, t;
    return (t = (e = this.beans.sideBar) == null ? void 0 : e.comp) == null ? void 0 : t.getState();
  }
  getFocusedCellState() {
    if (!this.isClientSideRowModel)
      return;
    const e = this.beans.focusSvc.getFocusedCell();
    if (e) {
      const { column: t, rowIndex: i, rowPinned: s } = e;
      return {
        colId: t.getColId(),
        rowIndex: i,
        rowPinned: s
      };
    }
  }
  setFocusedCellState(e) {
    if (!this.isClientSideRowModel)
      return;
    const { focusSvc: t, colModel: i } = this.beans;
    if (!e) {
      t.clearFocusedCell();
      return;
    }
    const { colId: s, rowIndex: o, rowPinned: n } = e;
    t.setFocusedCell({
      column: i.getCol(s),
      rowIndex: o,
      rowPinned: n,
      forceBrowserFocus: !0,
      preventScrollOnBrowserFocus: !0
    });
  }
  getPaginationState() {
    const { pagination: e, gos: t } = this.beans;
    if (!e)
      return;
    const i = e.getCurrentPage(), s = t.get("paginationAutoPageSize") ? void 0 : e.getPageSize();
    if (!(!i && !s))
      return { page: i, pageSize: s };
  }
  setPaginationState(e, t) {
    const { pagination: i, gos: s } = this.beans;
    if (!i)
      return;
    const { pageSize: o, page: n } = e ?? { page: 0, pageSize: s.get("paginationPageSize") }, r = t === "gridInitializing";
    o && !s.get("paginationAutoPageSize") && i.setPageSize(o, r ? "initialState" : "pageSizeSelector"), typeof n == "number" && (r ? i.setPage(n) : i.goToPage(n));
  }
  getRowSelectionState() {
    var s;
    const e = this.beans.selectionSvc;
    if (!e)
      return;
    const t = e.getSelectionState();
    return !t || !Array.isArray(t) && (t.selectAll === !1 || t.selectAllChildren === !1) && !((s = t == null ? void 0 : t.toggledNodes) != null && s.length) ? void 0 : t;
  }
  setRowSelectionState(e, t) {
    var i;
    (i = this.beans.selectionSvc) == null || i.setSelectionState(e, t, t === "api");
  }
  getRowGroupExpansionState() {
    const { expansionSvc: e } = this.beans;
    if (e)
      return e.getExpansionState();
  }
  getRowPinningState() {
    var e;
    return (e = this.beans.pinnedRowModel) == null ? void 0 : e.getPinnedState();
  }
  setRowPinningState(e) {
    const t = this.beans.pinnedRowModel;
    e ? t == null || t.setPinnedState(e) : t == null || t.reset();
  }
  setRowGroupExpansionState(e, t, i) {
    const s = this.beans.expansionSvc;
    if (!s)
      return;
    const o = t ?? { expandedRowGroupIds: [], collapsedRowGroupIds: [] };
    s.setExpansionState(o, i);
  }
  updateColumnState(e) {
    const t = this.getColumnState();
    let i = !1;
    const s = this.cachedState;
    for (const o of Object.keys(t)) {
      const n = t[o];
      vo(n, s[o]) || (i = !0);
    }
    this.cachedState = {
      ...s,
      ...t
    }, i && this.dispatchStateUpdateEvent(e);
  }
  updateCachedState(e, t) {
    const i = this.cachedState[e];
    this.setCachedStateValue(e, t), vo(t, i) || this.dispatchStateUpdateEvent([e]);
  }
  setCachedStateValue(e, t) {
    this.cachedState = {
      ...this.cachedState,
      [e]: t
    };
  }
  refreshStaleState() {
    const e = this.staleStateKeys;
    e.forEach((t) => {
      switch (t) {
        case "rowSelection":
          this.setCachedStateValue(t, this.getRowSelectionState());
          break;
      }
    }), e.clear();
  }
  dispatchStateUpdateEvent(e) {
    this.suppressEvents || (e.forEach((t) => this.queuedUpdateSources.add(t)), this.dispatchStateUpdateEventDebounced());
  }
  dispatchQueuedStateUpdateEvents() {
    const e = this.queuedUpdateSources, t = Array.from(e);
    e.clear(), this.eventSvc.dispatchEvent({
      type: "stateUpdated",
      sources: t,
      state: this.cachedState
    });
  }
  startSuppressEvents() {
    var e;
    this.suppressEvents = !0, (e = this.beans.colAnimation) == null || e.setSuppressAnimation(!0);
  }
  stopSuppressEvents(e) {
    setTimeout(() => {
      var t;
      this.suppressEvents = !1, this.queuedUpdateSources.clear(), this.isAlive() && ((t = this.beans.colAnimation) == null || t.setSuppressAnimation(!1), this.dispatchStateUpdateEvent([e]));
    });
  }
  suppressEventsAndDispatchInitEvent(e) {
    this.startSuppressEvents(), e(), this.stopSuppressEvents("gridInitializing");
  }
}, CA = {
  moduleName: "GridState",
  version: B,
  beans: [mA],
  apiFunctions: {
    getState: hA,
    setState: gA
  }
};
function vA(e) {
  return e.rowModel.isLastRowIndexKnown();
}
function wA(e) {
  var t;
  return ((t = e.pagination) == null ? void 0 : t.getPageSize()) ?? 100;
}
function bA(e) {
  var t;
  return ((t = e.pagination) == null ? void 0 : t.getCurrentPage()) ?? 0;
}
function yA(e) {
  var t;
  return ((t = e.pagination) == null ? void 0 : t.getTotalPages()) ?? 1;
}
function SA(e) {
  return e.pagination ? e.pagination.getMasterRowCount() : e.rowModel.getRowCount();
}
function RA(e) {
  var t;
  (t = e.pagination) == null || t.goToNextPage();
}
function xA(e) {
  var t;
  (t = e.pagination) == null || t.goToPreviousPage();
}
function FA(e) {
  var t;
  (t = e.pagination) == null || t.goToFirstPage();
}
function PA(e) {
  var t;
  (t = e.pagination) == null || t.goToLastPage();
}
function EA(e, t) {
  var i;
  (i = e.pagination) == null || i.goToPage(t);
}
var DA = class extends E {
  constructor() {
    super(...arguments), this.beanName = "paginationAutoPageSizeSvc";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.centerRowsCtrl = e.center;
      const t = this.checkPageSize.bind(this);
      this.addManagedEventListeners({
        bodyHeightChanged: t,
        scrollVisibilityChanged: t
      }), this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this)), this.checkPageSize();
    });
  }
  notActive() {
    return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
  }
  onPaginationAutoSizeChanged() {
    this.notActive() ? this.beans.pagination.unsetAutoCalculatedPageSize() : this.checkPageSize();
  }
  checkPageSize() {
    if (this.notActive())
      return;
    const e = this.centerRowsCtrl.viewportSizeFeature.getBodyHeight();
    if (e > 0) {
      const t = this.beans, i = () => {
        const s = Math.max(Ti(t), 1), o = Math.floor(e / s);
        t.pagination.setPageSize(o, "autoCalculated");
      };
      this.isBodyRendered ? De(this, i, 50)() : (i(), this.isBodyRendered = !0);
    } else
      this.isBodyRendered = !1;
  }
}, Ns = "paginationPageSizeSelector", TA = { tag: "span", cls: "ag-paging-page-size" }, MA = class extends te {
  constructor() {
    super(TA), this.hasEmptyOption = !1, this.handlePageSizeItemSelected = () => {
      if (!this.selectPageSizeComp)
        return;
      const e = this.selectPageSizeComp.getValue();
      if (!e)
        return;
      const t = Number(e);
      isNaN(t) || t < 1 || t === this.pagination.getPageSize() || (this.pagination.setPageSize(t, "pageSizeSelector"), this.hasEmptyOption && this.toggleSelectDisplay(!0), this.selectPageSizeComp.getFocusableElement().focus());
    };
  }
  wireBeans(e) {
    this.pagination = e.pagination;
  }
  postConstruct() {
    this.addManagedPropertyListener(Ns, () => {
      this.onPageSizeSelectorValuesChange();
    }), this.addManagedEventListeners({ paginationChanged: (e) => this.handlePaginationChanged(e) });
  }
  handlePaginationChanged(e) {
    if (!this.selectPageSizeComp || !(e != null && e.newPageSize))
      return;
    const t = this.pagination.getPageSize();
    this.getPageSizeSelectorValues().includes(t) ? this.selectPageSizeComp.setValue(t.toString()) : this.hasEmptyOption ? this.selectPageSizeComp.setValue("") : this.toggleSelectDisplay(!0);
  }
  toggleSelectDisplay(e) {
    this.selectPageSizeComp && !e && this.reset(), e && (this.reloadPageSizesSelector(), this.selectPageSizeComp);
  }
  reset() {
    Te(this.getGui()), this.selectPageSizeComp && (this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp));
  }
  onPageSizeSelectorValuesChange() {
    this.selectPageSizeComp && this.shouldShowPageSizeSelector() && this.reloadPageSizesSelector();
  }
  shouldShowPageSizeSelector() {
    return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get(Ns) !== !1;
  }
  reloadPageSizesSelector() {
    const e = this.getPageSizeSelectorValues(), t = this.pagination.getPageSize(), i = !t || !e.includes(t);
    if (i) {
      const o = this.gos.exists("paginationPageSize"), n = this.gos.get(Ns) !== !0;
      I(94, { pageSizeSet: o, pageSizesSet: n, pageSizeOptions: e, paginationPageSizeOption: t }), n || I(95, { paginationPageSizeOption: t, paginationPageSizeSelector: Ns }), e.unshift("");
    }
    const s = String(i ? "" : t);
    this.selectPageSizeComp ? (ci(this.pageSizeOptions, e) || (this.selectPageSizeComp.clearOptions().addOptions(this.createPageSizeSelectOptions(e)), this.pageSizeOptions = e), this.selectPageSizeComp.setValue(s, !0)) : this.createPageSizeSelectorComp(e, s), this.hasEmptyOption = i;
  }
  createPageSizeSelectOptions(e) {
    return e.map((t) => ({
      value: String(t)
    }));
  }
  createPageSizeSelectorComp(e, t) {
    const i = this.getLocaleTextFunc(), s = i("pageSizeSelectorLabel", "Page Size:"), o = i("ariaPageSizeSelectorLabel", "Page Size");
    this.selectPageSizeComp = this.createManagedBean(new Vl()).addOptions(this.createPageSizeSelectOptions(e)).setValue(t).setAriaLabel(o).setLabel(s).onValueChange(() => this.handlePageSizeItemSelected()), this.appendChild(this.selectPageSizeComp);
  }
  getPageSizeSelectorValues() {
    const e = [20, 50, 100], t = this.gos.get(Ns);
    return !Array.isArray(t) || !(t != null && t.length) ? e : [...t].sort((i, s) => i - s);
  }
  destroy() {
    this.toggleSelectDisplay(!1), super.destroy();
  }
}, AA = {
  selector: "AG-PAGE-SIZE-SELECTOR",
  component: MA
}, IA = (
  /*css*/
  ".ag-paging-panel{align-items:center;border-top:var(--ag-footer-row-border);display:flex;gap:calc(var(--ag-spacing)*4);height:var(--ag-pagination-panel-height);justify-content:flex-end;padding:0 var(--ag-cell-horizontal-padding)}:where(.ag-paging-page-size) .ag-wrapper{min-width:50px}.ag-paging-page-summary-panel{align-items:center;display:flex;gap:var(--ag-cell-widget-spacing);.ag-disabled &{pointer-events:none}}.ag-paging-button{cursor:pointer;position:relative;&.ag-disabled{cursor:default;opacity:.5}}.ag-paging-number,.ag-paging-row-summary-panel-number{font-weight:500}"
), kA = class extends rp {
  constructor() {
    super(), this.btFirst = _, this.btPrevious = _, this.btNext = _, this.btLast = _, this.lbRecordCount = _, this.lbFirstRowOnPage = _, this.lbLastRowOnPage = _, this.lbCurrent = _, this.lbTotal = _, this.pageSizeComp = _, this.previousAndFirstButtonsDisabled = !1, this.nextButtonDisabled = !1, this.lastButtonDisabled = !1, this.areListenersSetup = !1, this.allowFocusInnerElement = !1, this.registerCSS(IA);
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pagination = e.pagination, this.ariaAnnounce = e.ariaAnnounce;
  }
  postConstruct() {
    const e = this.gos.get("enableRtl");
    this.setTemplate(this.getTemplate(), [AA]);
    const { btFirst: t, btPrevious: i, btNext: s, btLast: o } = this;
    this.activateTabIndex([t, i, s, o]), t.insertAdjacentElement("afterbegin", Ze(e ? "last" : "first", this.beans)), i.insertAdjacentElement("afterbegin", Ze(e ? "next" : "previous", this.beans)), s.insertAdjacentElement("afterbegin", Ze(e ? "previous" : "next", this.beans)), o.insertAdjacentElement("afterbegin", Ze(e ? "first" : "last", this.beans)), this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this)), this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this)), this.addManagedPropertyListeners(
      ["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"],
      () => this.onPageSizeRelatedOptionsChange()
    ), this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector()), this.initialiseTabGuard({
      // prevent tab guard default logic
      onTabKeyDown: () => {
      },
      focusInnerElement: (n) => this.allowFocusInnerElement ? this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(n) : Py(this.beans, n),
      forceFocusOutWhenTabGuardsAreEmpty: !0
    }), this.onPaginationChanged();
  }
  setAllowFocus(e) {
    this.allowFocusInnerElement = e;
  }
  onPaginationChanged() {
    const t = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.setDisplayed(t), t && (this.setupListeners(), this.enableOrDisableButtons(), this.updateLabels(), this.onPageSizeRelatedOptionsChange());
  }
  onPageSizeRelatedOptionsChange() {
    this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
  }
  setupListeners() {
    this.areListenersSetup || (this.addManagedEventListeners({ paginationChanged: this.onPaginationChanged.bind(this) }), [
      { el: this.btFirst, fn: this.onBtFirst.bind(this) },
      { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
      { el: this.btNext, fn: this.onBtNext.bind(this) },
      { el: this.btLast, fn: this.onBtLast.bind(this) }
    ].forEach((e) => {
      const { el: t, fn: i } = e;
      this.addManagedListeners(t, {
        click: i,
        keydown: (s) => {
          (s.key === P.ENTER || s.key === P.SPACE) && (s.preventDefault(), i());
        }
      });
    }), Fy(this.beans, this, this.getGui()), this.areListenersSetup = !0);
  }
  onBtFirst() {
    this.previousAndFirstButtonsDisabled || this.pagination.goToFirstPage();
  }
  formatNumber(e) {
    const t = this.gos.getCallback("paginationNumberFormatter");
    return t ? t({ value: e }) : vE(e, this.getLocaleTextFunc.bind(this));
  }
  getTemplate() {
    const e = this.getLocaleTextFunc(), t = `ag-${this.getCompId()}`;
    return {
      tag: "div",
      cls: "ag-paging-panel ag-unselectable",
      attrs: { id: `${t}` },
      children: [
        {
          tag: "ag-page-size-selector",
          ref: "pageSizeComp"
        },
        {
          tag: "span",
          cls: "ag-paging-row-summary-panel",
          children: [
            {
              tag: "span",
              ref: "lbFirstRowOnPage",
              cls: "ag-paging-row-summary-panel-number",
              attrs: { id: `${t}-first-row` }
            },
            { tag: "span", attrs: { id: `${t}-to` }, children: e("to", "to") },
            {
              tag: "span",
              ref: "lbLastRowOnPage",
              cls: "ag-paging-row-summary-panel-number",
              attrs: { id: `${t}-last-row` }
            },
            { tag: "span", attrs: { id: `${t}-of` }, children: e("of", "of") },
            {
              tag: "span",
              ref: "lbRecordCount",
              cls: "ag-paging-row-summary-panel-number",
              attrs: { id: `${t}-row-count` }
            }
          ]
        },
        {
          tag: "span",
          cls: "ag-paging-page-summary-panel",
          role: "presentation",
          children: [
            {
              tag: "div",
              ref: "btFirst",
              cls: "ag-button ag-paging-button",
              role: "button",
              attrs: { "aria-label": e("firstPage", "First Page") }
            },
            {
              tag: "div",
              ref: "btPrevious",
              cls: "ag-button ag-paging-button",
              role: "button",
              attrs: { "aria-label": e("previousPage", "Previous Page") }
            },
            {
              tag: "span",
              cls: "ag-paging-description",
              children: [
                {
                  tag: "span",
                  attrs: {
                    id: `${t}-start-page`
                  },
                  children: e("page", "Page")
                },
                {
                  tag: "span",
                  ref: "lbCurrent",
                  cls: "ag-paging-number",
                  attrs: { id: `${t}-start-page-number` }
                },
                {
                  tag: "span",
                  attrs: {
                    id: `${t}-of-page`
                  },
                  children: e("of", "of")
                },
                {
                  tag: "span",
                  ref: "lbTotal",
                  cls: "ag-paging-number",
                  attrs: { id: `${t}-of-page-number` }
                }
              ]
            },
            {
              tag: "div",
              ref: "btNext",
              cls: "ag-button ag-paging-button",
              role: "button",
              attrs: { "aria-label": e("nextPage", "Next Page") }
            },
            {
              tag: "div",
              ref: "btLast",
              cls: "ag-button ag-paging-button",
              role: "button",
              attrs: { "aria-label": e("lastPage", "Last Page") }
            }
          ]
        }
      ]
    };
  }
  onBtNext() {
    this.nextButtonDisabled || this.pagination.goToNextPage();
  }
  onBtPrevious() {
    this.previousAndFirstButtonsDisabled || this.pagination.goToPreviousPage();
  }
  onBtLast() {
    this.lastButtonDisabled || this.pagination.goToLastPage();
  }
  enableOrDisableButtons() {
    const e = this.pagination.getCurrentPage(), t = this.rowModel.isLastRowIndexKnown(), i = this.pagination.getTotalPages();
    this.previousAndFirstButtonsDisabled = e === 0, this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled), this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const s = this.isZeroPagesToDisplay(), o = e === i - 1;
    this.nextButtonDisabled = o || s, this.lastButtonDisabled = !t || s || e === i - 1, this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled), this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(e, t) {
    Xm(e, t), e.classList.toggle("ag-disabled", t);
  }
  isZeroPagesToDisplay() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.pagination.getTotalPages();
    return e && t === 0;
  }
  updateLabels() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.pagination.getTotalPages(), i = this.pagination.getMasterRowCount(), s = e ? i : null, o = this.pagination.getCurrentPage(), n = this.pagination.getPageSize();
    let r, a;
    this.isZeroPagesToDisplay() ? r = a = 0 : (r = n * o + 1, a = r + n - 1, e && a > s && (a = s));
    const l = r + n - 1, d = !e && i < l, c = this.formatNumber(r);
    this.lbFirstRowOnPage.textContent = c;
    let u;
    const h = this.getLocaleTextFunc();
    d ? u = h("pageLastRowUnknown", "?") : u = this.formatNumber(a), this.lbLastRowOnPage.textContent = u;
    const p = t > 0 ? o + 1 : 0, f = this.formatNumber(p);
    this.lbCurrent.textContent = f;
    let m, C;
    if (e)
      m = this.formatNumber(t), C = this.formatNumber(s);
    else {
      const v = h("more", "more");
      m = v, C = v;
    }
    this.lbTotal.textContent = m, this.lbRecordCount.textContent = C, this.announceAriaStatus(c, u, C, f, m);
  }
  announceAriaStatus(e, t, i, s, o) {
    var u, h;
    const n = this.getLocaleTextFunc(), r = n("page", "Page"), a = n("to", "to"), l = n("of", "of"), d = `${e} ${a} ${t} ${l} ${i}`, c = `${r} ${s} ${l} ${o}`;
    d !== this.ariaRowStatus && (this.ariaRowStatus = d, (u = this.ariaAnnounce) == null || u.announceValue(d, "paginationRow")), c !== this.ariaPageStatus && (this.ariaPageStatus = c, (h = this.ariaAnnounce) == null || h.announceValue(c, "paginationPage"));
  }
}, LA = {
  selector: "AG-PAGINATION",
  component: kA
}, OA = class extends E {
  constructor() {
    super(...arguments), this.beanName = "pagination", this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = 0, this.masterRowCount = 0;
  }
  postConstruct() {
    const e = this.gos;
    this.active = e.get("pagination"), this.pageSizeFromGridOptions = e.get("paginationPageSize"), this.paginateChildRows = this.isPaginateChildRows(), this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this)), this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this));
  }
  getPaginationSelector() {
    return LA;
  }
  isPaginateChildRows() {
    const e = this.gos;
    return e.get("groupHideParentOfSingleChild") || // following two properties deprecated v32.3.0
    e.get("groupRemoveSingleChildren") || e.get("groupRemoveLowestSingleChildren") ? !0 : e.get("paginateChildRows");
  }
  onPaginationGridOptionChanged() {
    this.active = this.gos.get("pagination"), this.calculatePages(), this.dispatchPaginationChangedEvent({ keepRenderedRows: !0 });
  }
  onPageSizeGridOptionChanged() {
    this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
  }
  goToPage(e) {
    const t = this.currentPage;
    if (!this.active || t === e || typeof t != "number")
      return;
    const { editSvc: i } = this.beans;
    i != null && i.isEditing() && (i.isBatchEditing() ? i.cleanupEditors() : i.stopEditing(void 0, { source: "api" })), this.currentPage = e, this.calculatePages(), this.dispatchPaginationChangedEvent({ newPage: !0 });
  }
  goToPageWithIndex(e) {
    var i, s;
    if (!this.active)
      return;
    let t = e;
    this.paginateChildRows || (t = ((s = (i = this.beans.rowModel).getTopLevelIndexFromDisplayedIndex) == null ? void 0 : s.call(i, e)) ?? e), this.goToPage(Math.floor(t / this.pageSize));
  }
  isRowInPage(e) {
    return this.active ? e >= this.topDisplayedRowIndex && e <= this.bottomDisplayedRowIndex : !0;
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const e = this.beans.rowModel.getRowCount(), t = Math.floor(e / this.pageSize);
    this.goToPage(t);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  /** This is only for state setting before data has been loaded */
  setPage(e) {
    this.currentPage = e;
  }
  get pageSize() {
    return H(this.pageSizeAutoCalculated) && this.gos.get("paginationAutoPageSize") ? this.pageSizeAutoCalculated : H(this.pageSizeFromPageSizeSelector) ? this.pageSizeFromPageSizeSelector : H(this.pageSizeFromInitialState) ? this.pageSizeFromInitialState : H(this.pageSizeFromGridOptions) ? this.pageSizeFromGridOptions : this.defaultPageSize;
  }
  calculatePages() {
    this.active ? this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly() : this.calculatedPagesNotActive(), this.beans.pageBounds.calculateBounds(this.topDisplayedRowIndex, this.bottomDisplayedRowIndex);
  }
  unsetAutoCalculatedPageSize() {
    if (this.pageSizeAutoCalculated === void 0)
      return;
    const e = this.pageSizeAutoCalculated;
    this.pageSizeAutoCalculated = void 0, this.pageSize !== e && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0 }));
  }
  setPageSize(e, t) {
    const i = this.pageSize;
    switch (t) {
      case "autoCalculated":
        this.pageSizeAutoCalculated = e;
        break;
      case "pageSizeSelector":
        this.pageSizeFromPageSizeSelector = e, this.currentPage !== 0 && this.goToFirstPage();
        break;
      case "initialState":
        this.pageSizeFromInitialState = e;
        break;
      case "gridOptions":
        this.pageSizeFromGridOptions = e, this.pageSizeFromInitialState = void 0, this.pageSizeFromPageSizeSelector = void 0, this.currentPage !== 0 && this.goToFirstPage();
        break;
    }
    i !== this.pageSize && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0, keepRenderedRows: !0 }));
  }
  setZeroRows() {
    this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    const e = this.totalPages;
    this.currentPage >= e && (this.currentPage = e - 1);
    const t = this.currentPage;
    (!isFinite(t) || isNaN(t) || t < 0) && (this.currentPage = 0);
  }
  calculatePagesMasterRowsOnly() {
    const e = this.beans.rowModel, t = e.getTopLevelRowCount();
    if (this.masterRowCount = t, t <= 0) {
      this.setZeroRows();
      return;
    }
    const i = this.pageSize, s = t - 1;
    this.totalPages = Math.floor(s / i) + 1, this.adjustCurrentPageIfInvalid();
    const o = this.currentPage, n = i * o;
    let r = i * (o + 1) - 1;
    if (r > s && (r = s), this.topDisplayedRowIndex = e.getTopLevelRowDisplayedIndex(n), r === s)
      this.bottomDisplayedRowIndex = e.getRowCount() - 1;
    else {
      const a = e.getTopLevelRowDisplayedIndex(r + 1);
      this.bottomDisplayedRowIndex = a - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    const e = this.beans.rowModel.getRowCount();
    if (this.masterRowCount = e, e === 0) {
      this.setZeroRows();
      return;
    }
    const { pageSize: t, currentPage: i } = this, s = e - 1;
    this.totalPages = Math.floor(s / t) + 1, this.adjustCurrentPageIfInvalid(), this.topDisplayedRowIndex = t * i, this.bottomDisplayedRowIndex = t * (i + 1) - 1, this.bottomDisplayedRowIndex > s && (this.bottomDisplayedRowIndex = s);
  }
  calculatedPagesNotActive() {
    this.setPageSize(void 0, "autoCalculated"), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.beans.rowModel.getRowCount() - 1;
  }
  dispatchPaginationChangedEvent(e) {
    const { keepRenderedRows: t = !1, newPage: i = !1, newPageSize: s = !1 } = e;
    this.eventSvc.dispatchEvent({
      type: "paginationChanged",
      animate: !1,
      newData: !1,
      newPage: i,
      newPageSize: s,
      keepRenderedRows: t
    });
  }
}, _A = {
  moduleName: "Pagination",
  version: B,
  beans: [OA, DA],
  icons: {
    // "go to first" button in pagination controls
    first: "first",
    // "go to previous" button in pagination controls
    previous: "previous",
    // "go to next" button in pagination controls
    next: "next",
    // "go to last" button in pagination controls
    last: "last"
  },
  apiFunctions: {
    paginationIsLastPageFound: vA,
    paginationGetPageSize: wA,
    paginationGetCurrentPage: bA,
    paginationGetTotalPages: yA,
    paginationGetRowCount: SA,
    paginationGoToNextPage: RA,
    paginationGoToPreviousPage: xA,
    paginationGoToFirstPage: FA,
    paginationGoToLastPage: PA,
    paginationGoToPage: EA
  },
  dependsOn: [Pr]
};
function HA(e, t = {}) {
  const i = t ? t.rowNodes : void 0;
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.redrawRows(i));
}
function mf(e, t, i, s, o) {
  t && (s && t.parent && t.parent.level !== -1 && mf(e, t.parent, i, s, o), t.setExpanded(i, void 0, o));
}
function BA(e, t) {
  return e.rowModel.getRowNode(t);
}
function GA(e, t, i, s) {
  e.rowRenderer.addRenderedRowListener(t, i, s);
}
function VA(e) {
  return e.rowRenderer.getRenderedNodes();
}
function NA(e, t, i) {
  e.rowModel.forEachNode(t, i);
}
function WA(e) {
  return e.rowRenderer.firstRenderedRow;
}
function zA(e) {
  return e.rowRenderer.lastRenderedRow;
}
function UA(e, t) {
  return e.rowModel.getRow(t);
}
function $A(e) {
  return e.rowModel.getRowCount();
}
var Cf = {
  moduleName: "RowApi",
  version: B,
  apiFunctions: {
    redrawRows: HA,
    setRowNodeExpanded: mf,
    getRowNode: BA,
    addRenderedRowListener: GA,
    getRenderedNodes: VA,
    forEachNode: NA,
    getFirstDisplayedRowIndex: WA,
    getLastDisplayedRowIndex: zA,
    getDisplayedRowAtIndex: UA,
    getDisplayedRowCount: $A
  }
}, KA = {
  moduleName: "ScrollApi",
  version: B,
  apiFunctions: {
    getVerticalPixelRange: cT,
    getHorizontalPixelRange: uT,
    ensureColumnVisible: of,
    ensureIndexVisible: nf,
    ensureNodeVisible: hT
  }
};
function jA(e, t, i) {
  if (!t)
    return;
  const s = e.ctrlsSvc.getGridBodyCtrl().eGridBody, o = `aria-${t}`;
  i === null ? s.removeAttribute(o) : s.setAttribute(o, i);
}
function qA(e, t = {}) {
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.refreshCells(t));
}
function YA(e) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsSvc.getHeaderRowContainerCtrls().forEach((t) => t.refresh())
  );
}
function QA(e) {
  var t;
  return ((t = e.animationFrameSvc) == null ? void 0 : t.isQueueEmpty()) ?? !0;
}
function XA(e) {
  var t;
  (t = e.animationFrameSvc) == null || t.flushAllFrames();
}
function ZA(e) {
  return {
    rowHeight: Ti(e),
    headerHeight: Uo(e)
  };
}
function JA(e, t = {}) {
  var n;
  const i = [];
  if (e.rowRenderer.getCellCtrls(t.rowNodes, t.columns).forEach((r) => {
    const a = r.getCellRenderer();
    a != null && i.push(Po(a));
  }), (n = t.columns) != null && n.length)
    return i;
  const s = [], o = nl(t.rowNodes);
  return e.rowRenderer.getAllRowCtrls().forEach((r) => {
    if (o && !rl(r.rowNode, o) || !r.isFullWidth())
      return;
    const a = r.getFullWidthCellRenderers();
    for (let l = 0; l < a.length; l++) {
      const d = a[l];
      d != null && s.push(Po(d));
    }
  }), [...s, ...i];
}
var eI = {
  moduleName: "RenderApi",
  version: B,
  apiFunctions: {
    setGridAriaProperty: jA,
    refreshCells: qA,
    refreshHeader: YA,
    isAnimationFrameQueueEmpty: QA,
    flushAllAnimationFrames: XA,
    getSizesForCurrentTheme: ZA,
    getCellRendererInstances: JA
  }
};
function tI(e, t) {
  var i, s;
  typeof t == "number" ? (i = e.colAutosize) == null || i.sizeColumnsToFit(t, "api") : (s = e.colAutosize) == null || s.sizeColumnsToFitGridBody(t);
}
function vf({ colAutosize: e, visibleCols: t }, i, s) {
  Array.isArray(i) ? e == null || e.autoSizeCols({ colKeys: i, skipHeader: s, source: "api" }) : e == null || e.autoSizeCols({
    colKeys: i.colIds ?? t.allCols,
    skipHeader: i.skipHeader,
    defaultMaxWidth: i.defaultMaxWidth,
    defaultMinWidth: i.defaultMinWidth,
    columnLimits: i.columnLimits,
    source: "api"
  });
}
function iI(e, t) {
  var i;
  t && typeof t == "object" ? vf(e, t) : (i = e.colAutosize) == null || i.autoSizeAllColumns({ source: "api", skipHeader: t });
}
var sI = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colAutosize", this.timesDelayed = 0, this.shouldQueueResizeOperations = !1, this.resizeOperationQueue = [];
  }
  postConstruct() {
    var t;
    const e = this.gos.get("autoSizeStrategy");
    if (e) {
      let i = !1;
      const s = e.type;
      s === "fitGridWidth" || s === "fitProvidedWidth" ? i = !0 : s === "fitCellContents" && this.addManagedEventListeners({ firstDataRendered: () => this.onFirstDataRendered(e) }), i && ((t = this.beans.colDelayRenderSvc) == null || t.hideColumns(s));
    }
  }
  autoSizeCols(e) {
    if (this.shouldQueueResizeOperations) {
      this.pushResizeOperation(() => this.autoSizeCols(e));
      return;
    }
    const {
      colKeys: t,
      skipHeader: i,
      skipHeaderGroups: s,
      stopAtGroup: o,
      defaultMaxWidth: n,
      defaultMinWidth: r,
      columnLimits: a = [],
      source: l = "api"
    } = e, { animationFrameSvc: d, renderStatus: c, colModel: u, autoWidthCalc: h, visibleCols: g } = this.beans;
    if (d == null || d.flushAllFrames(), this.timesDelayed < 5 && c && (!c.areHeaderCellsRendered() || !c.areCellsRendered())) {
      this.timesDelayed++, setTimeout(() => {
        this.isAlive() && this.autoSizeCols(e);
      });
      return;
    }
    this.timesDelayed = 0;
    const p = [];
    let f = -1;
    const m = Object.fromEntries(
      a.map(({ colId: R, maxWidth: b, minWidth: w }) => [R, { maxWidth: b, minWidth: w }])
    ), C = i ?? this.gos.get("skipHeaderOnAutoSize"), v = s ?? C;
    for (; f !== 0; ) {
      f = 0;
      const R = [];
      t.forEach((b) => {
        if (!b || iv(b))
          return;
        const w = u.getCol(b);
        if (!w || p.indexOf(w) >= 0)
          return;
        const x = h.getPreferredWidthForColumn(w, C);
        if (x > 0) {
          const F = m[w.colId] ?? {};
          F.minWidth ?? (F.minWidth = r), F.maxWidth ?? (F.maxWidth = n);
          const D = oI(w, x, F);
          w.setActualWidth(D, l), p.push(w), f++;
        }
        R.push(w);
      }), R.length && g.refresh(l);
    }
    v || this.autoSizeColumnGroupsByColumns(t, l, o), bs(this.eventSvc, p, !0, "autosizeColumns");
  }
  autoSizeColumn(e, t, i) {
    e && this.autoSizeCols({ colKeys: [e], skipHeader: i, skipHeaderGroups: !0, source: t });
  }
  autoSizeColumnGroupsByColumns(e, t, i) {
    const { colModel: s, ctrlsSvc: o } = this.beans, n = /* @__PURE__ */ new Set();
    s.getColsForKeys(e).forEach((d) => {
      let c = d.getParent();
      for (; c && c != i; )
        c.isPadding() || n.add(c), c = c.getParent();
    });
    let a;
    const l = [];
    for (const d of n) {
      for (const c of o.getHeaderRowContainerCtrls())
        if (a = c.getHeaderCtrlForColumn(d), a)
          break;
      a && a.resizeLeafColumnsToFit(t);
    }
    return l;
  }
  autoSizeAllColumns(e) {
    if (this.shouldQueueResizeOperations) {
      this.pushResizeOperation(() => this.autoSizeAllColumns(e));
      return;
    }
    const t = this.beans.visibleCols.allCols;
    this.autoSizeCols({ colKeys: t, ...e });
  }
  addColumnAutosize(e, t) {
    const i = this.gos.get("skipHeaderOnAutoSize"), s = () => {
      this.autoSizeColumn(t, "uiColumnResized", i);
    };
    e.addEventListener("dblclick", s);
    const o = new bi(e);
    return o.addEventListener("doubleTap", s), () => {
      e.removeEventListener("dblclick", s), o.removeEventListener("doubleTap", s), o.destroy();
    };
  }
  addColumnGroupResize(e, t, i) {
    const s = this.gos.get("skipHeaderOnAutoSize"), o = () => {
      const n = [];
      t.getDisplayedLeafColumns().forEach((a) => {
        a.getColDef().suppressAutoSize || n.push(a.getColId());
      }), n.length > 0 && this.autoSizeCols({
        colKeys: n,
        skipHeader: s,
        stopAtGroup: t,
        source: "uiColumnResized"
      }), i();
    };
    return e.addEventListener("dblclick", o), () => e.removeEventListener("dblclick", o);
  }
  // method will call itself if no available width. this covers if the grid
  // isn't visible, but is just about to be visible.
  sizeColumnsToFitGridBody(e, t) {
    if (!this.isAlive())
      return;
    const { ctrlsSvc: i, scrollVisibleSvc: s } = this.beans, o = i.getGridBodyCtrl(), r = o.isVerticalScrollShowing() ? s.getScrollbarWidth() : 0, l = So(o.eGridBody) - r;
    if (l > 0) {
      this.sizeColumnsToFit(l, "sizeColumnsToFit", !1, e);
      return;
    }
    t === void 0 ? window.setTimeout(() => {
      this.sizeColumnsToFitGridBody(e, 100);
    }, 0) : t === 100 ? window.setTimeout(() => {
      this.sizeColumnsToFitGridBody(e, 500);
    }, 100) : t === 500 ? window.setTimeout(() => {
      this.sizeColumnsToFitGridBody(e, -1);
    }, 500) : I(29);
  }
  // called from api
  sizeColumnsToFit(e, t = "sizeColumnsToFit", i, s) {
    var g;
    if (this.shouldQueueResizeOperations) {
      this.pushResizeOperation(() => this.sizeColumnsToFit(e, t, i, s));
      return;
    }
    const o = {};
    s && ((g = s == null ? void 0 : s.columnLimits) == null || g.forEach(({ key: p, ...f }) => {
      o[typeof p == "string" ? p : p.getColId()] = f;
    }));
    const n = this.beans.visibleCols.allCols;
    if (e <= 0 || !n.length || e === _t(n) && n.every((f) => {
      if (f.colDef.suppressSizeToFit)
        return !0;
      const m = o == null ? void 0 : o[f.getId()], C = (m == null ? void 0 : m.minWidth) ?? (s == null ? void 0 : s.defaultMinWidth), v = (m == null ? void 0 : m.maxWidth) ?? (s == null ? void 0 : s.defaultMaxWidth), R = f.getActualWidth();
      return (C == null || R >= C) && (v == null || R <= v);
    }))
      return;
    const a = [], l = [];
    n.forEach((p) => {
      p.getColDef().suppressSizeToFit === !0 ? l.push(p) : a.push(p);
    });
    const d = a.slice(0);
    let c = !1;
    const u = (p) => {
      tt(a, p), l.push(p);
    };
    for (a.forEach((p) => {
      p.resetActualWidth(t);
      const f = o == null ? void 0 : o[p.getId()], m = (f == null ? void 0 : f.minWidth) ?? (s == null ? void 0 : s.defaultMinWidth), C = (f == null ? void 0 : f.maxWidth) ?? (s == null ? void 0 : s.defaultMaxWidth), v = p.getActualWidth();
      typeof m == "number" && v < m ? p.setActualWidth(m, t, !0) : typeof C == "number" && v > C && p.setActualWidth(C, t, !0);
    }); !c; ) {
      c = !0;
      const p = e - _t(l);
      if (p <= 0)
        a.forEach((f) => {
          var C;
          const m = ((C = o == null ? void 0 : o[f.getId()]) == null ? void 0 : C.minWidth) ?? (s == null ? void 0 : s.defaultMinWidth);
          if (typeof m == "number") {
            f.setActualWidth(m, t, !0);
            return;
          }
          f.setActualWidth(f.minWidth, t);
        });
      else {
        const f = p / _t(a);
        let m = p;
        for (let C = a.length - 1; C >= 0; C--) {
          const v = a[C], R = o == null ? void 0 : o[v.getId()], b = (R == null ? void 0 : R.minWidth) ?? (s == null ? void 0 : s.defaultMinWidth), w = (R == null ? void 0 : R.maxWidth) ?? (s == null ? void 0 : s.defaultMaxWidth), x = v.getMinWidth(), F = v.getMaxWidth(), D = typeof b == "number" && b > x ? b : x, T = typeof w == "number" && w < F ? w : F;
          let k = Math.round(v.getActualWidth() * f);
          k < D ? (k = D, u(v), c = !1) : k > T ? (k = T, u(v), c = !1) : C === 0 && (k = m), v.setActualWidth(k, t, !0), m -= k;
        }
      }
    }
    d.forEach((p) => {
      p.fireColumnWidthChangedEvent(t);
    });
    const h = this.beans.visibleCols;
    h.setLeftValues(t), h.updateBodyWidths(), !i && bs(this.eventSvc, d, !0, t);
  }
  applyAutosizeStrategy() {
    const { gos: e, colDelayRenderSvc: t } = this.beans, i = e.get("autoSizeStrategy");
    !i || i.type === "fitCellContents" || setTimeout(() => {
      if (!this.isAlive())
        return;
      const s = i.type;
      if (s === "fitGridWidth") {
        const { columnLimits: o, defaultMinWidth: n, defaultMaxWidth: r } = i, a = o == null ? void 0 : o.map(({ colId: l, minWidth: d, maxWidth: c }) => ({
          key: l,
          minWidth: d,
          maxWidth: c
        }));
        this.sizeColumnsToFitGridBody({
          defaultMinWidth: n,
          defaultMaxWidth: r,
          columnLimits: a
        });
      } else s === "fitProvidedWidth" && this.sizeColumnsToFit(i.width, "sizeColumnsToFit");
      t == null || t.revealColumns(s);
    });
  }
  onFirstDataRendered(e) {
    const { colIds: t, skipHeader: i, defaultMaxWidth: s, defaultMinWidth: o, columnLimits: n } = e;
    setTimeout(() => {
      if (!this.isAlive())
        return;
      const r = {
        skipHeader: i,
        source: "autosizeColumns",
        defaultMaxWidth: s,
        defaultMinWidth: o,
        columnLimits: n
      };
      t ? this.autoSizeCols({ colKeys: t, ...r }) : this.autoSizeAllColumns(r);
    });
  }
  processResizeOperations() {
    this.shouldQueueResizeOperations = !1, this.resizeOperationQueue.forEach((e) => e()), this.resizeOperationQueue = [];
  }
  pushResizeOperation(e) {
    this.resizeOperationQueue.push(e);
  }
  destroy() {
    this.resizeOperationQueue.length = 0, super.destroy();
  }
};
function oI(e, t, i = {}) {
  const s = i.minWidth ?? e.getMinWidth();
  t < s && (t = s);
  const o = i.maxWidth ?? e.getMaxWidth();
  return t > o && (t = o), t;
}
var nI = {
  moduleName: "ColumnAutoSize",
  version: B,
  beans: [sI],
  apiFunctions: {
    sizeColumnsToFit: tI,
    autoSizeColumns: vf,
    autoSizeAllColumns: iI
  },
  dependsOn: [mp]
}, rI = (
  /*css*/
  ".ag-row-pinned-source{background-color:var(--ag-pinned-source-row-background-color);color:var(--ag-pinned-source-row-text-color);font-weight:var(--ag-pinned-source-row-font-weight)}.ag-row-pinned-manual{background-color:var(--ag-pinned-row-background-color);color:var(--ag-pinned-row-text-color);font-weight:var(--ag-pinned-row-font-weight)}"
);
function aI(e) {
  var t;
  return ((t = e.pinnedRowModel) == null ? void 0 : t.getPinnedTopRowCount()) ?? 0;
}
function lI(e) {
  var t;
  return ((t = e.pinnedRowModel) == null ? void 0 : t.getPinnedBottomRowCount()) ?? 0;
}
function dI(e, t) {
  var i;
  return (i = e.pinnedRowModel) == null ? void 0 : i.getPinnedTopRow(t);
}
function cI(e, t) {
  var i;
  return (i = e.pinnedRowModel) == null ? void 0 : i.getPinnedBottomRow(t);
}
function uI(e, t, i) {
  var s;
  return (s = e.pinnedRowModel) == null ? void 0 : s.forEachPinnedRow(t, i);
}
var hI = {
  moduleName: "PinnedRow",
  version: B,
  beans: [aS],
  css: [rI],
  apiFunctions: {
    getPinnedTopRowCount: aI,
    getPinnedBottomRowCount: lI,
    getPinnedTopRow: dI,
    getPinnedBottomRow: cI,
    forEachPinnedRow: uI
  },
  icons: {
    rowPin: "pin",
    rowPinTop: "pinned-top",
    rowPinBottom: "pinned-bottom",
    rowUnpin: "un-pin"
  }
}, gI = class extends fs {
  constructor(e, t, i) {
    super(e.col, e.firstNode, i, t), this.cellSpan = e, this.SPANNED_CELL_CSS_CLASS = "ag-spanned-cell";
  }
  setComp(e, t, i, s, o, n, r) {
    this.eWrapper = i, super.setComp(e, t, i, s, o, n, r), this.setAriaRowSpan(), this.refreshAriaRowIndex();
  }
  isCellSpanning() {
    return !0;
  }
  getCellSpan() {
    return this.cellSpan;
  }
  /**
   * When cell is spanning, ensure row index is also available on the cell
   */
  refreshAriaRowIndex() {
    this.rowNode.rowIndex != null && Gn(this.eGui, this.rowNode.rowIndex);
  }
  /**
   * When cell is spanning, ensure row index is also available on the cell
   */
  setAriaRowSpan() {
    iC(this.eGui, this.cellSpan.spannedNodes.size);
  }
  // not ideal, for tabbing need to force the focused position
  setFocusedCellPosition(e) {
    this.focusedCellPosition = e;
  }
  getFocusedCellPosition() {
    return this.focusedCellPosition ?? this.cellPosition;
  }
  checkCellFocused() {
    const e = this.beans.focusSvc.getFocusedCell();
    return !!e && this.cellSpan.doesSpanContain(e);
  }
  applyStaticCssClasses() {
    super.applyStaticCssClasses(), this.comp.toggleCss(this.SPANNED_CELL_CSS_CLASS, !0);
  }
  onCellFocused(e) {
    const { beans: t } = this;
    if (Sr(t)) {
      this.focusedCellPosition = void 0;
      return;
    }
    const i = this.isCellFocused();
    i || (this.focusedCellPosition = void 0), e && i && (this.focusedCellPosition = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: e.column
      // fix
    }), super.onCellFocused(e);
  }
  getRootElement() {
    return this.eWrapper;
  }
}, pI = class extends rr {
  onRowIndexChanged() {
    super.onRowIndexChanged(), this.getAllCellCtrls().forEach((e) => e.refreshAriaRowIndex());
  }
  getInitialRowClasses(e) {
    return ["ag-spanned-row"];
  }
  getNewCellCtrl(e) {
    var s;
    const t = (s = this.beans.rowSpanSvc) == null ? void 0 : s.getCellSpan(e, this.rowNode);
    if (!(!t || t.firstNode !== this.rowNode))
      return new gI(t, this, this.beans);
  }
  isCorrectCtrlForSpan(e) {
    var s;
    const t = (s = this.beans.rowSpanSvc) == null ? void 0 : s.getCellSpan(e.column, this.rowNode);
    return !t || t.firstNode !== this.rowNode ? !1 : e.getCellSpan() === t;
  }
  /**
   * Below overrides are explicitly disabling styling and other unwanted behaviours for spannedRowCtrl
   */
  // row height should be 0 in spanned row - they're only included for purpose of aria
  onRowHeightChanged() {
  }
  // no styling spanned rows
  refreshFirstAndLastRowStyles() {
  }
  // no hover functionality for spanned rows
  addHoverFunctionality() {
  }
  resetHoveredStatus() {
  }
}, fI = class extends E {
  constructor() {
    super(...arguments), this.beanName = "spannedRowRenderer", this.topCtrls = /* @__PURE__ */ new Map(), this.bottomCtrls = /* @__PURE__ */ new Map(), this.centerCtrls = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    this.addManagedEventListeners({
      displayedRowsChanged: this.createAllCtrls.bind(this)
    });
  }
  createAllCtrls() {
    this.createCtrls("top"), this.createCtrls("bottom"), this.createCtrls("center");
  }
  /**
   * When displayed rows or cols change, the spanned cell ctrls need to update
   */
  createCtrls(e) {
    const { rowSpanSvc: t } = this.beans, i = `${e}Ctrls`, s = this[i], o = s.size, n = this.getAllRelevantRowControls(e), r = /* @__PURE__ */ new Map();
    let a = !1;
    for (const d of n)
      d.isAlive() && (t == null || t.forEachSpannedColumn(d.rowNode, (c, u) => {
        if (r.has(u.firstNode))
          return;
        const h = s.get(u.firstNode);
        if (h) {
          r.set(u.firstNode, h), s.delete(u.firstNode);
          return;
        }
        a = !0;
        const g = new pI(u.firstNode, this.beans, !1, !1, !1);
        r.set(u.firstNode, g);
      }));
    this[i] = r;
    const l = r.size === o;
    if (!(!a && l)) {
      for (const d of s.values())
        d.destroyFirstPass(!0), d.destroySecondPass();
      this.dispatchLocalEvent({
        type: "spannedRowsUpdated",
        ctrlsKey: e
      });
    }
  }
  // cannot use getAllRowCtrls as it returns this services row ctrls.
  getAllRelevantRowControls(e) {
    const { rowRenderer: t } = this.beans;
    switch (e) {
      case "top":
        return t.topRowCtrls;
      case "bottom":
        return t.bottomRowCtrls;
      case "center":
        return t.allRowCtrls;
    }
  }
  getCellByPosition(e) {
    const { rowSpanSvc: t } = this.beans, i = t == null ? void 0 : t.getCellSpanByPosition(e);
    if (!i)
      return;
    const s = `${wf(e.rowPinned)}Ctrls`, o = this[s].get(i.firstNode);
    if (o)
      return o.getAllCellCtrls().find((n) => n.column === e.column);
  }
  getCtrls(e) {
    const t = `${e}Ctrls`;
    return [...this[t].values()];
  }
  destroyRowCtrls(e) {
    const t = `${e}Ctrls`;
    for (const i of this[t].values())
      i.destroyFirstPass(!0), i.destroySecondPass();
    this[t] = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy(), this.destroyRowCtrls("top"), this.destroyRowCtrls("bottom"), this.destroyRowCtrls("center");
  }
}, wf = (e) => e ?? "center", mI = class {
  constructor(e, t) {
    this.col = e, this.firstNode = t, this.cellSpan = !0, this.spannedNodes = /* @__PURE__ */ new Set(), this.addSpannedNode(t);
  }
  /**
   * Reset the span leaving only the head.
   * Head is used as a comparison as this is the row used to render this cell
   * Even if the row data changes, the cell will properly reflect the correct value.
   */
  reset() {
    this.spannedNodes.clear(), this.addSpannedNode(this.firstNode);
  }
  addSpannedNode(e) {
    this.spannedNodes.add(e), this.lastNode = e;
  }
  getLastNode() {
    return this.lastNode;
  }
  getCellHeight() {
    return this.lastNode.rowTop + this.lastNode.rowHeight - this.firstNode.rowTop - 1;
  }
  doesSpanContain(e) {
    return e.column !== this.col || e.rowPinned != this.firstNode.rowPinned ? !1 : this.firstNode.rowIndex <= e.rowIndex && e.rowIndex <= this.lastNode.rowIndex;
  }
  /**
   * Gets the auto height value for last node in the spanned cell.
   * The first node is used to store the auto height for the cell, but the additional height for this cell
   * needs applied to the last row in the span.
   */
  getLastNodeAutoHeight() {
    var i;
    const e = (i = this.firstNode.__autoHeights) == null ? void 0 : i[this.col.getColId()];
    if (e == null)
      return;
    let t = 0;
    return this.spannedNodes.forEach((s) => {
      s !== this.lastNode && (t += s.rowHeight);
    }), e - t;
  }
}, CI = class extends E {
  constructor(e) {
    super(), this.column = e;
  }
  buildCache(e) {
    var R;
    const {
      column: t,
      beans: { gos: i, pinnedRowModel: s, rowModel: o, valueSvc: n, pagination: r }
    } = this, { colDef: a } = t, l = this[`${e}ValueNodeMap`], d = /* @__PURE__ */ new Map(), c = i.getCallback("isFullWidthRow"), u = a.equals, h = a.spanRows, g = typeof h == "function";
    let p = null, f = null, m;
    const C = (b, w) => {
      p = b, f = null, m = w;
    }, v = (b) => {
      const w = !b.isExpandable() && !b.group && !b.detail && (c ? !c({ rowNode: b }) : !0);
      if (b.rowIndex == null || !w) {
        C(null, null);
        return;
      }
      if (p == null || b.level !== p.level || // no span across groups
      b.footer || f && b.rowIndex - 1 !== (f == null ? void 0 : f.getLastNode().rowIndex)) {
        C(b, n.getValue(t, b));
        return;
      }
      const x = n.getValue(t, b);
      if (g) {
        const F = W(i, {
          valueA: m,
          nodeA: p,
          valueB: x,
          nodeB: b,
          column: t,
          colDef: a
        });
        if (!h(F)) {
          C(b, x);
          return;
        }
      } else if (u ? !u(m, x) : m !== x) {
        C(b, x);
        return;
      }
      if (!f) {
        const F = l == null ? void 0 : l.get(p);
        (F == null ? void 0 : F.firstNode) === p ? (F.reset(), f = F) : f = new mI(t, p), d.set(p, f);
      }
      f.addSpannedNode(b), d.set(b, f);
    };
    switch (e) {
      case "center":
        (R = o.forEachDisplayedNode) == null || R.call(o, (b) => {
          (!r || r.isRowInPage(b.rowIndex)) && v(b);
        });
        break;
      case "top":
        s == null || s.forEachPinnedRow("top", v);
        break;
      case "bottom":
        s == null || s.forEachPinnedRow("bottom", v);
        break;
    }
    this[`${e}ValueNodeMap`] = d;
  }
  isCellSpanning(e) {
    return !!this.getCellSpan(e);
  }
  getCellSpan(e) {
    return this[`${wf(e.rowPinned)}ValueNodeMap`].get(e);
  }
}, vI = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowSpanSvc", this.spanningColumns = /* @__PURE__ */ new Map(), this.debouncePinnedEvent = De(this, this.dispatchCellsUpdatedEvent.bind(this, !0), 0), this.debounceModelEvent = De(this, this.dispatchCellsUpdatedEvent.bind(this, !1), 0), this.pinnedTimeout = null, this.modelTimeout = null;
  }
  postConstruct() {
    const e = this.onRowDataUpdated.bind(this), t = this.buildPinnedCaches.bind(this);
    this.addManagedEventListeners({
      paginationChanged: this.buildModelCaches.bind(this),
      pinnedRowDataChanged: t,
      pinnedRowsChanged: t,
      rowNodeDataChanged: e,
      cellValueChanged: e
    });
  }
  /**
   * When a new column is created with spanning (or spanning changes for a column)
   * @param column column that is now spanning
   */
  register(e) {
    const { gos: t } = this.beans;
    if (!t.get("enableCellSpan") || this.spanningColumns.has(e))
      return;
    const i = this.createManagedBean(new CI(e));
    this.spanningColumns.set(e, i), i.buildCache("top"), i.buildCache("bottom"), i.buildCache("center"), this.debouncePinnedEvent(), this.debounceModelEvent();
  }
  dispatchCellsUpdatedEvent(e) {
    this.dispatchLocalEvent({ type: "spannedCellsUpdated", pinned: e });
  }
  /**
   * When a new column is destroyed with spanning (or spanning changes for a column)
   * @param column column that is now spanning
   */
  deregister(e) {
    this.spanningColumns.delete(e);
  }
  // called when data changes, as this could be a hot path it's debounced
  // it uses timeouts instead of debounce so that it can be cancelled by `modelUpdated`
  // which is expected to run immediately (to exec before the rowRenderer)
  onRowDataUpdated({ node: e }) {
    const { spannedRowRenderer: t } = this.beans;
    if (e.rowPinned) {
      if (this.pinnedTimeout != null)
        return;
      this.pinnedTimeout = window.setTimeout(() => {
        this.pinnedTimeout = null, this.buildPinnedCaches(), t == null || t.createCtrls("top"), t == null || t.createCtrls("bottom");
      }, 0);
      return;
    }
    this.modelTimeout == null && (this.modelTimeout = window.setTimeout(() => {
      this.modelTimeout = null, this.buildModelCaches(), t == null || t.createCtrls("center");
    }, 0));
  }
  buildModelCaches() {
    this.modelTimeout != null && clearTimeout(this.modelTimeout), this.spanningColumns.forEach((e) => e.buildCache("center")), this.debounceModelEvent();
  }
  buildPinnedCaches() {
    this.pinnedTimeout != null && clearTimeout(this.pinnedTimeout), this.spanningColumns.forEach((e) => {
      e.buildCache("top"), e.buildCache("bottom");
    }), this.debouncePinnedEvent();
  }
  isCellSpanning(e, t) {
    const i = this.spanningColumns.get(e);
    return i ? i.isCellSpanning(t) : !1;
  }
  getCellSpanByPosition(e) {
    const { pinnedRowModel: t, rowModel: i } = this.beans, s = e.column, o = e.rowIndex, n = this.spanningColumns.get(s);
    if (!n)
      return;
    let r;
    switch (e.rowPinned) {
      case "top":
        r = t == null ? void 0 : t.getPinnedTopRow(o);
        break;
      case "bottom":
        r = t == null ? void 0 : t.getPinnedBottomRow(o);
        break;
      default:
        r = i.getRow(o);
    }
    if (r)
      return n.getCellSpan(r);
  }
  getCellStart(e) {
    const t = this.getCellSpanByPosition(e);
    return t ? { ...e, rowIndex: t.firstNode.rowIndex } : e;
  }
  getCellEnd(e) {
    const t = this.getCellSpanByPosition(e);
    return t ? { ...e, rowIndex: t.getLastNode().rowIndex } : e;
  }
  /**
   * Look-up a spanned cell given a col and node as position indicators
   *
   * @param col a column to lookup a span at this position
   * @param rowNode a node that may be spanned at this position
   * @returns the CellSpan object if one exists
   */
  getCellSpan(e, t) {
    const i = this.spanningColumns.get(e);
    if (i)
      return i.getCellSpan(t);
  }
  forEachSpannedColumn(e, t) {
    for (const [i, s] of this.spanningColumns)
      if (s.isCellSpanning(e)) {
        const o = s.getCellSpan(e);
        t(i, o);
      }
  }
  destroy() {
    super.destroy(), this.spanningColumns.clear();
  }
}, wI = {
  moduleName: "CellSpan",
  version: B,
  beans: [vI, fI]
}, bI = class extends E {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.staticClasses = [], this.beans = t, this.column = e.column;
  }
  setComp(e) {
    this.cellComp = e, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const { column: e, cellComp: t } = this, i = e.colDef, s = i.cellClassRules, o = this.getCellClassParams(e, i);
    od(
      this.beans.expressionSvc,
      // if current was previous, skip
      s === this.cellClassRules ? void 0 : this.cellClassRules,
      s,
      o,
      (n) => t.toggleCss(n, !0),
      (n) => t.toggleCss(n, !1)
    ), this.cellClassRules = s;
  }
  applyUserStyles() {
    const e = this.column, t = e.colDef, i = t.cellStyle;
    if (!i)
      return;
    let s;
    if (typeof i == "function") {
      const o = this.getCellClassParams(e, t);
      s = i(o);
    } else
      s = i;
    s && this.cellComp.setUserStyles(s);
  }
  applyClassesFromColDef() {
    const { column: e, cellComp: t } = this, i = e.colDef, s = this.getCellClassParams(e, i);
    this.staticClasses.forEach((n) => t.toggleCss(n, !1));
    const o = this.beans.cellStyles.getStaticCellClasses(i, s);
    this.staticClasses = o, o.forEach((n) => t.toggleCss(n, !0));
  }
  getCellClassParams(e, t) {
    const { value: i, rowNode: s } = this.cellCtrl;
    return W(this.beans.gos, {
      value: i,
      data: s.data,
      node: s,
      colDef: t,
      column: e,
      rowIndex: s.rowIndex
    });
  }
}, yI = class extends E {
  constructor() {
    super(...arguments), this.beanName = "cellStyles";
  }
  processAllCellClasses(e, t, i, s) {
    od(
      this.beans.expressionSvc,
      void 0,
      e.cellClassRules,
      t,
      i,
      s
    ), this.processStaticCellClasses(e, t, i);
  }
  getStaticCellClasses(e, t) {
    const { cellClass: i } = e;
    if (!i)
      return [];
    let s;
    return typeof i == "function" ? s = i(t) : s = i, typeof s == "string" && (s = [s]), s || [];
  }
  createCellCustomStyleFeature(e, t) {
    return new bI(e, t);
  }
  processStaticCellClasses(e, t, i) {
    this.getStaticCellClasses(e, t).forEach((o) => {
      i(o);
    });
  }
}, SI = {
  moduleName: "CellStyle",
  version: B,
  beans: [yI]
}, RI = {
  moduleName: "RowStyle",
  version: B,
  beans: [pP]
};
function xI(e, t) {
  var i;
  return !!((i = e.colHover) != null && i.isHovered(t));
}
var FI = class extends E {
  constructor(e, t) {
    super(), this.columns = e, this.element = t, this.destroyManagedListeners = [], this.enableFeature = (i) => {
      const { beans: s, gos: o, element: n, columns: r } = this, a = s.colHover;
      i ?? !!o.get("columnHoverHighlight") ? this.destroyManagedListeners = this.addManagedElementListeners(n, {
        mouseover: a.setMouseOver.bind(a, r),
        mouseout: a.clearMouseOver.bind(a)
      }) : (this.destroyManagedListeners.forEach((d) => d()), this.destroyManagedListeners = []);
    };
  }
  postConstruct() {
    this.addManagedPropertyListener("columnHoverHighlight", ({ currentValue: e }) => {
      this.enableFeature(e);
    }), this.enableFeature();
  }
  destroy() {
    super.destroy(), this.destroyManagedListeners = null;
  }
}, PI = "ag-column-hover", EI = class extends E {
  constructor() {
    super(...arguments), this.beanName = "colHover";
  }
  postConstruct() {
    this.addManagedPropertyListener("columnHoverHighlight", ({ currentValue: e }) => {
      e || this.clearMouseOver();
    });
  }
  setMouseOver(e) {
    this.updateState(e);
  }
  clearMouseOver() {
    this.updateState(null);
  }
  isHovered(e) {
    if (!this.gos.get("columnHoverHighlight"))
      return !1;
    const t = this.selectedColumns;
    return !!t && t.indexOf(e) >= 0;
  }
  addHeaderColumnHoverListener(e, t, i) {
    const s = () => {
      const o = this.isHovered(i);
      t.toggleCss("ag-column-hover", o);
    };
    e.addManagedEventListeners({ columnHoverChanged: s }), s();
  }
  onCellColumnHover(e, t) {
    if (!t)
      return;
    const i = this.isHovered(e);
    t.toggleCss(PI, i);
  }
  addHeaderFilterColumnHoverListener(e, t, i, s) {
    this.createHoverFeature(e, [i], s);
    const o = () => {
      const n = this.isHovered(i);
      t.toggleCss("ag-column-hover", n);
    };
    e.addManagedEventListeners({ columnHoverChanged: o }), o();
  }
  createHoverFeature(e, t, i) {
    e.createManagedBean(new FI(t, i));
  }
  updateState(e) {
    this.selectedColumns = e, this.eventSvc.dispatchEvent({
      type: "columnHoverChanged"
    });
  }
}, DI = {
  moduleName: "ColumnHover",
  version: B,
  beans: [EI],
  apiFunctions: {
    isColumnHovered: xI
  }
}, TI = class extends E {
  constructor() {
    super(...arguments), this.beanName = "apiEventSvc", this.syncListeners = /* @__PURE__ */ new Map(), this.asyncListeners = /* @__PURE__ */ new Map(), this.syncGlobalListeners = /* @__PURE__ */ new Set(), this.globalListenerPairs = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    var e, t;
    this.wrapSvc = (t = (e = this.beans.frameworkOverrides).createGlobalEventListenerWrapper) == null ? void 0 : t.call(e);
  }
  addListener(e, t) {
    var n;
    const i = ((n = this.wrapSvc) == null ? void 0 : n.wrap(e, t)) ?? t, s = !ro.has(e), o = s ? this.asyncListeners : this.syncListeners;
    o.has(e) || o.set(e, /* @__PURE__ */ new Set()), o.get(e).add(i), this.eventSvc.addListener(e, i, s);
  }
  removeListener(e, t) {
    var n, r;
    const i = ((n = this.wrapSvc) == null ? void 0 : n.unwrap(e, t)) ?? t, s = this.asyncListeners.get(e), o = !!(s != null && s.delete(i));
    o || (r = this.syncListeners.get(e)) == null || r.delete(i), this.eventSvc.removeListener(e, i, o);
  }
  addGlobalListener(e) {
    var n;
    const t = ((n = this.wrapSvc) == null ? void 0 : n.wrapGlobal(e)) ?? e, i = (r, a) => {
      ro.has(r) && t(r, a);
    }, s = (r, a) => {
      ro.has(r) || t(r, a);
    };
    this.globalListenerPairs.set(e, { syncListener: i, asyncListener: s });
    const o = this.eventSvc;
    o.addGlobalListener(i, !1), o.addGlobalListener(s, !0);
  }
  removeGlobalListener(e) {
    const { eventSvc: t, wrapSvc: i, globalListenerPairs: s } = this, o = (i == null ? void 0 : i.unwrapGlobal(e)) ?? e;
    if (s.has(o)) {
      const { syncListener: r, asyncListener: a } = s.get(o);
      t.removeGlobalListener(r, !1), t.removeGlobalListener(a, !0), s.delete(e);
    } else
      this.syncGlobalListeners.delete(o), t.removeGlobalListener(o, !1);
  }
  destroyEventListeners(e, t) {
    e.forEach((i, s) => {
      i.forEach((o) => this.eventSvc.removeListener(s, o, t)), i.clear();
    }), e.clear();
  }
  destroyGlobalListeners(e, t) {
    e.forEach((i) => this.eventSvc.removeGlobalListener(i, t)), e.clear();
  }
  destroy() {
    super.destroy(), this.destroyEventListeners(this.syncListeners, !1), this.destroyEventListeners(this.asyncListeners, !0), this.destroyGlobalListeners(this.syncGlobalListeners, !1);
    const { globalListenerPairs: e, eventSvc: t } = this;
    e.forEach(({ syncListener: i, asyncListener: s }) => {
      t.removeGlobalListener(i, !1), t.removeGlobalListener(s, !0);
    }), e.clear();
  }
};
function MI(e, t, i) {
  var s;
  (s = e.apiEventSvc) == null || s.addListener(t, i);
}
function AI(e, t, i) {
  var s;
  (s = e.apiEventSvc) == null || s.removeListener(t, i);
}
function II(e, t) {
  var i;
  (i = e.apiEventSvc) == null || i.addGlobalListener(t);
}
function kI(e, t) {
  var i;
  (i = e.apiEventSvc) == null || i.removeGlobalListener(t);
}
var LI = {
  moduleName: "EventApi",
  version: B,
  apiFunctions: {
    addEventListener: MI,
    addGlobalListener: II,
    removeEventListener: AI,
    removeGlobalListener: kI
  },
  beans: [TI]
}, OI = {
  moduleName: "Locale",
  version: B,
  beans: [pE]
}, _I = class extends E {
  constructor() {
    super(...arguments), this.beanName = "rowAutoHeight", this.wasEverActive = !1, this._debouncedCalculateRowHeights = De(this, this.calculateRowHeights.bind(this), 1);
  }
  /**
   * If row height has been active, request a refresh of the row heights.
   */
  requestCheckAutoHeight() {
    this.wasEverActive && this._debouncedCalculateRowHeights();
  }
  calculateRowHeights() {
    var a, l, d, c;
    const { visibleCols: e, rowModel: t, rowSpanSvc: i, pinnedRowModel: s } = this.beans, o = e.autoHeightCols;
    let n = !1;
    const r = (u) => {
      var p;
      const h = u.__autoHeights;
      let g = ri(this.beans, u).height;
      for (const f of o) {
        let m = h == null ? void 0 : h[f.getColId()];
        const C = i == null ? void 0 : i.getCellSpan(f, u);
        if (C) {
          if (C.getLastNode() !== u)
            continue;
          if (m = (p = i == null ? void 0 : i.getCellSpan(f, u)) == null ? void 0 : p.getLastNodeAutoHeight(), !m)
            return;
        }
        if (m == null) {
          if (this.colSpanSkipCell(f, u))
            continue;
          return;
        }
        g = Math.max(m, g);
      }
      g !== u.rowHeight && (u.setRowHeight(g), n = !0);
    };
    (a = s == null ? void 0 : s.forEachPinnedRow) == null || a.call(s, "top", r), (l = s == null ? void 0 : s.forEachPinnedRow) == null || l.call(s, "bottom", r), (d = t.forEachDisplayedNode) == null || d.call(t, r), n && ((c = t.onRowHeightChanged) == null || c.call(t));
  }
  /**
   * Set the cell height into the row node, and request a refresh of the row heights if there's been a change.
   * @param rowNode the node to set the auto height on
   * @param cellHeight the height to set, undefined if the cell has just been destroyed
   * @param column the column of the cell
   */
  setRowAutoHeight(e, t, i) {
    if (e.__autoHeights ?? (e.__autoHeights = {}), t == null) {
      delete e.__autoHeights[i.getId()];
      return;
    }
    const s = e.__autoHeights[i.getId()];
    e.__autoHeights[i.getId()] = t, s !== t && this.requestCheckAutoHeight();
  }
  /**
   * If using col span, then cells which have been spanned over do not need an auto height value
   * @param col the column of the cell
   * @param node the node of the cell
   * @returns whether the row needs auto height value for that column
   */
  colSpanSkipCell(e, t) {
    const { colModel: i, colViewport: s, visibleCols: o } = this.beans;
    if (!i.colSpanActive)
      return !1;
    let n = [];
    switch (e.getPinned()) {
      case "left":
        n = o.getLeftColsForRow(t);
        break;
      case "right":
        n = o.getRightColsForRow(t);
        break;
      case null:
        n = s.getColsWithinViewport(t);
        break;
    }
    return !n.includes(e);
  }
  /**
   * If required, sets up observers to continuously measure changes in the cell height.
   * @param cellCtrl the cellCtrl of the cell
   * @param eCellWrapper the HTMLElement to track the height of
   * @param compBean the component bean to add the destroy/cleanup function to
   * @returns whether or not auto height has been set up on this cell
   */
  setupCellAutoHeight(e, t, i) {
    if (!e.column.isAutoHeight() || !t)
      return !1;
    this.wasEverActive = !0;
    const s = t.parentElement, { rowNode: o, column: n } = e, r = this.beans, a = (c) => {
      var v;
      if ((v = this.beans.editSvc) != null && v.isEditing(e) || !e.isAlive() || !i.isAlive())
        return;
      const { paddingTop: u, paddingBottom: h, borderBottomWidth: g, borderTopWidth: p } = Ni(s), f = u + h + g + p, C = t.offsetHeight + f;
      if (c < 5) {
        const R = Ee(r), b = !R || !R.contains(t), w = C == 0;
        if (b || w) {
          window.setTimeout(() => a(c + 1), 0);
          return;
        }
      }
      this.setRowAutoHeight(o, C, n);
    }, l = () => a(0);
    l();
    const d = di(r, t, l);
    return i.addDestroyFunc(() => {
      d(), this.setRowAutoHeight(o, void 0, n);
    }), !0;
  }
  setAutoHeightActive(e) {
    this.active = e.list.some((t) => t.isVisible() && t.isAutoHeight());
  }
  /**
   * Determines if the row auto height service has cells to grow.
   * @returns true if all of the rendered rows are at least as tall as their rendered cells.
   */
  areRowsMeasured() {
    if (!this.active)
      return !0;
    const e = this.beans.rowRenderer.getAllRowCtrls();
    let t = null;
    for (const { rowNode: i } of e)
      if ((!t || this.beans.colModel.colSpanActive) && (t = this.beans.colViewport.getColsWithinViewport(i).filter((o) => o.isAutoHeight())), t.length !== 0) {
        if (!i.__autoHeights)
          return !1;
        for (const s of t) {
          const o = i.__autoHeights[s.getColId()];
          if (!o || i.rowHeight < o)
            return !1;
        }
      }
    return !0;
  }
}, HI = {
  moduleName: "RowAutoHeight",
  version: B,
  beans: [_I]
}, BI = {
  moduleName: "AllCommunity",
  version: B,
  dependsOn: [
    HM,
    $M,
    tA,
    kE,
    zT,
    UT,
    $T,
    KT,
    jT,
    qT,
    YT,
    WT,
    OD,
    _D,
    HD,
    LD,
    GD,
    VD,
    CA,
    bM,
    _A,
    Cp,
    Cf,
    KA,
    eI,
    nI,
    bR,
    hI,
    cM,
    QP,
    SI,
    DI,
    RI,
    LI,
    JP,
    uA,
    sf,
    OI,
    HI,
    wR,
    BM,
    wI
  ]
}, GI = Object.defineProperty, VI = (e, t, i) => t in e ? GI(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, ms = (e, t, i) => VI(e, typeof t != "symbol" ? t + "" : t, i);
class Ao {
  static getComponentDefinition(t, i) {
    let s;
    return typeof t == "string" ? s = this.searchForComponentInstance(i, t) : s = { extends: Bo({ ...t }) }, s || Z(114, { component: t }), s.extends ? (s.extends.setup && (s.setup = s.extends.setup), s.extends.props = this.addParamsToProps(s.extends.props)) : s.props = this.addParamsToProps(s.props), s;
  }
  static addParamsToProps(t) {
    return !t || Array.isArray(t) && t.indexOf("params") === -1 ? t = ["params", ...t || []] : typeof t == "object" && !t.params && (t.params = {
      type: Object
    }), t;
  }
  static createAndMountComponent(t, i, s, o) {
    const n = Ao.getComponentDefinition(t, s);
    if (!n)
      return;
    const { vNode: r, destroy: a, el: l } = this.mount(
      n,
      { params: Object.freeze(i) },
      s,
      o || {}
    );
    return {
      componentInstance: r.component.proxy,
      element: l,
      destroy: a
    };
  }
  static mount(t, i, s, o) {
    let n = Ea(t, i);
    n.appContext = { ...s.appContext, provides: o };
    let r = document.createDocumentFragment();
    return Gd(n, r), { vNode: n, destroy: () => {
      r && Gd(null, r), r = null, n = null;
    }, el: r };
  }
  static searchForComponentInstance(t, i, s = 10, o = !1) {
    let n = null, r = 0, a = t.parent;
    for (; !n && a && a.components && ++r < s; )
      a.components && a.components[i] && (n = a.components[i]), a = a.parent;
    for (r = 0, a = t.parent; !n && a && a.$options && ++r < s; ) {
      const l = a;
      l.$options && l.$options.components && l.$options.components[i] ? n = l.$options.components[i] : l[i] && (n = l[i]), a = a.parent;
    }
    for (r = 0, a = t.parent; !n && a && ++r < s; ) {
      if (a.exposed) {
        const l = a;
        l.exposed && l.exposed[i] ? n = l.exposed[i] : l[i] && (n = l[i]);
      }
      a = a.parent;
    }
    if (!n) {
      const l = t.appContext.components;
      l && l[i] && (n = l[i]);
    }
    return !n && !o ? (Z(114, { component: i }), null) : n;
  }
}
class NI extends CE {
  constructor(t, i) {
    super(), ms(this, "parent"), ms(this, "provides"), this.parent = t, this.provides = i;
  }
  createWrapper(t) {
    const i = this;
    class s extends WI {
      init(r) {
        super.init(r);
      }
      hasMethod(r) {
        var a, l;
        const d = o.getFrameworkComponentInstance();
        return d[r] ? !0 : ((a = d.$.exposed) == null ? void 0 : a[r]) != null || ((l = d.exposed) == null ? void 0 : l[r]) != null || d.$.setupState[r] != null;
      }
      callMethod(r, a) {
        var l, d;
        const c = this.getFrameworkComponentInstance(), u = o.getFrameworkComponentInstance();
        if (u[r])
          return u[r].apply(c, a);
        {
          const h = ((l = c.$.exposed) == null ? void 0 : l[r]) || ((d = c.exposed) == null ? void 0 : d[r]) || c.$.setupState[r];
          return h == null ? void 0 : h.apply(c, a);
        }
      }
      addMethod(r, a) {
        o[r] = a;
      }
      processMethod(r, a) {
        return r === "refresh" && (this.getFrameworkComponentInstance().params = a[0]), this.hasMethod(r) ? this.callMethod(r, a) : r === "refresh";
      }
      createComponent(r) {
        return i.createComponent(t, r);
      }
    }
    const o = new s();
    return o;
  }
  createComponent(t, i) {
    return Ao.createAndMountComponent(t, i, this.parent, this.provides);
  }
  createMethodProxy(t, i, s) {
    return function() {
      return t.hasMethod(i) ? t.callMethod(i, arguments) : (s && I(233, { methodName: i }), null);
    };
  }
  destroy() {
    this.parent = null;
  }
}
class WI {
  constructor() {
    ms(this, "componentInstance"), ms(this, "element"), ms(this, "unmount");
  }
  getGui() {
    return this.element;
  }
  destroy() {
    this.getFrameworkComponentInstance() && typeof this.getFrameworkComponentInstance().destroy == "function" && this.getFrameworkComponentInstance().destroy(), this.unmount();
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  init(t) {
    const { componentInstance: i, element: s, destroy: o } = this.createComponent(t);
    this.componentInstance = i, this.unmount = o, this.element = s.firstElementChild ?? s;
  }
}
class zI extends ap {
  constructor(t) {
    super("vue"), ms(this, "parent"), this.parent = t;
  }
  /*
   * vue components are specified in the "components" part of the vue component - as such we need a way to determine
   * if a given component is within that context - this method provides this
   * Note: This is only really used/necessary with cellRendererSelectors
   */
  frameworkComponent(t, i) {
    let s = Ao.searchForComponentInstance(this.parent, t, 10, !0) ? t : null;
    if (!s && i && i[t]) {
      const o = i[t];
      s = Ao.searchForComponentInstance(this.parent, o, 10, !0) ? o : null;
    }
    return s;
  }
  isFrameworkComponent(t) {
    return typeof t == "object";
  }
}
function UI() {
  return {
    gridOptions: {},
    modules: [],
    // @START_DEFAULTS@
    statusBar: void 0,
    sideBar: void 0,
    suppressContextMenu: void 0,
    preventDefaultOnContextMenu: void 0,
    allowContextMenuWithControlKey: void 0,
    columnMenu: void 0,
    suppressMenuHide: void 0,
    enableBrowserTooltips: void 0,
    tooltipTrigger: void 0,
    tooltipShowDelay: void 0,
    tooltipHideDelay: void 0,
    tooltipMouseTrack: void 0,
    tooltipShowMode: void 0,
    tooltipInteraction: void 0,
    popupParent: void 0,
    copyHeadersToClipboard: void 0,
    copyGroupHeadersToClipboard: void 0,
    clipboardDelimiter: void 0,
    suppressCopyRowsToClipboard: void 0,
    suppressCopySingleCellRanges: void 0,
    suppressLastEmptyLineOnPaste: void 0,
    suppressClipboardPaste: void 0,
    suppressClipboardApi: void 0,
    suppressCutToClipboard: void 0,
    columnDefs: void 0,
    defaultColDef: void 0,
    defaultColGroupDef: void 0,
    columnTypes: void 0,
    dataTypeDefinitions: void 0,
    maintainColumnOrder: void 0,
    enableStrictPivotColumnOrder: void 0,
    suppressFieldDotNotation: void 0,
    headerHeight: void 0,
    groupHeaderHeight: void 0,
    floatingFiltersHeight: void 0,
    pivotHeaderHeight: void 0,
    pivotGroupHeaderHeight: void 0,
    hidePaddedHeaderRows: void 0,
    allowDragFromColumnsToolPanel: void 0,
    suppressMovableColumns: void 0,
    suppressColumnMoveAnimation: void 0,
    suppressMoveWhenColumnDragging: void 0,
    suppressDragLeaveHidesColumns: void 0,
    suppressGroupChangesColumnVisibility: void 0,
    suppressMakeColumnVisibleAfterUnGroup: void 0,
    suppressRowGroupHidesColumns: void 0,
    colResizeDefault: void 0,
    suppressAutoSize: void 0,
    autoSizePadding: void 0,
    skipHeaderOnAutoSize: void 0,
    autoSizeStrategy: void 0,
    components: void 0,
    editType: void 0,
    suppressStartEditOnTab: void 0,
    getFullRowEditValidationErrors: void 0,
    invalidEditValueMode: void 0,
    singleClickEdit: void 0,
    suppressClickEdit: void 0,
    readOnlyEdit: void 0,
    stopEditingWhenCellsLoseFocus: void 0,
    enterNavigatesVertically: void 0,
    enterNavigatesVerticallyAfterEdit: void 0,
    enableCellEditingOnBackspace: void 0,
    undoRedoCellEditing: void 0,
    undoRedoCellEditingLimit: void 0,
    defaultCsvExportParams: void 0,
    suppressCsvExport: void 0,
    defaultExcelExportParams: void 0,
    suppressExcelExport: void 0,
    excelStyles: void 0,
    findSearchValue: void 0,
    findOptions: void 0,
    quickFilterText: void 0,
    cacheQuickFilter: void 0,
    includeHiddenColumnsInQuickFilter: void 0,
    quickFilterParser: void 0,
    quickFilterMatcher: void 0,
    applyQuickFilterBeforePivotOrAgg: void 0,
    excludeChildrenWhenTreeDataFiltering: void 0,
    enableAdvancedFilter: void 0,
    alwaysPassFilter: void 0,
    includeHiddenColumnsInAdvancedFilter: void 0,
    advancedFilterParent: void 0,
    advancedFilterBuilderParams: void 0,
    advancedFilterParams: void 0,
    suppressAdvancedFilterEval: void 0,
    suppressSetFilterByDefault: void 0,
    enableFilterHandlers: void 0,
    filterHandlers: void 0,
    enableCharts: void 0,
    chartThemes: void 0,
    customChartThemes: void 0,
    chartThemeOverrides: void 0,
    chartToolPanelsDef: void 0,
    chartMenuItems: void 0,
    loadingCellRenderer: void 0,
    loadingCellRendererParams: void 0,
    loadingCellRendererSelector: void 0,
    localeText: void 0,
    masterDetail: void 0,
    keepDetailRows: void 0,
    keepDetailRowsCount: void 0,
    detailCellRenderer: void 0,
    detailCellRendererParams: void 0,
    detailRowHeight: void 0,
    detailRowAutoHeight: void 0,
    context: void 0,
    alignedGrids: void 0,
    tabIndex: void 0,
    rowBuffer: void 0,
    valueCache: void 0,
    valueCacheNeverExpires: void 0,
    enableCellExpressions: void 0,
    suppressTouch: void 0,
    suppressFocusAfterRefresh: void 0,
    suppressBrowserResizeObserver: void 0,
    suppressPropertyNamesCheck: void 0,
    suppressChangeDetection: void 0,
    debug: void 0,
    loading: void 0,
    overlayLoadingTemplate: void 0,
    loadingOverlayComponent: void 0,
    loadingOverlayComponentParams: void 0,
    suppressLoadingOverlay: void 0,
    overlayNoRowsTemplate: void 0,
    noRowsOverlayComponent: void 0,
    noRowsOverlayComponentParams: void 0,
    suppressNoRowsOverlay: void 0,
    pagination: void 0,
    paginationPageSize: void 0,
    paginationPageSizeSelector: void 0,
    paginationAutoPageSize: void 0,
    paginateChildRows: void 0,
    suppressPaginationPanel: void 0,
    pivotMode: void 0,
    pivotPanelShow: void 0,
    pivotMaxGeneratedColumns: void 0,
    pivotDefaultExpanded: void 0,
    pivotColumnGroupTotals: void 0,
    pivotRowTotals: void 0,
    pivotSuppressAutoColumn: void 0,
    suppressExpandablePivotGroups: void 0,
    functionsReadOnly: void 0,
    aggFuncs: void 0,
    suppressAggFuncInHeader: void 0,
    alwaysAggregateAtRootLevel: void 0,
    aggregateOnlyChangedColumns: void 0,
    suppressAggFilteredOnly: void 0,
    removePivotHeaderRowWhenSingleValueColumn: void 0,
    animateRows: void 0,
    cellFlashDuration: void 0,
    cellFadeDuration: void 0,
    allowShowChangeAfterFilter: void 0,
    domLayout: void 0,
    ensureDomOrder: void 0,
    enableCellSpan: void 0,
    enableRtl: void 0,
    suppressColumnVirtualisation: void 0,
    suppressMaxRenderedRowRestriction: void 0,
    suppressRowVirtualisation: void 0,
    rowDragManaged: void 0,
    rowDragInsertDelay: void 0,
    suppressRowDrag: void 0,
    suppressMoveWhenRowDragging: void 0,
    rowDragEntireRow: void 0,
    rowDragMultiRow: void 0,
    rowDragText: void 0,
    dragAndDropImageComponent: void 0,
    dragAndDropImageComponentParams: void 0,
    fullWidthCellRenderer: void 0,
    fullWidthCellRendererParams: void 0,
    embedFullWidthRows: void 0,
    groupDisplayType: void 0,
    groupDefaultExpanded: void 0,
    autoGroupColumnDef: void 0,
    groupMaintainOrder: void 0,
    groupSelectsChildren: void 0,
    groupLockGroupColumns: void 0,
    groupAggFiltering: void 0,
    groupTotalRow: void 0,
    grandTotalRow: void 0,
    suppressStickyTotalRow: void 0,
    groupSuppressBlankHeader: void 0,
    groupSelectsFiltered: void 0,
    showOpenedGroup: void 0,
    groupHideParentOfSingleChild: void 0,
    groupRemoveSingleChildren: void 0,
    groupRemoveLowestSingleChildren: void 0,
    groupHideOpenParents: void 0,
    groupAllowUnbalanced: void 0,
    rowGroupPanelShow: void 0,
    groupRowRenderer: void 0,
    groupRowRendererParams: void 0,
    treeData: void 0,
    treeDataChildrenField: void 0,
    treeDataParentIdField: void 0,
    rowGroupPanelSuppressSort: void 0,
    suppressGroupRowsSticky: void 0,
    groupHierarchyConfig: void 0,
    pinnedTopRowData: void 0,
    pinnedBottomRowData: void 0,
    enableRowPinning: void 0,
    isRowPinnable: void 0,
    isRowPinned: void 0,
    rowModelType: void 0,
    rowData: void 0,
    asyncTransactionWaitMillis: void 0,
    suppressModelUpdateAfterUpdateTransaction: void 0,
    datasource: void 0,
    cacheOverflowSize: void 0,
    infiniteInitialRowCount: void 0,
    serverSideInitialRowCount: void 0,
    suppressServerSideFullWidthLoadingRow: void 0,
    cacheBlockSize: void 0,
    maxBlocksInCache: void 0,
    maxConcurrentDatasourceRequests: void 0,
    blockLoadDebounceMillis: void 0,
    purgeClosedRowNodes: void 0,
    serverSideDatasource: void 0,
    serverSideSortAllLevels: void 0,
    serverSideEnableClientSideSort: void 0,
    serverSideOnlyRefreshFilteredGroups: void 0,
    serverSidePivotResultFieldSeparator: void 0,
    viewportDatasource: void 0,
    viewportRowModelPageSize: void 0,
    viewportRowModelBufferSize: void 0,
    alwaysShowHorizontalScroll: void 0,
    alwaysShowVerticalScroll: void 0,
    debounceVerticalScrollbar: void 0,
    suppressHorizontalScroll: void 0,
    suppressScrollOnNewData: void 0,
    suppressScrollWhenPopupsAreOpen: void 0,
    suppressAnimationFrame: void 0,
    suppressMiddleClickScrolls: void 0,
    suppressPreventDefaultOnMouseWheel: void 0,
    scrollbarWidth: void 0,
    rowSelection: void 0,
    cellSelection: void 0,
    rowMultiSelectWithClick: void 0,
    suppressRowDeselection: void 0,
    suppressRowClickSelection: void 0,
    suppressCellFocus: void 0,
    suppressHeaderFocus: void 0,
    selectionColumnDef: void 0,
    rowNumbers: void 0,
    suppressMultiRangeSelection: void 0,
    enableCellTextSelection: void 0,
    enableRangeSelection: void 0,
    enableRangeHandle: void 0,
    enableFillHandle: void 0,
    fillHandleDirection: void 0,
    suppressClearOnFillReduction: void 0,
    sortingOrder: void 0,
    accentedSort: void 0,
    unSortIcon: void 0,
    suppressMultiSort: void 0,
    alwaysMultiSort: void 0,
    multiSortKey: void 0,
    suppressMaintainUnsortedOrder: void 0,
    icons: void 0,
    rowHeight: void 0,
    rowStyle: void 0,
    rowClass: void 0,
    rowClassRules: void 0,
    suppressRowHoverHighlight: void 0,
    suppressRowTransform: void 0,
    columnHoverHighlight: void 0,
    gridId: void 0,
    deltaSort: void 0,
    treeDataDisplayType: void 0,
    enableGroupEdit: void 0,
    initialState: void 0,
    theme: void 0,
    loadThemeGoogleFonts: void 0,
    themeCssLayer: void 0,
    styleNonce: void 0,
    themeStyleContainer: void 0,
    getContextMenuItems: void 0,
    getMainMenuItems: void 0,
    postProcessPopup: void 0,
    processUnpinnedColumns: void 0,
    processCellForClipboard: void 0,
    processHeaderForClipboard: void 0,
    processGroupHeaderForClipboard: void 0,
    processCellFromClipboard: void 0,
    sendToClipboard: void 0,
    processDataFromClipboard: void 0,
    isExternalFilterPresent: void 0,
    doesExternalFilterPass: void 0,
    getChartToolbarItems: void 0,
    createChartContainer: void 0,
    focusGridInnerElement: void 0,
    navigateToNextHeader: void 0,
    tabToNextHeader: void 0,
    navigateToNextCell: void 0,
    tabToNextCell: void 0,
    getLocaleText: void 0,
    getDocument: void 0,
    paginationNumberFormatter: void 0,
    getGroupRowAgg: void 0,
    isGroupOpenByDefault: void 0,
    ssrmExpandAllAffectsAllRows: void 0,
    initialGroupOrderComparator: void 0,
    processPivotResultColDef: void 0,
    processPivotResultColGroupDef: void 0,
    getDataPath: void 0,
    getChildCount: void 0,
    getServerSideGroupLevelParams: void 0,
    isServerSideGroupOpenByDefault: void 0,
    isApplyServerSideTransaction: void 0,
    isServerSideGroup: void 0,
    getServerSideGroupKey: void 0,
    getBusinessKeyForNode: void 0,
    getRowId: void 0,
    resetRowDataOnUpdate: void 0,
    processRowPostCreate: void 0,
    isRowSelectable: void 0,
    isRowMaster: void 0,
    fillOperation: void 0,
    postSortRows: void 0,
    getRowStyle: void 0,
    getRowClass: void 0,
    getRowHeight: void 0,
    isFullWidthRow: void 0,
    isRowValidDropPosition: void 0,
    // @END_DEFAULTS@
    // @START_EVENT_PROPS@
    "onColumn-everything-changed": void 0,
    "onNew-columns-loaded": void 0,
    "onColumn-pivot-mode-changed": void 0,
    "onPivot-max-columns-exceeded": void 0,
    "onColumn-row-group-changed": void 0,
    "onExpand-or-collapse-all": void 0,
    "onColumn-pivot-changed": void 0,
    "onGrid-columns-changed": void 0,
    "onColumn-value-changed": void 0,
    "onColumn-moved": void 0,
    "onColumn-visible": void 0,
    "onColumn-pinned": void 0,
    "onColumn-group-opened": void 0,
    "onColumn-resized": void 0,
    "onDisplayed-columns-changed": void 0,
    "onVirtual-columns-changed": void 0,
    "onColumn-header-mouse-over": void 0,
    "onColumn-header-mouse-leave": void 0,
    "onColumn-header-clicked": void 0,
    "onColumn-header-context-menu": void 0,
    "onAsync-transactions-flushed": void 0,
    "onRow-group-opened": void 0,
    "onRow-data-updated": void 0,
    "onPinned-row-data-changed": void 0,
    "onPinned-rows-changed": void 0,
    "onRange-selection-changed": void 0,
    "onCell-selection-changed": void 0,
    "onChart-created": void 0,
    "onChart-range-selection-changed": void 0,
    "onChart-options-changed": void 0,
    "onChart-destroyed": void 0,
    "onTool-panel-visible-changed": void 0,
    "onTool-panel-size-changed": void 0,
    "onModel-updated": void 0,
    "onCut-start": void 0,
    "onCut-end": void 0,
    "onPaste-start": void 0,
    "onPaste-end": void 0,
    "onFill-start": void 0,
    "onFill-end": void 0,
    "onCell-selection-delete-start": void 0,
    "onCell-selection-delete-end": void 0,
    "onRange-delete-start": void 0,
    "onRange-delete-end": void 0,
    "onUndo-started": void 0,
    "onUndo-ended": void 0,
    "onRedo-started": void 0,
    "onRedo-ended": void 0,
    "onCell-clicked": void 0,
    "onCell-double-clicked": void 0,
    "onCell-mouse-down": void 0,
    "onCell-context-menu": void 0,
    "onCell-value-changed": void 0,
    "onCell-edit-request": void 0,
    "onRow-value-changed": void 0,
    "onHeader-focused": void 0,
    "onCell-focused": void 0,
    "onRow-selected": void 0,
    "onSelection-changed": void 0,
    "onTooltip-show": void 0,
    "onTooltip-hide": void 0,
    "onCell-key-down": void 0,
    "onCell-mouse-over": void 0,
    "onCell-mouse-out": void 0,
    "onFilter-changed": void 0,
    "onFilter-modified": void 0,
    "onFilter-ui-changed": void 0,
    "onFilter-opened": void 0,
    "onFloating-filter-ui-changed": void 0,
    "onAdvanced-filter-builder-visible-changed": void 0,
    "onSort-changed": void 0,
    "onVirtual-row-removed": void 0,
    "onRow-clicked": void 0,
    "onRow-double-clicked": void 0,
    "onGrid-ready": void 0,
    "onGrid-pre-destroyed": void 0,
    "onGrid-size-changed": void 0,
    "onViewport-changed": void 0,
    "onFirst-data-rendered": void 0,
    "onDrag-started": void 0,
    "onDrag-stopped": void 0,
    "onDrag-cancelled": void 0,
    "onRow-editing-started": void 0,
    "onRow-editing-stopped": void 0,
    "onCell-editing-started": void 0,
    "onCell-editing-stopped": void 0,
    "onBody-scroll": void 0,
    "onBody-scroll-end": void 0,
    "onPagination-changed": void 0,
    "onComponent-state-changed": void 0,
    "onStore-refreshed": void 0,
    "onState-updated": void 0,
    "onColumn-menu-visible-changed": void 0,
    "onContext-menu-visible-changed": void 0,
    "onRow-drag-enter": void 0,
    "onRow-drag-move": void 0,
    "onRow-drag-leave": void 0,
    "onRow-drag-end": void 0,
    "onRow-drag-cancel": void 0,
    "onFind-changed": void 0,
    "onRow-resize-started": void 0,
    "onRow-resize-ended": void 0,
    "onColumns-reset": void 0,
    "onBulk-editing-started": void 0,
    "onBulk-editing-stopped": void 0,
    "onBatch-editing-started": void 0,
    "onBatch-editing-stopped": void 0
    // @END_EVENT_PROPS@
  };
}
const $I = (e, t) => {
  let i;
  return () => {
    const s = function() {
      e();
    };
    window.clearTimeout(i), i = window.setTimeout(s, t);
  };
};
function KI(e) {
  return e && e.constructor && e.constructor.toString().substring(0, 5) === "class";
}
function Ws(e) {
  const t = (i) => KI(i) ? Co(i) : Array.isArray(i) ? i.map((s) => t(s)) : Dm(i) || Tm(i) || Sl(i) ? t(Co(i)) : i;
  return t(e);
}
const jI = { ref: "root" }, qI = /* @__PURE__ */ Bo({
  __name: "AgGridVue",
  props: /* @__PURE__ */ Bd(/* @__PURE__ */ Em({
    gridOptions: {},
    modules: {},
    statusBar: {},
    sideBar: { type: [Object, String, Array, Boolean, null] },
    suppressContextMenu: { type: Boolean },
    preventDefaultOnContextMenu: { type: Boolean },
    allowContextMenuWithControlKey: { type: Boolean },
    columnMenu: {},
    suppressMenuHide: { type: Boolean },
    enableBrowserTooltips: { type: Boolean },
    tooltipTrigger: {},
    tooltipShowDelay: {},
    tooltipHideDelay: {},
    tooltipMouseTrack: { type: Boolean },
    tooltipShowMode: {},
    tooltipInteraction: { type: Boolean },
    popupParent: {},
    copyHeadersToClipboard: { type: Boolean },
    copyGroupHeadersToClipboard: { type: Boolean },
    clipboardDelimiter: {},
    suppressCopyRowsToClipboard: { type: Boolean },
    suppressCopySingleCellRanges: { type: Boolean },
    suppressLastEmptyLineOnPaste: { type: Boolean },
    suppressClipboardPaste: { type: Boolean },
    suppressClipboardApi: { type: Boolean },
    suppressCutToClipboard: { type: Boolean },
    columnDefs: {},
    defaultColDef: {},
    defaultColGroupDef: {},
    columnTypes: {},
    dataTypeDefinitions: {},
    maintainColumnOrder: { type: Boolean },
    enableStrictPivotColumnOrder: { type: Boolean },
    suppressFieldDotNotation: { type: Boolean },
    headerHeight: {},
    groupHeaderHeight: {},
    floatingFiltersHeight: {},
    pivotHeaderHeight: {},
    pivotGroupHeaderHeight: {},
    hidePaddedHeaderRows: { type: Boolean },
    allowDragFromColumnsToolPanel: { type: Boolean },
    suppressMovableColumns: { type: Boolean },
    suppressColumnMoveAnimation: { type: Boolean },
    suppressMoveWhenColumnDragging: { type: Boolean },
    suppressDragLeaveHidesColumns: { type: Boolean },
    suppressGroupChangesColumnVisibility: { type: [Boolean, String] },
    suppressMakeColumnVisibleAfterUnGroup: { type: Boolean },
    suppressRowGroupHidesColumns: { type: Boolean },
    colResizeDefault: {},
    suppressAutoSize: { type: Boolean },
    autoSizePadding: {},
    skipHeaderOnAutoSize: { type: Boolean },
    autoSizeStrategy: {},
    components: {},
    editType: {},
    suppressStartEditOnTab: { type: Boolean },
    getFullRowEditValidationErrors: { type: Function },
    invalidEditValueMode: {},
    singleClickEdit: { type: Boolean },
    suppressClickEdit: { type: Boolean },
    readOnlyEdit: { type: Boolean },
    stopEditingWhenCellsLoseFocus: { type: Boolean },
    enterNavigatesVertically: { type: Boolean },
    enterNavigatesVerticallyAfterEdit: { type: Boolean },
    enableCellEditingOnBackspace: { type: Boolean },
    undoRedoCellEditing: { type: Boolean },
    undoRedoCellEditingLimit: {},
    defaultCsvExportParams: {},
    suppressCsvExport: { type: Boolean },
    defaultExcelExportParams: {},
    suppressExcelExport: { type: Boolean },
    excelStyles: {},
    findSearchValue: {},
    findOptions: {},
    quickFilterText: {},
    cacheQuickFilter: { type: Boolean },
    includeHiddenColumnsInQuickFilter: { type: Boolean },
    quickFilterParser: { type: Function },
    quickFilterMatcher: { type: Function },
    applyQuickFilterBeforePivotOrAgg: { type: Boolean },
    excludeChildrenWhenTreeDataFiltering: { type: Boolean },
    enableAdvancedFilter: { type: Boolean },
    alwaysPassFilter: { type: Function },
    includeHiddenColumnsInAdvancedFilter: { type: Boolean },
    advancedFilterParent: {},
    advancedFilterBuilderParams: {},
    advancedFilterParams: {},
    suppressAdvancedFilterEval: { type: Boolean },
    suppressSetFilterByDefault: { type: Boolean },
    enableFilterHandlers: { type: Boolean },
    filterHandlers: {},
    enableCharts: { type: Boolean },
    chartThemes: {},
    customChartThemes: {},
    chartThemeOverrides: {},
    chartToolPanelsDef: {},
    chartMenuItems: { type: [Array, Function] },
    loadingCellRenderer: {},
    loadingCellRendererParams: {},
    loadingCellRendererSelector: { type: Function },
    localeText: {},
    masterDetail: { type: Boolean },
    keepDetailRows: { type: Boolean },
    keepDetailRowsCount: {},
    detailCellRenderer: {},
    detailCellRendererParams: {},
    detailRowHeight: {},
    detailRowAutoHeight: { type: Boolean },
    context: {},
    alignedGrids: { type: [Array, Function] },
    tabIndex: {},
    rowBuffer: {},
    valueCache: { type: Boolean },
    valueCacheNeverExpires: { type: Boolean },
    enableCellExpressions: { type: Boolean },
    suppressTouch: { type: Boolean },
    suppressFocusAfterRefresh: { type: Boolean },
    suppressBrowserResizeObserver: { type: Boolean },
    suppressPropertyNamesCheck: { type: Boolean },
    suppressChangeDetection: { type: Boolean },
    debug: { type: Boolean },
    loading: { type: Boolean },
    overlayLoadingTemplate: {},
    loadingOverlayComponent: {},
    loadingOverlayComponentParams: {},
    suppressLoadingOverlay: { type: Boolean },
    overlayNoRowsTemplate: {},
    noRowsOverlayComponent: {},
    noRowsOverlayComponentParams: {},
    suppressNoRowsOverlay: { type: Boolean },
    pagination: { type: Boolean },
    paginationPageSize: {},
    paginationPageSizeSelector: { type: [Array, Boolean] },
    paginationAutoPageSize: { type: Boolean },
    paginateChildRows: { type: Boolean },
    suppressPaginationPanel: { type: Boolean },
    pivotMode: { type: Boolean },
    pivotPanelShow: {},
    pivotMaxGeneratedColumns: {},
    pivotDefaultExpanded: {},
    pivotColumnGroupTotals: {},
    pivotRowTotals: {},
    pivotSuppressAutoColumn: { type: Boolean },
    suppressExpandablePivotGroups: { type: Boolean },
    functionsReadOnly: { type: Boolean },
    aggFuncs: {},
    suppressAggFuncInHeader: { type: Boolean },
    alwaysAggregateAtRootLevel: { type: Boolean },
    aggregateOnlyChangedColumns: { type: Boolean },
    suppressAggFilteredOnly: { type: Boolean },
    removePivotHeaderRowWhenSingleValueColumn: { type: Boolean },
    animateRows: { type: Boolean },
    cellFlashDuration: {},
    cellFadeDuration: {},
    allowShowChangeAfterFilter: { type: Boolean },
    domLayout: {},
    ensureDomOrder: { type: Boolean },
    enableCellSpan: { type: Boolean },
    enableRtl: { type: Boolean },
    suppressColumnVirtualisation: { type: Boolean },
    suppressMaxRenderedRowRestriction: { type: Boolean },
    suppressRowVirtualisation: { type: Boolean },
    rowDragManaged: { type: Boolean },
    rowDragInsertDelay: {},
    suppressRowDrag: { type: Boolean },
    suppressMoveWhenRowDragging: { type: Boolean },
    rowDragEntireRow: { type: Boolean },
    rowDragMultiRow: { type: Boolean },
    rowDragText: { type: Function },
    dragAndDropImageComponent: {},
    dragAndDropImageComponentParams: {},
    fullWidthCellRenderer: {},
    fullWidthCellRendererParams: {},
    embedFullWidthRows: { type: Boolean },
    groupDisplayType: {},
    groupDefaultExpanded: {},
    autoGroupColumnDef: {},
    groupMaintainOrder: { type: Boolean },
    groupSelectsChildren: { type: Boolean },
    groupLockGroupColumns: {},
    groupAggFiltering: { type: [Boolean, Function] },
    groupTotalRow: { type: [String, Function] },
    grandTotalRow: {},
    suppressStickyTotalRow: { type: [Boolean, String] },
    groupSuppressBlankHeader: { type: Boolean },
    groupSelectsFiltered: { type: Boolean },
    showOpenedGroup: { type: Boolean },
    groupHideParentOfSingleChild: { type: [Boolean, String] },
    groupRemoveSingleChildren: { type: Boolean },
    groupRemoveLowestSingleChildren: { type: Boolean },
    groupHideOpenParents: { type: Boolean },
    groupAllowUnbalanced: { type: Boolean },
    rowGroupPanelShow: {},
    groupRowRenderer: {},
    groupRowRendererParams: {},
    treeData: { type: Boolean },
    treeDataChildrenField: {},
    treeDataParentIdField: {},
    rowGroupPanelSuppressSort: { type: Boolean },
    suppressGroupRowsSticky: { type: Boolean },
    groupHierarchyConfig: {},
    pinnedTopRowData: {},
    pinnedBottomRowData: {},
    enableRowPinning: { type: [Boolean, String] },
    isRowPinnable: { type: Function },
    isRowPinned: { type: Function },
    rowModelType: {},
    rowData: {},
    asyncTransactionWaitMillis: {},
    suppressModelUpdateAfterUpdateTransaction: { type: Boolean },
    datasource: {},
    cacheOverflowSize: {},
    infiniteInitialRowCount: {},
    serverSideInitialRowCount: {},
    suppressServerSideFullWidthLoadingRow: { type: Boolean },
    cacheBlockSize: {},
    maxBlocksInCache: {},
    maxConcurrentDatasourceRequests: {},
    blockLoadDebounceMillis: {},
    purgeClosedRowNodes: { type: Boolean },
    serverSideDatasource: {},
    serverSideSortAllLevels: { type: Boolean },
    serverSideEnableClientSideSort: { type: Boolean },
    serverSideOnlyRefreshFilteredGroups: { type: Boolean },
    serverSidePivotResultFieldSeparator: {},
    viewportDatasource: {},
    viewportRowModelPageSize: {},
    viewportRowModelBufferSize: {},
    alwaysShowHorizontalScroll: { type: Boolean },
    alwaysShowVerticalScroll: { type: Boolean },
    debounceVerticalScrollbar: { type: Boolean },
    suppressHorizontalScroll: { type: Boolean },
    suppressScrollOnNewData: { type: Boolean },
    suppressScrollWhenPopupsAreOpen: { type: Boolean },
    suppressAnimationFrame: { type: Boolean },
    suppressMiddleClickScrolls: { type: Boolean },
    suppressPreventDefaultOnMouseWheel: { type: Boolean },
    scrollbarWidth: {},
    rowSelection: {},
    cellSelection: { type: [Boolean, Object] },
    rowMultiSelectWithClick: { type: Boolean },
    suppressRowDeselection: { type: Boolean },
    suppressRowClickSelection: { type: Boolean },
    suppressCellFocus: { type: Boolean },
    suppressHeaderFocus: { type: Boolean },
    selectionColumnDef: {},
    rowNumbers: { type: [Boolean, Object] },
    suppressMultiRangeSelection: { type: Boolean },
    enableCellTextSelection: { type: Boolean },
    enableRangeSelection: { type: Boolean },
    enableRangeHandle: { type: Boolean },
    enableFillHandle: { type: Boolean },
    fillHandleDirection: {},
    suppressClearOnFillReduction: { type: Boolean },
    sortingOrder: {},
    accentedSort: { type: Boolean },
    unSortIcon: { type: Boolean },
    suppressMultiSort: { type: Boolean },
    alwaysMultiSort: { type: Boolean },
    multiSortKey: {},
    suppressMaintainUnsortedOrder: { type: Boolean },
    icons: {},
    rowHeight: {},
    rowStyle: {},
    rowClass: {},
    rowClassRules: {},
    suppressRowHoverHighlight: { type: Boolean },
    suppressRowTransform: { type: Boolean },
    columnHoverHighlight: { type: Boolean },
    gridId: {},
    deltaSort: { type: Boolean },
    treeDataDisplayType: {},
    enableGroupEdit: { type: Boolean },
    initialState: {},
    theme: {},
    loadThemeGoogleFonts: { type: Boolean },
    themeCssLayer: {},
    styleNonce: {},
    themeStyleContainer: {},
    getContextMenuItems: { type: Function },
    getMainMenuItems: { type: Function },
    postProcessPopup: { type: Function },
    processUnpinnedColumns: { type: Function },
    processCellForClipboard: { type: Function },
    processHeaderForClipboard: { type: Function },
    processGroupHeaderForClipboard: { type: Function },
    processCellFromClipboard: { type: Function },
    sendToClipboard: { type: Function },
    processDataFromClipboard: { type: Function },
    isExternalFilterPresent: { type: Function },
    doesExternalFilterPass: { type: Function },
    getChartToolbarItems: { type: Function },
    createChartContainer: { type: Function },
    focusGridInnerElement: { type: Function },
    navigateToNextHeader: { type: Function },
    tabToNextHeader: { type: Function },
    navigateToNextCell: { type: Function },
    tabToNextCell: { type: Function },
    getLocaleText: { type: Function },
    getDocument: { type: Function },
    paginationNumberFormatter: { type: Function },
    getGroupRowAgg: { type: Function },
    isGroupOpenByDefault: { type: Function },
    ssrmExpandAllAffectsAllRows: { type: Boolean },
    initialGroupOrderComparator: { type: Function },
    processPivotResultColDef: { type: Function },
    processPivotResultColGroupDef: { type: Function },
    getDataPath: { type: Function },
    getChildCount: { type: Function },
    getServerSideGroupLevelParams: { type: Function },
    isServerSideGroupOpenByDefault: { type: Function },
    isApplyServerSideTransaction: { type: Function },
    isServerSideGroup: { type: Function },
    getServerSideGroupKey: { type: Function },
    getBusinessKeyForNode: { type: Function },
    getRowId: { type: Function },
    resetRowDataOnUpdate: { type: Boolean },
    processRowPostCreate: { type: Function },
    isRowSelectable: { type: Function },
    isRowMaster: { type: Function },
    fillOperation: { type: Function },
    postSortRows: { type: Function },
    getRowStyle: { type: Function },
    getRowClass: { type: Function },
    getRowHeight: { type: Function },
    isFullWidthRow: { type: Function },
    isRowValidDropPosition: { type: Function },
    "onTool-panel-visible-changed": {},
    "onTool-panel-size-changed": {},
    "onColumn-menu-visible-changed": {},
    "onContext-menu-visible-changed": {},
    "onCut-start": {},
    "onCut-end": {},
    "onPaste-start": {},
    "onPaste-end": {},
    "onColumn-visible": {},
    "onColumn-pinned": {},
    "onColumn-resized": {},
    "onColumn-moved": {},
    "onColumn-value-changed": {},
    "onColumn-pivot-mode-changed": {},
    "onColumn-pivot-changed": {},
    "onColumn-group-opened": {},
    "onNew-columns-loaded": {},
    "onGrid-columns-changed": {},
    "onDisplayed-columns-changed": {},
    "onVirtual-columns-changed": {},
    "onColumn-everything-changed": {},
    "onColumns-reset": {},
    "onColumn-header-mouse-over": {},
    "onColumn-header-mouse-leave": {},
    "onColumn-header-clicked": {},
    "onColumn-header-context-menu": {},
    "onComponent-state-changed": {},
    "onCell-value-changed": {},
    "onCell-edit-request": {},
    "onRow-value-changed": {},
    "onCell-editing-started": {},
    "onCell-editing-stopped": {},
    "onRow-editing-started": {},
    "onRow-editing-stopped": {},
    "onBulk-editing-started": {},
    "onBulk-editing-stopped": {},
    "onBatch-editing-started": {},
    "onBatch-editing-stopped": {},
    "onUndo-started": {},
    "onUndo-ended": {},
    "onRedo-started": {},
    "onRedo-ended": {},
    "onCell-selection-delete-start": {},
    "onCell-selection-delete-end": {},
    "onRange-delete-start": {},
    "onRange-delete-end": {},
    "onFill-start": {},
    "onFill-end": {},
    "onFilter-opened": {},
    "onFilter-changed": {},
    "onFilter-modified": {},
    "onFilter-ui-changed": {},
    "onFloating-filter-ui-changed": {},
    "onAdvanced-filter-builder-visible-changed": {},
    "onFind-changed": {},
    "onChart-created": {},
    "onChart-range-selection-changed": {},
    "onChart-options-changed": {},
    "onChart-destroyed": {},
    "onCell-key-down": {},
    "onGrid-ready": {},
    "onGrid-pre-destroyed": {},
    "onFirst-data-rendered": {},
    "onGrid-size-changed": {},
    "onModel-updated": {},
    "onVirtual-row-removed": {},
    "onViewport-changed": {},
    "onBody-scroll": {},
    "onBody-scroll-end": {},
    "onDrag-started": {},
    "onDrag-stopped": {},
    "onDrag-cancelled": {},
    "onState-updated": {},
    "onPagination-changed": {},
    "onRow-drag-enter": {},
    "onRow-drag-move": {},
    "onRow-drag-leave": {},
    "onRow-drag-end": {},
    "onRow-drag-cancel": {},
    "onRow-resize-started": {},
    "onRow-resize-ended": {},
    "onColumn-row-group-changed": {},
    "onRow-group-opened": {},
    "onExpand-or-collapse-all": {},
    "onPivot-max-columns-exceeded": {},
    "onPinned-row-data-changed": {},
    "onPinned-rows-changed": {},
    "onRow-data-updated": {},
    "onAsync-transactions-flushed": {},
    "onStore-refreshed": {},
    "onHeader-focused": {},
    "onCell-clicked": {},
    "onCell-double-clicked": {},
    "onCell-focused": {},
    "onCell-mouse-over": {},
    "onCell-mouse-out": {},
    "onCell-mouse-down": {},
    "onRow-clicked": {},
    "onRow-double-clicked": {},
    "onRow-selected": {},
    "onSelection-changed": {},
    "onCell-context-menu": {},
    "onRange-selection-changed": {},
    "onCell-selection-changed": {},
    "onTooltip-show": {},
    "onTooltip-hide": {},
    "onSort-changed": {}
  }, UI()), {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ Bd(["update:modelValue"], ["update:modelValue"]),
  setup(e, { expose: t, emit: i }) {
    const s = e, o = Rm("root"), n = we(void 0), r = we(!1), a = we(!1), l = we(!1), d = we({}), c = we(null), u = xm(s);
    il().filter((T) => T != "gridOptions").forEach((T) => {
      mo(
        () => u[T],
        (k, A) => {
          (T === "rowData" && !f.value || T !== "rowData") && F(T, k), f.value = !1;
        },
        { deep: !0 }
      );
    });
    const h = /* @__PURE__ */ new Set(["rowDataUpdated", "cellValueChanged", "rowValueChanged"]), g = Fm(e, "modelValue"), p = we(!1), f = we(!1), m = i;
    mo(
      g,
      (T, k) => {
        r.value && (f.value || (p.value = !0, F("rowData", Ws(T), Ws(k))), f.value = !1);
      },
      { deep: !0 }
    );
    const C = $I(() => {
      f.value = !0, m("update:modelValue", w());
    }, 10), v = Xo(), R = (T) => {
      var k, A;
      l.value && h.has(T) && (A = (k = v == null ? void 0 : v.vnode) == null ? void 0 : k.props) != null && A["onUpdate:modelValue"] && C();
    }, b = () => g.value || s.rowData || s.gridOptions.rowData, w = () => {
      const T = [];
      return n == null || n.value.forEachLeafNode((k) => {
        T.push(k.data);
      }), T;
    }, x = (T) => (k) => {
      if (a.value)
        return;
      k === "gridReady" && (l.value = !0);
      const A = ro.has(k);
      A && !T || !A && T || h.has(k) && (p.value || R(k), p.value = !1);
    }, F = (T, k, A) => {
      if (r.value) {
        let G = k.value || k;
        T === "rowData" && G != null && (G = Ws(G)), d.value[T] = G, c.value == null && (c.value = window.setTimeout(() => {
          c.value = null, XC(d.value, n.value), d.value = {};
        }, 0));
      }
    }, D = () => Object.create(Xo().provides);
    return Bn(() => {
      or(Cf, void 0, !0);
      const T = new NI(Xo(), D()), k = {
        globalListener: x(),
        globalSyncListener: x(!0),
        frameworkOverrides: new zI(Xo()),
        providedBeanInstances: {
          frameworkCompWrapper: T
        },
        modules: s.modules
      }, A = Pm(
        QC(Ws(s.gridOptions), s, [
          ...il(),
          // we could have replaced it with GRID_OPTIONS_VALIDATORS().allProperties,
          // but that prevents tree shaking of validation code in Vue
          ...Object.values(Fr)
        ])
      ), G = b();
      G !== void 0 && (A.rowData = Ws(G)), n.value = uE(o.value, A, k), r.value = !0;
    }), vh(() => {
      var T;
      r.value && ((T = n == null ? void 0 : n.value) == null || T.destroy(), a.value = !0);
    }), t({
      api: n
    }), (T, k) => (X(), J("div", jI, null, 512));
  }
}), YI = Symbol.for("y2kfund.supabase"), QI = {
  positions: (e, t) => ["positions", e, t],
  trades: (e) => ["trades", e],
  nlvMargin: (e, t) => ["nlvMargin", e, t],
  thesis: () => ["thesis"],
  userAccountAccess: (e) => ["userAccountAccess", e]
};
function XI() {
  const e = wh(YI, null);
  if (!e) throw new Error("[@y2kfund/core] Supabase client not found. Did you install createCore()?");
  return e;
}
async function ZI(e, t) {
  if (!t)
    return console.log(" No userId provided, showing all positions"), [];
  try {
    console.log(" Fetching accessible accounts for user:", t);
    const { data: i, error: s } = await e.schema("hf").from("user_account_access").select("internal_account_id").eq("user_id", t).eq("is_active", !0);
    if (s)
      return console.error(" Error fetching user account access:", s), [];
    if (!i || i.length === 0)
      return console.log(" No account access found for user, showing all positions"), [];
    const o = i.map((n) => n.internal_account_id);
    return console.log(" User has access to accounts:", o), o;
  } catch (i) {
    return console.error(" Exception fetching account access:", i), [];
  }
}
function JI(e, t) {
  const i = XI(), s = QI.nlvMargin(e, t), o = Gm(), n = Ta({
    queryKey: s,
    queryFn: async () => {
      const l = await ZI(i, t);
      console.log(" Querying NLV/Margin with config:", {
        limit: e,
        userId: t || "none",
        accessibleAccountIds: l.length > 0 ? l : "all"
      });
      const { data: d, error: c } = await i.schema("hf").rpc("get_nlv_margin_with_excess", {
        p_limit: e
      });
      if (c) throw c;
      let u = d || [];
      return l.length > 0 && u.length > 0 ? u[0] && "nlv_internal_account_id" in u[0] ? (console.log(" Applying access filter for NLV/Margin data"), u = u.filter(
        (h) => h.nlv_internal_account_id && l.includes(h.nlv_internal_account_id)
      )) : console.warn(" NLV/Margin data missing nlv_internal_account_id field, cannot filter by access") : console.log(" No access filter applied - showing all NLV/Margin data"), console.log(" NLV/Margin query success:", {
        totalRows: (d == null ? void 0 : d.length) || 0,
        filteredRows: u.length,
        filtered: l.length > 0
      }), u;
    },
    staleTime: 6e4
  }), r = i.channel("netliquidation_all").on(
    "postgres_changes",
    {
      schema: "hf",
      table: "netliquidation",
      event: "*"
    },
    () => o.invalidateQueries({ queryKey: s })
  ).subscribe(), a = i.channel("maintenance_margin_all").on(
    "postgres_changes",
    {
      schema: "hf",
      table: "maintenance_margin",
      event: "*"
    },
    () => o.invalidateQueries({ queryKey: s })
  ).subscribe();
  return {
    ...n,
    _cleanup: () => {
      var l, d;
      (l = r == null ? void 0 : r.unsubscribe) == null || l.call(r), (d = a == null ? void 0 : a.unsubscribe) == null || d.call(a);
    }
  };
}
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function Ko(e) {
  return e + 0.5 | 0;
}
const ti = (e, t, i) => Math.max(Math.min(e, i), t);
function Qs(e) {
  return ti(Ko(e * 2.55), 0, 255);
}
function si(e) {
  return ti(Ko(e * 255), 0, 255);
}
function Ht(e) {
  return ti(Ko(e / 2.55) / 100, 0, 1);
}
function nu(e) {
  return ti(Ko(e * 100), 0, 100);
}
const qe = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, ul = [..."0123456789ABCDEF"], ek = (e) => ul[e & 15], tk = (e) => ul[(e & 240) >> 4] + ul[e & 15], dn = (e) => (e & 240) >> 4 === (e & 15), ik = (e) => dn(e.r) && dn(e.g) && dn(e.b) && dn(e.a);
function sk(e) {
  var t = e.length, i;
  return e[0] === "#" && (t === 4 || t === 5 ? i = {
    r: 255 & qe[e[1]] * 17,
    g: 255 & qe[e[2]] * 17,
    b: 255 & qe[e[3]] * 17,
    a: t === 5 ? qe[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (i = {
    r: qe[e[1]] << 4 | qe[e[2]],
    g: qe[e[3]] << 4 | qe[e[4]],
    b: qe[e[5]] << 4 | qe[e[6]],
    a: t === 9 ? qe[e[7]] << 4 | qe[e[8]] : 255
  })), i;
}
const ok = (e, t) => e < 255 ? t(e) : "";
function nk(e) {
  var t = ik(e) ? ek : tk;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + ok(e.a, t) : void 0;
}
const rk = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function bf(e, t, i) {
  const s = t * Math.min(i, 1 - i), o = (n, r = (n + e / 30) % 12) => i - s * Math.max(Math.min(r - 3, 9 - r, 1), -1);
  return [o(0), o(8), o(4)];
}
function ak(e, t, i) {
  const s = (o, n = (o + e / 60) % 6) => i - i * t * Math.max(Math.min(n, 4 - n, 1), 0);
  return [s(5), s(3), s(1)];
}
function lk(e, t, i) {
  const s = bf(e, 1, 0.5);
  let o;
  for (t + i > 1 && (o = 1 / (t + i), t *= o, i *= o), o = 0; o < 3; o++)
    s[o] *= 1 - t - i, s[o] += t;
  return s;
}
function dk(e, t, i, s, o) {
  return e === o ? (t - i) / s + (t < i ? 6 : 0) : t === o ? (i - e) / s + 2 : (e - t) / s + 4;
}
function hd(e) {
  const i = e.r / 255, s = e.g / 255, o = e.b / 255, n = Math.max(i, s, o), r = Math.min(i, s, o), a = (n + r) / 2;
  let l, d, c;
  return n !== r && (c = n - r, d = a > 0.5 ? c / (2 - n - r) : c / (n + r), l = dk(i, s, o, c, n), l = l * 60 + 0.5), [l | 0, d || 0, a];
}
function gd(e, t, i, s) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, i, s)).map(si);
}
function pd(e, t, i) {
  return gd(bf, e, t, i);
}
function ck(e, t, i) {
  return gd(lk, e, t, i);
}
function uk(e, t, i) {
  return gd(ak, e, t, i);
}
function yf(e) {
  return (e % 360 + 360) % 360;
}
function hk(e) {
  const t = rk.exec(e);
  let i = 255, s;
  if (!t)
    return;
  t[5] !== s && (i = t[6] ? Qs(+t[5]) : si(+t[5]));
  const o = yf(+t[2]), n = +t[3] / 100, r = +t[4] / 100;
  return t[1] === "hwb" ? s = ck(o, n, r) : t[1] === "hsv" ? s = uk(o, n, r) : s = pd(o, n, r), {
    r: s[0],
    g: s[1],
    b: s[2],
    a: i
  };
}
function gk(e, t) {
  var i = hd(e);
  i[0] = yf(i[0] + t), i = pd(i), e.r = i[0], e.g = i[1], e.b = i[2];
}
function pk(e) {
  if (!e)
    return;
  const t = hd(e), i = t[0], s = nu(t[1]), o = nu(t[2]);
  return e.a < 255 ? `hsla(${i}, ${s}%, ${o}%, ${Ht(e.a)})` : `hsl(${i}, ${s}%, ${o}%)`;
}
const ru = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, au = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function fk() {
  const e = {}, t = Object.keys(au), i = Object.keys(ru);
  let s, o, n, r, a;
  for (s = 0; s < t.length; s++) {
    for (r = a = t[s], o = 0; o < i.length; o++)
      n = i[o], a = a.replace(n, ru[n]);
    n = parseInt(au[r], 16), e[a] = [n >> 16 & 255, n >> 8 & 255, n & 255];
  }
  return e;
}
let cn;
function mk(e) {
  cn || (cn = fk(), cn.transparent = [0, 0, 0, 0]);
  const t = cn[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const Ck = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function vk(e) {
  const t = Ck.exec(e);
  let i = 255, s, o, n;
  if (t) {
    if (t[7] !== s) {
      const r = +t[7];
      i = t[8] ? Qs(r) : ti(r * 255, 0, 255);
    }
    return s = +t[1], o = +t[3], n = +t[5], s = 255 & (t[2] ? Qs(s) : ti(s, 0, 255)), o = 255 & (t[4] ? Qs(o) : ti(o, 0, 255)), n = 255 & (t[6] ? Qs(n) : ti(n, 0, 255)), {
      r: s,
      g: o,
      b: n,
      a: i
    };
  }
}
function wk(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${Ht(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const va = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, Ji = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function bk(e, t, i) {
  const s = Ji(Ht(e.r)), o = Ji(Ht(e.g)), n = Ji(Ht(e.b));
  return {
    r: si(va(s + i * (Ji(Ht(t.r)) - s))),
    g: si(va(o + i * (Ji(Ht(t.g)) - o))),
    b: si(va(n + i * (Ji(Ht(t.b)) - n))),
    a: e.a + i * (t.a - e.a)
  };
}
function un(e, t, i) {
  if (e) {
    let s = hd(e);
    s[t] = Math.max(0, Math.min(s[t] + s[t] * i, t === 0 ? 360 : 1)), s = pd(s), e.r = s[0], e.g = s[1], e.b = s[2];
  }
}
function Sf(e, t) {
  return e && Object.assign(t || {}, e);
}
function lu(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = si(e[3]))) : (t = Sf(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = si(t.a)), t;
}
function yk(e) {
  return e.charAt(0) === "r" ? vk(e) : hk(e);
}
class Io {
  constructor(t) {
    if (t instanceof Io)
      return t;
    const i = typeof t;
    let s;
    i === "object" ? s = lu(t) : i === "string" && (s = sk(t) || mk(t) || yk(t)), this._rgb = s, this._valid = !!s;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = Sf(this._rgb);
    return t && (t.a = Ht(t.a)), t;
  }
  set rgb(t) {
    this._rgb = lu(t);
  }
  rgbString() {
    return this._valid ? wk(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? nk(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? pk(this._rgb) : void 0;
  }
  mix(t, i) {
    if (t) {
      const s = this.rgb, o = t.rgb;
      let n;
      const r = i === n ? 0.5 : i, a = 2 * r - 1, l = s.a - o.a, d = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
      n = 1 - d, s.r = 255 & d * s.r + n * o.r + 0.5, s.g = 255 & d * s.g + n * o.g + 0.5, s.b = 255 & d * s.b + n * o.b + 0.5, s.a = r * s.a + (1 - r) * o.a, this.rgb = s;
    }
    return this;
  }
  interpolate(t, i) {
    return t && (this._rgb = bk(this._rgb, t._rgb, i)), this;
  }
  clone() {
    return new Io(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = si(t), this;
  }
  clearer(t) {
    const i = this._rgb;
    return i.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, i = Ko(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = i, this;
  }
  opaquer(t) {
    const i = this._rgb;
    return i.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return un(this._rgb, 2, t), this;
  }
  darken(t) {
    return un(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return un(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return un(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return gk(this._rgb, t), this;
  }
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
function kt() {
}
const Sk = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function re(e) {
  return e == null;
}
function Fe(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function ee(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function st(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function vt(e, t) {
  return st(e) ? e : t;
}
function Y(e, t) {
  return typeof e > "u" ? t : e;
}
const Rk = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function ae(e, t, i) {
  if (e && typeof e.call == "function")
    return e.apply(i, t);
}
function ie(e, t, i, s) {
  let o, n, r;
  if (Fe(e))
    for (n = e.length, o = 0; o < n; o++)
      t.call(i, e[o], o);
  else if (ee(e))
    for (r = Object.keys(e), n = r.length, o = 0; o < n; o++)
      t.call(i, e[r[o]], r[o]);
}
function dr(e, t) {
  let i, s, o, n;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (i = 0, s = e.length; i < s; ++i)
    if (o = e[i], n = t[i], o.datasetIndex !== n.datasetIndex || o.index !== n.index)
      return !1;
  return !0;
}
function cr(e) {
  if (Fe(e))
    return e.map(cr);
  if (ee(e)) {
    const t = /* @__PURE__ */ Object.create(null), i = Object.keys(e), s = i.length;
    let o = 0;
    for (; o < s; ++o)
      t[i[o]] = cr(e[i[o]]);
    return t;
  }
  return e;
}
function Rf(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function xk(e, t, i, s) {
  if (!Rf(e))
    return;
  const o = t[e], n = i[e];
  ee(o) && ee(n) ? ko(o, n, s) : t[e] = cr(n);
}
function ko(e, t, i) {
  const s = Fe(t) ? t : [
    t
  ], o = s.length;
  if (!ee(e))
    return e;
  i = i || {};
  const n = i.merger || xk;
  let r;
  for (let a = 0; a < o; ++a) {
    if (r = s[a], !ee(r))
      continue;
    const l = Object.keys(r);
    for (let d = 0, c = l.length; d < c; ++d)
      n(l[d], e, r, i);
  }
  return e;
}
function co(e, t) {
  return ko(e, t, {
    merger: Fk
  });
}
function Fk(e, t, i) {
  if (!Rf(e))
    return;
  const s = t[e], o = i[e];
  ee(s) && ee(o) ? co(s, o) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = cr(o));
}
const du = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function Pk(e) {
  const t = e.split("."), i = [];
  let s = "";
  for (const o of t)
    s += o, s.endsWith("\\") ? s = s.slice(0, -1) + "." : (i.push(s), s = "");
  return i;
}
function Ek(e) {
  const t = Pk(e);
  return (i) => {
    for (const s of t) {
      if (s === "")
        break;
      i = i && i[s];
    }
    return i;
  };
}
function ur(e, t) {
  return (du[t] || (du[t] = Ek(t)))(e);
}
function fd(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const hr = (e) => typeof e < "u", li = (e) => typeof e == "function", cu = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const i of e)
    if (!t.has(i))
      return !1;
  return !0;
};
function Dk(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const Pe = Math.PI, Et = 2 * Pe, Tk = Et + Pe, gr = Number.POSITIVE_INFINITY, Mk = Pe / 180, ct = Pe / 2, mi = Pe / 4, uu = Pe * 2 / 3, xf = Math.log10, xs = Math.sign;
function uo(e, t, i) {
  return Math.abs(e - t) < i;
}
function hu(e) {
  const t = Math.round(e);
  e = uo(e, t, e / 1e3) ? t : e;
  const i = Math.pow(10, Math.floor(xf(e))), s = e / i;
  return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i;
}
function Ak(e) {
  const t = [], i = Math.sqrt(e);
  let s;
  for (s = 1; s < i; s++)
    e % s === 0 && (t.push(s), t.push(e / s));
  return i === (i | 0) && t.push(i), t.sort((o, n) => o - n).pop(), t;
}
function Ik(e) {
  return typeof e == "symbol" || typeof e == "object" && e !== null && !(Symbol.toPrimitive in e || "toString" in e || "valueOf" in e);
}
function Lo(e) {
  return !Ik(e) && !isNaN(parseFloat(e)) && isFinite(e);
}
function kk(e, t) {
  const i = Math.round(e);
  return i - t <= e && i + t >= e;
}
function Lk(e, t, i) {
  let s, o, n;
  for (s = 0, o = e.length; s < o; s++)
    n = e[s][i], isNaN(n) || (t.min = Math.min(t.min, n), t.max = Math.max(t.max, n));
}
function Fi(e) {
  return e * (Pe / 180);
}
function Ok(e) {
  return e * (180 / Pe);
}
function gu(e) {
  if (!st(e))
    return;
  let t = 1, i = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, i++;
  return i;
}
function _k(e, t) {
  const i = t.x - e.x, s = t.y - e.y, o = Math.sqrt(i * i + s * s);
  let n = Math.atan2(s, i);
  return n < -0.5 * Pe && (n += Et), {
    angle: n,
    distance: o
  };
}
function hl(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function Hk(e, t) {
  return (e - t + Tk) % Et - Pe;
}
function Zt(e) {
  return (e % Et + Et) % Et;
}
function Ff(e, t, i, s) {
  const o = Zt(e), n = Zt(t), r = Zt(i), a = Zt(n - o), l = Zt(r - o), d = Zt(o - n), c = Zt(o - r);
  return o === n || o === r || s && n === r || a > l && d < c;
}
function Je(e, t, i) {
  return Math.max(t, Math.min(i, e));
}
function Bk(e) {
  return Je(e, -32768, 32767);
}
function Xs(e, t, i, s = 1e-6) {
  return e >= Math.min(t, i) - s && e <= Math.max(t, i) + s;
}
function md(e, t, i) {
  i = i || ((r) => e[r] < t);
  let s = e.length - 1, o = 0, n;
  for (; s - o > 1; )
    n = o + s >> 1, i(n) ? o = n : s = n;
  return {
    lo: o,
    hi: s
  };
}
const Pi = (e, t, i, s) => md(e, i, s ? (o) => {
  const n = e[o][t];
  return n < i || n === i && e[o + 1][t] === i;
} : (o) => e[o][t] < i), Gk = (e, t, i) => md(e, i, (s) => e[s][t] >= i);
function Vk(e, t, i) {
  let s = 0, o = e.length;
  for (; s < o && e[s] < t; )
    s++;
  for (; o > s && e[o - 1] > i; )
    o--;
  return s > 0 || o < e.length ? e.slice(s, o) : e;
}
const Pf = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function Nk(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), Pf.forEach((i) => {
    const s = "_onData" + fd(i), o = e[i];
    Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !1,
      value(...n) {
        const r = o.apply(this, n);
        return e._chartjs.listeners.forEach((a) => {
          typeof a[s] == "function" && a[s](...n);
        }), r;
      }
    });
  });
}
function pu(e, t) {
  const i = e._chartjs;
  if (!i)
    return;
  const s = i.listeners, o = s.indexOf(t);
  o !== -1 && s.splice(o, 1), !(s.length > 0) && (Pf.forEach((n) => {
    delete e[n];
  }), delete e._chartjs);
}
function Wk(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const Ef = function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
}();
function Df(e, t) {
  let i = [], s = !1;
  return function(...o) {
    i = o, s || (s = !0, Ef.call(window, () => {
      s = !1, e.apply(t, i);
    }));
  };
}
function zk(e, t) {
  let i;
  return function(...s) {
    return t ? (clearTimeout(i), i = setTimeout(e, t, s)) : e.apply(this, s), t;
  };
}
const Cd = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", Le = (e, t, i) => e === "start" ? t : e === "end" ? i : (t + i) / 2, Uk = (e, t, i, s) => e === (s ? "left" : "right") ? i : e === "center" ? (t + i) / 2 : t;
function $k(e, t, i) {
  const s = t.length;
  let o = 0, n = s;
  if (e._sorted) {
    const { iScale: r, vScale: a, _parsed: l } = e, d = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null, c = r.axis, { min: u, max: h, minDefined: g, maxDefined: p } = r.getUserBounds();
    if (g) {
      if (o = Math.min(
        // @ts-expect-error Need to type _parsed
        Pi(l, c, u).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? s : Pi(t, c, r.getPixelForValue(u)).lo
      ), d) {
        const f = l.slice(0, o + 1).reverse().findIndex((m) => !re(m[a.axis]));
        o -= Math.max(0, f);
      }
      o = Je(o, 0, s - 1);
    }
    if (p) {
      let f = Math.max(
        // @ts-expect-error Need to type _parsed
        Pi(l, r.axis, h, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? 0 : Pi(t, c, r.getPixelForValue(h), !0).hi + 1
      );
      if (d) {
        const m = l.slice(f - 1).findIndex((C) => !re(C[a.axis]));
        f += Math.max(0, m);
      }
      n = Je(f, o, s) - o;
    } else
      n = s - o;
  }
  return {
    start: o,
    count: n
  };
}
function Kk(e) {
  const { xScale: t, yScale: i, _scaleRanges: s } = e, o = {
    xmin: t.min,
    xmax: t.max,
    ymin: i.min,
    ymax: i.max
  };
  if (!s)
    return e._scaleRanges = o, !0;
  const n = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== i.min || s.ymax !== i.max;
  return Object.assign(s, o), n;
}
const hn = (e) => e === 0 || e === 1, fu = (e, t, i) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * Et / i)), mu = (e, t, i) => Math.pow(2, -10 * e) * Math.sin((e - t) * Et / i) + 1, ho = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * ct) + 1,
  easeOutSine: (e) => Math.sin(e * ct),
  easeInOutSine: (e) => -0.5 * (Math.cos(Pe * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => hn(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => hn(e) ? e : fu(e, 0.075, 0.3),
  easeOutElastic: (e) => hn(e) ? e : mu(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return hn(e) ? e : e < 0.5 ? 0.5 * fu(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * mu(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - ho.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? ho.easeInBounce(e * 2) * 0.5 : ho.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function vd(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function Cu(e) {
  return vd(e) ? e : new Io(e);
}
function wa(e) {
  return vd(e) ? e : new Io(e).saturate(0.5).darken(0.1).hexString();
}
const jk = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], qk = [
  "color",
  "borderColor",
  "backgroundColor"
];
function Yk(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: qk
    },
    numbers: {
      type: "number",
      properties: jk
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function Qk(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const vu = /* @__PURE__ */ new Map();
function Xk(e, t) {
  t = t || {};
  const i = e + JSON.stringify(t);
  let s = vu.get(i);
  return s || (s = new Intl.NumberFormat(e, t), vu.set(i, s)), s;
}
function Tf(e, t, i) {
  return Xk(t, i).format(e);
}
const Zk = {
  values(e) {
    return Fe(e) ? e : "" + e;
  },
  numeric(e, t, i) {
    if (e === 0)
      return "0";
    const s = this.chart.options.locale;
    let o, n = e;
    if (i.length > 1) {
      const d = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
      (d < 1e-4 || d > 1e15) && (o = "scientific"), n = Jk(e, i);
    }
    const r = xf(Math.abs(n)), a = isNaN(r) ? 1 : Math.max(Math.min(-1 * Math.floor(r), 20), 0), l = {
      notation: o,
      minimumFractionDigits: a,
      maximumFractionDigits: a
    };
    return Object.assign(l, this.options.ticks.format), Tf(e, s, l);
  }
};
function Jk(e, t) {
  let i = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(i) >= 1 && e !== Math.floor(e) && (i = e - Math.floor(e)), i;
}
var Mf = {
  formatters: Zk
};
function eL(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, i) => i.lineWidth,
      tickColor: (t, i) => i.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Mf.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const Vi = /* @__PURE__ */ Object.create(null), gl = /* @__PURE__ */ Object.create(null);
function go(e, t) {
  if (!t)
    return e;
  const i = t.split(".");
  for (let s = 0, o = i.length; s < o; ++s) {
    const n = i[s];
    e = e[n] || (e[n] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function ba(e, t, i) {
  return typeof t == "string" ? ko(go(e, t), i) : ko(go(e, ""), t);
}
class tL {
  constructor(t, i) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (s) => s.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (s, o) => wa(o.backgroundColor), this.hoverBorderColor = (s, o) => wa(o.borderColor), this.hoverColor = (s, o) => wa(o.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(i);
  }
  set(t, i) {
    return ba(this, t, i);
  }
  get(t) {
    return go(this, t);
  }
  describe(t, i) {
    return ba(gl, t, i);
  }
  override(t, i) {
    return ba(Vi, t, i);
  }
  route(t, i, s, o) {
    const n = go(this, t), r = go(this, s), a = "_" + i;
    Object.defineProperties(n, {
      [a]: {
        value: n[i],
        writable: !0
      },
      [i]: {
        enumerable: !0,
        get() {
          const l = this[a], d = r[o];
          return ee(l) ? Object.assign({}, d, l) : Y(l, d);
        },
        set(l) {
          this[a] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((i) => i(this));
  }
}
var Se = /* @__PURE__ */ new tL({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  Yk,
  Qk,
  eL
]);
function iL(e) {
  return !e || re(e.size) || re(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function wu(e, t, i, s, o) {
  let n = t[o];
  return n || (n = t[o] = e.measureText(o).width, i.push(o)), n > s && (s = n), s;
}
function Ci(e, t, i) {
  const s = e.currentDevicePixelRatio, o = i !== 0 ? Math.max(i / 2, 0.5) : 0;
  return Math.round((t - o) * s) / s + o;
}
function bu(e, t) {
  !t && !e || (t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore());
}
function pl(e, t, i, s) {
  Af(e, t, i, s, null);
}
function Af(e, t, i, s, o) {
  let n, r, a, l, d, c, u, h;
  const g = t.pointStyle, p = t.rotation, f = t.radius;
  let m = (p || 0) * Mk;
  if (g && typeof g == "object" && (n = g.toString(), n === "[object HTMLImageElement]" || n === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(i, s), e.rotate(m), e.drawImage(g, -g.width / 2, -g.height / 2, g.width, g.height), e.restore();
    return;
  }
  if (!(isNaN(f) || f <= 0)) {
    switch (e.beginPath(), g) {
      default:
        o ? e.ellipse(i, s, o / 2, f, 0, 0, Et) : e.arc(i, s, f, 0, Et), e.closePath();
        break;
      case "triangle":
        c = o ? o / 2 : f, e.moveTo(i + Math.sin(m) * c, s - Math.cos(m) * f), m += uu, e.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * f), m += uu, e.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * f), e.closePath();
        break;
      case "rectRounded":
        d = f * 0.516, l = f - d, r = Math.cos(m + mi) * l, u = Math.cos(m + mi) * (o ? o / 2 - d : l), a = Math.sin(m + mi) * l, h = Math.sin(m + mi) * (o ? o / 2 - d : l), e.arc(i - u, s - a, d, m - Pe, m - ct), e.arc(i + h, s - r, d, m - ct, m), e.arc(i + u, s + a, d, m, m + ct), e.arc(i - h, s + r, d, m + ct, m + Pe), e.closePath();
        break;
      case "rect":
        if (!p) {
          l = Math.SQRT1_2 * f, c = o ? o / 2 : l, e.rect(i - c, s - l, 2 * c, 2 * l);
          break;
        }
        m += mi;
      case "rectRot":
        u = Math.cos(m) * (o ? o / 2 : f), r = Math.cos(m) * f, a = Math.sin(m) * f, h = Math.sin(m) * (o ? o / 2 : f), e.moveTo(i - u, s - a), e.lineTo(i + h, s - r), e.lineTo(i + u, s + a), e.lineTo(i - h, s + r), e.closePath();
        break;
      case "crossRot":
        m += mi;
      case "cross":
        u = Math.cos(m) * (o ? o / 2 : f), r = Math.cos(m) * f, a = Math.sin(m) * f, h = Math.sin(m) * (o ? o / 2 : f), e.moveTo(i - u, s - a), e.lineTo(i + u, s + a), e.moveTo(i + h, s - r), e.lineTo(i - h, s + r);
        break;
      case "star":
        u = Math.cos(m) * (o ? o / 2 : f), r = Math.cos(m) * f, a = Math.sin(m) * f, h = Math.sin(m) * (o ? o / 2 : f), e.moveTo(i - u, s - a), e.lineTo(i + u, s + a), e.moveTo(i + h, s - r), e.lineTo(i - h, s + r), m += mi, u = Math.cos(m) * (o ? o / 2 : f), r = Math.cos(m) * f, a = Math.sin(m) * f, h = Math.sin(m) * (o ? o / 2 : f), e.moveTo(i - u, s - a), e.lineTo(i + u, s + a), e.moveTo(i + h, s - r), e.lineTo(i - h, s + r);
        break;
      case "line":
        r = o ? o / 2 : Math.cos(m) * f, a = Math.sin(m) * f, e.moveTo(i - r, s - a), e.lineTo(i + r, s + a);
        break;
      case "dash":
        e.moveTo(i, s), e.lineTo(i + Math.cos(m) * (o ? o / 2 : f), s + Math.sin(m) * f);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function Oo(e, t, i) {
  return i = i || 0.5, !t || e && e.x > t.left - i && e.x < t.right + i && e.y > t.top - i && e.y < t.bottom + i;
}
function wd(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function bd(e) {
  e.restore();
}
function sL(e, t, i, s, o) {
  if (!t)
    return e.lineTo(i.x, i.y);
  if (o === "middle") {
    const n = (t.x + i.x) / 2;
    e.lineTo(n, t.y), e.lineTo(n, i.y);
  } else o === "after" != !!s ? e.lineTo(t.x, i.y) : e.lineTo(i.x, t.y);
  e.lineTo(i.x, i.y);
}
function oL(e, t, i, s) {
  if (!t)
    return e.lineTo(i.x, i.y);
  e.bezierCurveTo(s ? t.cp1x : t.cp2x, s ? t.cp1y : t.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y);
}
function nL(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), re(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function rL(e, t, i, s, o) {
  if (o.strikethrough || o.underline) {
    const n = e.measureText(s), r = t - n.actualBoundingBoxLeft, a = t + n.actualBoundingBoxRight, l = i - n.actualBoundingBoxAscent, d = i + n.actualBoundingBoxDescent, c = o.strikethrough ? (l + d) / 2 : d;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = o.decorationWidth || 2, e.moveTo(r, c), e.lineTo(a, c), e.stroke();
  }
}
function aL(e, t) {
  const i = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = i;
}
function _o(e, t, i, s, o, n = {}) {
  const r = Fe(t) ? t : [
    t
  ], a = n.strokeWidth > 0 && n.strokeColor !== "";
  let l, d;
  for (e.save(), e.font = o.string, nL(e, n), l = 0; l < r.length; ++l)
    d = r[l], n.backdrop && aL(e, n.backdrop), a && (n.strokeColor && (e.strokeStyle = n.strokeColor), re(n.strokeWidth) || (e.lineWidth = n.strokeWidth), e.strokeText(d, i, s, n.maxWidth)), e.fillText(d, i, s, n.maxWidth), rL(e, i, s, d, n), s += Number(o.lineHeight);
  e.restore();
}
function fl(e, t) {
  const { x: i, y: s, w: o, h: n, radius: r } = t;
  e.arc(i + r.topLeft, s + r.topLeft, r.topLeft, 1.5 * Pe, Pe, !0), e.lineTo(i, s + n - r.bottomLeft), e.arc(i + r.bottomLeft, s + n - r.bottomLeft, r.bottomLeft, Pe, ct, !0), e.lineTo(i + o - r.bottomRight, s + n), e.arc(i + o - r.bottomRight, s + n - r.bottomRight, r.bottomRight, ct, 0, !0), e.lineTo(i + o, s + r.topRight), e.arc(i + o - r.topRight, s + r.topRight, r.topRight, 0, -ct, !0), e.lineTo(i + r.topLeft, s);
}
const lL = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, dL = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function cL(e, t) {
  const i = ("" + e).match(lL);
  if (!i || i[1] === "normal")
    return t * 1.2;
  switch (e = +i[2], i[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const uL = (e) => +e || 0;
function If(e, t) {
  const i = {}, s = ee(t), o = s ? Object.keys(t) : t, n = ee(e) ? s ? (r) => Y(e[r], e[t[r]]) : (r) => e[r] : () => e;
  for (const r of o)
    i[r] = uL(n(r));
  return i;
}
function hL(e) {
  return If(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function po(e) {
  return If(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function ot(e) {
  const t = hL(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function _e(e, t) {
  e = e || {}, t = t || Se.font;
  let i = Y(e.size, t.size);
  typeof i == "string" && (i = parseInt(i, 10));
  let s = Y(e.style, t.style);
  s && !("" + s).match(dL) && (console.warn('Invalid font style specified: "' + s + '"'), s = void 0);
  const o = {
    family: Y(e.family, t.family),
    lineHeight: cL(Y(e.lineHeight, t.lineHeight), i),
    size: i,
    style: s,
    weight: Y(e.weight, t.weight),
    string: ""
  };
  return o.string = iL(o), o;
}
function gn(e, t, i, s) {
  let o, n, r;
  for (o = 0, n = e.length; o < n; ++o)
    if (r = e[o], r !== void 0 && r !== void 0)
      return r;
}
function gL(e, t, i) {
  const { min: s, max: o } = e, n = Rk(t, (o - s) / 2), r = (a, l) => i && a === 0 ? 0 : a + l;
  return {
    min: r(s, -Math.abs(n)),
    max: r(o, n)
  };
}
function $i(e, t) {
  return Object.assign(Object.create(e), t);
}
function yd(e, t = [
  ""
], i, s, o = () => e[0]) {
  const n = i || e;
  typeof s > "u" && (s = _f("_fallback", e));
  const r = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: n,
    _fallback: s,
    _getTarget: o,
    override: (a) => yd([
      a,
      ...e
    ], t, n, s)
  };
  return new Proxy(r, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, l) {
      return delete a[l], delete a._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, l) {
      return Lf(a, l, () => yL(l, t, e, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, l) {
      return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(a, l) {
      return Su(a).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(a) {
      return Su(a);
    },
    /**
    * A trap for setting property values.
    */
    set(a, l, d) {
      const c = a._storage || (a._storage = o());
      return a[l] = c[l] = d, delete a._keys, !0;
    }
  });
}
function Fs(e, t, i, s) {
  const o = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: i,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: kf(e, s),
    setContext: (n) => Fs(e, n, i, s),
    override: (n) => Fs(e.override(n), t, i, s)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(n, r) {
      return delete n[r], delete e[r], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(n, r, a) {
      return Lf(n, r, () => fL(n, r, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(n, r) {
      return n._descriptors.allKeys ? Reflect.has(e, r) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, r);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(n, r) {
      return Reflect.has(e, r);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(n, r, a) {
      return e[r] = a, delete n[r], !0;
    }
  });
}
function kf(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: i = t.scriptable, _indexable: s = t.indexable, _allKeys: o = t.allKeys } = e;
  return {
    allKeys: o,
    scriptable: i,
    indexable: s,
    isScriptable: li(i) ? i : () => i,
    isIndexable: li(s) ? s : () => s
  };
}
const pL = (e, t) => e ? e + fd(t) : t, Sd = (e, t) => ee(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function Lf(e, t, i) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
    return e[t];
  const s = i();
  return e[t] = s, s;
}
function fL(e, t, i) {
  const { _proxy: s, _context: o, _subProxy: n, _descriptors: r } = e;
  let a = s[t];
  return li(a) && r.isScriptable(t) && (a = mL(t, a, e, i)), Fe(a) && a.length && (a = CL(t, a, e, r.isIndexable)), Sd(t, a) && (a = Fs(a, o, n && n[t], r)), a;
}
function mL(e, t, i, s) {
  const { _proxy: o, _context: n, _subProxy: r, _stack: a } = i;
  if (a.has(e))
    throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + e);
  a.add(e);
  let l = t(n, r || s);
  return a.delete(e), Sd(e, l) && (l = Rd(o._scopes, o, e, l)), l;
}
function CL(e, t, i, s) {
  const { _proxy: o, _context: n, _subProxy: r, _descriptors: a } = i;
  if (typeof n.index < "u" && s(e))
    return t[n.index % t.length];
  if (ee(t[0])) {
    const l = t, d = o._scopes.filter((c) => c !== l);
    t = [];
    for (const c of l) {
      const u = Rd(d, o, e, c);
      t.push(Fs(u, n, r && r[e], a));
    }
  }
  return t;
}
function Of(e, t, i) {
  return li(e) ? e(t, i) : e;
}
const vL = (e, t) => e === !0 ? t : typeof e == "string" ? ur(t, e) : void 0;
function wL(e, t, i, s, o) {
  for (const n of t) {
    const r = vL(i, n);
    if (r) {
      e.add(r);
      const a = Of(r._fallback, i, o);
      if (typeof a < "u" && a !== i && a !== s)
        return a;
    } else if (r === !1 && typeof s < "u" && i !== s)
      return null;
  }
  return !1;
}
function Rd(e, t, i, s) {
  const o = t._rootScopes, n = Of(t._fallback, i, s), r = [
    ...e,
    ...o
  ], a = /* @__PURE__ */ new Set();
  a.add(s);
  let l = yu(a, r, i, n || i, s);
  return l === null || typeof n < "u" && n !== i && (l = yu(a, r, n, l, s), l === null) ? !1 : yd(Array.from(a), [
    ""
  ], o, n, () => bL(t, i, s));
}
function yu(e, t, i, s, o) {
  for (; i; )
    i = wL(e, t, i, s, o);
  return i;
}
function bL(e, t, i) {
  const s = e._getTarget();
  t in s || (s[t] = {});
  const o = s[t];
  return Fe(o) && ee(i) ? i : o || {};
}
function yL(e, t, i, s) {
  let o;
  for (const n of t)
    if (o = _f(pL(n, e), i), typeof o < "u")
      return Sd(e, o) ? Rd(i, s, e, o) : o;
}
function _f(e, t) {
  for (const i of t) {
    if (!i)
      continue;
    const s = i[e];
    if (typeof s < "u")
      return s;
  }
}
function Su(e) {
  let t = e._keys;
  return t || (t = e._keys = SL(e._scopes)), t;
}
function SL(e) {
  const t = /* @__PURE__ */ new Set();
  for (const i of e)
    for (const s of Object.keys(i).filter((o) => !o.startsWith("_")))
      t.add(s);
  return Array.from(t);
}
const RL = Number.EPSILON || 1e-14, Ps = (e, t) => t < e.length && !e[t].skip && e[t], Hf = (e) => e === "x" ? "y" : "x";
function xL(e, t, i, s) {
  const o = e.skip ? t : e, n = t, r = i.skip ? t : i, a = hl(n, o), l = hl(r, n);
  let d = a / (a + l), c = l / (a + l);
  d = isNaN(d) ? 0 : d, c = isNaN(c) ? 0 : c;
  const u = s * d, h = s * c;
  return {
    previous: {
      x: n.x - u * (r.x - o.x),
      y: n.y - u * (r.y - o.y)
    },
    next: {
      x: n.x + h * (r.x - o.x),
      y: n.y + h * (r.y - o.y)
    }
  };
}
function FL(e, t, i) {
  const s = e.length;
  let o, n, r, a, l, d = Ps(e, 0);
  for (let c = 0; c < s - 1; ++c)
    if (l = d, d = Ps(e, c + 1), !(!l || !d)) {
      if (uo(t[c], 0, RL)) {
        i[c] = i[c + 1] = 0;
        continue;
      }
      o = i[c] / t[c], n = i[c + 1] / t[c], a = Math.pow(o, 2) + Math.pow(n, 2), !(a <= 9) && (r = 3 / Math.sqrt(a), i[c] = o * r * t[c], i[c + 1] = n * r * t[c]);
    }
}
function PL(e, t, i = "x") {
  const s = Hf(i), o = e.length;
  let n, r, a, l = Ps(e, 0);
  for (let d = 0; d < o; ++d) {
    if (r = a, a = l, l = Ps(e, d + 1), !a)
      continue;
    const c = a[i], u = a[s];
    r && (n = (c - r[i]) / 3, a[`cp1${i}`] = c - n, a[`cp1${s}`] = u - n * t[d]), l && (n = (l[i] - c) / 3, a[`cp2${i}`] = c + n, a[`cp2${s}`] = u + n * t[d]);
  }
}
function EL(e, t = "x") {
  const i = Hf(t), s = e.length, o = Array(s).fill(0), n = Array(s);
  let r, a, l, d = Ps(e, 0);
  for (r = 0; r < s; ++r)
    if (a = l, l = d, d = Ps(e, r + 1), !!l) {
      if (d) {
        const c = d[t] - l[t];
        o[r] = c !== 0 ? (d[i] - l[i]) / c : 0;
      }
      n[r] = a ? d ? xs(o[r - 1]) !== xs(o[r]) ? 0 : (o[r - 1] + o[r]) / 2 : o[r - 1] : o[r];
    }
  FL(e, o, n), PL(e, n, t);
}
function pn(e, t, i) {
  return Math.max(Math.min(e, i), t);
}
function DL(e, t) {
  let i, s, o, n, r, a = Oo(e[0], t);
  for (i = 0, s = e.length; i < s; ++i)
    r = n, n = a, a = i < s - 1 && Oo(e[i + 1], t), n && (o = e[i], r && (o.cp1x = pn(o.cp1x, t.left, t.right), o.cp1y = pn(o.cp1y, t.top, t.bottom)), a && (o.cp2x = pn(o.cp2x, t.left, t.right), o.cp2y = pn(o.cp2y, t.top, t.bottom)));
}
function TL(e, t, i, s, o) {
  let n, r, a, l;
  if (t.spanGaps && (e = e.filter((d) => !d.skip)), t.cubicInterpolationMode === "monotone")
    EL(e, o);
  else {
    let d = s ? e[e.length - 1] : e[0];
    for (n = 0, r = e.length; n < r; ++n)
      a = e[n], l = xL(d, a, e[Math.min(n + 1, r - (s ? 0 : 1)) % r], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, d = a;
  }
  t.capBezierPoints && DL(e, i);
}
function xd() {
  return typeof window < "u" && typeof document < "u";
}
function Fd(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function pr(e, t, i) {
  let s;
  return typeof e == "string" ? (s = parseInt(e, 10), e.indexOf("%") !== -1 && (s = s / 100 * t.parentNode[i])) : s = e, s;
}
const Tr = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function ML(e, t) {
  return Tr(e).getPropertyValue(t);
}
const AL = [
  "top",
  "right",
  "bottom",
  "left"
];
function ki(e, t, i) {
  const s = {};
  i = i ? "-" + i : "";
  for (let o = 0; o < 4; o++) {
    const n = AL[o];
    s[n] = parseFloat(e[t + "-" + n + i]) || 0;
  }
  return s.width = s.left + s.right, s.height = s.top + s.bottom, s;
}
const IL = (e, t, i) => (e > 0 || t > 0) && (!i || !i.shadowRoot);
function kL(e, t) {
  const i = e.touches, s = i && i.length ? i[0] : e, { offsetX: o, offsetY: n } = s;
  let r = !1, a, l;
  if (IL(o, n, e.target))
    a = o, l = n;
  else {
    const d = t.getBoundingClientRect();
    a = s.clientX - d.left, l = s.clientY - d.top, r = !0;
  }
  return {
    x: a,
    y: l,
    box: r
  };
}
function yi(e, t) {
  if ("native" in e)
    return e;
  const { canvas: i, currentDevicePixelRatio: s } = t, o = Tr(i), n = o.boxSizing === "border-box", r = ki(o, "padding"), a = ki(o, "border", "width"), { x: l, y: d, box: c } = kL(e, i), u = r.left + (c && a.left), h = r.top + (c && a.top);
  let { width: g, height: p } = t;
  return n && (g -= r.width + a.width, p -= r.height + a.height), {
    x: Math.round((l - u) / g * i.width / s),
    y: Math.round((d - h) / p * i.height / s)
  };
}
function LL(e, t, i) {
  let s, o;
  if (t === void 0 || i === void 0) {
    const n = e && Fd(e);
    if (!n)
      t = e.clientWidth, i = e.clientHeight;
    else {
      const r = n.getBoundingClientRect(), a = Tr(n), l = ki(a, "border", "width"), d = ki(a, "padding");
      t = r.width - d.width - l.width, i = r.height - d.height - l.height, s = pr(a.maxWidth, n, "clientWidth"), o = pr(a.maxHeight, n, "clientHeight");
    }
  }
  return {
    width: t,
    height: i,
    maxWidth: s || gr,
    maxHeight: o || gr
  };
}
const fn = (e) => Math.round(e * 10) / 10;
function OL(e, t, i, s) {
  const o = Tr(e), n = ki(o, "margin"), r = pr(o.maxWidth, e, "clientWidth") || gr, a = pr(o.maxHeight, e, "clientHeight") || gr, l = LL(e, t, i);
  let { width: d, height: c } = l;
  if (o.boxSizing === "content-box") {
    const h = ki(o, "border", "width"), g = ki(o, "padding");
    d -= g.width + h.width, c -= g.height + h.height;
  }
  return d = Math.max(0, d - n.width), c = Math.max(0, s ? d / s : c - n.height), d = fn(Math.min(d, r, l.maxWidth)), c = fn(Math.min(c, a, l.maxHeight)), d && !c && (c = fn(d / 2)), (t !== void 0 || i !== void 0) && s && l.height && c > l.height && (c = l.height, d = fn(Math.floor(c * s))), {
    width: d,
    height: c
  };
}
function Ru(e, t, i) {
  const s = t || 1, o = Math.floor(e.height * s), n = Math.floor(e.width * s);
  e.height = Math.floor(e.height), e.width = Math.floor(e.width);
  const r = e.canvas;
  return r.style && (i || !r.style.height && !r.style.width) && (r.style.height = `${e.height}px`, r.style.width = `${e.width}px`), e.currentDevicePixelRatio !== s || r.height !== o || r.width !== n ? (e.currentDevicePixelRatio = s, r.height = o, r.width = n, e.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1;
}
const _L = function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    xd() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
}();
function xu(e, t) {
  const i = ML(e, t), s = i && i.match(/^(\d+)(\.\d+)?px$/);
  return s ? +s[1] : void 0;
}
function Si(e, t, i, s) {
  return {
    x: e.x + i * (t.x - e.x),
    y: e.y + i * (t.y - e.y)
  };
}
function HL(e, t, i, s) {
  return {
    x: e.x + i * (t.x - e.x),
    y: s === "middle" ? i < 0.5 ? e.y : t.y : s === "after" ? i < 1 ? e.y : t.y : i > 0 ? t.y : e.y
  };
}
function BL(e, t, i, s) {
  const o = {
    x: e.cp2x,
    y: e.cp2y
  }, n = {
    x: t.cp1x,
    y: t.cp1y
  }, r = Si(e, o, i), a = Si(o, n, i), l = Si(n, t, i), d = Si(r, a, i), c = Si(a, l, i);
  return Si(d, c, i);
}
const GL = function(e, t) {
  return {
    x(i) {
      return e + e + t - i;
    },
    setWidth(i) {
      t = i;
    },
    textAlign(i) {
      return i === "center" ? i : i === "right" ? "left" : "right";
    },
    xPlus(i, s) {
      return i - s;
    },
    leftForLtr(i, s) {
      return i - s;
    }
  };
}, VL = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function Cs(e, t, i) {
  return e ? GL(t, i) : VL();
}
function Bf(e, t) {
  let i, s;
  (t === "ltr" || t === "rtl") && (i = e.canvas.style, s = [
    i.getPropertyValue("direction"),
    i.getPropertyPriority("direction")
  ], i.setProperty("direction", t, "important"), e.prevTextDirection = s);
}
function Gf(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
function Vf(e) {
  return e === "angle" ? {
    between: Ff,
    compare: Hk,
    normalize: Zt
  } : {
    between: Xs,
    compare: (t, i) => t - i,
    normalize: (t) => t
  };
}
function Fu({ start: e, end: t, count: i, loop: s, style: o }) {
  return {
    start: e % i,
    end: t % i,
    loop: s && (t - e + 1) % i === 0,
    style: o
  };
}
function NL(e, t, i) {
  const { property: s, start: o, end: n } = i, { between: r, normalize: a } = Vf(s), l = t.length;
  let { start: d, end: c, loop: u } = e, h, g;
  if (u) {
    for (d += l, c += l, h = 0, g = l; h < g && r(a(t[d % l][s]), o, n); ++h)
      d--, c--;
    d %= l, c %= l;
  }
  return c < d && (c += l), {
    start: d,
    end: c,
    loop: u,
    style: e.style
  };
}
function WL(e, t, i) {
  if (!i)
    return [
      e
    ];
  const { property: s, start: o, end: n } = i, r = t.length, { compare: a, between: l, normalize: d } = Vf(s), { start: c, end: u, loop: h, style: g } = NL(e, t, i), p = [];
  let f = !1, m = null, C, v, R;
  const b = () => l(o, R, C) && a(o, R) !== 0, w = () => a(n, C) === 0 || l(n, R, C), x = () => f || b(), F = () => !f || w();
  for (let D = c, T = c; D <= u; ++D)
    v = t[D % r], !v.skip && (C = d(v[s]), C !== R && (f = l(C, o, n), m === null && x() && (m = a(C, o) === 0 ? D : T), m !== null && F() && (p.push(Fu({
      start: m,
      end: D,
      loop: h,
      count: r,
      style: g
    })), m = null), T = D, R = C));
  return m !== null && p.push(Fu({
    start: m,
    end: u,
    loop: h,
    count: r,
    style: g
  })), p;
}
function zL(e, t) {
  const i = [], s = e.segments;
  for (let o = 0; o < s.length; o++) {
    const n = WL(s[o], e.points, t);
    n.length && i.push(...n);
  }
  return i;
}
function UL(e, t, i, s) {
  let o = 0, n = t - 1;
  if (i && !s)
    for (; o < t && !e[o].skip; )
      o++;
  for (; o < t && e[o].skip; )
    o++;
  for (o %= t, i && (n += o); n > o && e[n % t].skip; )
    n--;
  return n %= t, {
    start: o,
    end: n
  };
}
function $L(e, t, i, s) {
  const o = e.length, n = [];
  let r = t, a = e[t], l;
  for (l = t + 1; l <= i; ++l) {
    const d = e[l % o];
    d.skip || d.stop ? a.skip || (s = !1, n.push({
      start: t % o,
      end: (l - 1) % o,
      loop: s
    }), t = r = d.stop ? l : null) : (r = l, a.skip && (t = l)), a = d;
  }
  return r !== null && n.push({
    start: t % o,
    end: r % o,
    loop: s
  }), n;
}
function KL(e, t) {
  const i = e.points, s = e.options.spanGaps, o = i.length;
  if (!o)
    return [];
  const n = !!e._loop, { start: r, end: a } = UL(i, o, n, s);
  if (s === !0)
    return Pu(e, [
      {
        start: r,
        end: a,
        loop: n
      }
    ], i, t);
  const l = a < r ? a + o : a, d = !!e._fullLoop && r === 0 && a === o - 1;
  return Pu(e, $L(i, r, l, d), i, t);
}
function Pu(e, t, i, s) {
  return !s || !s.setContext || !i ? t : jL(e, t, i, s);
}
function jL(e, t, i, s) {
  const o = e._chart.getContext(), n = Eu(e.options), { _datasetIndex: r, options: { spanGaps: a } } = e, l = i.length, d = [];
  let c = n, u = t[0].start, h = u;
  function g(p, f, m, C) {
    const v = a ? -1 : 1;
    if (p !== f) {
      for (p += l; i[p % l].skip; )
        p -= v;
      for (; i[f % l].skip; )
        f += v;
      p % l !== f % l && (d.push({
        start: p % l,
        end: f % l,
        loop: m,
        style: C
      }), c = C, u = f % l);
    }
  }
  for (const p of t) {
    u = a ? u : p.start;
    let f = i[u % l], m;
    for (h = u + 1; h <= p.end; h++) {
      const C = i[h % l];
      m = Eu(s.setContext($i(o, {
        type: "segment",
        p0: f,
        p1: C,
        p0DataIndex: (h - 1) % l,
        p1DataIndex: h % l,
        datasetIndex: r
      }))), qL(m, c) && g(u, h - 1, p.loop, c), f = C, c = m;
    }
    u < h - 1 && g(u, h - 1, p.loop, c);
  }
  return d;
}
function Eu(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function qL(e, t) {
  if (!t)
    return !1;
  const i = [], s = function(o, n) {
    return vd(n) ? (i.includes(n) || i.push(n), i.indexOf(n)) : n;
  };
  return JSON.stringify(e, s) !== JSON.stringify(t, s);
}
function mn(e, t, i) {
  return e.options.clip ? e[i] : t[i];
}
function YL(e, t) {
  const { xScale: i, yScale: s } = e;
  return i && s ? {
    left: mn(i, t, "left"),
    right: mn(i, t, "right"),
    top: mn(s, t, "top"),
    bottom: mn(s, t, "bottom")
  } : t;
}
function QL(e, t) {
  const i = t._clip;
  if (i.disabled)
    return !1;
  const s = YL(t, e.chartArea);
  return {
    left: i.left === !1 ? 0 : s.left - (i.left === !0 ? 0 : i.left),
    right: i.right === !1 ? e.width : s.right + (i.right === !0 ? 0 : i.right),
    top: i.top === !1 ? 0 : s.top - (i.top === !0 ? 0 : i.top),
    bottom: i.bottom === !1 ? e.height : s.bottom + (i.bottom === !0 ? 0 : i.bottom)
  };
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */
class XL {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, i, s, o) {
    const n = i.listeners[o], r = i.duration;
    n.forEach((a) => a({
      chart: t,
      initial: i.initial,
      numSteps: r,
      currentStep: Math.min(s - i.start, r)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Ef.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let i = 0;
    this._charts.forEach((s, o) => {
      if (!s.running || !s.items.length)
        return;
      const n = s.items;
      let r = n.length - 1, a = !1, l;
      for (; r >= 0; --r)
        l = n[r], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(t), a = !0) : (n[r] = n[n.length - 1], n.pop());
      a && (o.draw(), this._notify(o, s, t, "progress")), n.length || (s.running = !1, this._notify(o, s, t, "complete"), s.initial = !1), i += n.length;
    }), this._lastDate = t, i === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const i = this._charts;
    let s = i.get(t);
    return s || (s = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, i.set(t, s)), s;
  }
  listen(t, i, s) {
    this._getAnims(t).listeners[i].push(s);
  }
  add(t, i) {
    !i || !i.length || this._getAnims(t).items.push(...i);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const i = this._charts.get(t);
    i && (i.running = !0, i.start = Date.now(), i.duration = i.items.reduce((s, o) => Math.max(s, o._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const i = this._charts.get(t);
    return !(!i || !i.running || !i.items.length);
  }
  stop(t) {
    const i = this._charts.get(t);
    if (!i || !i.items.length)
      return;
    const s = i.items;
    let o = s.length - 1;
    for (; o >= 0; --o)
      s[o].cancel();
    i.items = [], this._notify(t, i, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
}
var Lt = /* @__PURE__ */ new XL();
const Du = "transparent", ZL = {
  boolean(e, t, i) {
    return i > 0.5 ? t : e;
  },
  color(e, t, i) {
    const s = Cu(e || Du), o = s.valid && Cu(t || Du);
    return o && o.valid ? o.mix(s, i).hexString() : t;
  },
  number(e, t, i) {
    return e + (t - e) * i;
  }
};
class JL {
  constructor(t, i, s, o) {
    const n = i[s];
    o = gn([
      t.to,
      o,
      n,
      t.from
    ]);
    const r = gn([
      t.from,
      n,
      o
    ]);
    this._active = !0, this._fn = t.fn || ZL[t.type || typeof r], this._easing = ho[t.easing] || ho.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = i, this._prop = s, this._from = r, this._to = o, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, i, s) {
    if (this._active) {
      this._notify(!1);
      const o = this._target[this._prop], n = s - this._start, r = this._duration - n;
      this._start = s, this._duration = Math.floor(Math.max(r, t.duration)), this._total += n, this._loop = !!t.loop, this._to = gn([
        t.to,
        i,
        o,
        t.from
      ]), this._from = gn([
        t.from,
        o,
        i
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const i = t - this._start, s = this._duration, o = this._prop, n = this._from, r = this._loop, a = this._to;
    let l;
    if (this._active = n !== a && (r || i < s), !this._active) {
      this._target[o] = a, this._notify(!0);
      return;
    }
    if (i < 0) {
      this._target[o] = n;
      return;
    }
    l = i / s % 2, l = r && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[o] = this._fn(n, a, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((i, s) => {
      t.push({
        res: i,
        rej: s
      });
    });
  }
  _notify(t) {
    const i = t ? "res" : "rej", s = this._promises || [];
    for (let o = 0; o < s.length; o++)
      s[o][i]();
  }
}
class Nf {
  constructor(t, i) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(i);
  }
  configure(t) {
    if (!ee(t))
      return;
    const i = Object.keys(Se.animation), s = this._properties;
    Object.getOwnPropertyNames(t).forEach((o) => {
      const n = t[o];
      if (!ee(n))
        return;
      const r = {};
      for (const a of i)
        r[a] = n[a];
      (Fe(n.properties) && n.properties || [
        o
      ]).forEach((a) => {
        (a === o || !s.has(a)) && s.set(a, r);
      });
    });
  }
  _animateOptions(t, i) {
    const s = i.options, o = tO(t, s);
    if (!o)
      return [];
    const n = this._createAnimations(o, s);
    return s.$shared && eO(t.options.$animations, s).then(() => {
      t.options = s;
    }, () => {
    }), n;
  }
  _createAnimations(t, i) {
    const s = this._properties, o = [], n = t.$animations || (t.$animations = {}), r = Object.keys(i), a = Date.now();
    let l;
    for (l = r.length - 1; l >= 0; --l) {
      const d = r[l];
      if (d.charAt(0) === "$")
        continue;
      if (d === "options") {
        o.push(...this._animateOptions(t, i));
        continue;
      }
      const c = i[d];
      let u = n[d];
      const h = s.get(d);
      if (u)
        if (h && u.active()) {
          u.update(h, c, a);
          continue;
        } else
          u.cancel();
      if (!h || !h.duration) {
        t[d] = c;
        continue;
      }
      n[d] = u = new JL(h, t, d, c), o.push(u);
    }
    return o;
  }
  update(t, i) {
    if (this._properties.size === 0) {
      Object.assign(t, i);
      return;
    }
    const s = this._createAnimations(t, i);
    if (s.length)
      return Lt.add(this._chart, s), !0;
  }
}
function eO(e, t) {
  const i = [], s = Object.keys(t);
  for (let o = 0; o < s.length; o++) {
    const n = e[s[o]];
    n && n.active() && i.push(n.wait());
  }
  return Promise.all(i);
}
function tO(e, t) {
  if (!t)
    return;
  let i = e.options;
  if (!i) {
    e.options = t;
    return;
  }
  return i.$shared && (e.options = i = Object.assign({}, i, {
    $shared: !1,
    $animations: {}
  })), i;
}
function Tu(e, t) {
  const i = e && e.options || {}, s = i.reverse, o = i.min === void 0 ? t : 0, n = i.max === void 0 ? t : 0;
  return {
    start: s ? n : o,
    end: s ? o : n
  };
}
function iO(e, t, i) {
  if (i === !1)
    return !1;
  const s = Tu(e, i), o = Tu(t, i);
  return {
    top: o.end,
    right: s.end,
    bottom: o.start,
    left: s.start
  };
}
function sO(e) {
  let t, i, s, o;
  return ee(e) ? (t = e.top, i = e.right, s = e.bottom, o = e.left) : t = i = s = o = e, {
    top: t,
    right: i,
    bottom: s,
    left: o,
    disabled: e === !1
  };
}
function Wf(e, t) {
  const i = [], s = e._getSortedDatasetMetas(t);
  let o, n;
  for (o = 0, n = s.length; o < n; ++o)
    i.push(s[o].index);
  return i;
}
function Mu(e, t, i, s = {}) {
  const o = e.keys, n = s.mode === "single";
  let r, a, l, d;
  if (t === null)
    return;
  let c = !1;
  for (r = 0, a = o.length; r < a; ++r) {
    if (l = +o[r], l === i) {
      if (c = !0, s.all)
        continue;
      break;
    }
    d = e.values[l], st(d) && (n || t === 0 || xs(t) === xs(d)) && (t += d);
  }
  return !c && !s.all ? 0 : t;
}
function oO(e, t) {
  const { iScale: i, vScale: s } = t, o = i.axis === "x" ? "x" : "y", n = s.axis === "x" ? "x" : "y", r = Object.keys(e), a = new Array(r.length);
  let l, d, c;
  for (l = 0, d = r.length; l < d; ++l)
    c = r[l], a[l] = {
      [o]: c,
      [n]: e[c]
    };
  return a;
}
function ya(e, t) {
  const i = e && e.options.stacked;
  return i || i === void 0 && t.stack !== void 0;
}
function nO(e, t, i) {
  return `${e.id}.${t.id}.${i.stack || i.type}`;
}
function rO(e) {
  const { min: t, max: i, minDefined: s, maxDefined: o } = e.getUserBounds();
  return {
    min: s ? t : Number.NEGATIVE_INFINITY,
    max: o ? i : Number.POSITIVE_INFINITY
  };
}
function aO(e, t, i) {
  const s = e[t] || (e[t] = {});
  return s[i] || (s[i] = {});
}
function Au(e, t, i, s) {
  for (const o of t.getMatchingVisibleMetas(s).reverse()) {
    const n = e[o.index];
    if (i && n > 0 || !i && n < 0)
      return o.index;
  }
  return null;
}
function Iu(e, t) {
  const { chart: i, _cachedMeta: s } = e, o = i._stacks || (i._stacks = {}), { iScale: n, vScale: r, index: a } = s, l = n.axis, d = r.axis, c = nO(n, r, s), u = t.length;
  let h;
  for (let g = 0; g < u; ++g) {
    const p = t[g], { [l]: f, [d]: m } = p, C = p._stacks || (p._stacks = {});
    h = C[d] = aO(o, c, f), h[a] = m, h._top = Au(h, r, !0, s.type), h._bottom = Au(h, r, !1, s.type);
    const v = h._visualValues || (h._visualValues = {});
    v[a] = m;
  }
}
function Sa(e, t) {
  const i = e.scales;
  return Object.keys(i).filter((s) => i[s].axis === t).shift();
}
function lO(e, t) {
  return $i(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function dO(e, t, i) {
  return $i(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: i,
    index: t,
    mode: "default",
    type: "data"
  });
}
function zs(e, t) {
  const i = e.controller.index, s = e.vScale && e.vScale.axis;
  if (s) {
    t = t || e._parsed;
    for (const o of t) {
      const n = o._stacks;
      if (!n || n[s] === void 0 || n[s][i] === void 0)
        return;
      delete n[s][i], n[s]._visualValues !== void 0 && n[s]._visualValues[i] !== void 0 && delete n[s]._visualValues[i];
    }
  }
}
const Ra = (e) => e === "reset" || e === "none", ku = (e, t) => t ? e : Object.assign({}, e), cO = (e, t, i) => e && !t.hidden && t._stacked && {
  keys: Wf(i, !0),
  values: null
};
class fo {
  constructor(t, i) {
    this.chart = t, this._ctx = t.ctx, this.index = i, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = ya(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && zs(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, i = this._cachedMeta, s = this.getDataset(), o = (u, h, g, p) => u === "x" ? h : u === "r" ? p : g, n = i.xAxisID = Y(s.xAxisID, Sa(t, "x")), r = i.yAxisID = Y(s.yAxisID, Sa(t, "y")), a = i.rAxisID = Y(s.rAxisID, Sa(t, "r")), l = i.indexAxis, d = i.iAxisID = o(l, n, r, a), c = i.vAxisID = o(l, r, n, a);
    i.xScale = this.getScaleForId(n), i.yScale = this.getScaleForId(r), i.rScale = this.getScaleForId(a), i.iScale = this.getScaleForId(d), i.vScale = this.getScaleForId(c);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const i = this._cachedMeta;
    return t === i.iScale ? i.vScale : i.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && pu(this._data, this), t._stacked && zs(t);
  }
  _dataCheck() {
    const t = this.getDataset(), i = t.data || (t.data = []), s = this._data;
    if (ee(i)) {
      const o = this._cachedMeta;
      this._data = oO(i, o);
    } else if (s !== i) {
      if (s) {
        pu(s, this);
        const o = this._cachedMeta;
        zs(o), o._parsed = [];
      }
      i && Object.isExtensible(i) && Nk(i, this), this._syncList = [], this._data = i;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const i = this._cachedMeta, s = this.getDataset();
    let o = !1;
    this._dataCheck();
    const n = i._stacked;
    i._stacked = ya(i.vScale, i), i.stack !== s.stack && (o = !0, zs(i), i.stack = s.stack), this._resyncElements(t), (o || n !== i._stacked) && (Iu(this, i._parsed), i._stacked = ya(i.vScale, i));
  }
  configure() {
    const t = this.chart.config, i = t.datasetScopeKeys(this._type), s = t.getOptionScopes(this.getDataset(), i, !0);
    this.options = t.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, i) {
    const { _cachedMeta: s, _data: o } = this, { iScale: n, _stacked: r } = s, a = n.axis;
    let l = t === 0 && i === o.length ? !0 : s._sorted, d = t > 0 && s._parsed[t - 1], c, u, h;
    if (this._parsing === !1)
      s._parsed = o, s._sorted = !0, h = o;
    else {
      Fe(o[t]) ? h = this.parseArrayData(s, o, t, i) : ee(o[t]) ? h = this.parseObjectData(s, o, t, i) : h = this.parsePrimitiveData(s, o, t, i);
      const g = () => u[a] === null || d && u[a] < d[a];
      for (c = 0; c < i; ++c)
        s._parsed[c + t] = u = h[c], l && (g() && (l = !1), d = u);
      s._sorted = l;
    }
    r && Iu(this, h);
  }
  parsePrimitiveData(t, i, s, o) {
    const { iScale: n, vScale: r } = t, a = n.axis, l = r.axis, d = n.getLabels(), c = n === r, u = new Array(o);
    let h, g, p;
    for (h = 0, g = o; h < g; ++h)
      p = h + s, u[h] = {
        [a]: c || n.parse(d[p], p),
        [l]: r.parse(i[p], p)
      };
    return u;
  }
  parseArrayData(t, i, s, o) {
    const { xScale: n, yScale: r } = t, a = new Array(o);
    let l, d, c, u;
    for (l = 0, d = o; l < d; ++l)
      c = l + s, u = i[c], a[l] = {
        x: n.parse(u[0], c),
        y: r.parse(u[1], c)
      };
    return a;
  }
  parseObjectData(t, i, s, o) {
    const { xScale: n, yScale: r } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, d = new Array(o);
    let c, u, h, g;
    for (c = 0, u = o; c < u; ++c)
      h = c + s, g = i[h], d[c] = {
        x: n.parse(ur(g, a), h),
        y: r.parse(ur(g, l), h)
      };
    return d;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, i, s) {
    const o = this.chart, n = this._cachedMeta, r = i[t.axis], a = {
      keys: Wf(o, !0),
      values: i._stacks[t.axis]._visualValues
    };
    return Mu(a, r, n.index, {
      mode: s
    });
  }
  updateRangeFromParsed(t, i, s, o) {
    const n = s[i.axis];
    let r = n === null ? NaN : n;
    const a = o && s._stacks[i.axis];
    o && a && (o.values = a, r = Mu(o, n, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r);
  }
  getMinMax(t, i) {
    const s = this._cachedMeta, o = s._parsed, n = s._sorted && t === s.iScale, r = o.length, a = this._getOtherScale(t), l = cO(i, s, this.chart), d = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: c, max: u } = rO(a);
    let h, g;
    function p() {
      g = o[h];
      const f = g[a.axis];
      return !st(g[t.axis]) || c > f || u < f;
    }
    for (h = 0; h < r && !(!p() && (this.updateRangeFromParsed(d, t, g, l), n)); ++h)
      ;
    if (n) {
      for (h = r - 1; h >= 0; --h)
        if (!p()) {
          this.updateRangeFromParsed(d, t, g, l);
          break;
        }
    }
    return d;
  }
  getAllParsedValues(t) {
    const i = this._cachedMeta._parsed, s = [];
    let o, n, r;
    for (o = 0, n = i.length; o < n; ++o)
      r = i[o][t.axis], st(r) && s.push(r);
    return s;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, s = i.iScale, o = i.vScale, n = this.getParsed(t);
    return {
      label: s ? "" + s.getLabelForValue(n[s.axis]) : "",
      value: o ? "" + o.getLabelForValue(n[o.axis]) : ""
    };
  }
  _update(t) {
    const i = this._cachedMeta;
    this.update(t || "default"), i._clip = sO(Y(this.options.clip, iO(i.xScale, i.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, i = this.chart, s = this._cachedMeta, o = s.data || [], n = i.chartArea, r = [], a = this._drawStart || 0, l = this._drawCount || o.length - a, d = this.options.drawActiveElementsOnTop;
    let c;
    for (s.dataset && s.dataset.draw(t, n, a, l), c = a; c < a + l; ++c) {
      const u = o[c];
      u.hidden || (u.active && d ? r.push(u) : u.draw(t, n));
    }
    for (c = 0; c < r.length; ++c)
      r[c].draw(t, n);
  }
  getStyle(t, i) {
    const s = i ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s);
  }
  getContext(t, i, s) {
    const o = this.getDataset();
    let n;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const r = this._cachedMeta.data[t];
      n = r.$context || (r.$context = dO(this.getContext(), t, r)), n.parsed = this.getParsed(t), n.raw = o.data[t], n.index = n.dataIndex = t;
    } else
      n = this.$context || (this.$context = lO(this.chart.getContext(), this.index)), n.dataset = o, n.index = n.datasetIndex = this.index;
    return n.active = !!i, n.mode = s, n;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, i) {
    return this._resolveElementOptions(this.dataElementType.id, i, t);
  }
  _resolveElementOptions(t, i = "default", s) {
    const o = i === "active", n = this._cachedDataOpts, r = t + "-" + i, a = n[r], l = this.enableOptionSharing && hr(s);
    if (a)
      return ku(a, l);
    const d = this.chart.config, c = d.datasetElementScopeKeys(this._type, t), u = o ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], h = d.getOptionScopes(this.getDataset(), c), g = Object.keys(Se.elements[t]), p = () => this.getContext(s, o, i), f = d.resolveNamedOptions(h, g, p, u);
    return f.$shared && (f.$shared = l, n[r] = Object.freeze(ku(f, l))), f;
  }
  _resolveAnimations(t, i, s) {
    const o = this.chart, n = this._cachedDataOpts, r = `animation-${i}`, a = n[r];
    if (a)
      return a;
    let l;
    if (o.options.animation !== !1) {
      const c = this.chart.config, u = c.datasetAnimationScopeKeys(this._type, i), h = c.getOptionScopes(this.getDataset(), u);
      l = c.createResolver(h, this.getContext(t, s, i));
    }
    const d = new Nf(o, l && l.animations);
    return l && l._cacheable && (n[r] = Object.freeze(d)), d;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, i) {
    return !i || Ra(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, i) {
    const s = this.resolveDataElementOptions(t, i), o = this._sharedOptions, n = this.getSharedOptions(s), r = this.includeOptions(i, n) || n !== o;
    return this.updateSharedOptions(n, i, s), {
      sharedOptions: n,
      includeOptions: r
    };
  }
  updateElement(t, i, s, o) {
    Ra(o) ? Object.assign(t, s) : this._resolveAnimations(i, o).update(t, s);
  }
  updateSharedOptions(t, i, s) {
    t && !Ra(i) && this._resolveAnimations(void 0, i).update(t, s);
  }
  _setStyle(t, i, s, o) {
    t.active = o;
    const n = this.getStyle(i, o);
    this._resolveAnimations(i, s, o).update(t, {
      options: !o && this.getSharedOptions(n) || n
    });
  }
  removeHoverStyle(t, i, s) {
    this._setStyle(t, s, "active", !1);
  }
  setHoverStyle(t, i, s) {
    this._setStyle(t, s, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const i = this._data, s = this._cachedMeta.data;
    for (const [a, l, d] of this._syncList)
      this[a](l, d);
    this._syncList = [];
    const o = s.length, n = i.length, r = Math.min(n, o);
    r && this.parse(0, r), n > o ? this._insertElements(o, n - o, t) : n < o && this._removeElements(n, o - n);
  }
  _insertElements(t, i, s = !0) {
    const o = this._cachedMeta, n = o.data, r = t + i;
    let a;
    const l = (d) => {
      for (d.length += i, a = d.length - 1; a >= r; a--)
        d[a] = d[a - i];
    };
    for (l(n), a = t; a < r; ++a)
      n[a] = new this.dataElementType();
    this._parsing && l(o._parsed), this.parse(t, i), s && this.updateElements(n, t, i, "reset");
  }
  updateElements(t, i, s, o) {
  }
  _removeElements(t, i) {
    const s = this._cachedMeta;
    if (this._parsing) {
      const o = s._parsed.splice(t, i);
      s._stacked && zs(s, o);
    }
    s.data.splice(t, i);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [i, s, o] = t;
      this[i](s, o);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, i) {
    i && this._sync([
      "_removeElements",
      t,
      i
    ]);
    const s = arguments.length - 2;
    s && this._sync([
      "_insertElements",
      t,
      s
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
K(fo, "defaults", {}), K(fo, "datasetElementType", null), K(fo, "dataElementType", null);
class Ln extends fo {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const i = this._cachedMeta, { dataset: s, data: o = [], _dataset: n } = i, r = this.chart._animationsDisabled;
    let { start: a, count: l } = $k(i, o, r);
    this._drawStart = a, this._drawCount = l, Kk(i) && (a = 0, l = o.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!n._decimated, s.points = o;
    const d = this.resolveDatasetElementOptions(t);
    this.options.showLine || (d.borderWidth = 0), d.segment = this.options.segment, this.updateElement(s, void 0, {
      animated: !r,
      options: d
    }, t), this.updateElements(o, a, l, t);
  }
  updateElements(t, i, s, o) {
    const n = o === "reset", { iScale: r, vScale: a, _stacked: l, _dataset: d } = this._cachedMeta, { sharedOptions: c, includeOptions: u } = this._getSharedOptions(i, o), h = r.axis, g = a.axis, { spanGaps: p, segment: f } = this.options, m = Lo(p) ? p : Number.POSITIVE_INFINITY, C = this.chart._animationsDisabled || n || o === "none", v = i + s, R = t.length;
    let b = i > 0 && this.getParsed(i - 1);
    for (let w = 0; w < R; ++w) {
      const x = t[w], F = C ? x : {};
      if (w < i || w >= v) {
        F.skip = !0;
        continue;
      }
      const D = this.getParsed(w), T = re(D[g]), k = F[h] = r.getPixelForValue(D[h], w), A = F[g] = n || T ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, D, l) : D[g], w);
      F.skip = isNaN(k) || isNaN(A) || T, F.stop = w > 0 && Math.abs(D[h] - b[h]) > m, f && (F.parsed = D, F.raw = d.data[w]), u && (F.options = c || this.resolveDataElementOptions(w, x.active ? "active" : o)), C || this.updateElement(x, w, F, o), b = D;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, i = t.dataset, s = i.options && i.options.borderWidth || 0, o = t.data || [];
    if (!o.length)
      return s;
    const n = o[0].size(this.resolveDataElementOptions(0)), r = o[o.length - 1].size(this.resolveDataElementOptions(o.length - 1));
    return Math.max(s, n, r) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
K(Ln, "id", "line"), K(Ln, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), K(Ln, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
function vi() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class Pd {
  constructor(t) {
    K(this, "options");
    this.options = t || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(Pd.prototype, t);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return vi();
  }
  parse() {
    return vi();
  }
  format() {
    return vi();
  }
  add() {
    return vi();
  }
  diff() {
    return vi();
  }
  startOf() {
    return vi();
  }
  endOf() {
    return vi();
  }
}
var uO = {
  _date: Pd
};
function hO(e, t, i, s) {
  const { controller: o, data: n, _sorted: r } = e, a = o._cachedMeta.iScale, l = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null;
  if (a && t === a.axis && t !== "r" && r && n.length) {
    const d = a._reversePixels ? Gk : Pi;
    if (s) {
      if (o._sharedOptions) {
        const c = n[0], u = typeof c.getRange == "function" && c.getRange(t);
        if (u) {
          const h = d(n, t, i - u), g = d(n, t, i + u);
          return {
            lo: h.lo,
            hi: g.hi
          };
        }
      }
    } else {
      const c = d(n, t, i);
      if (l) {
        const { vScale: u } = o._cachedMeta, { _parsed: h } = e, g = h.slice(0, c.lo + 1).reverse().findIndex((f) => !re(f[u.axis]));
        c.lo -= Math.max(0, g);
        const p = h.slice(c.hi).findIndex((f) => !re(f[u.axis]));
        c.hi += Math.max(0, p);
      }
      return c;
    }
  }
  return {
    lo: 0,
    hi: n.length - 1
  };
}
function Mr(e, t, i, s, o) {
  const n = e.getSortedVisibleDatasetMetas(), r = i[t];
  for (let a = 0, l = n.length; a < l; ++a) {
    const { index: d, data: c } = n[a], { lo: u, hi: h } = hO(n[a], t, r, o);
    for (let g = u; g <= h; ++g) {
      const p = c[g];
      p.skip || s(p, d, g);
    }
  }
}
function gO(e) {
  const t = e.indexOf("x") !== -1, i = e.indexOf("y") !== -1;
  return function(s, o) {
    const n = t ? Math.abs(s.x - o.x) : 0, r = i ? Math.abs(s.y - o.y) : 0;
    return Math.sqrt(Math.pow(n, 2) + Math.pow(r, 2));
  };
}
function xa(e, t, i, s, o) {
  const n = [];
  return !o && !e.isPointInArea(t) || Mr(e, i, t, function(a, l, d) {
    !o && !Oo(a, e.chartArea, 0) || a.inRange(t.x, t.y, s) && n.push({
      element: a,
      datasetIndex: l,
      index: d
    });
  }, !0), n;
}
function pO(e, t, i, s) {
  let o = [];
  function n(r, a, l) {
    const { startAngle: d, endAngle: c } = r.getProps([
      "startAngle",
      "endAngle"
    ], s), { angle: u } = _k(r, {
      x: t.x,
      y: t.y
    });
    Ff(u, d, c) && o.push({
      element: r,
      datasetIndex: a,
      index: l
    });
  }
  return Mr(e, i, t, n), o;
}
function fO(e, t, i, s, o, n) {
  let r = [];
  const a = gO(i);
  let l = Number.POSITIVE_INFINITY;
  function d(c, u, h) {
    const g = c.inRange(t.x, t.y, o);
    if (s && !g)
      return;
    const p = c.getCenterPoint(o);
    if (!(!!n || e.isPointInArea(p)) && !g)
      return;
    const m = a(t, p);
    m < l ? (r = [
      {
        element: c,
        datasetIndex: u,
        index: h
      }
    ], l = m) : m === l && r.push({
      element: c,
      datasetIndex: u,
      index: h
    });
  }
  return Mr(e, i, t, d), r;
}
function Fa(e, t, i, s, o, n) {
  return !n && !e.isPointInArea(t) ? [] : i === "r" && !s ? pO(e, t, i, o) : fO(e, t, i, s, o, n);
}
function Lu(e, t, i, s, o) {
  const n = [], r = i === "x" ? "inXRange" : "inYRange";
  let a = !1;
  return Mr(e, i, t, (l, d, c) => {
    l[r] && l[r](t[i], o) && (n.push({
      element: l,
      datasetIndex: d,
      index: c
    }), a = a || l.inRange(t.x, t.y, o));
  }), s && !a ? [] : n;
}
var mO = {
  modes: {
    index(e, t, i, s) {
      const o = yi(t, e), n = i.axis || "x", r = i.includeInvisible || !1, a = i.intersect ? xa(e, o, n, s, r) : Fa(e, o, n, !1, s, r), l = [];
      return a.length ? (e.getSortedVisibleDatasetMetas().forEach((d) => {
        const c = a[0].index, u = d.data[c];
        u && !u.skip && l.push({
          element: u,
          datasetIndex: d.index,
          index: c
        });
      }), l) : [];
    },
    dataset(e, t, i, s) {
      const o = yi(t, e), n = i.axis || "xy", r = i.includeInvisible || !1;
      let a = i.intersect ? xa(e, o, n, s, r) : Fa(e, o, n, !1, s, r);
      if (a.length > 0) {
        const l = a[0].datasetIndex, d = e.getDatasetMeta(l).data;
        a = [];
        for (let c = 0; c < d.length; ++c)
          a.push({
            element: d[c],
            datasetIndex: l,
            index: c
          });
      }
      return a;
    },
    point(e, t, i, s) {
      const o = yi(t, e), n = i.axis || "xy", r = i.includeInvisible || !1;
      return xa(e, o, n, s, r);
    },
    nearest(e, t, i, s) {
      const o = yi(t, e), n = i.axis || "xy", r = i.includeInvisible || !1;
      return Fa(e, o, n, i.intersect, s, r);
    },
    x(e, t, i, s) {
      const o = yi(t, e);
      return Lu(e, o, "x", i.intersect, s);
    },
    y(e, t, i, s) {
      const o = yi(t, e);
      return Lu(e, o, "y", i.intersect, s);
    }
  }
};
const zf = [
  "left",
  "top",
  "right",
  "bottom"
];
function Us(e, t) {
  return e.filter((i) => i.pos === t);
}
function Ou(e, t) {
  return e.filter((i) => zf.indexOf(i.pos) === -1 && i.box.axis === t);
}
function $s(e, t) {
  return e.sort((i, s) => {
    const o = t ? s : i, n = t ? i : s;
    return o.weight === n.weight ? o.index - n.index : o.weight - n.weight;
  });
}
function CO(e) {
  const t = [];
  let i, s, o, n, r, a;
  for (i = 0, s = (e || []).length; i < s; ++i)
    o = e[i], { position: n, options: { stack: r, stackWeight: a = 1 } } = o, t.push({
      index: i,
      box: o,
      pos: n,
      horizontal: o.isHorizontal(),
      weight: o.weight,
      stack: r && n + r,
      stackWeight: a
    });
  return t;
}
function vO(e) {
  const t = {};
  for (const i of e) {
    const { stack: s, pos: o, stackWeight: n } = i;
    if (!s || !zf.includes(o))
      continue;
    const r = t[s] || (t[s] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    r.count++, r.weight += n;
  }
  return t;
}
function wO(e, t) {
  const i = vO(e), { vBoxMaxWidth: s, hBoxMaxHeight: o } = t;
  let n, r, a;
  for (n = 0, r = e.length; n < r; ++n) {
    a = e[n];
    const { fullSize: l } = a.box, d = i[a.stack], c = d && a.stackWeight / d.weight;
    a.horizontal ? (a.width = c ? c * s : l && t.availableWidth, a.height = o) : (a.width = s, a.height = c ? c * o : l && t.availableHeight);
  }
  return i;
}
function bO(e) {
  const t = CO(e), i = $s(t.filter((d) => d.box.fullSize), !0), s = $s(Us(t, "left"), !0), o = $s(Us(t, "right")), n = $s(Us(t, "top"), !0), r = $s(Us(t, "bottom")), a = Ou(t, "x"), l = Ou(t, "y");
  return {
    fullSize: i,
    leftAndTop: s.concat(n),
    rightAndBottom: o.concat(l).concat(r).concat(a),
    chartArea: Us(t, "chartArea"),
    vertical: s.concat(o).concat(l),
    horizontal: n.concat(r).concat(a)
  };
}
function _u(e, t, i, s) {
  return Math.max(e[i], t[i]) + Math.max(e[s], t[s]);
}
function Uf(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function yO(e, t, i, s) {
  const { pos: o, box: n } = i, r = e.maxPadding;
  if (!ee(o)) {
    i.size && (e[o] -= i.size);
    const u = s[i.stack] || {
      size: 0,
      count: 1
    };
    u.size = Math.max(u.size, i.horizontal ? n.height : n.width), i.size = u.size / u.count, e[o] += i.size;
  }
  n.getPadding && Uf(r, n.getPadding());
  const a = Math.max(0, t.outerWidth - _u(r, e, "left", "right")), l = Math.max(0, t.outerHeight - _u(r, e, "top", "bottom")), d = a !== e.w, c = l !== e.h;
  return e.w = a, e.h = l, i.horizontal ? {
    same: d,
    other: c
  } : {
    same: c,
    other: d
  };
}
function SO(e) {
  const t = e.maxPadding;
  function i(s) {
    const o = Math.max(t[s] - e[s], 0);
    return e[s] += o, o;
  }
  e.y += i("top"), e.x += i("left"), i("right"), i("bottom");
}
function RO(e, t) {
  const i = t.maxPadding;
  function s(o) {
    const n = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return o.forEach((r) => {
      n[r] = Math.max(t[r], i[r]);
    }), n;
  }
  return s(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Zs(e, t, i, s) {
  const o = [];
  let n, r, a, l, d, c;
  for (n = 0, r = e.length, d = 0; n < r; ++n) {
    a = e[n], l = a.box, l.update(a.width || t.w, a.height || t.h, RO(a.horizontal, t));
    const { same: u, other: h } = yO(t, i, a, s);
    d |= u && o.length, c = c || h, l.fullSize || o.push(a);
  }
  return d && Zs(o, t, i, s) || c;
}
function Cn(e, t, i, s, o) {
  e.top = i, e.left = t, e.right = t + s, e.bottom = i + o, e.width = s, e.height = o;
}
function Hu(e, t, i, s) {
  const o = i.padding;
  let { x: n, y: r } = t;
  for (const a of e) {
    const l = a.box, d = s[a.stack] || {
      placed: 0,
      weight: 1
    }, c = a.stackWeight / d.weight || 1;
    if (a.horizontal) {
      const u = t.w * c, h = d.size || l.height;
      hr(d.start) && (r = d.start), l.fullSize ? Cn(l, o.left, r, i.outerWidth - o.right - o.left, h) : Cn(l, t.left + d.placed, r, u, h), d.start = r, d.placed += u, r = l.bottom;
    } else {
      const u = t.h * c, h = d.size || l.width;
      hr(d.start) && (n = d.start), l.fullSize ? Cn(l, n, o.top, h, i.outerHeight - o.bottom - o.top) : Cn(l, n, t.top + d.placed, h, u), d.start = n, d.placed += u, n = l.right;
    }
  }
  t.x = n, t.y = r;
}
var et = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(i) {
            t.draw(i);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const i = e.boxes ? e.boxes.indexOf(t) : -1;
    i !== -1 && e.boxes.splice(i, 1);
  },
  configure(e, t, i) {
    t.fullSize = i.fullSize, t.position = i.position, t.weight = i.weight;
  },
  update(e, t, i, s) {
    if (!e)
      return;
    const o = ot(e.options.layout.padding), n = Math.max(t - o.width, 0), r = Math.max(i - o.height, 0), a = bO(e.boxes), l = a.vertical, d = a.horizontal;
    ie(e.boxes, (f) => {
      typeof f.beforeLayout == "function" && f.beforeLayout();
    });
    const c = l.reduce((f, m) => m.box.options && m.box.options.display === !1 ? f : f + 1, 0) || 1, u = Object.freeze({
      outerWidth: t,
      outerHeight: i,
      padding: o,
      availableWidth: n,
      availableHeight: r,
      vBoxMaxWidth: n / 2 / c,
      hBoxMaxHeight: r / 2
    }), h = Object.assign({}, o);
    Uf(h, ot(s));
    const g = Object.assign({
      maxPadding: h,
      w: n,
      h: r,
      x: o.left,
      y: o.top
    }, o), p = wO(l.concat(d), u);
    Zs(a.fullSize, g, u, p), Zs(l, g, u, p), Zs(d, g, u, p) && Zs(l, g, u, p), SO(g), Hu(a.leftAndTop, g, u, p), g.x += g.w, g.y += g.h, Hu(a.rightAndBottom, g, u, p), e.chartArea = {
      left: g.left,
      top: g.top,
      right: g.left + g.w,
      bottom: g.top + g.h,
      height: g.h,
      width: g.w
    }, ie(a.chartArea, (f) => {
      const m = f.box;
      Object.assign(m, e.chartArea), m.update(g.w, g.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class $f {
  acquireContext(t, i) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, i, s) {
  }
  removeEventListener(t, i, s) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, i, s, o) {
    return i = Math.max(0, i || t.width), s = s || t.height, {
      width: i,
      height: Math.max(0, o ? Math.floor(i / o) : s)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class xO extends $f {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const On = "$chartjs", FO = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, Bu = (e) => e === null || e === "";
function PO(e, t) {
  const i = e.style, s = e.getAttribute("height"), o = e.getAttribute("width");
  if (e[On] = {
    initial: {
      height: s,
      width: o,
      style: {
        display: i.display,
        height: i.height,
        width: i.width
      }
    }
  }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", Bu(o)) {
    const n = xu(e, "width");
    n !== void 0 && (e.width = n);
  }
  if (Bu(s))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const n = xu(e, "height");
      n !== void 0 && (e.height = n);
    }
  return e;
}
const Kf = _L ? {
  passive: !0
} : !1;
function EO(e, t, i) {
  e && e.addEventListener(t, i, Kf);
}
function DO(e, t, i) {
  e && e.canvas && e.canvas.removeEventListener(t, i, Kf);
}
function TO(e, t) {
  const i = FO[e.type] || e.type, { x: s, y: o } = yi(e, t);
  return {
    type: i,
    chart: t,
    native: e,
    x: s !== void 0 ? s : null,
    y: o !== void 0 ? o : null
  };
}
function fr(e, t) {
  for (const i of e)
    if (i === t || i.contains(t))
      return !0;
}
function MO(e, t, i) {
  const s = e.canvas, o = new MutationObserver((n) => {
    let r = !1;
    for (const a of n)
      r = r || fr(a.addedNodes, s), r = r && !fr(a.removedNodes, s);
    r && i();
  });
  return o.observe(document, {
    childList: !0,
    subtree: !0
  }), o;
}
function AO(e, t, i) {
  const s = e.canvas, o = new MutationObserver((n) => {
    let r = !1;
    for (const a of n)
      r = r || fr(a.removedNodes, s), r = r && !fr(a.addedNodes, s);
    r && i();
  });
  return o.observe(document, {
    childList: !0,
    subtree: !0
  }), o;
}
const Ho = /* @__PURE__ */ new Map();
let Gu = 0;
function jf() {
  const e = window.devicePixelRatio;
  e !== Gu && (Gu = e, Ho.forEach((t, i) => {
    i.currentDevicePixelRatio !== e && t();
  }));
}
function IO(e, t) {
  Ho.size || window.addEventListener("resize", jf), Ho.set(e, t);
}
function kO(e) {
  Ho.delete(e), Ho.size || window.removeEventListener("resize", jf);
}
function LO(e, t, i) {
  const s = e.canvas, o = s && Fd(s);
  if (!o)
    return;
  const n = Df((a, l) => {
    const d = o.clientWidth;
    i(a, l), d < o.clientWidth && i();
  }, window), r = new ResizeObserver((a) => {
    const l = a[0], d = l.contentRect.width, c = l.contentRect.height;
    d === 0 && c === 0 || n(d, c);
  });
  return r.observe(o), IO(e, n), r;
}
function Pa(e, t, i) {
  i && i.disconnect(), t === "resize" && kO(e);
}
function OO(e, t, i) {
  const s = e.canvas, o = Df((n) => {
    e.ctx !== null && i(TO(n, e));
  }, e);
  return EO(s, t, o), o;
}
class _O extends $f {
  acquireContext(t, i) {
    const s = t && t.getContext && t.getContext("2d");
    return s && s.canvas === t ? (PO(t, i), s) : null;
  }
  releaseContext(t) {
    const i = t.canvas;
    if (!i[On])
      return !1;
    const s = i[On].initial;
    [
      "height",
      "width"
    ].forEach((n) => {
      const r = s[n];
      re(r) ? i.removeAttribute(n) : i.setAttribute(n, r);
    });
    const o = s.style || {};
    return Object.keys(o).forEach((n) => {
      i.style[n] = o[n];
    }), i.width = i.width, delete i[On], !0;
  }
  addEventListener(t, i, s) {
    this.removeEventListener(t, i);
    const o = t.$proxies || (t.$proxies = {}), r = {
      attach: MO,
      detach: AO,
      resize: LO
    }[i] || OO;
    o[i] = r(t, i, s);
  }
  removeEventListener(t, i) {
    const s = t.$proxies || (t.$proxies = {}), o = s[i];
    if (!o)
      return;
    ({
      attach: Pa,
      detach: Pa,
      resize: Pa
    }[i] || DO)(t, i, o), s[i] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, i, s, o) {
    return OL(t, i, s, o);
  }
  isAttached(t) {
    const i = t && Fd(t);
    return !!(i && i.isConnected);
  }
}
function HO(e) {
  return !xd() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? xO : _O;
}
var Rn;
let Ki = (Rn = class {
  constructor() {
    K(this, "x");
    K(this, "y");
    K(this, "active", !1);
    K(this, "options");
    K(this, "$animations");
  }
  tooltipPosition(t) {
    const { x: i, y: s } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: s
    };
  }
  hasValue() {
    return Lo(this.x) && Lo(this.y);
  }
  getProps(t, i) {
    const s = this.$animations;
    if (!i || !s)
      return this;
    const o = {};
    return t.forEach((n) => {
      o[n] = s[n] && s[n].active() ? s[n]._to : this[n];
    }), o;
  }
}, K(Rn, "defaults", {}), K(Rn, "defaultRoutes"), Rn);
function BO(e, t) {
  const i = e.options.ticks, s = GO(e), o = Math.min(i.maxTicksLimit || s, s), n = i.major.enabled ? NO(t) : [], r = n.length, a = n[0], l = n[r - 1], d = [];
  if (r > o)
    return WO(t, d, n, r / o), d;
  const c = VO(n, t, o);
  if (r > 0) {
    let u, h;
    const g = r > 1 ? Math.round((l - a) / (r - 1)) : null;
    for (vn(t, d, c, re(g) ? 0 : a - g, a), u = 0, h = r - 1; u < h; u++)
      vn(t, d, c, n[u], n[u + 1]);
    return vn(t, d, c, l, re(g) ? t.length : l + g), d;
  }
  return vn(t, d, c), d;
}
function GO(e) {
  const t = e.options.offset, i = e._tickSize(), s = e._length / i + (t ? 0 : 1), o = e._maxLength / i;
  return Math.floor(Math.min(s, o));
}
function VO(e, t, i) {
  const s = zO(e), o = t.length / i;
  if (!s)
    return Math.max(o, 1);
  const n = Ak(s);
  for (let r = 0, a = n.length - 1; r < a; r++) {
    const l = n[r];
    if (l > o)
      return l;
  }
  return Math.max(o, 1);
}
function NO(e) {
  const t = [];
  let i, s;
  for (i = 0, s = e.length; i < s; i++)
    e[i].major && t.push(i);
  return t;
}
function WO(e, t, i, s) {
  let o = 0, n = i[0], r;
  for (s = Math.ceil(s), r = 0; r < e.length; r++)
    r === n && (t.push(e[r]), o++, n = i[o * s]);
}
function vn(e, t, i, s, o) {
  const n = Y(s, 0), r = Math.min(Y(o, e.length), e.length);
  let a = 0, l, d, c;
  for (i = Math.ceil(i), o && (l = o - s, i = l / Math.floor(l / i)), c = n; c < 0; )
    a++, c = Math.round(n + a * i);
  for (d = Math.max(n, 0); d < r; d++)
    d === c && (t.push(e[d]), a++, c = Math.round(n + a * i));
}
function zO(e) {
  const t = e.length;
  let i, s;
  if (t < 2)
    return !1;
  for (s = e[0], i = 1; i < t; ++i)
    if (e[i] - e[i - 1] !== s)
      return !1;
  return s;
}
const UO = (e) => e === "left" ? "right" : e === "right" ? "left" : e, Vu = (e, t, i) => t === "top" || t === "left" ? e[t] + i : e[t] - i, Nu = (e, t) => Math.min(t || e, e);
function Wu(e, t) {
  const i = [], s = e.length / t, o = e.length;
  let n = 0;
  for (; n < o; n += s)
    i.push(e[Math.floor(n)]);
  return i;
}
function $O(e, t, i) {
  const s = e.ticks.length, o = Math.min(t, s - 1), n = e._startPixel, r = e._endPixel, a = 1e-6;
  let l = e.getPixelForTick(o), d;
  if (!(i && (s === 1 ? d = Math.max(l - n, r - l) : t === 0 ? d = (e.getPixelForTick(1) - l) / 2 : d = (l - e.getPixelForTick(o - 1)) / 2, l += o < t ? d : -d, l < n - a || l > r + a)))
    return l;
}
function KO(e, t) {
  ie(e, (i) => {
    const s = i.gc, o = s.length / 2;
    let n;
    if (o > t) {
      for (n = 0; n < o; ++n)
        delete i.data[s[n]];
      s.splice(0, o);
    }
  });
}
function Ks(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function zu(e, t) {
  if (!e.display)
    return 0;
  const i = _e(e.font, t), s = ot(e.padding);
  return (Fe(e.text) ? e.text.length : 1) * i.lineHeight + s.height;
}
function jO(e, t) {
  return $i(e, {
    scale: t,
    type: "scale"
  });
}
function qO(e, t, i) {
  return $i(e, {
    tick: i,
    index: t,
    type: "tick"
  });
}
function YO(e, t, i) {
  let s = Cd(e);
  return (i && t !== "right" || !i && t === "right") && (s = UO(s)), s;
}
function QO(e, t, i, s) {
  const { top: o, left: n, bottom: r, right: a, chart: l } = e, { chartArea: d, scales: c } = l;
  let u = 0, h, g, p;
  const f = r - o, m = a - n;
  if (e.isHorizontal()) {
    if (g = Le(s, n, a), ee(i)) {
      const C = Object.keys(i)[0], v = i[C];
      p = c[C].getPixelForValue(v) + f - t;
    } else i === "center" ? p = (d.bottom + d.top) / 2 + f - t : p = Vu(e, i, t);
    h = a - n;
  } else {
    if (ee(i)) {
      const C = Object.keys(i)[0], v = i[C];
      g = c[C].getPixelForValue(v) - m + t;
    } else i === "center" ? g = (d.left + d.right) / 2 - m + t : g = Vu(e, i, t);
    p = Le(s, r, o), u = i === "left" ? -ct : ct;
  }
  return {
    titleX: g,
    titleY: p,
    maxWidth: h,
    rotation: u
  };
}
class Ms extends Ki {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, i) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: i, _suggestedMin: s, _suggestedMax: o } = this;
    return t = vt(t, Number.POSITIVE_INFINITY), i = vt(i, Number.NEGATIVE_INFINITY), s = vt(s, Number.POSITIVE_INFINITY), o = vt(o, Number.NEGATIVE_INFINITY), {
      min: vt(t, s),
      max: vt(i, o),
      minDefined: st(t),
      maxDefined: st(i)
    };
  }
  getMinMax(t) {
    let { min: i, max: s, minDefined: o, maxDefined: n } = this.getUserBounds(), r;
    if (o && n)
      return {
        min: i,
        max: s
      };
    const a = this.getMatchingVisibleMetas();
    for (let l = 0, d = a.length; l < d; ++l)
      r = a[l].controller.getMinMax(this, t), o || (i = Math.min(i, r.min)), n || (s = Math.max(s, r.max));
    return i = n && i > s ? s : i, s = o && i > s ? i : s, {
      min: vt(i, vt(s, i)),
      max: vt(s, vt(i, s))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    ae(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, i, s) {
    const { beginAtZero: o, grace: n, ticks: r } = this.options, a = r.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = i, this._margins = s = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = gL(this, n, o), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = a < this.ticks.length;
    this._convertTicksToLabels(l ? Wu(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r.display && (r.autoSkip || r.source === "auto") && (this.ticks = BO(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, i, s;
    this.isHorizontal() ? (i = this.left, s = this.right) : (i = this.top, s = this.bottom, t = !t), this._startPixel = i, this._endPixel = s, this._reversePixels = t, this._length = s - i, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    ae(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    ae(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    ae(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), ae(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    ae(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const i = this.options.ticks;
    let s, o, n;
    for (s = 0, o = t.length; s < o; s++)
      n = t[s], n.label = ae(i.callback, [
        n.value,
        s,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    ae(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    ae(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, i = t.ticks, s = Nu(this.ticks.length, t.ticks.maxTicksLimit), o = i.minRotation || 0, n = i.maxRotation;
    let r = o, a, l, d;
    if (!this._isVisible() || !i.display || o >= n || s <= 1 || !this.isHorizontal()) {
      this.labelRotation = o;
      return;
    }
    const c = this._getLabelSizes(), u = c.widest.width, h = c.highest.height, g = Je(this.chart.width - u, 0, this.maxWidth);
    a = t.offset ? this.maxWidth / s : g / (s - 1), u + 6 > a && (a = g / (s - (t.offset ? 0.5 : 1)), l = this.maxHeight - Ks(t.grid) - i.padding - zu(t.title, this.chart.options.font), d = Math.sqrt(u * u + h * h), r = Ok(Math.min(Math.asin(Je((c.highest.height + 6) / a, -1, 1)), Math.asin(Je(l / d, -1, 1)) - Math.asin(Je(h / d, -1, 1)))), r = Math.max(o, Math.min(n, r))), this.labelRotation = r;
  }
  afterCalculateLabelRotation() {
    ae(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    ae(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: i, options: { ticks: s, title: o, grid: n } } = this, r = this._isVisible(), a = this.isHorizontal();
    if (r) {
      const l = zu(o, i.options.font);
      if (a ? (t.width = this.maxWidth, t.height = Ks(n) + l) : (t.height = this.maxHeight, t.width = Ks(n) + l), s.display && this.ticks.length) {
        const { first: d, last: c, widest: u, highest: h } = this._getLabelSizes(), g = s.padding * 2, p = Fi(this.labelRotation), f = Math.cos(p), m = Math.sin(p);
        if (a) {
          const C = s.mirror ? 0 : m * u.width + f * h.height;
          t.height = Math.min(this.maxHeight, t.height + C + g);
        } else {
          const C = s.mirror ? 0 : f * u.width + m * h.height;
          t.width = Math.min(this.maxWidth, t.width + C + g);
        }
        this._calculatePadding(d, c, m, f);
      }
    }
    this._handleMargins(), a ? (this.width = this._length = i.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = i.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, i, s, o) {
    const { ticks: { align: n, padding: r }, position: a } = this.options, l = this.labelRotation !== 0, d = a !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const c = this.getPixelForTick(0) - this.left, u = this.right - this.getPixelForTick(this.ticks.length - 1);
      let h = 0, g = 0;
      l ? d ? (h = o * t.width, g = s * i.height) : (h = s * t.height, g = o * i.width) : n === "start" ? g = i.width : n === "end" ? h = t.width : n !== "inner" && (h = t.width / 2, g = i.width / 2), this.paddingLeft = Math.max((h - c + r) * this.width / (this.width - c), 0), this.paddingRight = Math.max((g - u + r) * this.width / (this.width - u), 0);
    } else {
      let c = i.height / 2, u = t.height / 2;
      n === "start" ? (c = 0, u = t.height) : n === "end" && (c = i.height, u = 0), this.paddingTop = c + r, this.paddingBottom = u + r;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    ae(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: i } = this.options;
    return i === "top" || i === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let i, s;
    for (i = 0, s = t.length; i < s; i++)
      re(t[i].label) && (t.splice(i, 1), s--, i--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const i = this.options.ticks.sampleSize;
      let s = this.ticks;
      i < s.length && (s = Wu(s, i)), this._labelSizes = t = this._computeLabelSizes(s, s.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, i, s) {
    const { ctx: o, _longestTextCache: n } = this, r = [], a = [], l = Math.floor(i / Nu(i, s));
    let d = 0, c = 0, u, h, g, p, f, m, C, v, R, b, w;
    for (u = 0; u < i; u += l) {
      if (p = t[u].label, f = this._resolveTickFontOptions(u), o.font = m = f.string, C = n[m] = n[m] || {
        data: {},
        gc: []
      }, v = f.lineHeight, R = b = 0, !re(p) && !Fe(p))
        R = wu(o, C.data, C.gc, R, p), b = v;
      else if (Fe(p))
        for (h = 0, g = p.length; h < g; ++h)
          w = p[h], !re(w) && !Fe(w) && (R = wu(o, C.data, C.gc, R, w), b += v);
      r.push(R), a.push(b), d = Math.max(R, d), c = Math.max(b, c);
    }
    KO(n, i);
    const x = r.indexOf(d), F = a.indexOf(c), D = (T) => ({
      width: r[T] || 0,
      height: a[T] || 0
    });
    return {
      first: D(0),
      last: D(i - 1),
      widest: D(x),
      highest: D(F),
      widths: r,
      heights: a
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, i) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const i = this._startPixel + t * this._length;
    return Bk(this._alignToPixels ? Ci(this.chart, i, 0) : i);
  }
  getDecimalForPixel(t) {
    const i = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - i : i;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: i } = this;
    return t < 0 && i < 0 ? i : t > 0 && i > 0 ? t : 0;
  }
  getContext(t) {
    const i = this.ticks || [];
    if (t >= 0 && t < i.length) {
      const s = i[t];
      return s.$context || (s.$context = qO(this.getContext(), t, s));
    }
    return this.$context || (this.$context = jO(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, i = Fi(this.labelRotation), s = Math.abs(Math.cos(i)), o = Math.abs(Math.sin(i)), n = this._getLabelSizes(), r = t.autoSkipPadding || 0, a = n ? n.widest.width + r : 0, l = n ? n.highest.height + r : 0;
    return this.isHorizontal() ? l * s > a * o ? a / s : l / o : l * o < a * s ? l / s : a / o;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const i = this.axis, s = this.chart, o = this.options, { grid: n, position: r, border: a } = o, l = n.offset, d = this.isHorizontal(), u = this.ticks.length + (l ? 1 : 0), h = Ks(n), g = [], p = a.setContext(this.getContext()), f = p.display ? p.width : 0, m = f / 2, C = function(oe) {
      return Ci(s, oe, f);
    };
    let v, R, b, w, x, F, D, T, k, A, G, $;
    if (r === "top")
      v = C(this.bottom), F = this.bottom - h, T = v - m, A = C(t.top) + m, $ = t.bottom;
    else if (r === "bottom")
      v = C(this.top), A = t.top, $ = C(t.bottom) - m, F = v + m, T = this.top + h;
    else if (r === "left")
      v = C(this.right), x = this.right - h, D = v - m, k = C(t.left) + m, G = t.right;
    else if (r === "right")
      v = C(this.left), k = t.left, G = C(t.right) - m, x = v + m, D = this.left + h;
    else if (i === "x") {
      if (r === "center")
        v = C((t.top + t.bottom) / 2 + 0.5);
      else if (ee(r)) {
        const oe = Object.keys(r)[0], ne = r[oe];
        v = C(this.chart.scales[oe].getPixelForValue(ne));
      }
      A = t.top, $ = t.bottom, F = v + m, T = F + h;
    } else if (i === "y") {
      if (r === "center")
        v = C((t.left + t.right) / 2);
      else if (ee(r)) {
        const oe = Object.keys(r)[0], ne = r[oe];
        v = C(this.chart.scales[oe].getPixelForValue(ne));
      }
      x = v - m, D = x - h, k = t.left, G = t.right;
    }
    const q = Y(o.ticks.maxTicksLimit, u), j = Math.max(1, Math.ceil(u / q));
    for (R = 0; R < u; R += j) {
      const oe = this.getContext(R), ne = n.setContext(oe), gt = a.setContext(oe), It = ne.lineWidth, je = ne.color, pt = gt.dash || [], rt = gt.dashOffset, ge = ne.tickWidth, He = ne.tickColor, at = ne.tickBorderDash || [], Ae = ne.tickBorderDashOffset;
      b = $O(this, R, l), b !== void 0 && (w = Ci(s, b, It), d ? x = D = k = G = w : F = T = A = $ = w, g.push({
        tx1: x,
        ty1: F,
        tx2: D,
        ty2: T,
        x1: k,
        y1: A,
        x2: G,
        y2: $,
        width: It,
        color: je,
        borderDash: pt,
        borderDashOffset: rt,
        tickWidth: ge,
        tickColor: He,
        tickBorderDash: at,
        tickBorderDashOffset: Ae
      }));
    }
    return this._ticksLength = u, this._borderValue = v, g;
  }
  _computeLabelItems(t) {
    const i = this.axis, s = this.options, { position: o, ticks: n } = s, r = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: d, padding: c, mirror: u } = n, h = Ks(s.grid), g = h + c, p = u ? -c : g, f = -Fi(this.labelRotation), m = [];
    let C, v, R, b, w, x, F, D, T, k, A, G, $ = "middle";
    if (o === "top")
      x = this.bottom - p, F = this._getXAxisLabelAlignment();
    else if (o === "bottom")
      x = this.top + p, F = this._getXAxisLabelAlignment();
    else if (o === "left") {
      const j = this._getYAxisLabelAlignment(h);
      F = j.textAlign, w = j.x;
    } else if (o === "right") {
      const j = this._getYAxisLabelAlignment(h);
      F = j.textAlign, w = j.x;
    } else if (i === "x") {
      if (o === "center")
        x = (t.top + t.bottom) / 2 + g;
      else if (ee(o)) {
        const j = Object.keys(o)[0], oe = o[j];
        x = this.chart.scales[j].getPixelForValue(oe) + g;
      }
      F = this._getXAxisLabelAlignment();
    } else if (i === "y") {
      if (o === "center")
        w = (t.left + t.right) / 2 - g;
      else if (ee(o)) {
        const j = Object.keys(o)[0], oe = o[j];
        w = this.chart.scales[j].getPixelForValue(oe);
      }
      F = this._getYAxisLabelAlignment(h).textAlign;
    }
    i === "y" && (l === "start" ? $ = "top" : l === "end" && ($ = "bottom"));
    const q = this._getLabelSizes();
    for (C = 0, v = a.length; C < v; ++C) {
      R = a[C], b = R.label;
      const j = n.setContext(this.getContext(C));
      D = this.getPixelForTick(C) + n.labelOffset, T = this._resolveTickFontOptions(C), k = T.lineHeight, A = Fe(b) ? b.length : 1;
      const oe = A / 2, ne = j.color, gt = j.textStrokeColor, It = j.textStrokeWidth;
      let je = F;
      r ? (w = D, F === "inner" && (C === v - 1 ? je = this.options.reverse ? "left" : "right" : C === 0 ? je = this.options.reverse ? "right" : "left" : je = "center"), o === "top" ? d === "near" || f !== 0 ? G = -A * k + k / 2 : d === "center" ? G = -q.highest.height / 2 - oe * k + k : G = -q.highest.height + k / 2 : d === "near" || f !== 0 ? G = k / 2 : d === "center" ? G = q.highest.height / 2 - oe * k : G = q.highest.height - A * k, u && (G *= -1), f !== 0 && !j.showLabelBackdrop && (w += k / 2 * Math.sin(f))) : (x = D, G = (1 - A) * k / 2);
      let pt;
      if (j.showLabelBackdrop) {
        const rt = ot(j.backdropPadding), ge = q.heights[C], He = q.widths[C];
        let at = G - rt.top, Ae = 0 - rt.left;
        switch ($) {
          case "middle":
            at -= ge / 2;
            break;
          case "bottom":
            at -= ge;
            break;
        }
        switch (F) {
          case "center":
            Ae -= He / 2;
            break;
          case "right":
            Ae -= He;
            break;
          case "inner":
            C === v - 1 ? Ae -= He : C > 0 && (Ae -= He / 2);
            break;
        }
        pt = {
          left: Ae,
          top: at,
          width: He + rt.width,
          height: ge + rt.height,
          color: j.backdropColor
        };
      }
      m.push({
        label: b,
        font: T,
        textOffset: G,
        options: {
          rotation: f,
          color: ne,
          strokeColor: gt,
          strokeWidth: It,
          textAlign: je,
          textBaseline: $,
          translation: [
            w,
            x
          ],
          backdrop: pt
        }
      });
    }
    return m;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: i } = this.options;
    if (-Fi(this.labelRotation))
      return t === "top" ? "left" : "right";
    let o = "center";
    return i.align === "start" ? o = "left" : i.align === "end" ? o = "right" : i.align === "inner" && (o = "inner"), o;
  }
  _getYAxisLabelAlignment(t) {
    const { position: i, ticks: { crossAlign: s, mirror: o, padding: n } } = this.options, r = this._getLabelSizes(), a = t + n, l = r.widest.width;
    let d, c;
    return i === "left" ? o ? (c = this.right + n, s === "near" ? d = "left" : s === "center" ? (d = "center", c += l / 2) : (d = "right", c += l)) : (c = this.right - a, s === "near" ? d = "right" : s === "center" ? (d = "center", c -= l / 2) : (d = "left", c = this.left)) : i === "right" ? o ? (c = this.left + n, s === "near" ? d = "right" : s === "center" ? (d = "center", c -= l / 2) : (d = "left", c -= l)) : (c = this.left + a, s === "near" ? d = "left" : s === "center" ? (d = "center", c += l / 2) : (d = "right", c = this.right)) : d = "right", {
      textAlign: d,
      x: c
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, i = this.options.position;
    if (i === "left" || i === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (i === "top" || i === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: i }, left: s, top: o, width: n, height: r } = this;
    i && (t.save(), t.fillStyle = i, t.fillRect(s, o, n, r), t.restore());
  }
  getLineWidthForValue(t) {
    const i = this.options.grid;
    if (!this._isVisible() || !i.display)
      return 0;
    const o = this.ticks.findIndex((n) => n.value === t);
    return o >= 0 ? i.setContext(this.getContext(o)).lineWidth : 0;
  }
  drawGrid(t) {
    const i = this.options.grid, s = this.ctx, o = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let n, r;
    const a = (l, d, c) => {
      !c.width || !c.color || (s.save(), s.lineWidth = c.width, s.strokeStyle = c.color, s.setLineDash(c.borderDash || []), s.lineDashOffset = c.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(d.x, d.y), s.stroke(), s.restore());
    };
    if (i.display)
      for (n = 0, r = o.length; n < r; ++n) {
        const l = o[n];
        i.drawOnChartArea && a({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), i.drawTicks && a({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: i, options: { border: s, grid: o } } = this, n = s.setContext(this.getContext()), r = s.display ? n.width : 0;
    if (!r)
      return;
    const a = o.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let d, c, u, h;
    this.isHorizontal() ? (d = Ci(t, this.left, r) - r / 2, c = Ci(t, this.right, a) + a / 2, u = h = l) : (u = Ci(t, this.top, r) - r / 2, h = Ci(t, this.bottom, a) + a / 2, d = c = l), i.save(), i.lineWidth = n.width, i.strokeStyle = n.color, i.beginPath(), i.moveTo(d, u), i.lineTo(c, h), i.stroke(), i.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const s = this.ctx, o = this._computeLabelArea();
    o && wd(s, o);
    const n = this.getLabelItems(t);
    for (const r of n) {
      const a = r.options, l = r.font, d = r.label, c = r.textOffset;
      _o(s, d, 0, c, l, a);
    }
    o && bd(s);
  }
  drawTitle() {
    const { ctx: t, options: { position: i, title: s, reverse: o } } = this;
    if (!s.display)
      return;
    const n = _e(s.font), r = ot(s.padding), a = s.align;
    let l = n.lineHeight / 2;
    i === "bottom" || i === "center" || ee(i) ? (l += r.bottom, Fe(s.text) && (l += n.lineHeight * (s.text.length - 1))) : l += r.top;
    const { titleX: d, titleY: c, maxWidth: u, rotation: h } = QO(this, l, i, a);
    _o(t, s.text, 0, 0, n, {
      color: s.color,
      maxWidth: u,
      rotation: h,
      textAlign: YO(a, i, o),
      textBaseline: "middle",
      translation: [
        d,
        c
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, i = t.ticks && t.ticks.z || 0, s = Y(t.grid && t.grid.z, -1), o = Y(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== Ms.prototype.draw ? [
      {
        z: i,
        draw: (n) => {
          this.draw(n);
        }
      }
    ] : [
      {
        z: s,
        draw: (n) => {
          this.drawBackground(), this.drawGrid(n), this.drawTitle();
        }
      },
      {
        z: o,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: i,
        draw: (n) => {
          this.drawLabels(n);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const i = this.chart.getSortedVisibleDatasetMetas(), s = this.axis + "AxisID", o = [];
    let n, r;
    for (n = 0, r = i.length; n < r; ++n) {
      const a = i[n];
      a[s] === this.id && (!t || a.type === t) && o.push(a);
    }
    return o;
  }
  _resolveTickFontOptions(t) {
    const i = this.options.ticks.setContext(this.getContext(t));
    return _e(i.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class wn {
  constructor(t, i, s) {
    this.type = t, this.scope = i, this.override = s, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const i = Object.getPrototypeOf(t);
    let s;
    JO(i) && (s = this.register(i));
    const o = this.items, n = t.id, r = this.scope + "." + n;
    if (!n)
      throw new Error("class does not have id: " + t);
    return n in o || (o[n] = t, XO(t, r, s), this.override && Se.override(t.id, t.overrides)), r;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const i = this.items, s = t.id, o = this.scope;
    s in i && delete i[s], o && s in Se[o] && (delete Se[o][s], this.override && delete Vi[s]);
  }
}
function XO(e, t, i) {
  const s = ko(/* @__PURE__ */ Object.create(null), [
    i ? Se.get(i) : {},
    Se.get(t),
    e.defaults
  ]);
  Se.set(t, s), e.defaultRoutes && ZO(t, e.defaultRoutes), e.descriptors && Se.describe(t, e.descriptors);
}
function ZO(e, t) {
  Object.keys(t).forEach((i) => {
    const s = i.split("."), o = s.pop(), n = [
      e
    ].concat(s).join("."), r = t[i].split("."), a = r.pop(), l = r.join(".");
    Se.route(n, o, l, a);
  });
}
function JO(e) {
  return "id" in e && "defaults" in e;
}
class e1 {
  constructor() {
    this.controllers = new wn(fo, "datasets", !0), this.elements = new wn(Ki, "elements"), this.plugins = new wn(Object, "plugins"), this.scales = new wn(Ms, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, i, s) {
    [
      ...i
    ].forEach((o) => {
      const n = s || this._getRegistryForType(o);
      s || n.isForType(o) || n === this.plugins && o.id ? this._exec(t, n, o) : ie(o, (r) => {
        const a = s || this._getRegistryForType(r);
        this._exec(t, a, r);
      });
    });
  }
  _exec(t, i, s) {
    const o = fd(t);
    ae(s["before" + o], [], s), i[t](s), ae(s["after" + o], [], s);
  }
  _getRegistryForType(t) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const s = this._typedRegistries[i];
      if (s.isForType(t))
        return s;
    }
    return this.plugins;
  }
  _get(t, i, s) {
    const o = i.get(t);
    if (o === void 0)
      throw new Error('"' + t + '" is not a registered ' + s + ".");
    return o;
  }
}
var bt = /* @__PURE__ */ new e1();
class t1 {
  constructor() {
    this._init = [];
  }
  notify(t, i, s, o) {
    i === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
    const n = o ? this._descriptors(t).filter(o) : this._descriptors(t), r = this._notify(n, t, i, s);
    return i === "afterDestroy" && (this._notify(n, t, "stop"), this._notify(this._init, t, "uninstall")), r;
  }
  _notify(t, i, s, o) {
    o = o || {};
    for (const n of t) {
      const r = n.plugin, a = r[s], l = [
        i,
        o,
        n.options
      ];
      if (ae(a, l, r) === !1 && o.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    re(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const i = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), i;
  }
  _createDescriptors(t, i) {
    const s = t && t.config, o = Y(s.options && s.options.plugins, {}), n = i1(s);
    return o === !1 && !i ? [] : o1(t, n, o, i);
  }
  _notifyStateChanges(t) {
    const i = this._oldCache || [], s = this._cache, o = (n, r) => n.filter((a) => !r.some((l) => a.plugin.id === l.plugin.id));
    this._notify(o(i, s), t, "stop"), this._notify(o(s, i), t, "start");
  }
}
function i1(e) {
  const t = {}, i = [], s = Object.keys(bt.plugins.items);
  for (let n = 0; n < s.length; n++)
    i.push(bt.getPlugin(s[n]));
  const o = e.plugins || [];
  for (let n = 0; n < o.length; n++) {
    const r = o[n];
    i.indexOf(r) === -1 && (i.push(r), t[r.id] = !0);
  }
  return {
    plugins: i,
    localIds: t
  };
}
function s1(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function o1(e, { plugins: t, localIds: i }, s, o) {
  const n = [], r = e.getContext();
  for (const a of t) {
    const l = a.id, d = s1(s[l], o);
    d !== null && n.push({
      plugin: a,
      options: n1(e.config, {
        plugin: a,
        local: i[l]
      }, d, r)
    });
  }
  return n;
}
function n1(e, { plugin: t, local: i }, s, o) {
  const n = e.pluginScopeKeys(t), r = e.getOptionScopes(s, n);
  return i && t.defaults && r.push(t.defaults), e.createResolver(r, o, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function ml(e, t) {
  const i = Se.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || i.indexAxis || "x";
}
function r1(e, t) {
  let i = e;
  return e === "_index_" ? i = t : e === "_value_" && (i = t === "x" ? "y" : "x"), i;
}
function a1(e, t) {
  return e === t ? "_index_" : "_value_";
}
function Uu(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function l1(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function Cl(e, ...t) {
  if (Uu(e))
    return e;
  for (const i of t) {
    const s = i.axis || l1(i.position) || e.length > 1 && Uu(e[0].toLowerCase());
    if (s)
      return s;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function $u(e, t, i) {
  if (i[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function d1(e, t) {
  if (t.data && t.data.datasets) {
    const i = t.data.datasets.filter((s) => s.xAxisID === e || s.yAxisID === e);
    if (i.length)
      return $u(e, "x", i[0]) || $u(e, "y", i[0]);
  }
  return {};
}
function c1(e, t) {
  const i = Vi[e.type] || {
    scales: {}
  }, s = t.scales || {}, o = ml(e.type, t), n = /* @__PURE__ */ Object.create(null);
  return Object.keys(s).forEach((r) => {
    const a = s[r];
    if (!ee(a))
      return console.error(`Invalid scale configuration for scale: ${r}`);
    if (a._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${r}`);
    const l = Cl(r, a, d1(r, e), Se.scales[a.type]), d = a1(l, o), c = i.scales || {};
    n[r] = co(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      a,
      c[l],
      c[d]
    ]);
  }), e.data.datasets.forEach((r) => {
    const a = r.type || e.type, l = r.indexAxis || ml(a, t), c = (Vi[a] || {}).scales || {};
    Object.keys(c).forEach((u) => {
      const h = r1(u, l), g = r[h + "AxisID"] || h;
      n[g] = n[g] || /* @__PURE__ */ Object.create(null), co(n[g], [
        {
          axis: h
        },
        s[g],
        c[u]
      ]);
    });
  }), Object.keys(n).forEach((r) => {
    const a = n[r];
    co(a, [
      Se.scales[a.type],
      Se.scale
    ]);
  }), n;
}
function qf(e) {
  const t = e.options || (e.options = {});
  t.plugins = Y(t.plugins, {}), t.scales = c1(e, t);
}
function Yf(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function u1(e) {
  return e = e || {}, e.data = Yf(e.data), qf(e), e;
}
const Ku = /* @__PURE__ */ new Map(), Qf = /* @__PURE__ */ new Set();
function bn(e, t) {
  let i = Ku.get(e);
  return i || (i = t(), Ku.set(e, i), Qf.add(i)), i;
}
const js = (e, t, i) => {
  const s = ur(t, i);
  s !== void 0 && e.add(s);
};
class h1 {
  constructor(t) {
    this._config = u1(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = Yf(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), qf(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return bn(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, i) {
    return bn(`${t}.transition.${i}`, () => [
      [
        `datasets.${t}.transitions.${i}`,
        `transitions.${i}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, i) {
    return bn(`${t}-${i}`, () => [
      [
        `datasets.${t}.elements.${i}`,
        `datasets.${t}`,
        `elements.${i}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const i = t.id, s = this.type;
    return bn(`${s}-plugin-${i}`, () => [
      [
        `plugins.${i}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, i) {
    const s = this._scopeCache;
    let o = s.get(t);
    return (!o || i) && (o = /* @__PURE__ */ new Map(), s.set(t, o)), o;
  }
  getOptionScopes(t, i, s) {
    const { options: o, type: n } = this, r = this._cachedScopes(t, s), a = r.get(i);
    if (a)
      return a;
    const l = /* @__PURE__ */ new Set();
    i.forEach((c) => {
      t && (l.add(t), c.forEach((u) => js(l, t, u))), c.forEach((u) => js(l, o, u)), c.forEach((u) => js(l, Vi[n] || {}, u)), c.forEach((u) => js(l, Se, u)), c.forEach((u) => js(l, gl, u));
    });
    const d = Array.from(l);
    return d.length === 0 && d.push(/* @__PURE__ */ Object.create(null)), Qf.has(i) && r.set(i, d), d;
  }
  chartOptionScopes() {
    const { options: t, type: i } = this;
    return [
      t,
      Vi[i] || {},
      Se.datasets[i] || {},
      {
        type: i
      },
      Se,
      gl
    ];
  }
  resolveNamedOptions(t, i, s, o = [
    ""
  ]) {
    const n = {
      $shared: !0
    }, { resolver: r, subPrefixes: a } = ju(this._resolverCache, t, o);
    let l = r;
    if (p1(r, i)) {
      n.$shared = !1, s = li(s) ? s() : s;
      const d = this.createResolver(t, s, a);
      l = Fs(r, s, d);
    }
    for (const d of i)
      n[d] = l[d];
    return n;
  }
  createResolver(t, i, s = [
    ""
  ], o) {
    const { resolver: n } = ju(this._resolverCache, t, s);
    return ee(i) ? Fs(n, i, void 0, o) : n;
  }
}
function ju(e, t, i) {
  let s = e.get(t);
  s || (s = /* @__PURE__ */ new Map(), e.set(t, s));
  const o = i.join();
  let n = s.get(o);
  return n || (n = {
    resolver: yd(t, i),
    subPrefixes: i.filter((a) => !a.toLowerCase().includes("hover"))
  }, s.set(o, n)), n;
}
const g1 = (e) => ee(e) && Object.getOwnPropertyNames(e).some((t) => li(e[t]));
function p1(e, t) {
  const { isScriptable: i, isIndexable: s } = kf(e);
  for (const o of t) {
    const n = i(o), r = s(o), a = (r || n) && e[o];
    if (n && (li(a) || g1(a)) || r && Fe(a))
      return !0;
  }
  return !1;
}
var f1 = "4.5.0";
const m1 = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function qu(e, t) {
  return e === "top" || e === "bottom" || m1.indexOf(e) === -1 && t === "x";
}
function Yu(e, t) {
  return function(i, s) {
    return i[e] === s[e] ? i[t] - s[t] : i[e] - s[e];
  };
}
function Qu(e) {
  const t = e.chart, i = t.options.animation;
  t.notifyPlugins("afterRender"), ae(i && i.onComplete, [
    e
  ], t);
}
function C1(e) {
  const t = e.chart, i = t.options.animation;
  ae(i && i.onProgress, [
    e
  ], t);
}
function Xf(e) {
  return xd() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const _n = {}, Xu = (e) => {
  const t = Xf(e);
  return Object.values(_n).filter((i) => i.canvas === t).pop();
};
function v1(e, t, i) {
  const s = Object.keys(e);
  for (const o of s) {
    const n = +o;
    if (n >= t) {
      const r = e[o];
      delete e[o], (i > 0 || n > t) && (e[n + i] = r);
    }
  }
}
function w1(e, t, i, s) {
  return !i || e.type === "mouseout" ? null : s ? t : e;
}
var Xt;
let Ar = (Xt = class {
  static register(...t) {
    bt.add(...t), Zu();
  }
  static unregister(...t) {
    bt.remove(...t), Zu();
  }
  constructor(t, i) {
    const s = this.config = new h1(i), o = Xf(t), n = Xu(o);
    if (n)
      throw new Error("Canvas is already in use. Chart with ID '" + n.id + "' must be destroyed before the canvas with ID '" + n.canvas.id + "' can be reused.");
    const r = s.createResolver(s.chartOptionScopes(), this.getContext());
    this.platform = new (s.platform || HO(o))(), this.platform.updateConfig(s);
    const a = this.platform.acquireContext(o, r.aspectRatio), l = a && a.canvas, d = l && l.height, c = l && l.width;
    if (this.id = Sk(), this.ctx = a, this.canvas = l, this.width = c, this.height = d, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new t1(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = zk((u) => this.update(u), r.resizeDelay || 0), this._dataChanges = [], _n[this.id] = this, !a || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Lt.listen(this, "complete", Qu), Lt.listen(this, "progress", C1), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: i }, width: s, height: o, _aspectRatio: n } = this;
    return re(t) ? i && n ? n : o ? s / o : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return bt;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Ru(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return bu(this.canvas, this.ctx), this;
  }
  stop() {
    return Lt.stop(this), this;
  }
  resize(t, i) {
    Lt.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: i
    } : this._resize(t, i);
  }
  _resize(t, i) {
    const s = this.options, o = this.canvas, n = s.maintainAspectRatio && this.aspectRatio, r = this.platform.getMaximumSize(o, t, i, n), a = s.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = r.width, this.height = r.height, this._aspectRatio = this.aspectRatio, Ru(this, a, !0) && (this.notifyPlugins("resize", {
      size: r
    }), ae(s.onResize, [
      this,
      r
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const i = this.options.scales || {};
    ie(i, (s, o) => {
      s.id = o;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, i = t.scales, s = this.scales, o = Object.keys(s).reduce((r, a) => (r[a] = !1, r), {});
    let n = [];
    i && (n = n.concat(Object.keys(i).map((r) => {
      const a = i[r], l = Cl(r, a), d = l === "r", c = l === "x";
      return {
        options: a,
        dposition: d ? "chartArea" : c ? "bottom" : "left",
        dtype: d ? "radialLinear" : c ? "category" : "linear"
      };
    }))), ie(n, (r) => {
      const a = r.options, l = a.id, d = Cl(l, a), c = Y(a.type, r.dtype);
      (a.position === void 0 || qu(a.position, d) !== qu(r.dposition)) && (a.position = r.dposition), o[l] = !0;
      let u = null;
      if (l in s && s[l].type === c)
        u = s[l];
      else {
        const h = bt.getScale(c);
        u = new h({
          id: l,
          type: c,
          ctx: this.ctx,
          chart: this
        }), s[u.id] = u;
      }
      u.init(a, t);
    }), ie(o, (r, a) => {
      r || delete s[a];
    }), ie(s, (r) => {
      et.configure(this, r, r.options), et.addBox(this, r);
    });
  }
  _updateMetasets() {
    const t = this._metasets, i = this.data.datasets.length, s = t.length;
    if (t.sort((o, n) => o.index - n.index), s > i) {
      for (let o = i; o < s; ++o)
        this._destroyDatasetMeta(o);
      t.splice(i, s - i);
    }
    this._sortedMetasets = t.slice(0).sort(Yu("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: i } } = this;
    t.length > i.length && delete this._stacks, t.forEach((s, o) => {
      i.filter((n) => n === s._dataset).length === 0 && this._destroyDatasetMeta(o);
    });
  }
  buildOrUpdateControllers() {
    const t = [], i = this.data.datasets;
    let s, o;
    for (this._removeUnreferencedMetasets(), s = 0, o = i.length; s < o; s++) {
      const n = i[s];
      let r = this.getDatasetMeta(s);
      const a = n.type || this.config.type;
      if (r.type && r.type !== a && (this._destroyDatasetMeta(s), r = this.getDatasetMeta(s)), r.type = a, r.indexAxis = n.indexAxis || ml(a, this.options), r.order = n.order || 0, r.index = s, r.label = "" + n.label, r.visible = this.isDatasetVisible(s), r.controller)
        r.controller.updateIndex(s), r.controller.linkScales();
      else {
        const l = bt.getController(a), { datasetElementType: d, dataElementType: c } = Se.datasets[a];
        Object.assign(l, {
          dataElementType: bt.getElement(c),
          datasetElementType: d && bt.getElement(d)
        }), r.controller = new l(this, s), t.push(r.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    ie(this.data.datasets, (t, i) => {
      this.getDatasetMeta(i).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const i = this.config;
    i.update();
    const s = this._options = i.createResolver(i.chartOptionScopes(), this.getContext()), o = this._animationsDisabled = !s.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const n = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let r = 0;
    for (let d = 0, c = this.data.datasets.length; d < c; d++) {
      const { controller: u } = this.getDatasetMeta(d), h = !o && n.indexOf(u) === -1;
      u.buildOrUpdateElements(h), r = Math.max(+u.getMaxOverflow(), r);
    }
    r = this._minPadding = s.layout.autoPadding ? r : 0, this._updateLayout(r), o || ie(n, (d) => {
      d.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(Yu("z", "_idx"));
    const { _active: a, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();
  }
  _updateScales() {
    ie(this.scales, (t) => {
      et.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, i = new Set(Object.keys(this._listeners)), s = new Set(t.events);
    (!cu(i, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, i = this._getUniformDataChanges() || [];
    for (const { method: s, start: o, count: n } of i) {
      const r = s === "_removeElements" ? -n : n;
      v1(t, o, r);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const i = this.data.datasets.length, s = (n) => new Set(t.filter((r) => r[0] === n).map((r, a) => a + "," + r.splice(1).join(","))), o = s(0);
    for (let n = 1; n < i; n++)
      if (!cu(o, s(n)))
        return;
    return Array.from(o).map((n) => n.split(",")).map((n) => ({
      method: n[1],
      start: +n[2],
      count: +n[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    et.update(this, this.width, this.height, t);
    const i = this.chartArea, s = i.width <= 0 || i.height <= 0;
    this._layers = [], ie(this.boxes, (o) => {
      s && o.position === "chartArea" || (o.configure && o.configure(), this._layers.push(...o._layers()));
    }, this), this._layers.forEach((o, n) => {
      o._idx = n;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let i = 0, s = this.data.datasets.length; i < s; ++i)
        this.getDatasetMeta(i).controller.configure();
      for (let i = 0, s = this.data.datasets.length; i < s; ++i)
        this._updateDataset(i, li(t) ? t({
          datasetIndex: i
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, i) {
    const s = this.getDatasetMeta(t), o = {
      meta: s,
      index: t,
      mode: i,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", o) !== !1 && (s.controller._update(i), o.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", o));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Lt.has(this) ? this.attached && !Lt.running(this) && Lt.start(this) : (this.draw(), Qu({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: s, height: o } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(s, o);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const i = this._layers;
    for (t = 0; t < i.length && i[t].z <= 0; ++t)
      i[t].draw(this.chartArea);
    for (this._drawDatasets(); t < i.length; ++t)
      i[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const i = this._sortedMetasets, s = [];
    let o, n;
    for (o = 0, n = i.length; o < n; ++o) {
      const r = i[o];
      (!t || r.visible) && s.push(r);
    }
    return s;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let i = t.length - 1; i >= 0; --i)
      this._drawDataset(t[i]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const i = this.ctx, s = {
      meta: t,
      index: t.index,
      cancelable: !0
    }, o = QL(this, t);
    this.notifyPlugins("beforeDatasetDraw", s) !== !1 && (o && wd(i, o), t.controller.draw(), o && bd(i), s.cancelable = !1, this.notifyPlugins("afterDatasetDraw", s));
  }
  isPointInArea(t) {
    return Oo(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, i, s, o) {
    const n = mO.modes[i];
    return typeof n == "function" ? n(this, t, s, o) : [];
  }
  getDatasetMeta(t) {
    const i = this.data.datasets[t], s = this._metasets;
    let o = s.filter((n) => n && n._dataset === i).pop();
    return o || (o = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: i && i.order || 0,
      index: t,
      _dataset: i,
      _parsed: [],
      _sorted: !1
    }, s.push(o)), o;
  }
  getContext() {
    return this.$context || (this.$context = $i(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const i = this.data.datasets[t];
    if (!i)
      return !1;
    const s = this.getDatasetMeta(t);
    return typeof s.hidden == "boolean" ? !s.hidden : !i.hidden;
  }
  setDatasetVisibility(t, i) {
    const s = this.getDatasetMeta(t);
    s.hidden = !i;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, i, s) {
    const o = s ? "show" : "hide", n = this.getDatasetMeta(t), r = n.controller._resolveAnimations(void 0, o);
    hr(i) ? (n.data[i].hidden = !s, this.update()) : (this.setDatasetVisibility(t, s), r.update(n, {
      visible: s
    }), this.update((a) => a.datasetIndex === t ? o : void 0));
  }
  hide(t, i) {
    this._updateVisibility(t, i, !1);
  }
  show(t, i) {
    this._updateVisibility(t, i, !0);
  }
  _destroyDatasetMeta(t) {
    const i = this._metasets[t];
    i && i.controller && i.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, i;
    for (this.stop(), Lt.remove(this), t = 0, i = this.data.datasets.length; t < i; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: i } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), bu(t, i), this.platform.releaseContext(i), this.canvas = null, this.ctx = null), delete _n[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, i = this.platform, s = (n, r) => {
      i.addEventListener(this, n, r), t[n] = r;
    }, o = (n, r, a) => {
      n.offsetX = r, n.offsetY = a, this._eventHandler(n);
    };
    ie(this.options.events, (n) => s(n, o));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, i = this.platform, s = (l, d) => {
      i.addEventListener(this, l, d), t[l] = d;
    }, o = (l, d) => {
      t[l] && (i.removeEventListener(this, l, d), delete t[l]);
    }, n = (l, d) => {
      this.canvas && this.resize(l, d);
    };
    let r;
    const a = () => {
      o("attach", a), this.attached = !0, this.resize(), s("resize", n), s("detach", r);
    };
    r = () => {
      this.attached = !1, o("resize", n), this._stop(), this._resize(0, 0), s("attach", a);
    }, i.isAttached(this.canvas) ? a() : r();
  }
  unbindEvents() {
    ie(this._listeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._listeners = {}, ie(this._responsiveListeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, i, s) {
    const o = s ? "set" : "remove";
    let n, r, a, l;
    for (i === "dataset" && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller["_" + o + "DatasetHoverStyle"]()), a = 0, l = t.length; a < l; ++a) {
      r = t[a];
      const d = r && this.getDatasetMeta(r.datasetIndex).controller;
      d && d[o + "HoverStyle"](r.element, r.datasetIndex, r.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const i = this._active || [], s = t.map(({ datasetIndex: n, index: r }) => {
      const a = this.getDatasetMeta(n);
      if (!a)
        throw new Error("No dataset found at index " + n);
      return {
        datasetIndex: n,
        element: a.data[r],
        index: r
      };
    });
    !dr(s, i) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, i));
  }
  notifyPlugins(t, i, s) {
    return this._plugins.notify(this, t, i, s);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((i) => i.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, i, s) {
    const o = this.options.hover, n = (l, d) => l.filter((c) => !d.some((u) => c.datasetIndex === u.datasetIndex && c.index === u.index)), r = n(i, t), a = s ? t : n(t, i);
    r.length && this.updateHoverStyle(r, o.mode, !1), a.length && o.mode && this.updateHoverStyle(a, o.mode, !0);
  }
  _eventHandler(t, i) {
    const s = {
      event: t,
      replay: i,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, o = (r) => (r.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", s, o) === !1)
      return;
    const n = this._handleEvent(t, i, s.inChartArea);
    return s.cancelable = !1, this.notifyPlugins("afterEvent", s, o), (n || s.changed) && this.render(), this;
  }
  _handleEvent(t, i, s) {
    const { _active: o = [], options: n } = this, r = i, a = this._getActiveElements(t, o, s, r), l = Dk(t), d = w1(t, this._lastEvent, s, l);
    s && (this._lastEvent = null, ae(n.onHover, [
      t,
      a,
      this
    ], this), l && ae(n.onClick, [
      t,
      a,
      this
    ], this));
    const c = !dr(a, o);
    return (c || i) && (this._active = a, this._updateHoverStyles(a, o, i)), this._lastEvent = d, c;
  }
  _getActiveElements(t, i, s, o) {
    if (t.type === "mouseout")
      return [];
    if (!s)
      return i;
    const n = this.options.hover;
    return this.getElementsAtEventForMode(t, n.mode, n, o);
  }
}, K(Xt, "defaults", Se), K(Xt, "instances", _n), K(Xt, "overrides", Vi), K(Xt, "registry", bt), K(Xt, "version", f1), K(Xt, "getChart", Xu), Xt);
function Zu() {
  return ie(Ar.instances, (e) => e._plugins.invalidate());
}
function Zf(e, t, i = t) {
  e.lineCap = Y(i.borderCapStyle, t.borderCapStyle), e.setLineDash(Y(i.borderDash, t.borderDash)), e.lineDashOffset = Y(i.borderDashOffset, t.borderDashOffset), e.lineJoin = Y(i.borderJoinStyle, t.borderJoinStyle), e.lineWidth = Y(i.borderWidth, t.borderWidth), e.strokeStyle = Y(i.borderColor, t.borderColor);
}
function b1(e, t, i) {
  e.lineTo(i.x, i.y);
}
function y1(e) {
  return e.stepped ? sL : e.tension || e.cubicInterpolationMode === "monotone" ? oL : b1;
}
function Jf(e, t, i = {}) {
  const s = e.length, { start: o = 0, end: n = s - 1 } = i, { start: r, end: a } = t, l = Math.max(o, r), d = Math.min(n, a), c = o < r && n < r || o > a && n > a;
  return {
    count: s,
    start: l,
    loop: t.loop,
    ilen: d < l && !c ? s + d - l : d - l
  };
}
function S1(e, t, i, s) {
  const { points: o, options: n } = t, { count: r, start: a, loop: l, ilen: d } = Jf(o, i, s), c = y1(n);
  let { move: u = !0, reverse: h } = s || {}, g, p, f;
  for (g = 0; g <= d; ++g)
    p = o[(a + (h ? d - g : g)) % r], !p.skip && (u ? (e.moveTo(p.x, p.y), u = !1) : c(e, f, p, h, n.stepped), f = p);
  return l && (p = o[(a + (h ? d : 0)) % r], c(e, f, p, h, n.stepped)), !!l;
}
function R1(e, t, i, s) {
  const o = t.points, { count: n, start: r, ilen: a } = Jf(o, i, s), { move: l = !0, reverse: d } = s || {};
  let c = 0, u = 0, h, g, p, f, m, C;
  const v = (b) => (r + (d ? a - b : b)) % n, R = () => {
    f !== m && (e.lineTo(c, m), e.lineTo(c, f), e.lineTo(c, C));
  };
  for (l && (g = o[v(0)], e.moveTo(g.x, g.y)), h = 0; h <= a; ++h) {
    if (g = o[v(h)], g.skip)
      continue;
    const b = g.x, w = g.y, x = b | 0;
    x === p ? (w < f ? f = w : w > m && (m = w), c = (u * c + b) / ++u) : (R(), e.lineTo(b, w), p = x, u = 0, f = m = w), C = w;
  }
  R();
}
function vl(e) {
  const t = e.options, i = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !i ? R1 : S1;
}
function x1(e) {
  return e.stepped ? HL : e.tension || e.cubicInterpolationMode === "monotone" ? BL : Si;
}
function F1(e, t, i, s) {
  let o = t._path;
  o || (o = t._path = new Path2D(), t.path(o, i, s) && o.closePath()), Zf(e, t.options), e.stroke(o);
}
function P1(e, t, i, s) {
  const { segments: o, options: n } = t, r = vl(t);
  for (const a of o)
    Zf(e, n, a.style), e.beginPath(), r(e, t, a, {
      start: i,
      end: i + s - 1
    }) && e.closePath(), e.stroke();
}
const E1 = typeof Path2D == "function";
function D1(e, t, i, s) {
  E1 && !t.options.segment ? F1(e, t, i, s) : P1(e, t, i, s);
}
class Js extends Ki {
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, i) {
    const s = this.options;
    if ((s.tension || s.cubicInterpolationMode === "monotone") && !s.stepped && !this._pointsUpdated) {
      const o = s.spanGaps ? this._loop : this._fullLoop;
      TL(this._points, s, t, o, i), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = KL(this, this.options.segment));
  }
  first() {
    const t = this.segments, i = this.points;
    return t.length && i[t[0].start];
  }
  last() {
    const t = this.segments, i = this.points, s = t.length;
    return s && i[t[s - 1].end];
  }
  interpolate(t, i) {
    const s = this.options, o = t[i], n = this.points, r = zL(this, {
      property: i,
      start: o,
      end: o
    });
    if (!r.length)
      return;
    const a = [], l = x1(s);
    let d, c;
    for (d = 0, c = r.length; d < c; ++d) {
      const { start: u, end: h } = r[d], g = n[u], p = n[h];
      if (g === p) {
        a.push(g);
        continue;
      }
      const f = Math.abs((o - g[i]) / (p[i] - g[i])), m = l(g, p, f, s.stepped);
      m[i] = t[i], a.push(m);
    }
    return a.length === 1 ? a[0] : a;
  }
  pathSegment(t, i, s) {
    return vl(this)(t, this, i, s);
  }
  path(t, i, s) {
    const o = this.segments, n = vl(this);
    let r = this._loop;
    i = i || 0, s = s || this.points.length - i;
    for (const a of o)
      r &= n(t, this, a, {
        start: i,
        end: i + s - 1
      });
    return !!r;
  }
  draw(t, i, s, o) {
    const n = this.options || {};
    (this.points || []).length && n.borderWidth && (t.save(), D1(t, this, s, o), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
K(Js, "id", "line"), K(Js, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), K(Js, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), K(Js, "descriptors", {
  _scriptable: !0,
  _indexable: (t) => t !== "borderDash" && t !== "fill"
});
function Ju(e, t, i, s) {
  const o = e.options, { [i]: n } = e.getProps([
    i
  ], s);
  return Math.abs(t - n) < o.radius + o.hitRadius;
}
class Hn extends Ki {
  constructor(i) {
    super();
    K(this, "parsed");
    K(this, "skip");
    K(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, i && Object.assign(this, i);
  }
  inRange(i, s, o) {
    const n = this.options, { x: r, y: a } = this.getProps([
      "x",
      "y"
    ], o);
    return Math.pow(i - r, 2) + Math.pow(s - a, 2) < Math.pow(n.hitRadius + n.radius, 2);
  }
  inXRange(i, s) {
    return Ju(this, i, "x", s);
  }
  inYRange(i, s) {
    return Ju(this, i, "y", s);
  }
  getCenterPoint(i) {
    const { x: s, y: o } = this.getProps([
      "x",
      "y"
    ], i);
    return {
      x: s,
      y: o
    };
  }
  size(i) {
    i = i || this.options || {};
    let s = i.radius || 0;
    s = Math.max(s, s && i.hoverRadius || 0);
    const o = s && i.borderWidth || 0;
    return (s + o) * 2;
  }
  draw(i, s) {
    const o = this.options;
    this.skip || o.radius < 0.1 || !Oo(this, s, this.size(o) / 2) || (i.strokeStyle = o.borderColor, i.lineWidth = o.borderWidth, i.fillStyle = o.backgroundColor, pl(i, o, this.x, this.y));
  }
  getRange() {
    const i = this.options || {};
    return i.radius + i.hitRadius;
  }
}
K(Hn, "id", "point"), /**
* @type {any}
*/
K(Hn, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
K(Hn, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
const eh = (e, t) => {
  let { boxHeight: i = t, boxWidth: s = t } = e;
  return e.usePointStyle && (i = Math.min(i, t), s = e.pointStyleWidth || Math.min(s, t)), {
    boxWidth: s,
    boxHeight: i,
    itemHeight: Math.max(t, i)
  };
}, T1 = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class th extends Ki {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i, s) {
    this.maxWidth = t, this.maxHeight = i, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let i = ae(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (i = i.filter((s) => t.filter(s, this.chart.data))), t.sort && (i = i.sort((s, o) => t.sort(s, o, this.chart.data))), this.options.reverse && i.reverse(), this.legendItems = i;
  }
  fit() {
    const { options: t, ctx: i } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const s = t.labels, o = _e(s.font), n = o.size, r = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = eh(s, n);
    let d, c;
    i.font = o.string, this.isHorizontal() ? (d = this.maxWidth, c = this._fitRows(r, n, a, l) + 10) : (c = this.maxHeight, d = this._fitCols(r, o, a, l) + 10), this.width = Math.min(d, t.maxWidth || this.maxWidth), this.height = Math.min(c, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, i, s, o) {
    const { ctx: n, maxWidth: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], d = this.lineWidths = [
      0
    ], c = o + a;
    let u = t;
    n.textAlign = "left", n.textBaseline = "middle";
    let h = -1, g = -c;
    return this.legendItems.forEach((p, f) => {
      const m = s + i / 2 + n.measureText(p.text).width;
      (f === 0 || d[d.length - 1] + m + 2 * a > r) && (u += c, d[d.length - (f > 0 ? 0 : 1)] = 0, g += c, h++), l[f] = {
        left: 0,
        top: g,
        row: h,
        width: m,
        height: o
      }, d[d.length - 1] += m + a;
    }), u;
  }
  _fitCols(t, i, s, o) {
    const { ctx: n, maxHeight: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], d = this.columnSizes = [], c = r - t;
    let u = a, h = 0, g = 0, p = 0, f = 0;
    return this.legendItems.forEach((m, C) => {
      const { itemWidth: v, itemHeight: R } = M1(s, i, n, m, o);
      C > 0 && g + R + 2 * a > c && (u += h + a, d.push({
        width: h,
        height: g
      }), p += h + a, f++, h = g = 0), l[C] = {
        left: p,
        top: g,
        col: f,
        width: v,
        height: R
      }, h = Math.max(h, v), g += R + a;
    }), u += h, d.push({
      width: h,
      height: g
    }), u;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: i, options: { align: s, labels: { padding: o }, rtl: n } } = this, r = Cs(n, this.left, this.width);
    if (this.isHorizontal()) {
      let a = 0, l = Le(s, this.left + o, this.right - this.lineWidths[a]);
      for (const d of i)
        a !== d.row && (a = d.row, l = Le(s, this.left + o, this.right - this.lineWidths[a])), d.top += this.top + t + o, d.left = r.leftForLtr(r.x(l), d.width), l += d.width + o;
    } else {
      let a = 0, l = Le(s, this.top + t + o, this.bottom - this.columnSizes[a].height);
      for (const d of i)
        d.col !== a && (a = d.col, l = Le(s, this.top + t + o, this.bottom - this.columnSizes[a].height)), d.top = l, d.left += this.left + o, d.left = r.leftForLtr(r.x(d.left), d.width), l += d.height + o;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      wd(t, this), this._draw(), bd(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: i, lineWidths: s, ctx: o } = this, { align: n, labels: r } = t, a = Se.color, l = Cs(t.rtl, this.left, this.width), d = _e(r.font), { padding: c } = r, u = d.size, h = u / 2;
    let g;
    this.drawTitle(), o.textAlign = l.textAlign("left"), o.textBaseline = "middle", o.lineWidth = 0.5, o.font = d.string;
    const { boxWidth: p, boxHeight: f, itemHeight: m } = eh(r, u), C = function(x, F, D) {
      if (isNaN(p) || p <= 0 || isNaN(f) || f < 0)
        return;
      o.save();
      const T = Y(D.lineWidth, 1);
      if (o.fillStyle = Y(D.fillStyle, a), o.lineCap = Y(D.lineCap, "butt"), o.lineDashOffset = Y(D.lineDashOffset, 0), o.lineJoin = Y(D.lineJoin, "miter"), o.lineWidth = T, o.strokeStyle = Y(D.strokeStyle, a), o.setLineDash(Y(D.lineDash, [])), r.usePointStyle) {
        const k = {
          radius: f * Math.SQRT2 / 2,
          pointStyle: D.pointStyle,
          rotation: D.rotation,
          borderWidth: T
        }, A = l.xPlus(x, p / 2), G = F + h;
        Af(o, k, A, G, r.pointStyleWidth && p);
      } else {
        const k = F + Math.max((u - f) / 2, 0), A = l.leftForLtr(x, p), G = po(D.borderRadius);
        o.beginPath(), Object.values(G).some(($) => $ !== 0) ? fl(o, {
          x: A,
          y: k,
          w: p,
          h: f,
          radius: G
        }) : o.rect(A, k, p, f), o.fill(), T !== 0 && o.stroke();
      }
      o.restore();
    }, v = function(x, F, D) {
      _o(o, D.text, x, F + m / 2, d, {
        strikethrough: D.hidden,
        textAlign: l.textAlign(D.textAlign)
      });
    }, R = this.isHorizontal(), b = this._computeTitleHeight();
    R ? g = {
      x: Le(n, this.left + c, this.right - s[0]),
      y: this.top + c + b,
      line: 0
    } : g = {
      x: this.left + c,
      y: Le(n, this.top + b + c, this.bottom - i[0].height),
      line: 0
    }, Bf(this.ctx, t.textDirection);
    const w = m + c;
    this.legendItems.forEach((x, F) => {
      o.strokeStyle = x.fontColor, o.fillStyle = x.fontColor;
      const D = o.measureText(x.text).width, T = l.textAlign(x.textAlign || (x.textAlign = r.textAlign)), k = p + h + D;
      let A = g.x, G = g.y;
      l.setWidth(this.width), R ? F > 0 && A + k + c > this.right && (G = g.y += w, g.line++, A = g.x = Le(n, this.left + c, this.right - s[g.line])) : F > 0 && G + w > this.bottom && (A = g.x = A + i[g.line].width + c, g.line++, G = g.y = Le(n, this.top + b + c, this.bottom - i[g.line].height));
      const $ = l.x(A);
      if (C($, G, x), A = Uk(T, A + p + h, R ? A + k : this.right, t.rtl), v(l.x(A), G, x), R)
        g.x += k + c;
      else if (typeof x.text != "string") {
        const q = d.lineHeight;
        g.y += em(x, q) + c;
      } else
        g.y += w;
    }), Gf(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, i = t.title, s = _e(i.font), o = ot(i.padding);
    if (!i.display)
      return;
    const n = Cs(t.rtl, this.left, this.width), r = this.ctx, a = i.position, l = s.size / 2, d = o.top + l;
    let c, u = this.left, h = this.width;
    if (this.isHorizontal())
      h = Math.max(...this.lineWidths), c = this.top + d, u = Le(t.align, u, this.right - h);
    else {
      const p = this.columnSizes.reduce((f, m) => Math.max(f, m.height), 0);
      c = d + Le(t.align, this.top, this.bottom - p - t.labels.padding - this._computeTitleHeight());
    }
    const g = Le(a, u, u + h);
    r.textAlign = n.textAlign(Cd(a)), r.textBaseline = "middle", r.strokeStyle = i.color, r.fillStyle = i.color, r.font = s.string, _o(r, i.text, g, c, s);
  }
  _computeTitleHeight() {
    const t = this.options.title, i = _e(t.font), s = ot(t.padding);
    return t.display ? i.lineHeight + s.height : 0;
  }
  _getLegendItemAt(t, i) {
    let s, o, n;
    if (Xs(t, this.left, this.right) && Xs(i, this.top, this.bottom)) {
      for (n = this.legendHitBoxes, s = 0; s < n.length; ++s)
        if (o = n[s], Xs(t, o.left, o.left + o.width) && Xs(i, o.top, o.top + o.height))
          return this.legendItems[s];
    }
    return null;
  }
  handleEvent(t) {
    const i = this.options;
    if (!k1(t.type, i))
      return;
    const s = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const o = this._hoveredItem, n = T1(o, s);
      o && !n && ae(i.onLeave, [
        t,
        o,
        this
      ], this), this._hoveredItem = s, s && !n && ae(i.onHover, [
        t,
        s,
        this
      ], this);
    } else s && ae(i.onClick, [
      t,
      s,
      this
    ], this);
  }
}
function M1(e, t, i, s, o) {
  const n = A1(s, e, t, i), r = I1(o, s, t.lineHeight);
  return {
    itemWidth: n,
    itemHeight: r
  };
}
function A1(e, t, i, s) {
  let o = e.text;
  return o && typeof o != "string" && (o = o.reduce((n, r) => n.length > r.length ? n : r)), t + i.size / 2 + s.measureText(o).width;
}
function I1(e, t, i) {
  let s = e;
  return typeof t.text != "string" && (s = em(t, i)), s;
}
function em(e, t) {
  const i = e.text ? e.text.length : 0;
  return t * i;
}
function k1(e, t) {
  return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"));
}
var L1 = {
  id: "legend",
  _element: th,
  start(e, t, i) {
    const s = e.legend = new th({
      ctx: e.ctx,
      options: i,
      chart: e
    });
    et.configure(e, s, i), et.addBox(e, s);
  },
  stop(e) {
    et.removeBox(e, e.legend), delete e.legend;
  },
  beforeUpdate(e, t, i) {
    const s = e.legend;
    et.configure(e, s, i), s.options = i;
  },
  afterUpdate(e) {
    const t = e.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, i) {
      const s = t.datasetIndex, o = i.chart;
      o.isDatasetVisible(s) ? (o.hide(s), t.hidden = !0) : (o.show(s), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets, { labels: { usePointStyle: i, pointStyle: s, textAlign: o, color: n, useBorderRadius: r, borderRadius: a } } = e.legend.options;
        return e._getSortedDatasetMetas().map((l) => {
          const d = l.controller.getStyle(i ? 0 : void 0), c = ot(d.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: d.backgroundColor,
            fontColor: n,
            hidden: !l.visible,
            lineCap: d.borderCapStyle,
            lineDash: d.borderDash,
            lineDashOffset: d.borderDashOffset,
            lineJoin: d.borderJoinStyle,
            lineWidth: (c.width + c.height) / 4,
            strokeStyle: d.borderColor,
            pointStyle: s || d.pointStyle,
            rotation: d.rotation,
            textAlign: o || d.textAlign,
            borderRadius: r && (a || d.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (e) => e.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith("on"),
    labels: {
      _scriptable: (e) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(e)
    }
  }
};
class tm extends Ki {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i) {
    const s = this.options;
    if (this.left = 0, this.top = 0, !s.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = i;
    const o = Fe(s.text) ? s.text.length : 1;
    this._padding = ot(s.padding);
    const n = o * _e(s.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = n : this.width = n;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: i, left: s, bottom: o, right: n, options: r } = this, a = r.align;
    let l = 0, d, c, u;
    return this.isHorizontal() ? (c = Le(a, s, n), u = i + t, d = n - s) : (r.position === "left" ? (c = s + t, u = Le(a, o, i), l = Pe * -0.5) : (c = n - t, u = Le(a, i, o), l = Pe * 0.5), d = o - i), {
      titleX: c,
      titleY: u,
      maxWidth: d,
      rotation: l
    };
  }
  draw() {
    const t = this.ctx, i = this.options;
    if (!i.display)
      return;
    const s = _e(i.font), n = s.lineHeight / 2 + this._padding.top, { titleX: r, titleY: a, maxWidth: l, rotation: d } = this._drawArgs(n);
    _o(t, i.text, 0, 0, s, {
      color: i.color,
      maxWidth: l,
      rotation: d,
      textAlign: Cd(i.align),
      textBaseline: "middle",
      translation: [
        r,
        a
      ]
    });
  }
}
function O1(e, t) {
  const i = new tm({
    ctx: e.ctx,
    options: t,
    chart: e
  });
  et.configure(e, i, t), et.addBox(e, i), e.titleBlock = i;
}
var _1 = {
  id: "title",
  _element: tm,
  start(e, t, i) {
    O1(e, i);
  },
  stop(e) {
    const t = e.titleBlock;
    et.removeBox(e, t), delete e.titleBlock;
  },
  beforeUpdate(e, t, i) {
    const s = e.titleBlock;
    et.configure(e, s, i), s.options = i;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const eo = {
  average(e) {
    if (!e.length)
      return !1;
    let t, i, s = /* @__PURE__ */ new Set(), o = 0, n = 0;
    for (t = 0, i = e.length; t < i; ++t) {
      const a = e[t].element;
      if (a && a.hasValue()) {
        const l = a.tooltipPosition();
        s.add(l.x), o += l.y, ++n;
      }
    }
    return n === 0 || s.size === 0 ? !1 : {
      x: [
        ...s
      ].reduce((a, l) => a + l) / s.size,
      y: o / n
    };
  },
  nearest(e, t) {
    if (!e.length)
      return !1;
    let i = t.x, s = t.y, o = Number.POSITIVE_INFINITY, n, r, a;
    for (n = 0, r = e.length; n < r; ++n) {
      const l = e[n].element;
      if (l && l.hasValue()) {
        const d = l.getCenterPoint(), c = hl(t, d);
        c < o && (o = c, a = l);
      }
    }
    if (a) {
      const l = a.tooltipPosition();
      i = l.x, s = l.y;
    }
    return {
      x: i,
      y: s
    };
  }
};
function wt(e, t) {
  return t && (Fe(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function Ot(e) {
  return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e;
}
function H1(e, t) {
  const { element: i, datasetIndex: s, index: o } = t, n = e.getDatasetMeta(s).controller, { label: r, value: a } = n.getLabelAndValue(o);
  return {
    chart: e,
    label: r,
    parsed: n.getParsed(o),
    raw: e.data.datasets[s].data[o],
    formattedValue: a,
    dataset: n.getDataset(),
    dataIndex: o,
    datasetIndex: s,
    element: i
  };
}
function ih(e, t) {
  const i = e.chart.ctx, { body: s, footer: o, title: n } = e, { boxWidth: r, boxHeight: a } = t, l = _e(t.bodyFont), d = _e(t.titleFont), c = _e(t.footerFont), u = n.length, h = o.length, g = s.length, p = ot(t.padding);
  let f = p.height, m = 0, C = s.reduce((b, w) => b + w.before.length + w.lines.length + w.after.length, 0);
  if (C += e.beforeBody.length + e.afterBody.length, u && (f += u * d.lineHeight + (u - 1) * t.titleSpacing + t.titleMarginBottom), C) {
    const b = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
    f += g * b + (C - g) * l.lineHeight + (C - 1) * t.bodySpacing;
  }
  h && (f += t.footerMarginTop + h * c.lineHeight + (h - 1) * t.footerSpacing);
  let v = 0;
  const R = function(b) {
    m = Math.max(m, i.measureText(b).width + v);
  };
  return i.save(), i.font = d.string, ie(e.title, R), i.font = l.string, ie(e.beforeBody.concat(e.afterBody), R), v = t.displayColors ? r + 2 + t.boxPadding : 0, ie(s, (b) => {
    ie(b.before, R), ie(b.lines, R), ie(b.after, R);
  }), v = 0, i.font = c.string, ie(e.footer, R), i.restore(), m += p.width, {
    width: m,
    height: f
  };
}
function B1(e, t) {
  const { y: i, height: s } = t;
  return i < s / 2 ? "top" : i > e.height - s / 2 ? "bottom" : "center";
}
function G1(e, t, i, s) {
  const { x: o, width: n } = s, r = i.caretSize + i.caretPadding;
  if (e === "left" && o + n + r > t.width || e === "right" && o - n - r < 0)
    return !0;
}
function V1(e, t, i, s) {
  const { x: o, width: n } = i, { width: r, chartArea: { left: a, right: l } } = e;
  let d = "center";
  return s === "center" ? d = o <= (a + l) / 2 ? "left" : "right" : o <= n / 2 ? d = "left" : o >= r - n / 2 && (d = "right"), G1(d, e, t, i) && (d = "center"), d;
}
function sh(e, t, i) {
  const s = i.yAlign || t.yAlign || B1(e, i);
  return {
    xAlign: i.xAlign || t.xAlign || V1(e, t, i, s),
    yAlign: s
  };
}
function N1(e, t) {
  let { x: i, width: s } = e;
  return t === "right" ? i -= s : t === "center" && (i -= s / 2), i;
}
function W1(e, t, i) {
  let { y: s, height: o } = e;
  return t === "top" ? s += i : t === "bottom" ? s -= o + i : s -= o / 2, s;
}
function oh(e, t, i, s) {
  const { caretSize: o, caretPadding: n, cornerRadius: r } = e, { xAlign: a, yAlign: l } = i, d = o + n, { topLeft: c, topRight: u, bottomLeft: h, bottomRight: g } = po(r);
  let p = N1(t, a);
  const f = W1(t, l, d);
  return l === "center" ? a === "left" ? p += d : a === "right" && (p -= d) : a === "left" ? p -= Math.max(c, h) + o : a === "right" && (p += Math.max(u, g) + o), {
    x: Je(p, 0, s.width - t.width),
    y: Je(f, 0, s.height - t.height)
  };
}
function yn(e, t, i) {
  const s = ot(i.padding);
  return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - s.right : e.x + s.left;
}
function nh(e) {
  return wt([], Ot(e));
}
function z1(e, t, i) {
  return $i(e, {
    tooltip: t,
    tooltipItems: i,
    type: "tooltip"
  });
}
function rh(e, t) {
  const i = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return i ? e.override(i) : e;
}
const im = {
  beforeTitle: kt,
  title(e) {
    if (e.length > 0) {
      const t = e[0], i = t.chart.data.labels, s = i ? i.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (s > 0 && t.dataIndex < s)
        return i[t.dataIndex];
    }
    return "";
  },
  afterTitle: kt,
  beforeBody: kt,
  beforeLabel: kt,
  label(e) {
    if (this && this.options && this.options.mode === "dataset")
      return e.label + ": " + e.formattedValue || e.formattedValue;
    let t = e.dataset.label || "";
    t && (t += ": ");
    const i = e.formattedValue;
    return re(i) || (t += i), t;
  },
  labelColor(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      borderColor: i.borderColor,
      backgroundColor: i.backgroundColor,
      borderWidth: i.borderWidth,
      borderDash: i.borderDash,
      borderDashOffset: i.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      pointStyle: i.pointStyle,
      rotation: i.rotation
    };
  },
  afterLabel: kt,
  afterBody: kt,
  beforeFooter: kt,
  footer: kt,
  afterFooter: kt
};
function Ve(e, t, i, s) {
  const o = e[t].call(i, s);
  return typeof o > "u" ? im[t].call(i, s) : o;
}
class wl extends Ki {
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const i = this.chart, s = this.options.setContext(this.getContext()), o = s.enabled && i.options.animation && s.animations, n = new Nf(this.chart, o);
    return o._cacheable && (this._cachedAnimations = Object.freeze(n)), n;
  }
  getContext() {
    return this.$context || (this.$context = z1(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, i) {
    const { callbacks: s } = i, o = Ve(s, "beforeTitle", this, t), n = Ve(s, "title", this, t), r = Ve(s, "afterTitle", this, t);
    let a = [];
    return a = wt(a, Ot(o)), a = wt(a, Ot(n)), a = wt(a, Ot(r)), a;
  }
  getBeforeBody(t, i) {
    return nh(Ve(i.callbacks, "beforeBody", this, t));
  }
  getBody(t, i) {
    const { callbacks: s } = i, o = [];
    return ie(t, (n) => {
      const r = {
        before: [],
        lines: [],
        after: []
      }, a = rh(s, n);
      wt(r.before, Ot(Ve(a, "beforeLabel", this, n))), wt(r.lines, Ve(a, "label", this, n)), wt(r.after, Ot(Ve(a, "afterLabel", this, n))), o.push(r);
    }), o;
  }
  getAfterBody(t, i) {
    return nh(Ve(i.callbacks, "afterBody", this, t));
  }
  getFooter(t, i) {
    const { callbacks: s } = i, o = Ve(s, "beforeFooter", this, t), n = Ve(s, "footer", this, t), r = Ve(s, "afterFooter", this, t);
    let a = [];
    return a = wt(a, Ot(o)), a = wt(a, Ot(n)), a = wt(a, Ot(r)), a;
  }
  _createItems(t) {
    const i = this._active, s = this.chart.data, o = [], n = [], r = [];
    let a = [], l, d;
    for (l = 0, d = i.length; l < d; ++l)
      a.push(H1(this.chart, i[l]));
    return t.filter && (a = a.filter((c, u, h) => t.filter(c, u, h, s))), t.itemSort && (a = a.sort((c, u) => t.itemSort(c, u, s))), ie(a, (c) => {
      const u = rh(t.callbacks, c);
      o.push(Ve(u, "labelColor", this, c)), n.push(Ve(u, "labelPointStyle", this, c)), r.push(Ve(u, "labelTextColor", this, c));
    }), this.labelColors = o, this.labelPointStyles = n, this.labelTextColors = r, this.dataPoints = a, a;
  }
  update(t, i) {
    const s = this.options.setContext(this.getContext()), o = this._active;
    let n, r = [];
    if (!o.length)
      this.opacity !== 0 && (n = {
        opacity: 0
      });
    else {
      const a = eo[s.position].call(this, o, this._eventPosition);
      r = this._createItems(s), this.title = this.getTitle(r, s), this.beforeBody = this.getBeforeBody(r, s), this.body = this.getBody(r, s), this.afterBody = this.getAfterBody(r, s), this.footer = this.getFooter(r, s);
      const l = this._size = ih(this, s), d = Object.assign({}, a, l), c = sh(this.chart, s, d), u = oh(s, d, c, this.chart);
      this.xAlign = c.xAlign, this.yAlign = c.yAlign, n = {
        opacity: 1,
        x: u.x,
        y: u.y,
        width: l.width,
        height: l.height,
        caretX: a.x,
        caretY: a.y
      };
    }
    this._tooltipItems = r, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && s.external && s.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: i
    });
  }
  drawCaret(t, i, s, o) {
    const n = this.getCaretPosition(t, s, o);
    i.lineTo(n.x1, n.y1), i.lineTo(n.x2, n.y2), i.lineTo(n.x3, n.y3);
  }
  getCaretPosition(t, i, s) {
    const { xAlign: o, yAlign: n } = this, { caretSize: r, cornerRadius: a } = s, { topLeft: l, topRight: d, bottomLeft: c, bottomRight: u } = po(a), { x: h, y: g } = t, { width: p, height: f } = i;
    let m, C, v, R, b, w;
    return n === "center" ? (b = g + f / 2, o === "left" ? (m = h, C = m - r, R = b + r, w = b - r) : (m = h + p, C = m + r, R = b - r, w = b + r), v = m) : (o === "left" ? C = h + Math.max(l, c) + r : o === "right" ? C = h + p - Math.max(d, u) - r : C = this.caretX, n === "top" ? (R = g, b = R - r, m = C - r, v = C + r) : (R = g + f, b = R + r, m = C + r, v = C - r), w = R), {
      x1: m,
      x2: C,
      x3: v,
      y1: R,
      y2: b,
      y3: w
    };
  }
  drawTitle(t, i, s) {
    const o = this.title, n = o.length;
    let r, a, l;
    if (n) {
      const d = Cs(s.rtl, this.x, this.width);
      for (t.x = yn(this, s.titleAlign, s), i.textAlign = d.textAlign(s.titleAlign), i.textBaseline = "middle", r = _e(s.titleFont), a = s.titleSpacing, i.fillStyle = s.titleColor, i.font = r.string, l = 0; l < n; ++l)
        i.fillText(o[l], d.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + a, l + 1 === n && (t.y += s.titleMarginBottom - a);
    }
  }
  _drawColorBox(t, i, s, o, n) {
    const r = this.labelColors[s], a = this.labelPointStyles[s], { boxHeight: l, boxWidth: d } = n, c = _e(n.bodyFont), u = yn(this, "left", n), h = o.x(u), g = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, p = i.y + g;
    if (n.usePointStyle) {
      const f = {
        radius: Math.min(d, l) / 2,
        pointStyle: a.pointStyle,
        rotation: a.rotation,
        borderWidth: 1
      }, m = o.leftForLtr(h, d) + d / 2, C = p + l / 2;
      t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, pl(t, f, m, C), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, pl(t, f, m, C);
    } else {
      t.lineWidth = ee(r.borderWidth) ? Math.max(...Object.values(r.borderWidth)) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0;
      const f = o.leftForLtr(h, d), m = o.leftForLtr(o.xPlus(h, 1), d - 2), C = po(r.borderRadius);
      Object.values(C).some((v) => v !== 0) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, fl(t, {
        x: f,
        y: p,
        w: d,
        h: l,
        radius: C
      }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), fl(t, {
        x: m,
        y: p + 1,
        w: d - 2,
        h: l - 2,
        radius: C
      }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(f, p, d, l), t.strokeRect(f, p, d, l), t.fillStyle = r.backgroundColor, t.fillRect(m, p + 1, d - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[s];
  }
  drawBody(t, i, s) {
    const { body: o } = this, { bodySpacing: n, bodyAlign: r, displayColors: a, boxHeight: l, boxWidth: d, boxPadding: c } = s, u = _e(s.bodyFont);
    let h = u.lineHeight, g = 0;
    const p = Cs(s.rtl, this.x, this.width), f = function(D) {
      i.fillText(D, p.x(t.x + g), t.y + h / 2), t.y += h + n;
    }, m = p.textAlign(r);
    let C, v, R, b, w, x, F;
    for (i.textAlign = r, i.textBaseline = "middle", i.font = u.string, t.x = yn(this, m, s), i.fillStyle = s.bodyColor, ie(this.beforeBody, f), g = a && m !== "right" ? r === "center" ? d / 2 + c : d + 2 + c : 0, b = 0, x = o.length; b < x; ++b) {
      for (C = o[b], v = this.labelTextColors[b], i.fillStyle = v, ie(C.before, f), R = C.lines, a && R.length && (this._drawColorBox(i, t, b, p, s), h = Math.max(u.lineHeight, l)), w = 0, F = R.length; w < F; ++w)
        f(R[w]), h = u.lineHeight;
      ie(C.after, f);
    }
    g = 0, h = u.lineHeight, ie(this.afterBody, f), t.y -= n;
  }
  drawFooter(t, i, s) {
    const o = this.footer, n = o.length;
    let r, a;
    if (n) {
      const l = Cs(s.rtl, this.x, this.width);
      for (t.x = yn(this, s.footerAlign, s), t.y += s.footerMarginTop, i.textAlign = l.textAlign(s.footerAlign), i.textBaseline = "middle", r = _e(s.footerFont), i.fillStyle = s.footerColor, i.font = r.string, a = 0; a < n; ++a)
        i.fillText(o[a], l.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + s.footerSpacing;
    }
  }
  drawBackground(t, i, s, o) {
    const { xAlign: n, yAlign: r } = this, { x: a, y: l } = t, { width: d, height: c } = s, { topLeft: u, topRight: h, bottomLeft: g, bottomRight: p } = po(o.cornerRadius);
    i.fillStyle = o.backgroundColor, i.strokeStyle = o.borderColor, i.lineWidth = o.borderWidth, i.beginPath(), i.moveTo(a + u, l), r === "top" && this.drawCaret(t, i, s, o), i.lineTo(a + d - h, l), i.quadraticCurveTo(a + d, l, a + d, l + h), r === "center" && n === "right" && this.drawCaret(t, i, s, o), i.lineTo(a + d, l + c - p), i.quadraticCurveTo(a + d, l + c, a + d - p, l + c), r === "bottom" && this.drawCaret(t, i, s, o), i.lineTo(a + g, l + c), i.quadraticCurveTo(a, l + c, a, l + c - g), r === "center" && n === "left" && this.drawCaret(t, i, s, o), i.lineTo(a, l + u), i.quadraticCurveTo(a, l, a + u, l), i.closePath(), i.fill(), o.borderWidth > 0 && i.stroke();
  }
  _updateAnimationTarget(t) {
    const i = this.chart, s = this.$animations, o = s && s.x, n = s && s.y;
    if (o || n) {
      const r = eo[t.position].call(this, this._active, this._eventPosition);
      if (!r)
        return;
      const a = this._size = ih(this, t), l = Object.assign({}, r, this._size), d = sh(i, t, l), c = oh(t, l, d, i);
      (o._to !== c.x || n._to !== c.y) && (this.xAlign = d.xAlign, this.yAlign = d.yAlign, this.width = a.width, this.height = a.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, c));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const i = this.options.setContext(this.getContext());
    let s = this.opacity;
    if (!s)
      return;
    this._updateAnimationTarget(i);
    const o = {
      width: this.width,
      height: this.height
    }, n = {
      x: this.x,
      y: this.y
    };
    s = Math.abs(s) < 1e-3 ? 0 : s;
    const r = ot(i.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    i.enabled && a && (t.save(), t.globalAlpha = s, this.drawBackground(n, t, o, i), Bf(t, i.textDirection), n.y += r.top, this.drawTitle(n, t, i), this.drawBody(n, t, i), this.drawFooter(n, t, i), Gf(t, i.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, i) {
    const s = this._active, o = t.map(({ datasetIndex: a, index: l }) => {
      const d = this.chart.getDatasetMeta(a);
      if (!d)
        throw new Error("Cannot find a dataset at index " + a);
      return {
        datasetIndex: a,
        element: d.data[l],
        index: l
      };
    }), n = !dr(s, o), r = this._positionChanged(o, i);
    (n || r) && (this._active = o, this._eventPosition = i, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, i, s = !0) {
    if (i && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const o = this.options, n = this._active || [], r = this._getActiveElements(t, n, i, s), a = this._positionChanged(r, t), l = i || !dr(r, n) || a;
    return l && (this._active = r, (o.enabled || o.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, i))), l;
  }
  _getActiveElements(t, i, s, o) {
    const n = this.options;
    if (t.type === "mouseout")
      return [];
    if (!o)
      return i.filter((a) => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0);
    const r = this.chart.getElementsAtEventForMode(t, n.mode, n, s);
    return n.reverse && r.reverse(), r;
  }
  _positionChanged(t, i) {
    const { caretX: s, caretY: o, options: n } = this, r = eo[n.position].call(this, t, i);
    return r !== !1 && (s !== r.x || o !== r.y);
  }
}
K(wl, "positioners", eo);
var U1 = {
  id: "tooltip",
  _element: wl,
  positioners: eo,
  afterInit(e, t, i) {
    i && (e.tooltip = new wl({
      chart: e,
      options: i
    }));
  },
  beforeUpdate(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  reset(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  afterDraw(e) {
    const t = e.tooltip;
    if (t && t._willRender()) {
      const i = {
        tooltip: t
      };
      if (e.notifyPlugins("beforeTooltipDraw", {
        ...i,
        cancelable: !0
      }) === !1)
        return;
      t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", i);
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const i = t.replay;
      e.tooltip.handleEvent(t.event, i, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: im
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (e) => e !== "filter" && e !== "itemSort" && e !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const $1 = (e, t, i, s) => (typeof t == "string" ? (i = e.push(t) - 1, s.unshift({
  index: i,
  label: t
})) : isNaN(t) && (i = null), i);
function K1(e, t, i, s) {
  const o = e.indexOf(t);
  if (o === -1)
    return $1(e, t, i, s);
  const n = e.lastIndexOf(t);
  return o !== n ? i : o;
}
const j1 = (e, t) => e === null ? null : Je(Math.round(e), 0, t);
function ah(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class bl extends Ms {
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const i = this._addedLabels;
    if (i.length) {
      const s = this.getLabels();
      for (const { index: o, label: n } of i)
        s[o] === n && s.splice(o, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, i) {
    if (re(t))
      return null;
    const s = this.getLabels();
    return i = isFinite(i) && s[i] === t ? i : K1(s, t, Y(i, t), this._addedLabels), j1(i, s.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: i } = this.getUserBounds();
    let { min: s, max: o } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (s = 0), i || (o = this.getLabels().length - 1)), this.min = s, this.max = o;
  }
  buildTicks() {
    const t = this.min, i = this.max, s = this.options.offset, o = [];
    let n = this.getLabels();
    n = t === 0 && i === n.length - 1 ? n : n.slice(t, i + 1), this._valueRange = Math.max(n.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? 0.5 : 0);
    for (let r = t; r <= i; r++)
      o.push({
        value: r
      });
    return o;
  }
  getLabelForValue(t) {
    return ah.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
K(bl, "id", "category"), K(bl, "defaults", {
  ticks: {
    callback: ah
  }
});
function q1(e, t) {
  const i = [], { bounds: o, step: n, min: r, max: a, precision: l, count: d, maxTicks: c, maxDigits: u, includeBounds: h } = e, g = n || 1, p = c - 1, { min: f, max: m } = t, C = !re(r), v = !re(a), R = !re(d), b = (m - f) / (u + 1);
  let w = hu((m - f) / p / g) * g, x, F, D, T;
  if (w < 1e-14 && !C && !v)
    return [
      {
        value: f
      },
      {
        value: m
      }
    ];
  T = Math.ceil(m / w) - Math.floor(f / w), T > p && (w = hu(T * w / p / g) * g), re(l) || (x = Math.pow(10, l), w = Math.ceil(w * x) / x), o === "ticks" ? (F = Math.floor(f / w) * w, D = Math.ceil(m / w) * w) : (F = f, D = m), C && v && n && kk((a - r) / n, w / 1e3) ? (T = Math.round(Math.min((a - r) / w, c)), w = (a - r) / T, F = r, D = a) : R ? (F = C ? r : F, D = v ? a : D, T = d - 1, w = (D - F) / T) : (T = (D - F) / w, uo(T, Math.round(T), w / 1e3) ? T = Math.round(T) : T = Math.ceil(T));
  const k = Math.max(gu(w), gu(F));
  x = Math.pow(10, re(l) ? k : l), F = Math.round(F * x) / x, D = Math.round(D * x) / x;
  let A = 0;
  for (C && (h && F !== r ? (i.push({
    value: r
  }), F < r && A++, uo(Math.round((F + A * w) * x) / x, r, lh(r, b, e)) && A++) : F < r && A++); A < T; ++A) {
    const G = Math.round((F + A * w) * x) / x;
    if (v && G > a)
      break;
    i.push({
      value: G
    });
  }
  return v && h && D !== a ? i.length && uo(i[i.length - 1].value, a, lh(a, b, e)) ? i[i.length - 1].value = a : i.push({
    value: a
  }) : (!v || D === a) && i.push({
    value: D
  }), i;
}
function lh(e, t, { horizontal: i, minRotation: s }) {
  const o = Fi(s), n = (i ? Math.sin(o) : Math.cos(o)) || 1e-3, r = 0.75 * t * ("" + e).length;
  return Math.min(t / n, r);
}
class Y1 extends Ms {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, i) {
    return re(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: i, maxDefined: s } = this.getUserBounds();
    let { min: o, max: n } = this;
    const r = (l) => o = i ? o : l, a = (l) => n = s ? n : l;
    if (t) {
      const l = xs(o), d = xs(n);
      l < 0 && d < 0 ? a(0) : l > 0 && d > 0 && r(0);
    }
    if (o === n) {
      let l = n === 0 ? 1 : Math.abs(n * 0.05);
      a(n + l), t || r(o - l);
    }
    this.min = o, this.max = n;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: i, stepSize: s } = t, o;
    return s ? (o = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, o > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${o} ticks. Limiting to 1000.`), o = 1e3)) : (o = this.computeTickLimit(), i = i || 11), i && (o = Math.min(i, o)), o;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, i = t.ticks;
    let s = this.getTickLimit();
    s = Math.max(2, s);
    const o = {
      maxTicks: s,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: i.precision,
      step: i.stepSize,
      count: i.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: i.minRotation || 0,
      includeBounds: i.includeBounds !== !1
    }, n = this._range || this, r = q1(o, n);
    return t.bounds === "ticks" && Lk(r, this, "value"), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;
  }
  configure() {
    const t = this.ticks;
    let i = this.min, s = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const o = (s - i) / Math.max(t.length - 1, 1) / 2;
      i -= o, s += o;
    }
    this._startValue = i, this._endValue = s, this._valueRange = s - i;
  }
  getLabelForValue(t) {
    return Tf(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class yl extends Y1 {
  determineDataLimits() {
    const { min: t, max: i } = this.getMinMax(!0);
    this.min = st(t) ? t : 0, this.max = st(i) ? i : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), i = t ? this.width : this.height, s = Fi(this.options.ticks.minRotation), o = (t ? Math.sin(s) : Math.cos(s)) || 1e-3, n = this._resolveTickFontOptions(0);
    return Math.ceil(i / Math.min(40, n.lineHeight / o));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
K(yl, "id", "linear"), K(yl, "defaults", {
  ticks: {
    callback: Mf.formatters.numeric
  }
});
const Ir = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, Ne = /* @__PURE__ */ Object.keys(Ir);
function dh(e, t) {
  return e - t;
}
function ch(e, t) {
  if (re(t))
    return null;
  const i = e._adapter, { parser: s, round: o, isoWeekday: n } = e._parseOpts;
  let r = t;
  return typeof s == "function" && (r = s(r)), st(r) || (r = typeof s == "string" ? i.parse(r, s) : i.parse(r)), r === null ? null : (o && (r = o === "week" && (Lo(n) || n === !0) ? i.startOf(r, "isoWeek", n) : i.startOf(r, o)), +r);
}
function uh(e, t, i, s) {
  const o = Ne.length;
  for (let n = Ne.indexOf(e); n < o - 1; ++n) {
    const r = Ir[Ne[n]], a = r.steps ? r.steps : Number.MAX_SAFE_INTEGER;
    if (r.common && Math.ceil((i - t) / (a * r.size)) <= s)
      return Ne[n];
  }
  return Ne[o - 1];
}
function Q1(e, t, i, s, o) {
  for (let n = Ne.length - 1; n >= Ne.indexOf(i); n--) {
    const r = Ne[n];
    if (Ir[r].common && e._adapter.diff(o, s, r) >= t - 1)
      return r;
  }
  return Ne[i ? Ne.indexOf(i) : 0];
}
function X1(e) {
  for (let t = Ne.indexOf(e) + 1, i = Ne.length; t < i; ++t)
    if (Ir[Ne[t]].common)
      return Ne[t];
}
function hh(e, t, i) {
  if (!i)
    e[t] = !0;
  else if (i.length) {
    const { lo: s, hi: o } = md(i, t), n = i[s] >= t ? i[s] : i[o];
    e[n] = !0;
  }
}
function Z1(e, t, i, s) {
  const o = e._adapter, n = +o.startOf(t[0].value, s), r = t[t.length - 1].value;
  let a, l;
  for (a = n; a <= r; a = +o.add(a, 1, s))
    l = i[a], l >= 0 && (t[l].major = !0);
  return t;
}
function gh(e, t, i) {
  const s = [], o = {}, n = t.length;
  let r, a;
  for (r = 0; r < n; ++r)
    a = t[r], o[a] = r, s.push({
      value: a,
      major: !1
    });
  return n === 0 || !i ? s : Z1(e, s, o, i);
}
class mr extends Ms {
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, i = {}) {
    const s = t.time || (t.time = {}), o = this._adapter = new uO._date(t.adapters.date);
    o.init(i), co(s.displayFormats, o.formats()), this._parseOpts = {
      parser: s.parser,
      round: s.round,
      isoWeekday: s.isoWeekday
    }, super.init(t), this._normalized = i.normalized;
  }
  parse(t, i) {
    return t === void 0 ? null : ch(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, i = this._adapter, s = t.time.unit || "day";
    let { min: o, max: n, minDefined: r, maxDefined: a } = this.getUserBounds();
    function l(d) {
      !r && !isNaN(d.min) && (o = Math.min(o, d.min)), !a && !isNaN(d.max) && (n = Math.max(n, d.max));
    }
    (!r || !a) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), o = st(o) && !isNaN(o) ? o : +i.startOf(Date.now(), s), n = st(n) && !isNaN(n) ? n : +i.endOf(Date.now(), s) + 1, this.min = Math.min(o, n - 1), this.max = Math.max(o + 1, n);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let i = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    return t.length && (i = t[0], s = t[t.length - 1]), {
      min: i,
      max: s
    };
  }
  buildTicks() {
    const t = this.options, i = t.time, s = t.ticks, o = s.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && o.length && (this.min = this._userMin || o[0], this.max = this._userMax || o[o.length - 1]);
    const n = this.min, r = this.max, a = Vk(o, n, r);
    return this._unit = i.unit || (s.autoSkip ? uh(i.minUnit, this.min, this.max, this._getLabelCapacity(n)) : Q1(this, a.length, i.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === "year" ? void 0 : X1(this._unit), this.initOffsets(o), t.reverse && a.reverse(), gh(this, a, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let i = 0, s = 0, o, n;
    this.options.offset && t.length && (o = this.getDecimalForValue(t[0]), t.length === 1 ? i = 1 - o : i = (this.getDecimalForValue(t[1]) - o) / 2, n = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s = n : s = (n - this.getDecimalForValue(t[t.length - 2])) / 2);
    const r = t.length < 3 ? 0.5 : 0.25;
    i = Je(i, 0, r), s = Je(s, 0, r), this._offsets = {
      start: i,
      end: s,
      factor: 1 / (i + 1 + s)
    };
  }
  _generate() {
    const t = this._adapter, i = this.min, s = this.max, o = this.options, n = o.time, r = n.unit || uh(n.minUnit, i, s, this._getLabelCapacity(i)), a = Y(o.ticks.stepSize, 1), l = r === "week" ? n.isoWeekday : !1, d = Lo(l) || l === !0, c = {};
    let u = i, h, g;
    if (d && (u = +t.startOf(u, "isoWeek", l)), u = +t.startOf(u, d ? "day" : r), t.diff(s, i, r) > 1e5 * a)
      throw new Error(i + " and " + s + " are too far apart with stepSize of " + a + " " + r);
    const p = o.ticks.source === "data" && this.getDataTimestamps();
    for (h = u, g = 0; h < s; h = +t.add(h, a, r), g++)
      hh(c, h, p);
    return (h === s || o.bounds === "ticks" || g === 1) && hh(c, h, p), Object.keys(c).sort(dh).map((f) => +f);
  }
  getLabelForValue(t) {
    const i = this._adapter, s = this.options.time;
    return s.tooltipFormat ? i.format(t, s.tooltipFormat) : i.format(t, s.displayFormats.datetime);
  }
  format(t, i) {
    const o = this.options.time.displayFormats, n = this._unit, r = i || o[n];
    return this._adapter.format(t, r);
  }
  _tickFormatFunction(t, i, s, o) {
    const n = this.options, r = n.ticks.callback;
    if (r)
      return ae(r, [
        t,
        i,
        s
      ], this);
    const a = n.time.displayFormats, l = this._unit, d = this._majorUnit, c = l && a[l], u = d && a[d], h = s[i], g = d && u && h && h.major;
    return this._adapter.format(t, o || (g ? u : c));
  }
  generateTickLabels(t) {
    let i, s, o;
    for (i = 0, s = t.length; i < s; ++i)
      o = t[i], o.label = this._tickFormatFunction(o.value, i, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const i = this._offsets, s = this.getDecimalForValue(t);
    return this.getPixelForDecimal((i.start + s) * i.factor);
  }
  getValueForPixel(t) {
    const i = this._offsets, s = this.getDecimalForPixel(t) / i.factor - i.end;
    return this.min + s * (this.max - this.min);
  }
  _getLabelSize(t) {
    const i = this.options.ticks, s = this.ctx.measureText(t).width, o = Fi(this.isHorizontal() ? i.maxRotation : i.minRotation), n = Math.cos(o), r = Math.sin(o), a = this._resolveTickFontOptions(0).size;
    return {
      w: s * n + a * r,
      h: s * r + a * n
    };
  }
  _getLabelCapacity(t) {
    const i = this.options.time, s = i.displayFormats, o = s[i.unit] || s.millisecond, n = this._tickFormatFunction(t, 0, gh(this, [
      t
    ], this._majorUnit), o), r = this._getLabelSize(n), a = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1;
    return a > 0 ? a : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], i, s;
    if (t.length)
      return t;
    const o = this.getMatchingVisibleMetas();
    if (this._normalized && o.length)
      return this._cache.data = o[0].controller.getAllParsedValues(this);
    for (i = 0, s = o.length; i < s; ++i)
      t = t.concat(o[i].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let i, s;
    if (t.length)
      return t;
    const o = this.getLabels();
    for (i = 0, s = o.length; i < s; ++i)
      t.push(ch(this, o[i]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return Wk(t.sort(dh));
  }
}
K(mr, "id", "time"), K(mr, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function Sn(e, t, i) {
  let s = 0, o = e.length - 1, n, r, a, l;
  i ? (t >= e[s].pos && t <= e[o].pos && ({ lo: s, hi: o } = Pi(e, "pos", t)), { pos: n, time: a } = e[s], { pos: r, time: l } = e[o]) : (t >= e[s].time && t <= e[o].time && ({ lo: s, hi: o } = Pi(e, "time", t)), { time: n, pos: a } = e[s], { time: r, pos: l } = e[o]);
  const d = r - n;
  return d ? a + (l - a) * (t - n) / d : a;
}
class ph extends mr {
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), i = this._table = this.buildLookupTable(t);
    this._minPos = Sn(i, this.min), this._tableRange = Sn(i, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: i, max: s } = this, o = [], n = [];
    let r, a, l, d, c;
    for (r = 0, a = t.length; r < a; ++r)
      d = t[r], d >= i && d <= s && o.push(d);
    if (o.length < 2)
      return [
        {
          time: i,
          pos: 0
        },
        {
          time: s,
          pos: 1
        }
      ];
    for (r = 0, a = o.length; r < a; ++r)
      c = o[r + 1], l = o[r - 1], d = o[r], Math.round((c + l) / 2) !== d && n.push({
        time: d,
        pos: r / (a - 1)
      });
    return n;
  }
  _generate() {
    const t = this.min, i = this.max;
    let s = super.getDataTimestamps();
    return (!s.includes(t) || !s.length) && s.splice(0, 0, t), (!s.includes(i) || s.length === 1) && s.push(i), s.sort((o, n) => o - n);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const i = this.getDataTimestamps(), s = this.getLabelTimestamps();
    return i.length && s.length ? t = this.normalize(i.concat(s)) : t = i.length ? i : s, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (Sn(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const i = this._offsets, s = this.getDecimalForPixel(t) / i.factor - i.end;
    return Sn(this._table, s * this._tableRange + this._minPos, !0);
  }
}
K(ph, "id", "timeseries"), K(ph, "defaults", mr.defaults);
const sm = {
  data: {
    type: Object,
    required: !0
  },
  options: {
    type: Object,
    default: () => ({})
  },
  plugins: {
    type: Array,
    default: () => []
  },
  datasetIdKey: {
    type: String,
    default: "label"
  },
  updateMode: {
    type: String,
    default: void 0
  }
}, J1 = {
  ariaLabel: {
    type: String
  },
  ariaDescribedby: {
    type: String
  }
}, e_ = {
  type: {
    type: String,
    required: !0
  },
  destroyDelay: {
    type: Number,
    default: 0
    // No delay by default
  },
  ...sm,
  ...J1
}, t_ = Am[0] === "2" ? (e, t) => Object.assign(e, {
  attrs: t
}) : (e, t) => Object.assign(e, t);
function es(e) {
  return Sl(e) ? Co(e) : e;
}
function i_(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e;
  return Sl(t) ? new Proxy(e, {}) : e;
}
function s_(e, t) {
  const i = e.options;
  i && t && Object.assign(i, t);
}
function om(e, t) {
  e.labels = t;
}
function nm(e, t, i) {
  const s = [];
  e.datasets = t.map((o) => {
    const n = e.datasets.find((r) => r[i] === o[i]);
    return !n || !o.data || s.includes(n) ? {
      ...o
    } : (s.push(n), Object.assign(n, o), n);
  });
}
function o_(e, t) {
  const i = {
    labels: [],
    datasets: []
  };
  return om(i, e.labels), nm(i, e.datasets, t), i;
}
const n_ = Bo({
  props: e_,
  setup(e, t) {
    let { expose: i, slots: s } = t;
    const o = we(null), n = bh(null);
    i({
      chart: n
    });
    const r = () => {
      if (!o.value) return;
      const { type: d, data: c, options: u, plugins: h, datasetIdKey: g } = e, p = o_(c, g), f = i_(p, c);
      n.value = new Ar(o.value, {
        type: d,
        data: f,
        options: {
          ...u
        },
        plugins: h
      });
    }, a = () => {
      const d = Co(n.value);
      d && (e.destroyDelay > 0 ? setTimeout(() => {
        d.destroy(), n.value = null;
      }, e.destroyDelay) : (d.destroy(), n.value = null));
    }, l = (d) => {
      d.update(e.updateMode);
    };
    return Bn(r), vh(a), mo([
      () => e.options,
      () => e.data
    ], (d, c) => {
      let [u, h] = d, [g, p] = c;
      const f = Co(n.value);
      if (!f)
        return;
      let m = !1;
      if (u) {
        const C = es(u), v = es(g);
        C && C !== v && (s_(f, C), m = !0);
      }
      if (h) {
        const C = es(h.labels), v = es(p.labels), R = es(h.datasets), b = es(p.datasets);
        C !== v && (om(f.config.data, C), m = !0), R && R !== b && (nm(f.config.data, R, e.datasetIdKey), m = !0);
      }
      m && Mm(() => {
        l(f);
      });
    }, {
      deep: !0
    }), () => Da("canvas", {
      role: "img",
      ariaLabel: e.ariaLabel,
      ariaDescribedby: e.ariaDescribedby,
      ref: o
    }, [
      Da("p", {}, [
        s.default ? s.default() : ""
      ])
    ]);
  }
});
function r_(e, t) {
  return Ar.register(t), Bo({
    props: sm,
    setup(i, s) {
      let { expose: o } = s;
      const n = bh(null), r = (a) => {
        n.value = a == null ? void 0 : a.chart;
      };
      return o({
        chart: n
      }), () => Da(n_, t_({
        ref: r
      }, {
        type: e,
        ...i
      }));
    }
  });
}
const a_ = /* @__PURE__ */ r_("line", Ln), l_ = { class: "notification-container" }, d_ = { class: "notification-content" }, c_ = { class: "notification-icon" }, u_ = { class: "notification-message" }, h_ = ["onClick"], g_ = { class: "dashboard-container" }, p_ = {
  key: 0,
  class: "loading"
}, f_ = {
  key: 1,
  class: "error"
}, m_ = { key: 2 }, C_ = { class: "metric-block" }, v_ = { class: "block-header" }, w_ = { key: 1 }, b_ = { class: "header-tools" }, y_ = { class: "columns-content" }, S_ = ["value"], R_ = { class: "column-label" }, x_ = { class: "columns-footer" }, F_ = {
  key: 0,
  class: "summary-filters-bar"
}, P_ = { class: "filters-tags" }, E_ = ["onClick"], D_ = { class: "ag-theme-alpine summary-grid" }, T_ = {
  key: 1,
  class: "graph-section"
}, M_ = {
  key: 0,
  class: "graph-loading"
}, A_ = {
  key: 1,
  class: "graph-error"
}, I_ = {
  key: 2,
  class: "chart-section"
}, k_ = { class: "chart-container" }, L_ = {
  key: 3,
  class: "graph-empty"
}, O_ = { class: "breakdown-header" }, __ = { class: "breakdown-header-left" }, H_ = { class: "breakdown-header-right" }, B_ = { class: "docker-control-section" }, G_ = ["disabled", "onClick"], V_ = { key: 0 }, N_ = { key: 1 }, W_ = ["disabled", "onClick"], z_ = { key: 0 }, U_ = { key: 1 }, $_ = { class: "breakdown-columns" }, K_ = { class: "breakdown-stage stage-1" }, j_ = { class: "stage-item" }, q_ = { class: "item-value" }, Y_ = { class: "formula" }, Q_ = { class: "stage-item" }, X_ = { class: "item-value" }, Z_ = { class: "formula" }, J_ = { class: "stage-item" }, eH = { class: "item-value" }, tH = { class: "formula" }, iH = { class: "stage-item" }, sH = { class: "item-value" }, oH = { class: "formula" }, nH = { class: "breakdown-stage stage-2" }, rH = { class: "stage-item" }, aH = { class: "item-value" }, lH = { class: "formula" }, dH = { class: "stage-item" }, cH = { class: "item-value" }, uH = { class: "formula" }, hH = { class: "stage-item" }, gH = { class: "item-value" }, pH = { class: "formula" }, fH = { class: "stage-item" }, mH = { class: "item-value" }, CH = { class: "formula" }, vH = ["onClick"], wH = { class: "context-menu-icon" }, bH = {
  key: 0,
  class: "active-indicator"
}, yH = {
  key: 0,
  class: "context-menu-separator"
}, SH = { class: "context-menu-info" }, RH = { class: "context-menu-value" }, fh = "https://ibkr-docker-manage.aiworkspace.pro/docker_control.php", xH = 1e4, FH = 8e3, PH = /* @__PURE__ */ Bo({
  __name: "Summary",
  props: {
    showHeaderLink: { type: Boolean, default: !1 },
    userId: { default: null }
  },
  emits: ["minimize"],
  setup(e, { emit: t }) {
    Ar.register(
      bl,
      yl,
      Hn,
      Js,
      _1,
      U1,
      L1
    );
    const i = e, s = t, o = we(null), n = we(null), r = JI(10, i.userId), a = Hr({}), l = we(null), d = we(null), c = Hr({}), u = we(null), h = Hr({
      bansi: { isLoading: !1, isStarting: !1, isStopping: !1 },
      cis: { isLoading: !1, isStarting: !1, isStopping: !1 },
      hediye: { isLoading: !1, isStarting: !1, isStopping: !1 },
      ovlg: { isLoading: !1, isStarting: !1, isStopping: !1 },
      sc: { isLoading: !1, isStarting: !1, isStopping: !1 },
      stamp: { isLoading: !1, isStarting: !1, isStopping: !1 },
      vk: { isLoading: !1, isStarting: !1, isStopping: !1 }
    }), g = we([]);
    let p = 0;
    function f() {
      return new URLSearchParams(window.location.search).get("all_cts_clientId");
    }
    function m(y) {
      if (!y) return null;
      const S = y.match(/Client\s*(\d+)/i);
      return S ? parseInt(S[1]) : null;
    }
    Bn(() => {
      u.value = f(), window.addEventListener("popstate", () => {
        u.value = f();
      });
    });
    const C = Vm(), v = Ta({
      queryKey: Ie(() => ["nlvHistory", l.value]),
      queryFn: async () => {
        if (!l.value) return [];
        console.log(" Querying NLV history for account:", l.value);
        const { data: y, error: S } = await C.schema("hf").from("netliquidation").select("internal_account_id, fetched_at, nlv").eq("internal_account_id", l.value).gte("fetched_at", new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString()).order("fetched_at", { ascending: !0 });
        if (S)
          throw console.error(" NLV history query error:", S), S;
        return console.log(" NLV history query success:", y == null ? void 0 : y.length, "records"), y || [];
      },
      staleTime: 6e4,
      enabled: Ie(() => !!l.value && d.value === "nlv")
    }), R = Ta({
      queryKey: Ie(() => ["maintenanceHistory", l.value]),
      queryFn: async () => {
        if (!l.value) return [];
        console.log(" Querying Maintenance Margin history for account:", l.value);
        const { data: y, error: S } = await C.schema("hf").from("maintenance_margin").select("internal_account_id, fetched_at, maintenance").eq("internal_account_id", l.value).gte("fetched_at", new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString()).order("fetched_at", { ascending: !0 });
        if (S)
          throw console.error(" Maintenance Margin history query error:", S), S;
        return console.log(" Maintenance Margin history query success:", y == null ? void 0 : y.length, "records"), y || [];
      },
      staleTime: 6e4,
      enabled: Ie(() => !!l.value && d.value === "mm")
    });
    function b(y) {
      if (y == null) return "$0";
      const S = typeof y == "string" ? parseFloat(y) : y;
      return isNaN(S) ? "$0" : new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      }).format(S);
    }
    function w(y, S, L) {
      const V = 1 - L, N = 1 - S, U = 1 - V * N;
      return y / U;
    }
    const x = Ie(() => r.data.value ? r.data.value.map((y) => {
      const S = w(y.nlv_val, 0.3, 0.15), L = w(y.nlv_val, 0.3, 0.1), V = S * 30 / 100, N = L * 30 / 100, M = typeof y.maintenance_val == "string" ? parseFloat(y.maintenance_val) : y.maintenance_val, U = V - M, Ce = N - M, ft = U * 100 / 30, qi = Ce * 100 / 30;
      return {
        ...y,
        maintenance_val_numeric: M,
        // Add numeric version for calculations
        maxGmvNlvSide: S,
        maxGmvMaintenanceSide: L,
        mkNlvSide: V,
        mkMaintenanceSide: N,
        maintnanceMarginHeadroomNlvSide: U,
        maintnanceMarginHeadroomMaintenanceSide: Ce,
        addlGmvAllowedNlvSide: ft,
        addlGmvAllowedMaintenanceSide: qi
      };
    }) : []), F = Ie(() => {
      if (!u.value || !x.value)
        return x.value;
      const y = m(u.value);
      if (y === null)
        return x.value;
      const S = y - 1;
      return S >= 0 && S < x.value.length ? [x.value[S]] : x.value;
    }), D = Ie(() => {
      if (!x.value) return null;
      const y = x.value.reduce((M, U) => M + (U.nlv_val || 0), 0), S = x.value.reduce((M, U) => {
        const Ce = typeof U.maintenance_val == "string" ? parseFloat(U.maintenance_val) : U.maintenance_val;
        return M + (isNaN(Ce) ? 0 : Ce);
      }, 0), L = x.value.reduce((M, U) => M + (U.excess_maintenance_margin || 0), 0), V = x.value.reduce((M, U) => M + (U.addlGmvAllowedNlvSide || 0), 0), N = x.value.reduce((M, U) => M + (U.addlGmvAllowedMaintenanceSide || 0), 0);
      return {
        totalNlv: y,
        totalMaintenance: S,
        totalExcessMaintenance: L,
        totalAddlGmvToStopReducing: V,
        totalAddlGmvToStartReducing: N
      };
    });
    function T(y) {
      console.log(" toggleBreakdown called with ID:", y), console.log(" Current breakdownVisibility state:", c);
      const S = typeof y == "string" ? parseInt(y) : y, L = c[S];
      Object.keys(c).forEach((V) => {
        const N = parseInt(V);
        c[N] = !1;
      }), c[S] = !L, console.log(" Updated breakdownVisibility state:", c), console.log(" breakdownVisibility[" + S + "]:", c[S]);
    }
    const k = Ie(() => {
      var S;
      console.log(" Computing breakdown items..."), console.log(" filteredMetrics:", F.value), console.log(" breakdownVisibility:", c);
      const y = ((S = F.value) == null ? void 0 : S.filter((L) => {
        const V = typeof L.nlv_internal_account_id == "string" ? parseInt(L.nlv_internal_account_id) : L.nlv_internal_account_id, N = c[V];
        return console.log(" Item", V, "(original:", L.nlv_internal_account_id, ") should show:", N), N;
      })) || [];
      return console.log(" Final breakdown items:", y), y;
    });
    wh("eventBus");
    const A = [
      { field: "account", label: "Account" },
      { field: "nlv_val", label: "NLV" },
      { field: "maintenance_val", label: "Maintenance Margin" },
      { field: "excess_maintenance_margin", label: "Excess Maintenance Margin" },
      // Add this line
      { field: "addlGmvAllowedNlvSide", label: "Add'l GMV to stop-adding threshold" },
      { field: "addlGmvAllowedMaintenanceSide", label: "Add'l GMV to start-reducing threshold" }
    ];
    function G() {
      const S = new URL(window.location.href).searchParams.get("summary_cols");
      if (!S)
        return A.map((M) => M.field);
      const L = S.split("-and-").map((M) => M.trim()).filter(Boolean), V = new Set(A.map((M) => M.field)), N = L.filter((M) => V.has(M));
      return N.length ? N : A.map((M) => M.field);
    }
    function $(y) {
      const S = new URL(window.location.href);
      S.searchParams.set("summary_cols", y.join("-and-")), window.history.replaceState({}, "", S.toString());
    }
    const q = we(G());
    function j(y) {
      return q.value.includes(y);
    }
    const oe = we(!1), ne = we(null), gt = we(null);
    function It() {
      oe.value = !oe.value;
    }
    function je() {
      oe.value = !1;
    }
    function pt(y) {
      oe.value && gt.value && ne.value && !gt.value.contains(y.target) && !ne.value.contains(y.target) && je();
    }
    function rt(y, S) {
      const L = o.value;
      if (L)
        try {
          typeof L.setColumnsVisible == "function" ? L.setColumnsVisible([y], S) : typeof L.setColumnVisible == "function" && L.setColumnVisible(y, S);
        } catch (V) {
          console.warn("Could not set column visibility:", V);
        }
    }
    mo(q, (y) => {
      $(y);
      for (const S of A)
        rt(S.field, j(S.field));
    }, { deep: !0 });
    const ge = Ie(() => [
      {
        headerName: "Account",
        field: "account",
        valueGetter: (y) => {
          var V;
          if (y.data.isTotal) return "All Accounts";
          if (y.data.legal_entity)
            return y.data.legal_entity;
          const S = typeof y.data.nlv_internal_account_id == "string" ? parseInt(y.data.nlv_internal_account_id) : y.data.nlv_internal_account_id;
          return `Client${(((V = x.value) == null ? void 0 : V.findIndex((N) => (typeof N.nlv_internal_account_id == "string" ? parseInt(N.nlv_internal_account_id) : N.nlv_internal_account_id) === S)) ?? -1) + 1}`;
        },
        pinned: "left",
        width: 95,
        hide: !j("account"),
        onCellClicked: (y) => {
          var S;
          (S = y.data) != null && S.isTotal || mm(y == null ? void 0 : y.value);
        },
        cellRenderer: (y) => {
          if (y.data.isTotal)
            return `<div class="account-cell total-row">
          <span class="account-name">${y.value}</span>
        </div>`;
          const S = y.data.addlGmvAllowedNlvSide < 0 && y.data.addlGmvAllowedMaintenanceSide < 0 ? "STAGE 2 EXHAUSTED" : y.data.addlGmvAllowedNlvSide < 0 ? "STAGE 1 EXHAUSTED" : "OK", L = S === "STAGE 2 EXHAUSTED" ? "status-stage2" : S === "STAGE 1 EXHAUSTED" ? "status-stage1" : "status-ok";
          return `<div class="account-cell clickable-account">
        <span class="account-name">${y.value}</span>
        <span class="status-badge ${L}">${S}</span>
      </div>`;
        }
      },
      {
        headerName: "NLV",
        field: "nlv_val",
        valueFormatter: (y) => b(y.value),
        cellClass: "number-cell",
        headerClass: "graph-header",
        flex: 1,
        hide: !j("nlv_val"),
        cellRenderer: (y) => {
          var L;
          if (y.data.isTotal)
            return `<span class="cell-value total-cell">${b(y.value)}</span>`;
          const S = typeof y.data.nlv_internal_account_id == "string" ? parseInt(y.data.nlv_internal_account_id) : y.data.nlv_internal_account_id;
          return (L = a[S]) == null || L.nlv, `<div class="cell-with-graph">
        <span class="cell-value">${b(y.value)}</span>
      </div>`;
        }
      },
      {
        headerName: "Maintenance Margin",
        field: "maintenance_val",
        valueFormatter: (y) => {
          const S = typeof y.value == "string" ? parseFloat(y.value) : y.value;
          return b(S);
        },
        cellClass: "number-cell",
        headerClass: "graph-header",
        flex: 1,
        hide: !j("maintenance_val"),
        cellRenderer: (y) => {
          var V;
          if (y.data.isTotal)
            return `<span class="cell-value total-cell">${b(y.value)}</span>`;
          const S = typeof y.data.nlv_internal_account_id == "string" ? parseInt(y.data.nlv_internal_account_id) : y.data.nlv_internal_account_id;
          (V = a[S]) == null || V.mm;
          const L = typeof y.value == "string" ? parseFloat(y.value) : y.value;
          return `<div class="cell-with-graph">
        <span class="cell-value">${b(L)}</span>
      </div>`;
        }
      },
      {
        headerName: "Excess Maintenance Margin",
        field: "excess_maintenance_margin",
        valueFormatter: (y) => b(y.value),
        cellClass: (y) => {
          const S = "number-cell";
          return y.data.isTotal ? `${S} total-cell` : y.value < 0 ? `${S} negative` : S;
        },
        flex: 1,
        hide: !j("excess_maintenance_margin")
      },
      {
        headerName: "Stop-adding threshold (Add'l GMV)",
        field: "addlGmvAllowedNlvSide",
        valueFormatter: (y) => b(y.value),
        cellClass: (y) => {
          const S = "number-cell";
          return y.data.isTotal ? `${S} total-cell` : y.value < 0 ? `${S} negative` : S;
        },
        flex: 1,
        hide: !j("addlGmvAllowedNlvSide")
      },
      {
        headerName: "Start-reducing threshold (Add'l GMV)",
        field: "addlGmvAllowedMaintenanceSide",
        valueFormatter: (y) => b(y.value),
        cellClass: (y) => {
          const S = "number-cell";
          return y.data.isTotal ? `${S} total-cell` : y.value < 0 ? `${S} negative` : S;
        },
        flex: 1,
        hide: !j("addlGmvAllowedMaintenanceSide")
      }
    ]);
    function He(y) {
      o.value = y.api, n.value = y.columnApi;
      const S = wm();
      if (S.account) {
        const V = {
          account: { type: "equals", filter: S.account }
        };
        y.api.setFilterModel(V);
      }
      const L = document.querySelector(".summary-ag-grid .ag-root-wrapper");
      L && (L.addEventListener("click", (V) => {
        const N = V.target;
        if (ji(), N.classList.contains("graph-btn")) {
          const M = parseInt(N.getAttribute("data-account") || "0"), U = N.getAttribute("data-type");
          Lr(M, U), o.value && typeof o.value.refreshCells == "function" && o.value.refreshCells();
        }
      }), L.addEventListener("contextmenu", (V) => {
        var Ce;
        const N = V.target, M = N.closest(".ag-cell"), U = N.closest(".ag-row");
        if (U && M) {
          const ft = U.getAttribute("row-index"), qi = M.getAttribute("col-id");
          if (ft !== null) {
            const mt = (Ce = o.value) == null ? void 0 : Ce.getDisplayedRowAtIndex(parseInt(ft));
            if (mt != null && mt.data && !mt.data.isTotal) {
              const ks = typeof mt.data.nlv_internal_account_id == "string" ? parseInt(mt.data.nlv_internal_account_id) : mt.data.nlv_internal_account_id;
              ks && rm(V, ks, qi || void 0);
            }
          }
        }
      })), Is();
    }
    Ie(() => x.value ? F.value : []);
    const at = Ie(() => F.value || []), Ae = Ie(() => !u.value && D.value && qo.value.length === 0 ? [{
      nlv_internal_account_id: -1,
      nlv_val: D.value.totalNlv,
      maintenance_val: D.value.totalMaintenance,
      excess_maintenance_margin: D.value.totalExcessMaintenance,
      addlGmvAllowedNlvSide: D.value.totalAddlGmvToStopReducing,
      addlGmvAllowedMaintenanceSide: D.value.totalAddlGmvToStartReducing,
      isTotal: !0
    }] : []), me = we({
      visible: !1,
      x: 0,
      y: 0,
      accountId: null,
      columnId: null,
      // Add column tracking
      fetchedAt: null
      // Add fetched_at tracking
    });
    function rm(y, S, L) {
      var N;
      y.preventDefault();
      const V = (N = x.value) == null ? void 0 : N.find((M) => (typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id) === S);
      me.value = {
        visible: !0,
        x: y.clientX,
        y: y.clientY,
        accountId: S,
        columnId: L || null,
        fetchedAt: (V == null ? void 0 : V.fetched_at_val) || null
      };
    }
    function ji() {
      me.value.visible = !1;
    }
    function am() {
      var y;
      if (me.value.accountId) {
        const S = me.value.accountId;
        console.log(" Details clicked for account:", S);
        const L = (y = x.value) == null ? void 0 : y.find((V) => (typeof V.nlv_internal_account_id == "string" ? parseInt(V.nlv_internal_account_id) : V.nlv_internal_account_id) === S);
        console.log(" Found item for breakdown:", L), L ? (console.log(" Toggling breakdown for account ID:", S), T(S)) : console.warn(" No item found for account ID:", S);
      }
      ji();
    }
    function lm() {
      if (me.value.accountId) {
        const y = me.value.accountId;
        console.log(" NLV Graph clicked for account:", y), Lr(y, "nlv"), o.value && typeof o.value.refreshCells == "function" && o.value.refreshCells();
      }
      ji();
    }
    function dm() {
      if (me.value.accountId) {
        const y = me.value.accountId;
        console.log(" Maintenance Margin Graph clicked for account:", y), Lr(y, "mm"), o.value && typeof o.value.refreshCells == "function" && o.value.refreshCells();
      }
      ji();
    }
    function Ed(y, S) {
      var L;
      return ((L = a[y]) == null ? void 0 : L[S]) || !1;
    }
    function jo(y, S) {
      const L = {
        id: ++p,
        type: y,
        message: S
      };
      g.value.push(L), setTimeout(() => {
        Dd(L.id);
      }, 4e3);
    }
    function Dd(y) {
      const S = g.value.findIndex((L) => L.id === y);
      S > -1 && g.value.splice(S, 1);
    }
    function jt(y) {
      return {
        1: "bansi",
        2: "cis",
        3: "hediye",
        4: "ovlg",
        5: "sc",
        6: "stamp",
        7: "vk"
      }[y] || null;
    }
    async function cm(y) {
      const S = h[y];
      if (!S) {
        console.error(`Container state not found for: ${y}`);
        return;
      }
      if (S.isLoading) return;
      const L = `${fh}?action=start&container_name=${y}`;
      S.isLoading = !0, S.isStarting = !0;
      try {
        console.log(`Starting container: ${y}`);
        const V = await fetch(L, {
          method: "GET",
          headers: {
            "Content-Type": "application/json"
          }
        });
        if (!V.ok)
          throw new Error(`HTTP error! status: ${V.status}`);
        const N = await V.json();
        if (console.log("Docker Start API Response:", N), N.status === "success")
          S.lastUpdated = /* @__PURE__ */ new Date(), console.log(`Container ${y} started successfully`), jo("success", `Container "${y}" started successfully!`), N.output && console.log("Start command output:", N.output);
        else
          throw new Error(N.message || "Failed to start container");
      } catch (V) {
        console.error("Error starting Docker container:", V), jo("error", `Failed to start container "${y}". Check console for details.`);
      } finally {
        S.isLoading = !1, S.isStarting = !1;
      }
    }
    async function um(y) {
      const S = h[y];
      if (!S) {
        console.error(`Container state not found for: ${y}`);
        return;
      }
      if (S.isLoading) return;
      const L = `${fh}?action=stop&container_name=${y}`;
      S.isLoading = !0, S.isStopping = !0;
      try {
        console.log(`Stopping container: ${y}`);
        const V = await fetch(L, {
          method: "GET",
          headers: {
            "Content-Type": "application/json"
          }
        });
        if (!V.ok)
          throw new Error(`HTTP error! status: ${V.status}`);
        const N = await V.json();
        if (console.log("Docker Stop API Response:", N), N.status === "success")
          S.lastUpdated = /* @__PURE__ */ new Date(), console.log(`Container ${y} stopped successfully`), jo("success", `Container "${y}" stopped successfully!`), N.output && console.log("Stop command output:", N.output);
        else
          throw new Error(N.message || "Failed to stop container");
      } catch (V) {
        console.error("Error stopping Docker container:", V), jo("error", `Failed to stop container "${y}". Check console for details.`);
      } finally {
        S.isLoading = !1, S.isStopping = !1;
      }
    }
    const As = [];
    function hm(y) {
      const S = jt(y);
      return S ? h[S] || { isLoading: !1, isStarting: !1, isStopping: !1, online: !1 } : { isLoading: !1, isStarting: !1, isStopping: !1, online: !1 };
    }
    async function Td(y) {
      const S = jt(y);
      if (!S) return;
      const L = h[S];
      if (!L || L.isLoading) return;
      L.isLoading = !0, L.lastError = null;
      const V = S === "vk" ? "https://ibkr.vk.to5001.aiworkspace.pro/api/maintenance" : `https://ibkr.${S}.to5001.aiworkspace.pro/api/maintenance`, N = new AbortController(), M = setTimeout(() => N.abort(), FH);
      try {
        const U = await fetch(V, { signal: N.signal });
        if (!U.ok)
          L.online = !1, L.lastError = `HTTP ${U.status}`;
        else {
          const Ce = await U.json().catch(() => null);
          Ce && Ce.account_id ? (L.online = !0, L.lastUpdated = Ce.timestamp ? new Date(Ce.timestamp) : /* @__PURE__ */ new Date(), L.lastError = null) : (L.online = !1, L.lastError = "missing account_id");
        }
      } catch (U) {
        L.online = !1, L.lastError = String((U == null ? void 0 : U.message) || U);
      } finally {
        clearTimeout(M), L.isLoading = !1;
      }
    }
    function gm() {
      As.forEach((S) => clearInterval(S)), As.length = 0, [1, 2, 3, 4, 5, 6, 7].forEach((S, L) => {
        setTimeout(() => {
          Td(S);
        }, L * 500);
        const V = setInterval(() => Td(S), xH);
        As.push(V);
      });
    }
    function kr(y) {
      const S = hm(y);
      return {
        online: !!S.online,
        lastUpdatedText: S.lastUpdated ? S.lastUpdated.toLocaleString() : "",
        isLoading: S.isLoading,
        lastError: S.lastError
      };
    }
    Bn(() => {
      u.value = f(), window.addEventListener("popstate", () => {
        u.value = f();
      }), document.addEventListener("click", ji), document.addEventListener("click", pt), gm();
    }), Im(() => {
      r._cleanup && r._cleanup(), document.removeEventListener("click", ji), document.removeEventListener("click", pt), As.forEach((y) => clearInterval(y)), As.length = 0;
    });
    const Md = Ie(() => {
      const y = [];
      return y.push({
        icon: "",
        label: "Details",
        action: "details"
      }), me.value.columnId === "nlv_val" && y.push({
        icon: "",
        label: "NLV Graph",
        action: "nlv-graph",
        active: me.value.accountId ? Ed(me.value.accountId, "nlv") : !1
      }), me.value.columnId === "maintenance_val" && y.push({
        icon: "",
        label: "Maintenance Margin Graph",
        action: "mm-graph",
        active: me.value.accountId ? Ed(me.value.accountId, "mm") : !1
      }), y;
    });
    function pm(y) {
      if (me.value.accountId)
        switch (y) {
          case "details":
            am();
            break;
          case "nlv-graph":
            lm();
            break;
          case "mm-graph":
            dm();
            break;
        }
    }
    function fm(y) {
      if (!y) return "N/A";
      try {
        const S = new Date(y);
        return new Intl.DateTimeFormat("en-US", {
          timeZone: "America/Los_Angeles",
          // PST/PDT timezone
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: !1
          // 24-hour format
        }).format(S);
      } catch (S) {
        return console.error("Error formatting timestamp:", S), "Invalid Date";
      }
    }
    const qo = we([]);
    function Is() {
      var L;
      const y = o.value, S = [];
      if (y) {
        const V = ((L = y.getFilterModel) == null ? void 0 : L.call(y)) || {}, M = ((U) => {
          var Ce, ft;
          return ((Ce = V == null ? void 0 : V[U]) == null ? void 0 : Ce.filter) || ((ft = V == null ? void 0 : V[U]) == null ? void 0 : ft.values) || null;
        })("account");
        typeof M == "string" && M.length && S.push({ field: "account", value: M });
      }
      qo.value = S;
    }
    function mm(y) {
      const S = o.value;
      if (!S || y === void 0 || y === null) return;
      const L = S.getFilterModel && S.getFilterModel() || {};
      L.account = { type: "equals", filter: String(y) }, typeof S.setFilterModel == "function" && S.setFilterModel(L), typeof S.onFilterChanged == "function" && S.onFilterChanged(), Yo(L), Is();
    }
    function Cm(y) {
      const S = o.value;
      if (!S) return;
      const L = S.getFilterModel && S.getFilterModel() || {};
      delete L[y], typeof S.setFilterModel == "function" && S.setFilterModel(L), typeof S.onFilterChanged == "function" && S.onFilterChanged(), Yo(L), Is();
    }
    function vm() {
      const y = o.value;
      y && (typeof y.setFilterModel == "function" && y.setFilterModel({}), typeof y.onFilterChanged == "function" && y.onFilterChanged(), Yo({}), Is());
    }
    mo(() => o.value, (y) => {
      var L;
      if (!y) return;
      const S = () => {
        var V;
        {
          Is();
          const N = ((V = y.getFilterModel) == null ? void 0 : V.call(y)) || {};
          Yo(N);
        }
      };
      (L = y.addEventListener) == null || L.call(y, "filterChanged", S);
    }, { immediate: !0 });
    function wm() {
      return { account: new URL(window.location.href).searchParams.get("summary_account") || void 0 };
    }
    function Yo(y) {
      var V;
      const S = new URL(window.location.href), L = ((V = y == null ? void 0 : y.account) == null ? void 0 : V.filter) || "";
      L ? S.searchParams.set("summary_account", L) : S.searchParams.delete("summary_account"), window.history.replaceState({}, "", S.toString());
    }
    function Lr(y, S) {
      if (console.log(" toggleGraph called with:", y, S), a[y] || (a[y] = { nlv: !1, mm: !1 }), l.value === y && d.value === S) {
        l.value = null, d.value = null, a[y][S] = !1;
        return;
      }
      Object.keys(a).forEach((L) => {
        const V = parseInt(L);
        a[V] = { nlv: !1, mm: !1 };
      }), a[y][S] = !0, l.value = y, d.value = S, console.log(" Graph visibility updated:", a), console.log(" Selected account/type:", y, S);
    }
    const Qo = Ie(() => d.value === "nlv" ? v : d.value === "mm" ? R : null), Ad = Ie(() => {
      const y = Qo.value;
      if (!(y != null && y.data.value) || !Array.isArray(y.data.value)) return null;
      const S = y.data.value, L = S.map((N) => new Date(N.fetched_at).toLocaleDateString("en-US", { month: "short", day: "numeric" })), V = d.value === "nlv" ? S.map((N) => parseFloat(N.nlv) || 0) : S.map((N) => parseFloat(N.maintenance) || 0);
      return {
        labels: L,
        datasets: [{
          label: d.value === "nlv" ? "NLV" : "Maintenance Margin",
          data: V,
          borderColor: d.value === "nlv" ? "#3b82f6" : "#ef4444",
          backgroundColor: d.value === "nlv" ? "rgba(59, 130, 246, 0.1)" : "rgba(239, 68, 68, 0.1)",
          borderWidth: 2,
          fill: !0,
          tension: 0.1
        }]
      };
    }), bm = Ie(() => ({
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          display: !0,
          position: "top"
        },
        title: {
          display: !0,
          text: `${d.value === "nlv" ? "NLV" : "Maintenance Margin"} History (Last 30 Days)`
        }
      },
      scales: {
        y: {
          beginAtZero: !1,
          ticks: {
            callback: function(y) {
              return new Intl.NumberFormat("en-US", {
                style: "currency",
                currency: "USD",
                minimumFractionDigits: 0
              }).format(y);
            }
          }
        }
      },
      interaction: {
        intersect: !1,
        mode: "index"
      }
    }));
    return (y, S) => {
      var V, N;
      const L = km("router-link");
      return X(), J(Yi, null, [
        O("div", l_, [
          (X(!0), J(Yi, null, Ls(g.value, (M) => (X(), J("div", {
            key: M.id,
            class: Br(["notification", M.type])
          }, [
            O("div", d_, [
              O("span", c_, ce(M.type === "success" ? "" : ""), 1),
              O("span", u_, ce(M.message), 1)
            ]),
            O("button", {
              class: "notification-close",
              onClick: (U) => Dd(M.id)
            }, "", 8, h_)
          ], 2))), 128))
        ]),
        O("div", g_, [
          fi(r).isLoading.value ? (X(), J("div", p_, [...S[5] || (S[5] = [
            O("div", { class: "loading-spinner" }, null, -1),
            O("p", null, "Loading the latest metrics...", -1)
          ])])) : fi(r).isError.value ? (X(), J("div", f_, [
            S[6] || (S[6] = O("h2", null, "Error Loading Data", -1)),
            S[7] || (S[7] = O("p", null, "An error occurred while fetching the metrics:", -1)),
            O("pre", null, ce(fi(r).error.value), 1)
          ])) : fi(r).isSuccess.value ? (X(), J("div", m_, [
            O("div", C_, [
              O("div", v_, [
                O("h2", null, [
                  e.showHeaderLink ? (X(), Lm(L, {
                    key: 0,
                    to: "/summary",
                    class: "summary-link"
                  }, {
                    default: Om(() => [...S[8] || (S[8] = [
                      Vd("Summary", -1)
                    ])]),
                    _: 1
                  })) : (X(), J("span", w_, "Summary"))
                ]),
                O("div", b_, [
                  O("button", {
                    ref_key: "summaryColumnsBtnRef",
                    ref: ne,
                    class: "columns-btn",
                    "aria-label": "Column settings",
                    onClick: Os(It, ["stop"]),
                    title: "Column Settings"
                  }, [...S[9] || (S[9] = [
                    O("svg", {
                      class: "icon",
                      viewBox: "0 0 24 24",
                      width: "18",
                      height: "18",
                      "aria-hidden": "true"
                    }, [
                      O("path", {
                        fill: "currentColor",
                        d: "M19.14 12.94c.04-.31.06-.63.06-.94s-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.21-.37-.3-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.03-.22-.22-.39-.44-.39h-3.84c-.22 0-.41.16-.44.39l-.36 2.54c-.59.24-1.13.56-1.62.94l-2.39-.96c-.22-.09-.47 0-.59.22l-1.92 3.32c-.12.21-.07.47.12.61l2.03 1.58c.04.31.06.63.06.94s-.02.63-.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.21.37.3.59.22l2.39.96c.5.38 1.03.7 1.62.94l.36 2.54c.03.22.22.39.44.39h3.84c.22 0 .41-.16.44-.39l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.09.47 0 .59-.22l1.92-3.32c.12-.21.07-.47-.12-.61l-2.03-1.58ZM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5Z"
                      })
                    ], -1)
                  ])], 512),
                  O("button", {
                    onClick: S[0] || (S[0] = (M) => s("minimize")),
                    class: "minimize-button",
                    title: "Minimize Summary"
                  }, "  "),
                  oe.value ? (X(), J("div", {
                    key: 0,
                    ref_key: "summaryColumnsPopupRef",
                    ref: gt,
                    class: "columns-dropdown",
                    onClick: S[3] || (S[3] = Os(() => {
                    }, ["stop"]))
                  }, [
                    S[10] || (S[10] = O("div", { class: "columns-header" }, [
                      O("span", { class: "columns-title" }, "Columns")
                    ], -1)),
                    O("div", y_, [
                      (X(), J(Yi, null, Ls(A, (M) => O("label", {
                        key: M.field,
                        class: "column-option"
                      }, [
                        _m(O("input", {
                          type: "checkbox",
                          value: M.field,
                          "onUpdate:modelValue": S[1] || (S[1] = (U) => q.value = U),
                          class: "column-checkbox"
                        }, null, 8, S_), [
                          [Hm, q.value]
                        ]),
                        O("span", R_, ce(M.label), 1)
                      ])), 64))
                    ]),
                    O("div", x_, [
                      O("button", {
                        class: "btn-link",
                        onClick: S[2] || (S[2] = (M) => q.value = A.map((U) => U.field))
                      }, " Show All "),
                      O("button", {
                        class: "btn-done",
                        onClick: je
                      }, "Done")
                    ])
                  ], 512)) : pi("", !0)
                ])
              ]),
              qo.value.length ? (X(), J("div", F_, [
                S[11] || (S[11] = O("span", { class: "filters-label" }, "Filtered by:", -1)),
                O("div", P_, [
                  (X(!0), J(Yi, null, Ls(qo.value, (M) => (X(), J("span", {
                    key: `${M.field}-${M.value}`,
                    class: "filter-tag"
                  }, [
                    O("strong", null, ce(M.field === "account" ? "Account" : M.field) + ":", 1),
                    Vd(" " + ce(M.value) + " ", 1),
                    O("button", {
                      class: "tag-clear",
                      onClick: (U) => Cm(M.field),
                      "aria-label": "Clear filter"
                    }, "", 8, E_)
                  ]))), 128)),
                  O("button", {
                    class: "btn btn-clear-all",
                    onClick: vm
                  }, "Clear all")
                ])
              ])) : pi("", !0),
              O("div", D_, [
                Ea(fi(qI), {
                  columnDefs: ge.value,
                  rowData: at.value,
                  pinnedBottomRowData: Ae.value,
                  modules: [fi(BI)],
                  defaultColDef: {
                    resizable: !0,
                    sortable: !0,
                    filter: !0
                  },
                  gridOptions: {
                    domLayout: "autoHeight",
                    suppressMenuHide: !0,
                    enableBrowserTooltips: !0,
                    getRowStyle: (M) => {
                      var U;
                      return (U = M.data) != null && U.isTotal ? { "font-weight": "bold", "background-color": "#f8f9fa" } : null;
                    }
                  },
                  onGridReady: He,
                  class: "summary-ag-grid"
                }, null, 8, ["columnDefs", "rowData", "pinnedBottomRowData", "modules", "gridOptions"])
              ]),
              l.value && d.value ? (X(), J("div", T_, [
                (V = Qo.value) != null && V.isLoading.value ? (X(), J("div", M_, " Loading " + ce(d.value === "nlv" ? "NLV" : "Maintenance Margin") + " historical data... ", 1)) : (N = Qo.value) != null && N.isError.value ? (X(), J("div", A_, " Error loading " + ce(d.value === "nlv" ? "NLV" : "Maintenance Margin") + " historical data: " + ce(Qo.value.error.value), 1)) : Ad.value ? (X(), J("div", I_, [
                  O("h4", null, ce(d.value === "nlv" ? "NLV" : "Maintenance Margin") + " History ", 1),
                  O("div", k_, [
                    Ea(fi(a_), {
                      data: Ad.value,
                      options: bm.value,
                      height: 300
                    }, null, 8, ["data", "options"])
                  ])
                ])) : (X(), J("div", L_, " No " + ce(d.value === "nlv" ? "NLV" : "Maintenance Margin") + " historical data available ", 1))
              ])) : pi("", !0),
              (X(!0), J(Yi, null, Ls(k.value, (M) => {
                var U, Ce, ft, qi, mt, ks, Id, kd, Ld, Od, _d, Hd;
                return X(), J("div", {
                  key: `breakdown-${typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id}`,
                  class: "calculation-breakdown"
                }, [
                  O("div", O_, [
                    O("div", __, [
                      O("div", null, " Calculation breakdown for " + ce(M.legal_entity || `Client${((U = x.value) == null ? void 0 : U.findIndex((Q) => {
                        const ve = typeof Q.nlv_internal_account_id == "string" ? parseInt(Q.nlv_internal_account_id) : Q.nlv_internal_account_id, pe = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                        return ve === pe;
                      })) + 1}`) + ": ", 1),
                      S[12] || (S[12] = O("div", null, "Assumptions: maintenance margin (m) = 30%", -1))
                    ]),
                    O("div", H_, [
                      O("div", B_, [
                        O("div", {
                          class: Br(["container-status-badge", kr(((Ce = x.value) == null ? void 0 : Ce.findIndex((Q) => {
                            const ve = typeof Q.nlv_internal_account_id == "string" ? parseInt(Q.nlv_internal_account_id) : Q.nlv_internal_account_id, pe = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                            return ve === pe;
                          })) + 1).online ? "status-online" : "status-offline"])
                        }, ce(kr(((ft = x.value) == null ? void 0 : ft.findIndex((Q) => {
                          const ve = typeof Q.nlv_internal_account_id == "string" ? parseInt(Q.nlv_internal_account_id) : Q.nlv_internal_account_id, pe = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                          return ve === pe;
                        })) + 1).online ? " Online" : " Offline"), 3),
                        kr(((qi = x.value) == null ? void 0 : qi.findIndex((Q) => {
                          const ve = typeof Q.nlv_internal_account_id == "string" ? parseInt(Q.nlv_internal_account_id) : Q.nlv_internal_account_id, pe = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                          return ve === pe;
                        })) + 1).online ? (X(), J("button", {
                          key: 1,
                          class: "docker-control-btn stop-btn",
                          disabled: (Od = h[jt(((Ld = x.value) == null ? void 0 : Ld.findIndex((Q) => {
                            const ve = typeof Q.nlv_internal_account_id == "string" ? parseInt(Q.nlv_internal_account_id) : Q.nlv_internal_account_id, pe = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                            return ve === pe;
                          })) + 1)]) == null ? void 0 : Od.isLoading,
                          onClick: Os((Q) => {
                            var ve;
                            um(jt(((ve = x.value) == null ? void 0 : ve.findIndex((pe) => {
                              const Or = typeof pe.nlv_internal_account_id == "string" ? parseInt(pe.nlv_internal_account_id) : pe.nlv_internal_account_id, _r = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                              return Or === _r;
                            })) + 1));
                          }, ["stop"])
                        }, [
                          (Hd = h[jt(((_d = x.value) == null ? void 0 : _d.findIndex((Q) => {
                            const ve = typeof Q.nlv_internal_account_id == "string" ? parseInt(Q.nlv_internal_account_id) : Q.nlv_internal_account_id, pe = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                            return ve === pe;
                          })) + 1)]) != null && Hd.isStopping ? (X(), J("span", z_, "Stopping...")) : (X(), J("span", U_, " Stop Container"))
                        ], 8, W_)) : (X(), J("button", {
                          key: 0,
                          class: "docker-control-btn start-btn",
                          disabled: (ks = h[jt(((mt = x.value) == null ? void 0 : mt.findIndex((Q) => {
                            const ve = typeof Q.nlv_internal_account_id == "string" ? parseInt(Q.nlv_internal_account_id) : Q.nlv_internal_account_id, pe = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                            return ve === pe;
                          })) + 1)]) == null ? void 0 : ks.isLoading,
                          onClick: Os((Q) => {
                            var ve;
                            cm(jt(((ve = x.value) == null ? void 0 : ve.findIndex((pe) => {
                              const Or = typeof pe.nlv_internal_account_id == "string" ? parseInt(pe.nlv_internal_account_id) : pe.nlv_internal_account_id, _r = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                              return Or === _r;
                            })) + 1));
                          }, ["stop"])
                        }, [
                          (kd = h[jt(((Id = x.value) == null ? void 0 : Id.findIndex((Q) => {
                            const ve = typeof Q.nlv_internal_account_id == "string" ? parseInt(Q.nlv_internal_account_id) : Q.nlv_internal_account_id, pe = typeof M.nlv_internal_account_id == "string" ? parseInt(M.nlv_internal_account_id) : M.nlv_internal_account_id;
                            return ve === pe;
                          })) + 1)]) != null && kd.isStarting ? (X(), J("span", V_, "Starting...")) : (X(), J("span", N_, " Start Container"))
                        ], 8, G_))
                      ])
                    ])
                  ]),
                  O("div", $_, [
                    O("div", K_, [
                      S[17] || (S[17] = O("div", { class: "stage-header" }, "Stage-1 (drop d = 15%)", -1)),
                      O("div", j_, [
                        S[13] || (S[13] = O("div", { class: "item-label" }, "Max GMV that survives stop-adding threshold", -1)),
                        O("div", q_, [
                          O("span", Y_, "Gmax = NLV / [ 1 - (1 - d) x (1 - m) ] = " + ce(b(M.maxGmvNlvSide)), 1)
                        ])
                      ]),
                      O("div", Q_, [
                        S[14] || (S[14] = O("div", { class: "item-label" }, "Max Maintenance margin (Before drop) to survive drop", -1)),
                        O("div", X_, [
                          O("span", Z_, "Mk = Gmax x m = " + ce(b(M.mkNlvSide)), 1)
                        ])
                      ]),
                      O("div", J_, [
                        S[15] || (S[15] = O("div", { class: "item-label" }, "Maintenance margin headroom", -1)),
                        O("div", eH, [
                          O("span", tH, "Mk - M = " + ce(b(M.maintnanceMarginHeadroomNlvSide)), 1)
                        ])
                      ]),
                      O("div", iH, [
                        S[16] || (S[16] = O("div", { class: "item-label" }, "Add'l GMV allowed", -1)),
                        O("div", sH, [
                          O("span", oH, "(Mk - M) / m = " + ce(b(M.addlGmvAllowedNlvSide)), 1)
                        ])
                      ])
                    ]),
                    O("div", nH, [
                      S[22] || (S[22] = O("div", { class: "stage-header" }, "Stage-2 (drop d = 10%)", -1)),
                      O("div", rH, [
                        S[18] || (S[18] = O("div", { class: "item-label" }, "Max GMV that survives start-reducing threshold", -1)),
                        O("div", aH, [
                          O("span", lH, "Gmax = NLV / [ 1 - (1 - d) x (1 - m) ] = " + ce(b(M.maxGmvMaintenanceSide)), 1)
                        ])
                      ]),
                      O("div", dH, [
                        S[19] || (S[19] = O("div", { class: "item-label" }, "Max Maintenance margin (Before drop) to survive drop", -1)),
                        O("div", cH, [
                          O("span", uH, "Mk = Gmax x m = " + ce(b(M.mkMaintenanceSide)), 1)
                        ])
                      ]),
                      O("div", hH, [
                        S[20] || (S[20] = O("div", { class: "item-label" }, "Maintenance margin headroom", -1)),
                        O("div", gH, [
                          O("span", pH, "Mk - M = " + ce(b(M.maintnanceMarginHeadroomMaintenanceSide)), 1)
                        ])
                      ]),
                      O("div", fH, [
                        S[21] || (S[21] = O("div", { class: "item-label" }, "Add'l GMV allowed", -1)),
                        O("div", mH, [
                          O("span", CH, "(Mk - M) / m = " + ce(b(M.addlGmvAllowedMaintenanceSide)), 1)
                        ])
                      ])
                    ])
                  ])
                ]);
              }), 128)),
              me.value.visible ? (X(), J("div", {
                key: 2,
                class: "context-menu",
                style: Bm({ left: me.value.x + "px", top: me.value.y + "px" }),
                onClick: S[4] || (S[4] = Os(() => {
                }, ["stop"]))
              }, [
                (X(!0), J(Yi, null, Ls(Md.value, (M, U) => (X(), J("div", {
                  key: M.action,
                  class: Br(["context-menu-item", { active: M.active }]),
                  onClick: (Ce) => pm(M.action)
                }, [
                  O("span", wH, ce(M.icon), 1),
                  O("span", null, ce(M.label), 1),
                  M.active ? (X(), J("span", bH, "")) : pi("", !0)
                ], 10, vH))), 128)),
                Md.value.length > 0 ? (X(), J("div", yH)) : pi("", !0),
                O("div", SH, [
                  S[23] || (S[23] = O("span", { class: "context-menu-label" }, "Fetched:", -1)),
                  O("span", RH, ce(fm(me.value.fetchedAt)) + " (PST) ", 1)
                ])
              ], 4)) : pi("", !0)
            ])
          ])) : pi("", !0)
        ])
      ], 64);
    };
  }
}), EH = (e, t) => {
  const i = e.__vccOpts || e;
  for (const [s, o] of t)
    i[s] = o;
  return i;
}, OH = /* @__PURE__ */ EH(PH, [["__scopeId", "data-v-c46d7521"]]);
export {
  OH as Summary,
  OH as default
};
